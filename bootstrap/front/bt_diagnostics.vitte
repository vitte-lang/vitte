module vitte.bootstrap.front.bt_diagnostics

import std.collections as coll
import vitte.bootstrap.front.bt_ast as ast

# ============================================================================
# Vitte bootstrap front-end – Modèle logique des diagnostics (maximal, sans I/O)
#
# Objectifs :
#   - Définir une représentation purement déclarative des diagnostics produits
#     par le front-end Vitte (lexer, parser, résolution, typage, désucrage).
#   - Servir de contrat entre :
#       * les passes du compilateur (front/mid),
#       * les outils (dump de diagnostics, IDE, tests),
#       * les runners/CLIs (formatage, filtrage, remontée d’erreurs).
#   - Ne contenir :
#       * aucune fonction,
#       * aucune logique de formatage (textuel, JSON, etc.),
#       * aucune I/O.
#
# Convention générale :
#   - Tous les diagnostics ont un identifiant stable dans une run (DiagId),
#     un niveau (severity) et au moins une étiquette (label) pointant sur un
#     span source (AstSpan).
#   - Les codes d’erreurs sont des chaînes stables (ex: "E0001", "W0100").
# ============================================================================

# ---------------------------------------------------------------------------
# Identifiants et niveaux de diagnostic
# ---------------------------------------------------------------------------

struct DiagId
    raw: u32                  # identifiant interne stable dans une run
.end

enum DiagSeverity
    Help
    Note
    Warning
    Error
    Fatal
.end

enum DiagPhase
    Lexing
    Parsing
    NameResolution
    TypeChecking
    Desugaring
    Lowering
    Other
.end

# ---------------------------------------------------------------------------
# Codes, catégories et groupes de diagnostics
# ---------------------------------------------------------------------------

struct DiagCode
    # Code stable pour un type de diagnostic, ex: "E0001", "W0100"
    value: String
    # Nom lisible, ex: "Unexpected token", "Unused variable"
    name: String
    # Catégorie générale, ex: "syntax", "type", "lint", "internal"
    category: String
    # Sous-catégorie ou tag supplémentaire, ex: "pattern", "lifetime", "import"
    subcategory: String
.end

struct DiagGroup
    # Regroupe plusieurs codes (ex: "lints.style", "lints.correctness")
    id: String
    display_name: String
    description: String

    codes: coll.Vec<DiagCode>
.end

# ---------------------------------------------------------------------------
# Labels et notes attachés à un diagnostic
# ---------------------------------------------------------------------------

enum DiagLabelKind
    Primary     # span principal de l’erreur
    Secondary   # span secondaire (contexte, définition, usage)
    Hint        # suggestion sur un autre span
.end

struct DiagLabel
    kind: DiagLabelKind
    span: ast.AstSpan
    # Message associé à ce span précis
    message: String
.end

struct DiagNote
    # Notes additionnelles, non directement liées à un span unique
    message: String
    # Span optionnel si la note pointe vers un endroit particulier
    span: ast.AstSpan
.end

# ---------------------------------------------------------------------------
# Suggestions & fixes
# ---------------------------------------------------------------------------

enum DiagFixKind
    Insert
    Delete
    Replace
    Surround
    Custom
.end

struct DiagFixEdit
    kind: DiagFixKind
    span: ast.AstSpan      # région à modifier (pour Delete/Replace/Surround)

    # Contenu pour Insert/Replace/Surround (avant/après)
    insert_text: String
    replace_text: String
    prefix_text: String
    suffix_text: String

    # Description lisible de la modification proposée
    message: String
.end

struct DiagFixSuggestion
    # Un diagnostic peut proposer plusieurs suggestions alternatives
    id: String                    # identifiant logique de la suggestion
    is_primary: bool              # true pour la suggestion "principale"
    description: String           # description de la suggestion
    edits: coll.Vec<DiagFixEdit>  # liste d’édits à appliquer
.end

# ---------------------------------------------------------------------------
# Attachements : références AST, contexte logique
# ---------------------------------------------------------------------------

struct DiagAstContext
    # Ids des éléments AST concernés par le diagnostic
    item_id: ast.AstNodeId        # ex: item fonction ou type concerné
    expr_id: ast.AstNodeId        # ex: expression fautive
    pattern_id: ast.AstNodeId     # ex: pattern fautif
    type_id: ast.AstNodeId        # ex: type associé
    block_id: ast.AstNodeId       # ex: bloc dans lequel l’erreur survient

    # Ces champs peuvent rester "vides" (id raw=0) si non pertinents.
.end

struct DiagContextInfo
    # Informations additionnelles structurées (clé/valeur) pour tooling
    data: coll.HashMap<String, String>

    # Éventuellement, identifiants logiques supplémentaires
    # ex: module_name, symbol_name, file_id logique, etc.
    module_name: String
    symbol_name: String
    file_id: String
    extra_tags: coll.Vec<String>      # tags libres utilisables par les outils
.end

struct DiagSourceContext
    # Provenance "tooling" du diagnostic
    stage_name: String           # ex: "parse", "resolve", "typecheck"
    pass_name: String            # ex: "parse_core", "resolve_names"
    tool_name: String            # ex: "vittec", "bt-check"

    # Fichier / module logique ayant émis le diagnostic
    file_path: String
    module_path: String          # ex: "my.pkg.module"

    notes: String
.end

struct DiagRelatedFile
    # Références à d’autres fichiers impliqués dans le diagnostic
    file_path: String
    span: ast.AstSpan
    relation: String             # ex: "included_from", "imported_module", "definition_site"
    message: String
.end

# ---------------------------------------------------------------------------
# Diagnostic principal
# ---------------------------------------------------------------------------

struct BtDiagnostic
    id: DiagId
    severity: DiagSeverity
    phase: DiagPhase
    code: DiagCode

    # Message principal (titre)
    message: String

    # Spans annotés
    labels: coll.Vec<DiagLabel>

    # Notes additionnelles
    notes: coll.Vec<DiagNote>

    # Suggestions de corrections
    fixes: coll.Vec<DiagFixSuggestion>

    # Contexte AST / logique
    ast_context: DiagAstContext
    context_info: DiagContextInfo

    # Contexte "source" (pass/stage/tool) et fichiers liés
    source: DiagSourceContext
    related_files: coll.Vec<DiagRelatedFile>

    # Flags de filtrage/rapport (post-politique de diagnostics)
    is_suppressed: bool          # true si filtré par une politique (mais présent dans la collection brute)
    is_reported: bool            # true si effectivement rapporté à l’utilisateur
.end

# ---------------------------------------------------------------------------
# Collections de diagnostics pour un fichier / unité
# ---------------------------------------------------------------------------

struct BtDiagnosticsSummary
    # Compteurs agrégés
    count_help: u32
    count_note: u32
    count_warning: u32
    count_error: u32
    count_fatal: u32

    # Indique s’il y a au moins une erreur bloquante
    has_errors: bool
    has_fatals: bool
.end

struct BtDiagnostics
    # Diagnostics pour une unité de compilation donnée
    # (souvent 1:1 avec BtAst)
    file_path: String
    diagnostics: coll.Vec<BtDiagnostic>
    summary: BtDiagnosticsSummary

    # Map optionnelle code -> occurrences, utile pour lints/statistiques
    count_by_code: coll.HashMap<String, u32>
.end

struct BtDiagnosticsBundle
    # Diagnostics agrégés pour un ensemble d’unités (workspace, build, etc.)
    units: coll.Vec<BtDiagnostics>

    # Résumé global
    total_summary: BtDiagnosticsSummary

    # Compteurs globaux par code, toutes unités confondues
    global_count_by_code: coll.HashMap<String, u32>
.end