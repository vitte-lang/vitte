

module vitte.bootstrap.core.bt_result

import std.collections as coll

# ============================================================================
# Vitte bootstrap – Run & result model (maximal, déclaratif, sans I/O)
#
# Objectifs :
#   - Décrire de manière purement déclarative le résultat d’un bootstrap :
#       * exécution globale (profil utilisé, dates, statut),
#       * exécution par stage (succès/échec, timings, outils invoqués),
#       * artefacts produits (binaires, libs, bytecode, manifests, etc.),
#       * diagnostics (warnings, erreurs, notes).
#   - Servir de format logique commun pour :
#       * un runner de bootstrap (scripts shell, outils Vitte),
#       * une UI ou un TUI d’inspection de build,
#       * des outils d’analyse (diff de résultats, historisation).
#   - Ne contenir aucune logique impérative de build ou d’I/O.
# ============================================================================
#
# Convention :
#   - Ce module ne fait que référencer des éléments du profil par leurs id :
#       * profile_id, stage_id, tool_id, artifact_name, target_name, etc.
#   - Les valeurs temporelles sont stockées en chaîne ISO 8601 pour rester
#     agnostique de toute représentation de temps concrète.
# ============================================================================

# ---------------------------------------------------------------------------
# Métadonnées globales de la run
# ---------------------------------------------------------------------------

enum BtRunStatus
    Success          # tous les stages requis ont réussi
    Failed           # au moins un stage requis a échoué
    PartialSuccess   # certains stages ont réussi, d’autres ont été ignorés/échoués
    Skipped          # aucune exécution réelle (dry-run, plan)
.end

struct BtRunMetadata
    run_id: String           # identifiant unique (UUID, hash, etc.)
    profile_id: String       # identifiant du profil logique (BtProfileMetadata.id)
    profile_version: String  # version du profil utilisé
    started_at: String       # timestamp ISO 8601
    finished_at: String      # timestamp ISO 8601
    duration_ms: u64         # durée totale estimée en millisecondes

    status: BtRunStatus
    hostname: String         # nom machine hôte
    user: String             # utilisateur qui a lancé la run
    working_dir: String      # répertoire de travail
    invocation: String       # ligne de commande ou scénario ayant déclenché le bootstrap

    notes: String
.end

# ---------------------------------------------------------------------------
# Environment snapshot / info hôte
# ---------------------------------------------------------------------------

struct BtEnvSnapshot
    os_name: String              # ex: "macOS", "Linux", "Windows"
    os_version: String           # ex: "15.0", "24.04"
    arch: String                 # ex: "x86_64", "aarch64"
    cpu_model: String
    cpu_cores_logical: u32
    cpu_cores_physical: u32

    ram_total_bytes: u64
    ram_available_bytes: u64

    env_vars: coll.HashMap<String, String>  # snapshot filtré des variables d’environnement
    path: String                            # PATH effectif
    shell: String                           # ex: "/bin/zsh"
    extra: coll.HashMap<String, String>     # champs supplémentaires arbitraires
.end

# ---------------------------------------------------------------------------
# Diagnostics
# ---------------------------------------------------------------------------

enum BtDiagnosticLevel
    Info
    Warning
    Error
    Fatal
.end

struct BtDiagnostic
    id: String                    # identifiant optionnel de diagnostic (code)
    level: BtDiagnosticLevel
    message: String

    # Contexte logique
    stage_id: String              # stage concerné (peut être vide si global)
    tool_id: String               # outil concerné (peut être vide)
    artifact_name: String         # artefact logique concerné (peut être vide)

    # Contexte source ou fichier, libre
    file: String                  # chemin vers un fichier concerné ou vide
    line: u32                     # 0 si non applicable
    column: u32                   # 0 si non applicable

    # Données complémentaires structurées (clé/valeur)
    details: coll.HashMap<String, String>
.end

# ---------------------------------------------------------------------------
# Commandes / outils invoqués
# ---------------------------------------------------------------------------

enum BtCommandStatus
    NotRun         # par exemple en dry-run ou stage skip
    Running        # utile si on sérialise un état en cours
    Succeeded
    Failed
    TimedOut
    Cancelled
.end

struct BtCommandInvocation
    id: String                    # identifiant d’invocation (unique dans la run)
    stage_id: String              # stage logique auquel est rattachée l’invocation
    tool_id: String               # id logique du profil d’outil (BtToolProfile.id)

    command: String               # chemin/binaire principal
    args: coll.Vec<String>       # arguments passés à l’outil
    cwd: String                   # répertoire de travail effectif
    env: coll.HashMap<String, String>  # variables d’environnement spécifiques

    status: BtCommandStatus
    exit_code: i32                # code de retour, -1 si non applicable
    started_at: String            # timestamp ISO 8601
    finished_at: String           # timestamp ISO 8601
    duration_ms: u64

    # L’emplacement des sorties est référencé plutôt que le contenu :
    stdout_path: String           # chemin du fichier capturant stdout (optionnel)
    stderr_path: String           # chemin du fichier capturant stderr (optionnel)
    log_path: String              # log agrégé (optionnel)

    notes: String
.end

# ---------------------------------------------------------------------------
# Artefacts produits
# ---------------------------------------------------------------------------

enum BtProducedArtifactStatus
    Created        # artefact créé correctement
    Updated        # artefact mis à jour
    Unchanged      # artefact déjà à jour (cache, incremental)
    Failed         # la création de l’artefact a échoué
    Skipped        # artefact non tenté (stage skip, condition)
.end

struct BtProducedArtifact
    # Référence logique (venant du profil BtArtifactPattern / BtStageProfile.artifacts)
    stage_id: String              # stage qui a produit (ou tenté de produire) l’artefact
    artifact_name: String         # nom logique, ex: "vittec_stage1"
    kind: String                  # miroir de BtArtifactKind, stocké en texte pour robustesse
    target_name: String           # nom de la cible, ex: "stage1_native"

    # Chemin et métadonnées effectives
    path: String                  # chemin calculé effectif
    status: BtProducedArtifactStatus

    size_bytes: u64               # taille du fichier si existant, 0 sinon
    hash: String                  # hash (sha256, blake3…) si calculé, sinon vide
    generated_at: String          # timestamp ISO 8601, vide si non produit

    # Diagnostics associés à cet artefact uniquement (ids, pas le contenu)
    diagnostic_ids: coll.Vec<String>

    notes: String
.end

# ---------------------------------------------------------------------------
# Résultat par stage
# ---------------------------------------------------------------------------

enum BtStageRunStatus
    StageSuccess
    StageFailed
    StageSkipped
    StagePartial   # ex: certains artefacts produits, d’autres échoués
.end

struct BtStageRunSummary
    stage_id: String              # identifiant logique du stage (BtStageProfile.id)
    status: BtStageRunStatus

    # Horodatage de l’exécution
    started_at: String
    finished_at: String
    duration_ms: u64

    # Résumé chiffré
    artifacts_expected: u32
    artifacts_created: u32
    artifacts_failed: u32
    artifacts_skipped: u32

    commands_invoked: u32
    commands_succeeded: u32
    commands_failed: u32

    diagnostics_info: u32
    diagnostics_warning: u32
    diagnostics_error: u32
    diagnostics_fatal: u32

    notes: String
.end

struct BtStageRunDetail
    # Résumé
    summary: BtStageRunSummary

    # Détails de l’exécution
    produced_artifacts: coll.Vec<BtProducedArtifact>
    command_invocations: coll.Vec<BtCommandInvocation>

    # Diagnostics dont stage_id == summary.stage_id (ou global à ce stage)
    diagnostics: coll.Vec<BtDiagnostic>

    # Dépendances (stage_id -> statut tel qu’observé pendant cette run)
    deps_status: coll.HashMap<String, BtStageRunStatus>
.end

# ---------------------------------------------------------------------------
# Résumé global de la run
# ---------------------------------------------------------------------------

struct BtRunCounters
    stages_total: u32
    stages_succeeded: u32
    stages_failed: u32
    stages_skipped: u32
    stages_partial: u32

    artifacts_total: u32
    artifacts_created: u32
    artifacts_failed: u32
    artifacts_skipped: u32

    commands_total: u32
    commands_succeeded: u32
    commands_failed: u32

    diagnostics_info: u32
    diagnostics_warning: u32
    diagnostics_error: u32
    diagnostics_fatal: u32
.end

struct BtRunSummary
    metadata: BtRunMetadata
    counters: BtRunCounters

    # Quelques flags globaux
    has_failures: bool
    has_warnings: bool
    was_dry_run: bool          # true si la run n’a pas exécuté les commandes réellement

    primary_target: String     # cible principale si applicable
    primary_stage: String      # stage principal si applicable
.end

# ---------------------------------------------------------------------------
# Modèle racine : résultat complet d’un bootstrap
# ---------------------------------------------------------------------------

struct BtRunResult
    # Métadonnées et environnement
    summary: BtRunSummary
    env_snapshot: BtEnvSnapshot

    # Détails par stage (clé: stage_id)
    stages: coll.Vec<BtStageRunDetail>

    # Diagnostics globaux (non attachés à un stage en particulier)
    global_diagnostics: coll.Vec<BtDiagnostic>

    # Indexation / accélérateurs de recherche facultatifs :
    #   - map stage_id -> index dans stages,
    #   - map diagnostic_id -> index dans un pool commun, etc.
    # Ici on reste simple et déclaratif, un outil peut construire
    # ses propres index à partir de ces données.
    indices: coll.HashMap<String, String>

    # Données annexes spécifiques à un outil ou pipeline
    extra: coll.HashMap<String, String>
.end