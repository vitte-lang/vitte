

module vitte.bootstrap.core.bt_toolchain

import std.collections as coll
import vitte.bootstrap.core.bt_profile as bt

# ============================================================================
# Vitte bootstrap – Toolchain & pipeline model (maximal, déclaratif, sans I/O)
#
# Objectifs :
#   - Décrire la "toolchain logique" utilisée pendant le bootstrap :
#       * composants (compilateurs, backends, VM, outils),
#       * pipelines (front/mid/back-end, passes, IR),
#       * cibles supportées (triples, ABIs, features),
#       * capacités (build, run, test, format, package…).
#   - Servir de contrat entre :
#       * le profil de bootstrap (bt_profile.vitte),
#       * les runners/CLI (bt-runner, vittec, lvm…),
#       * les UIs / TUI / outils d’inspection.
#   - Rester purement déclaratif :
#       * aucun accès au système,
#       * aucune exécution de commande,
#       * aucune logique de build.
#
# Ce module complète bt_profile.vitte en donnant une vue plus fine de la
# toolchain utilisée pour réaliser les stages.
# ============================================================================

# ---------------------------------------------------------------------------
# Versioning, canaux, build-info
# ---------------------------------------------------------------------------

enum TcReleaseChannel
    Dev
    Nightly
    Beta
    Stable
    Lts
    Custom
.end

struct TcVersion
    semver: String            # ex: "0.1.0", "1.0.0"
    commit: String            # hash court/long, ex: "a1b2c3d4"
    build_date: String        # ISO 8601, ex: "2025-12-05T18:30:00Z"
    channel: TcReleaseChannel
    extra: coll.HashMap<String, String>   # ex: "rustc" -> "1.82.0"
.end

# ---------------------------------------------------------------------------
# Langages, IR et backends
# ---------------------------------------------------------------------------

enum TcLanguageKind
    VitteCore          # subset noyau utilisé pour le bootstrap
    VitteFull          # langage complet, hors features expérimentales
    VitteExperimental  # variantes/features instables
    MuffinManifest     # fichiers .muf
    C
    Cpp
    Asm
    IrText             # IR textuel (propre à Vitte)
    Bytecode           # bytecode VM Vitte
    Other
.end

enum TcIrKind
    Ast                # arbre syntaxique
    Hir                # high-level IR
    Mir                # mid-level IR
    Lir                # low-level IR
    BytecodeIr         # IR spécifique au bytecode VM
    TextIr             # IR textuel interne
    Other
.end

struct TcIrDescriptor
    id: String                   # ex: "ast.core", "mir.core", "lir.vm"
    kind: TcIrKind
    language: TcLanguageKind     # langage auquel l’IR se rapporte
    description: String
    is_stable: bool              # true si l’IR est considéré stable/publique
    file_extension: String       # ex: ".ast", ".mir", ".lir"
    mime_type: String            # ex: "text/x-vitte-ir"
    extra: coll.HashMap<String, String>
.end

enum TcBackendKind
    BytecodeVm        # compilation vers bytecode VM et exécution
    NativeObject      # compilation vers .o / .obj
    NativeExecutable  # compilation vers binaire exécutable
    LlvmIr
    CSource
    Wasm
    Custom
.end

struct TcBackendConfig
    id: String                  # ex: "backend.bytecode", "backend.native"
    kind: TcBackendKind
    input_ir: String            # id d’un TcIrDescriptor
    output_format: String       # ex: "bytecode", "elf", "mach-o", "pe", "wasm"
    description: String
    default_output_extension: String   # ex: ".bc", ".exe", ".out"
    supports_debug_info: bool
    supports_lto: bool
    supports_incremental: bool
    supported_targets: coll.Vec<String>  # ids de cibles (TcTargetConfig.id)
    extra: coll.HashMap<String, String>
.end

# ---------------------------------------------------------------------------
# Cibles, CPU features et layout mémoire
# ---------------------------------------------------------------------------

struct TcCpuFeature
    name: String                # ex: "sse2", "avx2", "neon"
    description: String
    enabled_by_default: bool
.end

struct TcTargetLayout
    pointer_width: u8           # en bits (ex: 64)
    pointer_align: u8           # alignement pointer en bits
    int_width: u8               # largeur de "int" en bits
    long_width: u8              # largeur de "long" en bits
    size_t_width: u8            # largeur de size_t en bits

    # Alignements primitifs (en bits)
    align_i8: u8
    align_i16: u8
    align_i32: u8
    align_i64: u8
    align_f32: u8
    align_f64: u8

    # Taille de page mémoire (en octets)
    page_size_bytes: u32

    extra: coll.HashMap<String, String>
.end

struct TcTargetConfig
    id: String                  # identifiant logique, ex: "host_native_core"
    triple: bt.BtTriple         # triple partagé avec bt_profile
    abi: String                 # ex: "sysv", "msvc", "wasm32-unknown"
    os_name: String             # redondant mais pratique
    arch_name: String           # ex: "x86_64", "aarch64"

    layout: TcTargetLayout
    cpu_model: String           # ex: "x86_64-v3", "apple-m1"
    cpu_features: coll.Vec<TcCpuFeature>

    # IR / backend par défaut pour cette cible
    default_ir: String          # id d’un TcIrDescriptor
    default_backend: String     # id d’un TcBackendConfig

    # Flags/capacités spécifiques
    supports_threads: bool
    supports_exceptions: bool
    supports_dynamic_linking: bool
    supports_filesystem: bool

    notes: String
.end

# ---------------------------------------------------------------------------
# Composants de la toolchain
# ---------------------------------------------------------------------------

enum TcComponentKind
    CompilerFrontEnd    # parse, résolution, typage
    CompilerMidEnd      # optimisations, transformations IR
    CompilerBackEnd     # génération de code/bytecode
    Linker              # édition de liens
    RuntimeVm           # VM / interpréteur / runner
    LspServer           # serveur de langage
    Formatter           # formatteur de code
    PackageManager      # gestionnaire de paquets (Muffin, etc.)
    BuildDriver         # orchestrateur de build (bt-runner, make-like)
    TestRunner          # runner de tests
    Tool                # outil divers (doc, lints, etc.)
    Custom
.end

enum TcCapabilityKind
    CanCompileSources     # compile *.vitte vers IR/bytecode/obj
    CanLink               # produit des exécutables/bibliothèques
    CanRunBytecode        # exécute le bytecode VM Vitte
    CanRunNative          # lance des exécutables natifs
    CanFormatCode         # reformate le code source
    CanProvideLsp         # fournit un serveur LSP
    CanManagePackages     # installe/résout des dépendances
    CanRunTests           # exécute des tests unitaires/intégration
    CanEmitDocs           # génère documentation
    CustomCapability
.end

struct TcCapability
    kind: TcCapabilityKind
    description: String
    enabled: bool
    extra: coll.HashMap<String, String>
.end

struct TcExecutableRef
    # Référence à un binaire concret de la toolchain (souvent dérivé de bt.BtToolProfile)
    tool_id: String             # id logique (peut correspondre à BtToolProfile.id)
    command: String             # binaire principal
    default_args: coll.Vec<String>
    description: String
.end

struct TcComponent
    id: String                  # ex: "vittec.frontend.stage1"
    kind: TcComponentKind
    display_name: String        # ex: "Vitte Compiler Front-End (Stage1)"
    description: String

    version: TcVersion
    languages_in: coll.Vec<TcLanguageKind>  # langages en entrée
    languages_out: coll.Vec<TcLanguageKind> # langages en sortie

    ir_inputs: coll.Vec<String>             # ids de TcIrDescriptor supportés en entrée
    ir_outputs: coll.Vec<String>            # ids de TcIrDescriptor supportés en sortie

    capabilities: coll.Vec<TcCapability>
    executable: TcExecutableRef

    # Cibles supportées par ce composant (optionnel, sinon "hérite" des backends)
    supported_targets: coll.Vec<String>     # ids de TcTargetConfig
    enabled: bool                    # permet d’activer/désactiver globalement le composant
    extra: coll.HashMap<String, String>
.end

# ---------------------------------------------------------------------------
# Passes et pipeline de compilation
# ---------------------------------------------------------------------------

enum TcPassKind
    Parse
    Resolve
    TypeCheck
    Desugar
    Lowering
    Simplify
    Inline
    ConstFold
    Dce                  # dead code elimination
    CfgCleanup
    BorrowCheck
    LifetimeAnalysis
    CodegenPrep
    Codegen
    Link
    Validation
    Lint
    Format
    Custom
.end

struct TcPassDescriptor
    id: String                   # ex: "parse.core", "typecheck.core", "lower.mir"
    kind: TcPassKind
    display_name: String         # ex: "Type-checker (core)"
    description: String

    # IR d’entrée / sortie
    input_ir: String             # id d’un TcIrDescriptor
    output_ir: String            # id d’un TcIrDescriptor

    # Ordonnancement
    order_index: u32             # position dans le pipeline
    depends_on: coll.Vec<String> # ids d’autres TcPassDescriptor requis

    enabled_by_default: bool
    can_be_disabled: bool

    # Options de tuning (clé/valeur, ex: "inline.threshold" -> "100")
    options: coll.HashMap<String, String>
.end

struct TcPipeline
    id: String                   # ex: "pipeline.stage1.native"
    display_name: String         # ex: "Stage1 – Native pipeline"
    description: String

    # Langage d’entrée et cible de sortie
    input_language: TcLanguageKind
    primary_target: String       # id d’une TcTargetConfig
    backend_id: String           # id d’un TcBackendConfig
    diagnostic_policy_id: String   # id d’une TcDiagnosticPolicy à appliquer

    # Passes composant le pipeline (dans l’ordre)
    passes: coll.Vec<TcPassDescriptor>

    # Flags globaux pour ce pipeline
    is_default_for_target: bool
    is_experimental: bool

    notes: String
.end

# ---------------------------------------------------------------------------
# Layout de la toolchain (répertoires, binaires, libs)
# ---------------------------------------------------------------------------

struct TcPathLayout
    root_dir: String             # racine de la toolchain, ex: "/opt/vitte"
    bin_dir: String              # ex: "{root}/bin"
    lib_dir: String              # ex: "{root}/lib"
    include_dir: String          # ex: "{root}/include"
    share_dir: String            # ex: "{root}/share"
    cache_dir: String            # ex: "{root}/cache"
    temp_dir: String             # ex: "{root}/tmp"

    # Patterns de fichiers (avec placeholders, par ex {version}, {target})
    pattern_exe: String          # ex: "{bin}/{name}"
    pattern_lib_static: String   # ex: "{lib}/lib{name}.a"
    pattern_lib_shared: String   # ex: "{lib}/lib{name}.so"
    pattern_pkg: String          # ex: "{share}/pkgs/{name}"
    extra: coll.HashMap<String, String>
.end

# ---------------------------------------------------------------------------
# Metadata globale de la toolchain
# ---------------------------------------------------------------------------

struct TcToolchainMetadata
    id: String                   # ex: "vitte-core-toolchain"
    display_name: String         # ex: "Vitte Core Toolchain"
    edition: String              # ex: "2025"
    description: String

    version: TcVersion
    built_for_profile: String    # id du BtProfileMetadata associé
    created_at: String           # ISO 8601
    updated_at: String           # ISO 8601

    tags: coll.Vec<String>       # ex: ["bootstrap", "stage1", "experimental"]
    notes: String
.end

# ---------------------------------------------------------------------------
# Profils d’optimisation, liaisons stage/toolchain et presets CLI
# ---------------------------------------------------------------------------

struct TcOptimizationProfile
    id: String                       # ex: "debug", "release", "size"
    display_name: String             # ex: "Debug", "Release"
    description: String

    # Niveau d’optimisation logique, souvent aligné avec BtOptimizationLevel
    level: String                    # ex: "Debug", "Release", "Size", "Custom"
    bt_level: bt.BtOptimizationLevel # lien logique vers le profil d’optimisation BtProfile

    # Options spécifiques, par exemple :
    #   "opt.level"        -> "0" | "1" | "2" | "3"
    #   "debuginfo"        -> "full" | "line" | "none"
    #   "lto"              -> "off" | "thin" | "full"
    #   "inlining"         -> "off" | "on"
    #   "panic.strategy"   -> "unwind" | "abort"
    options: coll.HashMap<String, String>

    is_default: bool                  # true si c’est le profil par défaut
    notes: String
.end

struct TcStageToolchainBinding
    # Lien entre un stage de bootstrap (bt.BtStageProfile) et le pipeline/toolchain
    stage_id: String                  # id du stage (BtStageProfile.id)
    target_id: String                 # id de la cible (TcTargetConfig.id)
    pipeline_id: String               # id du pipeline (TcPipeline.id)

    # Composants principaux impliqués pour ce stage
    frontend_id: String               # TcComponent.id du front-end utilisé
    midend_id: String                 # TcComponent.id du mid-end utilisé
    backend_id: String                # TcComponent.id du back-end utilisé
    linker_id: String                 # TcComponent.id du linker, si applicable
    runtime_vm_id: String             # TcComponent.id de la VM/runner, si applicable

    # Profils et options
    optimization_profile_id: String   # TcOptimizationProfile.id
    extra_options: coll.HashMap<String, String>

    enabled: bool
    notes: String
.end

struct TcCliPreset
    # Preset pour une commande CLI de haut niveau (ex: "vittec build", "vittec test")
    id: String                        # ex: "build.debug.native", "test.core"
    display_name: String              # ex: "Build debug (native)"
    description: String

    # Contexte toolchain
    target_id: String                 # TcTargetConfig.id
    pipeline_id: String               # TcPipeline.id
    optimization_profile_id: String   # TcOptimizationProfile.id
    diagnostic_policy_id: String      # TcDiagnosticPolicy.id

    # Commande haut niveau et arguments par défaut
    command: String                   # ex: "vittec"
    args: coll.Vec<String>           # ex: ["build", "--color", "auto"]

    # Options supplémentaires pour ce preset (clé/valeur)
    options: coll.HashMap<String, String>
    notes: String
.end

# ---------------------------------------------------------------------------
# Contraintes d’environnement et index de toolchain
# ---------------------------------------------------------------------------

struct TcHostConstraint
    # Contraintes minimales recommandées pour l’hôte exécutant cette toolchain
    min_cores_logical: u32          # 0 = non spécifié
    min_ram_bytes: u64              # 0 = non spécifié

    # Listes d’OS/arch supportés ou déconseillés (valeurs libres, ex: "macOS-15")
    supported_os: coll.Vec<String>
    unsupported_os: coll.Vec<String>
    supported_arch: coll.Vec<String>    # ex: ["x86_64", "aarch64"]
    unsupported_arch: coll.Vec<String>

    notes: String
.end

struct TcRequiredTool
    # Outil externe requis pour utiliser cette toolchain
    usage: bt.BtToolUsage              # rôle logique, repris de bt_profile
    preferred_tool_ids: coll.Vec<String>  # ids de BtToolProfile ou TcComponent liés
    min_version: String                # contrainte libre, ex: ">= 15.0"
    notes: String
.end

struct TcToolchainRequirements
    host: TcHostConstraint
    required_tools: coll.Vec<TcRequiredTool>
    required_env_vars: coll.Vec<String>      # ex: ["VITTE_HOME", "VITTE_BOOTSTRAP_ROOT"]
    notes: String
.end

struct TcToolchainIndex
    # Indexation facultative pour accélérer les résolutions à l’exécution
    component_by_id: coll.HashMap<String, u32>
    target_by_id: coll.HashMap<String, u32>
    backend_by_id: coll.HashMap<String, u32>
    pipeline_by_id: coll.HashMap<String, u32>
    optimization_by_id: coll.HashMap<String, u32>

    notes: String
.end

# ---------------------------------------------------------------------------
# Features, politiques de diagnostics et profilage
# ---------------------------------------------------------------------------

struct TcFeatureFlag
    id: String                        # ex: "lvm.bytecode", "parser.full"
    display_name: String              # nom lisible, ex: "Full parser"
    description: String

    enabled_by_default: bool
    experimental: bool

    # Relations entre features (par id)
    requires: coll.Vec<String>        # features requises
    conflicts_with: coll.Vec<String>  # features incompatibles

    notes: String
.end

struct TcDiagnosticPolicy
    id: String                        # ex: "strict", "lenient", "ci"
    display_name: String
    description: String

    warn_as_error: bool               # traite tous les warnings comme des erreurs
    treat_unused_as_warning: bool
    treat_deprecated_as_warning: bool
    treat_internal_as_error: bool

    # Codes de diagnostics spécifiques
    suppressed_codes: coll.Vec<String>    # ex: ["unused-variable"]
    promoted_codes: coll.Vec<String>      # ex: ["missing-docs"]

    notes: String
.end

struct TcProfilingConfig
    enable_timings: bool              # chronométrage des passes/pipelines
    enable_memory_stats: bool         # mesures mémoire (approx/optionnel)
    enable_traces: bool               # traces détaillées (logs, IR dumps, etc.)

    # Chemin de sortie pour les artefacts de profilage (avec placeholders)
    output_path_pattern: String       # ex: "target/profile/{pipeline}/{stage}.json"

    extra: coll.HashMap<String, String>
    notes: String
.end

# ---------------------------------------------------------------------------
# Modèle racine : toolchain utilisée par le bootstrap
# ---------------------------------------------------------------------------

struct TcToolchainProfile
    metadata: TcToolchainMetadata

    # Layout de fichiers / installation
    layout: TcPathLayout

    # IR connus
    irs: coll.Vec<TcIrDescriptor>

    # Backends
    backends: coll.Vec<TcBackendConfig>

    # Cibles
    targets: coll.Vec<TcTargetConfig>

    # Composants de la toolchain
    components: coll.Vec<TcComponent>

    # Pipelines de compilation
    pipelines: coll.Vec<TcPipeline>

    # Profils d’optimisation connus
    optimization_profiles: coll.Vec<TcOptimizationProfile>

    # Features activables/désactivables au niveau toolchain
    features: coll.Vec<TcFeatureFlag>

    # Politiques de diagnostics disponibles
    diagnostic_policies: coll.Vec<TcDiagnosticPolicy>

    # Liaisons entre stages de bootstrap et toolchain/pipelines
    stage_bindings: coll.Vec<TcStageToolchainBinding>

    # Presets de haut niveau pour les CLIs (vittec, bt-runner, etc.)
    cli_presets: coll.Vec<TcCliPreset>

    # Contraintes globales et outils requis pour cette toolchain
    requirements: TcToolchainRequirements

    # Indexation optionnelle pour accéder rapidement aux composants/cibles/backends
    indices: TcToolchainIndex

    # Configuration par défaut du profilage pour cette toolchain
    profiling_defaults: TcProfilingConfig

    # Variables globales de configuration (clé/valeur)
    vars: coll.HashMap<String, String>

    # Notes globales sur cette toolchain
    notes: String
.end