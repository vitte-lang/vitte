

module vitte.bootstrap.back.codegen_c

import std.collections as coll
import vitte.compiler.diagnostics as diag
import vitte.compiler.ir as ir

# ============================================================================
# Vitte bootstrap - Backend C
# Modele logique maximal de generation de code C, purement declaratif, sans I O
#
# Objectifs
#   - Decrire les structures de donnees intermediaires utilisees par le backend C
#   - Representer les types, declarations, instructions et expressions C
#   - Capturer les options de compilation et les informations de mappage depuis l IR Vitte
#   - Servir de contrat entre le moteur de passage IR vers C et les etapes suivantes
#
# Conventions
#   - Module purement declaratif aucune logique de generation ni I O
#   - Tous les noeuds significatifs portent un identifiant et un span pour le debug
#   - Les etats mutables de generation sont regrouper dans des structures de contexte
#   - Pas d accolades les blocs sont delimites avec le mot cle .end

# ----------------------------------------------------------------------------
# Identifiants generiques et utilitaires
# ----------------------------------------------------------------------------

type CNodeId = i32
type CDeclId = i32
type CExprId = i32
type CStmtId = i32
type CTypeId = i32
type CLabelId = i32
type CTempId = i32
type CFileId = i32

# Nom logique visible en C tel qu il apparait dans le code source
struct CName
    id: i32
    text: String
    is_generated: bool
    origin_span: diag.SpanId
.end

# Nom mangle pour la liaison binaire cote C
enum CManglingScheme
    | Plain                # nom directement reutilise
    | StaticInternal       # nom local, non exporte
    | ExportedSymbol       # symbole exporte pour le monde exterieur
    | VitteRuntime         # symbole reserve au runtime Vitte
    | Temp                 # symboles temporaires internes
.end

struct CMangledName
    original: CName
    mangled: String
    scheme: CManglingScheme
.end

# ----------------------------------------------------------------------------
# Options de backend C
# ----------------------------------------------------------------------------

enum CCStandard
    | C89
    | C99
    | C11
    | C17
    | C23
.end

struct CBackendOptions
    c_standard: CCStandard
    target_triplet: String
    runtime_header: String
    emit_line_directives: bool
    enable_debug_names: bool
    prefer_static_inline: bool
    single_translation_unit: bool
    emit_runtime_prelude: bool
    extra_include_paths: coll.Vec[String]
    extra_defines: coll.Vec[String]
.end

# ----------------------------------------------------------------------------
# Types C
# ----------------------------------------------------------------------------

enum CIntRank
    | Bool
    | Char
    | SignedChar
    | UnsignedChar
    | Short
    | UnsignedShort
    | Int
    | UnsignedInt
    | Long
    | UnsignedLong
    | LongLong
    | UnsignedLongLong
    | SizeT
    | PtrDiffT
.end

enum CFloatRank
    | Float
    | Double
    | LongDouble
.end

enum CTypeKind
    | Void
    | Integer
    | Floating
    | Pointer
    | Array
    | Function
    | Struct
    | Union
    | Enum
    | Typedef
    | Qualified
.end

enum CTypeQualifier
    | Const
    | Volatile
    | Restrict
    | Atomic
.end

struct CVoidType
    dummy: bool
.end

struct CIntegerType
    rank: CIntRank
    is_signed: bool
.end

struct CFloatType
    rank: CFloatRank
.end

struct CPointerType
    pointee: CTypeId
.end

enum CArrayLengthKind
    | Unspecified
    | Fixed
    | VariableLength
.end

struct CArrayLength
    kind: CArrayLengthKind
    value: i64          # utilise quand kind vaut Fixed
.end

struct CArrayType
    element: CTypeId
    length: CArrayLength
.end

struct CFunctionType
    result: CTypeId
    params: coll.Vec[CTypeId]
    is_variadic: bool
.end

struct CQualifiedType
    base: CTypeId
    extra_qualifiers: coll.Vec[CTypeQualifier]
.end

# Reference a un type nomme struct union enum ou typedef
struct CNamedTypeRef
    name: CName
    has_resolved_decl: bool
    resolved_decl: CDeclId
.end

union CTypeDetail
    void_ty: CVoidType
    int_ty: CIntegerType
    float_ty: CFloatType
    ptr_ty: CPointerType
    array_ty: CArrayType
    fn_ty: CFunctionType
    struct_ty: CNamedTypeRef
    union_ty: CNamedTypeRef
    enum_ty: CNamedTypeRef
    typedef_ty: CNamedTypeRef
    qualified_ty: CQualifiedType
.end

struct CType
    id: CTypeId
    kind: CTypeKind
    qualifiers: coll.Vec[CTypeQualifier]
    detail: CTypeDetail
    span: diag.SpanId
.end

# ----------------------------------------------------------------------------
# Declarations et elements de translation unit
# ----------------------------------------------------------------------------

enum CStorageClass
    | Auto
    | Register
    | Static
    | Extern
    | TypedefStorage
    | ThreadLocal
.end

enum CLinkage
    | Internal
    | External
    | ExternalInline
    | VitteRuntimeInternal
.end

enum CFunctionAttr
    | Inline
    | NoInline
    | Naked
    | Cold
    | Hot
    | Weak
    | NoReturn
    | VitteInit
    | VitteFini
.end

enum CStructTagKind
    | Struct
    | Union
.end

enum CIncludeKind
    | System
    | Local
.end

struct CInclude
    kind: CIncludeKind
    path: String
    is_optional: bool
.end

enum CDefineKind
    | ObjectLike
    | FunctionLike
.end

struct CDefine
    kind: CDefineKind
    name: String
    params: coll.Vec[String]
    body: String
.end

struct CParam
    id: i32
    name: CName
    ty: CTypeId
    span: diag.SpanId
.end

struct CField
    id: i32
    name: CName
    ty: CTypeId
    bit_width: i32
    has_bit_width: bool
    span: diag.SpanId
.end

struct CEnumVariant
    id: i32
    name: CName
    has_value: bool
    value: CExprId
    span: diag.SpanId
.end

struct CStructDecl
    id: CDeclId
    tag_kind: CStructTagKind
    name: CName
    fields: coll.Vec[CField]
    is_complete: bool
    span: diag.SpanId
.end

struct CEnumDecl
    id: CDeclId
    name: CName
    underlying_int: CTypeId
    variants: coll.Vec[CEnumVariant]
    span: diag.SpanId
.end

struct CTypedefDecl
    id: CDeclId
    name: CName
    aliased_type: CTypeId
    span: diag.SpanId
.end

struct CLabel
    id: CLabelId
    name: CName
    is_generated: bool
.end

struct CFunctionDecl
    id: CDeclId
    name: CName
    link_name: CMangledName
    result_ty: CTypeId
    params: coll.Vec[CParam]
    storage: CStorageClass
    linkage: CLinkage
    attrs: coll.Vec[CFunctionAttr]
    has_body: bool
    body: CStmtId           # pointe sur un bloc principal
    span: diag.SpanId
.end

struct CGlobalVarDecl
    id: CDeclId
    name: CName
    link_name: CMangledName
    ty: CTypeId
    storage: CStorageClass
    linkage: CLinkage
    has_initializer: bool
    initializer: CExprId
    span: diag.SpanId
.end

struct CPragma
    name: String
    args: coll.Vec[String]
    span: diag.SpanId
.end

struct CStaticAssert
    cond: CExprId
    message: String
    span: diag.SpanId
.end

enum CTopLevelKind
    | Function
    | GlobalVar
    | Tag
    | TypedefDecl
    | Pragma
    | StaticAssertDecl
.end

union CTagDecl
    struct_decl: CStructDecl
    enum_decl: CEnumDecl
.end

union CTopLevelPayload
    fun_decl: CFunctionDecl
    global_decl: CGlobalVarDecl
    tag_decl: CTagDecl
    typedef_decl: CTypedefDecl
    pragma_decl: CPragma
    static_assert_decl: CStaticAssert
.end

struct CTopLevelDecl
    id: CDeclId
    kind: CTopLevelKind
    payload: CTopLevelPayload
    span: diag.SpanId
.end

struct CFile
    id: CFileId
    path: String
    include_guard: String
    includes: coll.Vec[CInclude]
    defines: coll.Vec[CDefine]
    decls: coll.Vec[CTopLevelDecl]
.end

# ----------------------------------------------------------------------------
# Expressions
# ----------------------------------------------------------------------------

enum CLiteralKind
    | Int
    | Float
    | Char
    | String
    | NullPtr
    | Bool
.end

struct CLiteral
    kind: CLiteralKind
    text: String
    span: diag.SpanId
.end

enum CUnaryOp
    | Plus
    | Minus
    | LogicalNot
    | BitNot
    | PreInc
    | PreDec
    | PostInc
    | PostDec
.end

enum CBinaryOp
    | Add
    | Sub
    | Mul
    | Div
    | Mod
    | Shl
    | Shr
    | BitAnd
    | BitOr
    | BitXor
    | LogicalAnd
    | LogicalOr
    | Less
    | LessEq
    | Greater
    | GreaterEq
    | Equal
    | NotEqual
.end

enum CAssignOp
    | Simple
    | AddAssign
    | SubAssign
    | MulAssign
    | DivAssign
    | ModAssign
    | ShlAssign
    | ShrAssign
    | AndAssign
    | OrAssign
    | XorAssign
.end

enum CExprKind
    | Literal
    | VarRef
    | Call
    | Unary
    | Binary
    | Assign
    | Conditional
    | Cast
    | Index
    | Member
    | AddressOf
    | Deref
    | SizeOfType
    | SizeOfExpr
    | Comma
.end

enum CMemberAccessKind
    | Direct          # e point membre
    | Pointer         # e fleche membre
.end

struct CLiteralExpr
    value: CLiteral
.end

struct CVarRefExpr
    name: CName
    resolved_decl: CDeclId
.end

struct CCallExpr
    callee: CExprId
    args: coll.Vec[CExprId]
.end

struct CUnaryExpr
    op: CUnaryOp
    expr: CExprId
    is_prefix: bool
.end

struct CBinaryExpr
    op: CBinaryOp
    left: CExprId
    right: CExprId
.end

struct CAssignExpr
    op: CAssignOp
    lhs: CExprId
    rhs: CExprId
.end

struct CConditionalExpr
    cond: CExprId
    then_expr: CExprId
    else_expr: CExprId
.end

struct CCastExpr
    target_type: CTypeId
    expr: CExprId
    is_implicit: bool
.end

struct CIndexExpr
    base: CExprId
    index: CExprId
.end

struct CMemberExpr
    base: CExprId
    access_kind: CMemberAccessKind
    member: CName
.end

struct CAddrOfExpr
    expr: CExprId
.end

struct CDerefExpr
    expr: CExprId
.end

struct CSizeOfTypeExpr
    ty: CTypeId
.end

struct CSizeOfExprExpr
    expr: CExprId
.end

struct CCommaExpr
    parts: coll.Vec[CExprId]
.end

union CExprPayload
    lit: CLiteralExpr
    var_ref: CVarRefExpr
    call: CCallExpr
    unary: CUnaryExpr
    binary: CBinaryExpr
    assign: CAssignExpr
    conditional: CConditionalExpr
    cast: CCastExpr
    index: CIndexExpr
    member: CMemberExpr
    addr_of: CAddrOfExpr
    deref: CDerefExpr
    sizeof_type: CSizeOfTypeExpr
    sizeof_expr: CSizeOfExprExpr
    comma: CCommaExpr
.end

struct CExpr
    id: CExprId
    kind: CExprKind
    ty: CTypeId
    payload: CExprPayload
    span: diag.SpanId
.end

# ----------------------------------------------------------------------------
# Instructions
# ----------------------------------------------------------------------------

enum CStmtKind
    | Decl
    | Expr
    | If
    | While
    | DoWhile
    | For
    | Break
    | Continue
    | Return
    | Goto
    | Label
    | Switch
    | Case
    | Default
    | Block
.end

struct CLocalVarDecl
    id: CDeclId
    name: CName
    ty: CTypeId
    storage: CStorageClass
    has_initializer: bool
    initializer: CExprId
    span: diag.SpanId
.end

struct CLocalDeclStmt
    decls: coll.Vec[CLocalVarDecl]
.end

struct CExprStmt
    expr: CExprId
.end

struct CIfStmt
    cond: CExprId
    then_block: CStmtId
    has_else: bool
    else_block: CStmtId
.end

struct CWhileStmt
    cond: CExprId
    body: CStmtId
.end

struct CDoWhileStmt
    body: CStmtId
    cond: CExprId
.end

struct CForStmt
    has_init: bool
    init: CStmtId
    has_cond: bool
    cond: CExprId
    has_step: bool
    step: CExprId
    body: CStmtId
.end

struct CBreakStmt
    dummy: bool
.end

struct CContinueStmt
    dummy: bool
.end

struct CReturnStmt
    has_value: bool
    value: CExprId
.end

struct CLabelStmt
    label: CLabel
    inner: CStmtId
.end

struct CGotoStmt
    target: CLabel
.end

struct CSwitchStmt
    expr: CExprId
    body: CStmtId
.end

struct CCaseStmt
    value: CExprId
    body: CStmtId
.end

struct CDefaultStmt
    body: CStmtId
.end

struct CBlock
    id: CStmtId
    items: coll.Vec[CStmtId]
    span: diag.SpanId
.end

union CStmtPayload
    decl: CLocalDeclStmt
    expr: CExprStmt
    if_stmt: CIfStmt
    while_stmt: CWhileStmt
    do_while_stmt: CDoWhileStmt
    for_stmt: CForStmt
    break_stmt: CBreakStmt
    continue_stmt: CContinueStmt
    return_stmt: CReturnStmt
    goto_stmt: CGotoStmt
    label_stmt: CLabelStmt
    switch_stmt: CSwitchStmt
    case_stmt: CCaseStmt
    default_stmt: CDefaultStmt
    block_stmt: CBlock
.end

struct CStmt
    id: CStmtId
    kind: CStmtKind
    payload: CStmtPayload
    span: diag.SpanId
.end

# ----------------------------------------------------------------------------
# Contexte de generation depuis l IR
# ----------------------------------------------------------------------------

struct CLoweringTrace
    value_to_expr: coll.Map[ir.ValueId, CExprId]
    block_to_label: coll.Map[ir.BlockId, CLabelId]
    func_to_decl: coll.Map[ir.FuncId, CDeclId]
.end

struct CNameSupply
    next_temp: CTempId
    next_label: CLabelId
    next_file: CFileId
.end

struct CBackendContext
    options: CBackendOptions
    ir_module: ir.ModuleId
    files: coll.Vec[CFile]
    types: coll.Vec[CType]
    trace: CLoweringTrace
    names: CNameSupply
.end