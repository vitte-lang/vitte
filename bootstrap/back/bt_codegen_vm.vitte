

module vitte.bootstrap.back.codegen_vm

import std.collections as coll
import vitte.compiler.diagnostics as diag
import vitte.compiler.ir as ir

# ============================================================================
# Vitte bootstrap - Backend VM
# Modèle logique maximal de génération de bytecode VM, purement déclaratif
#
# Objectifs
#   - Décrire les structures intermédiaires pour la génération de bytecode VM
#   - Représenter
#       * le format des instructions VM,
#       * les registres, piles, frames, constantes,
#       * les fonctions, modules et blocs de base,
#       * les informations de debug et de mappage IR -> VM.
#   - Servir de contrat entre le front-end (IR Vitte) et la VM/runtime.
#
# Conventions
#   - Aucune fonction ni logique de génération ici, uniquement des données.
#   - Tous les noeuds intéressants portent un identifiant et un span.
#   - L’API est pensée pour un backend de type “bytecode register-based hybride”.
#   - Aucun usage d’accolades, les blocs sont terminés par `.end`.
#
# Ce module n’impose pas une VM unique mais un sur-ensemble raisonnable
# pour couvrir plusieurs variantes (stack-based, register-based, SSA-lowered).

# ----------------------------------------------------------------------------
# Identifiants génériques et utilitaires
# ----------------------------------------------------------------------------

type VmModuleId   = i32
type VmFuncId     = i32
type VmBlockId    = i32
type VmInstId     = i32
type VmValueId    = i32
type VmConstId    = i32
type VmRegId      = i32
type VmStackSlotId = i32
type VmLocalId    = i32
type VmParamId    = i32
type VmDebugFileId = i32
type VmDebugLineId = i32

# Nom logique au niveau VM (souvent dérivé de l’IR ou de la source)
struct VmName
    id: i32
    text: String
    is_generated: bool
    origin_span: diag.SpanId
.end

# ----------------------------------------------------------------------------
# Options / Capabilities de la VM
# ----------------------------------------------------------------------------

enum VmEndianness
    | Little
    | Big
.end

enum VmWordSize
    | Bits32
    | Bits64
.end

enum VmAddrModel
    | Flat
    | Segmented
.end

struct VmBackendOptions
    word_size: VmWordSize
    endianness: VmEndianness
    addr_model: VmAddrModel

    max_registers: i32              # nombre de registres logiques autorisés
    has_separate_fp_regs: bool      # registres flottants dédiés
    supports_tail_calls: bool
    supports_inline_constpool: bool
    supports_exceptions: bool
    supports_coroutines: bool

    enable_debug_names: bool
    enable_line_info: bool
    enable_verify_checks: bool
.end

# ----------------------------------------------------------------------------
# Types VM (vu du backend)
# ----------------------------------------------------------------------------

enum VmScalarKind
    | I8
    | I16
    | I32
    | I64
    | U8
    | U16
    | U32
    | U64
    | F32
    | F64
    | Bool
    | Ptr
.end

enum VmTypeKind
    | Unit
    | Scalar
    | Ref
    | Tuple
    | Array
    | FuncRef
    | ObjRef
.end

struct VmScalarType
    kind: VmScalarKind
.end

struct VmRefType
    target: VmTypeId
    is_mut: bool
.end

struct VmArrayType
    element: VmTypeId
    length: i64           # -1 pour taille dynamique/indéterminée
.end

struct VmTupleType
    elements: coll.Vec[VmTypeId]
.end

struct VmFuncRefType
    func: VmFuncId        # référence logique à une fonction VM
.end

struct VmObjRefType
    type_name: VmName     # objets runtime spécifiques (ex: string, slice, map)
.end

type VmTypeId = i32

union VmTypeDetail
    scalar_ty: VmScalarType
    ref_ty: VmRefType
    tuple_ty: VmTupleType
    array_ty: VmArrayType
    func_ref_ty: VmFuncRefType
    obj_ref_ty: VmObjRefType
.end

struct VmType
    id: VmTypeId
    kind: VmTypeKind
    detail: VmTypeDetail
    span: diag.SpanId
.end

# ----------------------------------------------------------------------------
# Constantes VM
# ----------------------------------------------------------------------------

enum VmConstKind
    | Int
    | Float
    | Bool
    | String
    | Bytes
    | Null
    | Undef
.end

struct VmConstValue
    kind: VmConstKind
    ty: VmTypeId
    text_repr: String         # représentation canonique (pour debug / sérialisation)
.end

struct VmConst
    id: VmConstId
    value: VmConstValue
    origin_span: diag.SpanId
.end

# Constante dans un pool (par ex. par module ou par fonction)
struct VmConstPool
    consts: coll.Vec[VmConst]
.end

# ----------------------------------------------------------------------------
# Registres, locals, params, slots
# ----------------------------------------------------------------------------

enum VmRegClass
    | General
    | Floating
    | Special
.end

struct VmReg
    id: VmRegId
    class: VmRegClass
    ty: VmTypeId
    debug_name: VmName
.end

struct VmLocal
    id: VmLocalId
    ty: VmTypeId
    debug_name: VmName
    span: diag.SpanId
.end

struct VmParam
    id: VmParamId
    ty: VmTypeId
    debug_name: VmName
    span: diag.SpanId
.end

struct VmStackSlot
    id: VmStackSlotId
    ty: VmTypeId
    size_bytes: i64
    alignment: i32
    debug_name: VmName
.end

# Valeur VM logique (peut référencer registre, param, local, slot ou const)
enum VmValueKind
    | Reg
    | Local
    | Param
    | Const
    | StackSlotAddr
.end

union VmValuePayload
    reg: VmRegId
    local: VmLocalId
    param: VmParamId
    const_id: VmConstId
    stack_slot: VmStackSlotId
.end

struct VmValue
    id: VmValueId
    kind: VmValueKind
    payload: VmValuePayload
    ty: VmTypeId
    span: diag.SpanId
.end

# ----------------------------------------------------------------------------
# Debug info VM
# ----------------------------------------------------------------------------

struct VmDebugFile
    id: VmDebugFileId
    path: String
.end

struct VmDebugLine
    id: VmDebugLineId
    file: VmDebugFileId
    line: i32
    column: i32
.end

struct VmInstDebug
    line: VmDebugLineId
    original_span: diag.SpanId
.end

# ----------------------------------------------------------------------------
# Instructions VM
# ----------------------------------------------------------------------------

# Opérations arithmétiques/scalaires
enum VmArithOp
    | Add
    | Sub
    | Mul
    | Div
    | Mod
    | Neg
    | Abs
.end

# Opérations logiques/bit
enum VmBitOp
    | And
    | Or
    | Xor
    | Not
    | Shl
    | Shr
.end

# Comparaisons
enum VmCmpOp
    | Eq
    | Ne
    | Lt
    | Le
    | Gt
    | Ge
.end

# Conversions
enum VmConvOp
    | IntToInt
    | IntToFloat
    | FloatToInt
    | FloatToFloat
    | IntToBool
    | PtrToInt
    | IntToPtr
.end

# Flux de contrôle
enum VmBranchKind
    | Uncond
    | IfTrue
    | IfFalse
    | Switch
.end

# Appels
enum VmCallKind
    | Direct
    | Indirect
    | Tail
.end

# Instructions “high level” VM
enum VmOpcode
    | Nop
    | Move
    | LoadConst
    | LoadAddr
    | Load
    | Store
    | Arith
    | Bit
    | Cmp
    | Conv
    | Phi

    | Branch
    | JumpTable
    | Return
    | Call

    | StackAlloc
    | StackFree
    | Spill
    | Reload

    | Enter
    | Leave

    | Throw
    | Catch
    | Rethrow

    | Yield
    | Resume

    | DebugTrap
    | DebugMarker
.end

# Payloads spécialisés par opcode
struct VmInstMove
    dst: VmValueId
    src: VmValueId
.end

struct VmInstLoadConst
    dst: VmValueId
    const_id: VmConstId
.end

struct VmInstLoadAddr
    dst: VmValueId
    base: VmValueId
    offset_bytes: i64
.end

struct VmInstLoad
    dst: VmValueId
    addr: VmValueId
.end

struct VmInstStore
    addr: VmValueId
    value: VmValueId
.end

struct VmInstArith
    op: VmArithOp
    dst: VmValueId
    lhs: VmValueId
    rhs: VmValueId
.end

struct VmInstBit
    op: VmBitOp
    dst: VmValueId
    lhs: VmValueId
    rhs: VmValueId
.end

struct VmInstCmp
    op: VmCmpOp
    dst: VmValueId
    lhs: VmValueId
    rhs: VmValueId
.end

struct VmInstConv
    op: VmConvOp
    dst: VmValueId
    src: VmValueId
    target_ty: VmTypeId
.end

struct VmInstPhiIncoming
    from_block: VmBlockId
    value: VmValueId
.end

struct VmInstPhi
    dst: VmValueId
    incomings: coll.Vec[VmInstPhiIncoming]
.end

struct VmInstBranch
    kind: VmBranchKind
    cond: VmValueId       # utilisé seulement pour IfTrue / IfFalse
    true_target: VmBlockId
    false_target: VmBlockId
.end

struct VmInstJumpTableEntry
    index: i64
    target: VmBlockId
.end

struct VmInstJumpTable
    scrutinee: VmValueId
    default_target: VmBlockId
    entries: coll.Vec[VmInstJumpTableEntry]
.end

struct VmInstReturn
    has_value: bool
    value: VmValueId
.end

struct VmInstCall
    kind: VmCallKind
    callee: VmValueId
    args: coll.Vec[VmValueId]
    dst: VmValueId
.end

struct VmInstStackAlloc
    dst: VmStackSlotId
    size_bytes: i64
    alignment: i32
.end

struct VmInstStackFree
    slot: VmStackSlotId
.end

struct VmInstSpill
    value: VmValueId
    slot: VmStackSlotId
.end

struct VmInstReload
    dst: VmValueId
    slot: VmStackSlotId
.end

struct VmInstEnter
    frame_size_bytes: i64
.end

struct VmInstLeave
    dummy: bool
.end

struct VmInstThrow
    exception_value: VmValueId
.end

struct VmInstCatch
    dst: VmValueId
.end

struct VmInstRethrow
    dummy: bool
.end

struct VmInstYield
    value: VmValueId
.end

struct VmInstResume
    value: VmValueId
.end

struct VmInstDebugTrap
    dummy: bool
.end

struct VmInstDebugMarker
    message: String
.end

# Union de payload par instruction
union VmInstPayload
    move_inst: VmInstMove
    load_const: VmInstLoadConst
    load_addr: VmInstLoadAddr
    load_inst: VmInstLoad
    store_inst: VmInstStore
    arith_inst: VmInstArith
    bit_inst: VmInstBit
    cmp_inst: VmInstCmp
    conv_inst: VmInstConv
    phi_inst: VmInstPhi
    branch_inst: VmInstBranch
    jumptable_inst: VmInstJumpTable
    return_inst: VmInstReturn
    call_inst: VmInstCall
    stack_alloc_inst: VmInstStackAlloc
    stack_free_inst: VmInstStackFree
    spill_inst: VmInstSpill
    reload_inst: VmInstReload
    enter_inst: VmInstEnter
    leave_inst: VmInstLeave
    throw_inst: VmInstThrow
    catch_inst: VmInstCatch
    rethrow_inst: VmInstRethrow
    yield_inst: VmInstYield
    resume_inst: VmInstResume
    debug_trap_inst: VmInstDebugTrap
    debug_marker_inst: VmInstDebugMarker
.end

struct VmInst
    id: VmInstId
    opcode: VmOpcode
    payload: VmInstPayload
    debug: VmInstDebug
.end

# ----------------------------------------------------------------------------
# Blocs de base et CFG
# ----------------------------------------------------------------------------

struct VmBlock
    id: VmBlockId
    name: VmName
    params: coll.Vec[VmValueId]      # paramètres de bloc (pour style SSA/phi)
    insts: coll.Vec[VmInstId]
    terminator: VmInstId             # instruction de terminaison (branche/ret)
    span: diag.SpanId
.end

struct VmCfgEdge
    from: VmBlockId
    to: VmBlockId
    is_critical: bool
.end

struct VmCfg
    blocks: coll.Vec[VmBlockId]
    edges: coll.Vec[VmCfgEdge]
    entry: VmBlockId
.end

# ----------------------------------------------------------------------------
# Fonctions VM
# ----------------------------------------------------------------------------

enum VmFuncKind
    | Normal
    | Intrinsic
    | Import
    | Export
.end

struct VmFuncSignature
    params: coll.Vec[VmTypeId]
    result: VmTypeId
.end

struct VmFuncBody
    locals: coll.Vec[VmLocal]
    params: coll.Vec[VmParam]
    regs: coll.Vec[VmReg]
    stack_slots: coll.Vec[VmStackSlot]

    blocks: coll.Vec[VmBlock]
    cfg: VmCfg

    const_pool: VmConstPool
.end

struct VmFunc
    id: VmFuncId
    name: VmName
    kind: VmFuncKind
    sig: VmFuncSignature
    body: VmFuncBody
    is_variadic: bool
    is_async: bool
    is_generator: bool
    origin_span: diag.SpanId
.end

# ----------------------------------------------------------------------------
# Modules VM
# ----------------------------------------------------------------------------

struct VmModule
    id: VmModuleId
    name: VmName
    funcs: coll.Vec[VmFunc]
    types: coll.Vec[VmType]
    const_pool: VmConstPool
.end

# ----------------------------------------------------------------------------
# Traces de lowering IR -> VM
# ----------------------------------------------------------------------------

struct VmLoweringTrace
    ir_value_to_vm: coll.Map[ir.ValueId, VmValueId]
    ir_block_to_vm: coll.Map[ir.BlockId, VmBlockId]
    ir_func_to_vm: coll.Map[ir.FuncId, VmFuncId]
.end

# ----------------------------------------------------------------------------
# Contexte de backend VM
# ----------------------------------------------------------------------------

struct VmBackendContext
    options: VmBackendOptions
    ir_module: ir.ModuleId

    vm_module: VmModule

    types: coll.Vec[VmType]
    globals_const_pool: VmConstPool

    lowering: VmLoweringTrace
.end