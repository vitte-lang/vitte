#!/usr/bin/env python3
from pathlib import Path
from typing import Optional
import sys
from dataclasses import dataclass
import json

ROOT = Path(__file__).resolve().parents[2]
if str(ROOT) not in sys.path:
    sys.path.insert(0, str(ROOT))

try:
    from tools.frontend_host import Diagnostic, diag_to_json, format_diag, run_frontend
    try:
        from vitte.compiler import driver as vitte_driver
    except Exception:
        vitte_driver = None  # type: ignore
except Exception as exc:  # pragma: no cover - fallback pour environnements cassés
    print(f"[vittec][frontend] frontend Python indisponible: {exc}")
    Diagnostic = None  # type: ignore
    diag_to_json = None  # type: ignore
    format_diag = None  # type: ignore
    run_frontend = None  # type: ignore
    vitte_driver = None  # type: ignore


@dataclass
class ProjectCommandOptions:
    """
    Options normalisées pour les commandes orientées projet (build / check).
    """
    project: Path
    out_bin: Optional[Path]
    log_file: Optional[Path]


def log_if_needed(log_file: Optional[Path], message: str) -> None:
    """
    Écrit `message` dans le fichier de log si `log_file` est défini.
    Sinon, ne fait rien.
    """
    if not log_file:
        return
    try:
        with log_file.open("a", encoding="utf-8") as f:
            f.write(message.rstrip("\n") + "\n")
    except OSError as exc:
        print(
            f"vittec: impossible d'écrire dans log {log_file}: {exc}",
            file=sys.stderr,
        )


def write_text(path: Path, content: str) -> None:
    """
    Helper simple pour écrire du texte en UTF-8.
    """
    path.parent.mkdir(parents=True, exist_ok=True)
    path.write_text(content, encoding="utf-8")


def find_vitte_sources(project_manifest: Path) -> list[Path]:
    """
    Retourne la liste des fichiers .vitte pertinents pour le projet,
    en scannant les répertoires bootstrap/, compiler/ et src/ à côté
    du manifest Muffin.
    """
    root = project_manifest.parent
    sources: list[Path] = []

    for subdir_name in ("bootstrap", "compiler", "src"):
        base = root / subdir_name
        if not base.is_dir():
            continue
        for path in base.rglob("*.vitte"):
            sources.append(path)

    # Tri pour des résultats déterministes
    sources.sort()
    return sources


def create_placeholder_binary(path: Path, project: Path) -> None:
    script = """#!/usr/bin/env sh
echo "[vittec][bootstrap] binaire fictif pour {project}"
echo "Ce fichier a été généré par le bootstrap Python (stage0)."
echo "Aucune compilation réelle n'a été effectuée."
exit 0
"""
    path.parent.mkdir(parents=True, exist_ok=True)
    path.write_text(script.format(project=project), encoding="utf-8")
    path.chmod(0o755)


def run_vitte_driver(
    mode: str,
    project: Path,
    out_bin: Optional[Path],
    log_file: Optional[Path],
) -> int:
    """
    Point d'unification pour appeler le driver Vitte.

    mode     : "build" ou "check"
    project  : chemin vers le manifest .muf
    out_bin  : binaire de sortie (build), None pour check
    log_file : log à produire (optionnel)

    Contrat codes retour :
      0 -> succès
      1 -> erreurs de compilation utilisateur
      2 -> erreur interne du compilateur
    """
    project = project.resolve()
    out_bin_resolved = out_bin.resolve() if out_bin is not None else None
    log_path = log_file.resolve() if log_file is not None else None

    if mode not in ("build", "check"):
        msg = f"[vittec][host] run_vitte_driver: mode invalide: {mode!r}"
        print(msg)
        log_if_needed(log_file, msg)
        return 2

    if vitte_driver is None or format_diag is None:
        msg = "[vittec][host] driver Python vitte.compiler.driver indisponible"
        print(msg)
        log_if_needed(log_file, msg)
        return 2

    try:
        if mode == "build":
            result = vitte_driver.run_build(project, out_bin_resolved, log_path)
        else:
            result = vitte_driver.run_check(project, log_path)
    except Exception as exc:  # pragma: no cover - garde-fou
        msg = f"[vittec][host] erreur interne du driver: {exc}"
        print(msg)
        log_if_needed(log_file, msg)
        return 2

    for diag in result.diagnostics:
        print(format_diag(diag))
        log_if_needed(log_file, format_diag(diag, with_context=False))

    return int(result.exit_code)


def cmd_build_project(opts: ProjectCommandOptions) -> int:
    root = opts.project.parent

    # 1) Scanner les sources Vitte
    sources = find_vitte_sources(opts.project)
    rel_sources = [str(p.relative_to(root)) for p in sources]

    msg = (
        f"[vittec][bootstrap] build du projet (Muffin) : {opts.project}\n"
        f"  racine   = {root}\n"
        f"  binaire  = {opts.out_bin}\n"
        f"  journal  = {opts.log_file}\n"
        f"  sources  = {len(sources)} fichiers .vitte trouvés sous bootstrap/, compiler/, src/"
    )
    print(msg)
    log_if_needed(opts.log_file, msg)

    # 2) Appel contractuel au driver Vitte (futur point unique)
    code = run_vitte_driver(
        mode="build",
        project=opts.project,
        out_bin=opts.out_bin,
        log_file=opts.log_file,
    )

    # 3) Si le driver signale une erreur, on propage immédiatement
    if code != 0:
        # Pas de binaire fictif en cas d'échec du compilateur.
        return code

    # 4) Bootstrap actuel : .sources.json + binaire fictif en cas de succès
    if opts.out_bin is not None:
        meta = {
            "project": str(opts.project),
            "root": str(root),
            "sources": rel_sources,
        }
        meta_path = opts.out_bin.with_suffix(".sources.json")
        write_text(meta_path, json.dumps(meta, indent=2))
        log_if_needed(
            opts.log_file,
            f"[vittec][bootstrap] liste des sources écrite dans {meta_path}",
        )
        print(f"[vittec][bootstrap] liste des sources écrite dans {meta_path}")

        create_placeholder_binary(opts.out_bin, opts.project)
        log_if_needed(
            opts.log_file,
            f"[vittec][bootstrap] binaire fictif écrit dans {opts.out_bin}",
        )
        print(f"[vittec][bootstrap] binaire fictif écrit dans {opts.out_bin}")

    # 5) Retourner le code du driver (0 ici tant que le driver est stub)
    return code


def cmd_check_project(opts: ProjectCommandOptions) -> int:
    root = opts.project.parent
    sources = find_vitte_sources(opts.project)
    msg = (
        f"[vittec][bootstrap] check du projet (Muffin) : {opts.project}\n"
        f"  racine   = {root}\n"
        f"  journal  = {opts.log_file}\n"
        f"  sources  = {len(sources)} fichiers .vitte trouvés sous bootstrap/, compiler/, src/\n"
        "  (implémentation réelle à écrire en Vitte : parse + resolve + typecheck.)"
    )
    print(msg)
    log_if_needed(opts.log_file, msg)

    code = run_vitte_driver(
        mode="check",
        project=opts.project,
        out_bin=None,
        log_file=opts.log_file,
    )

    return code


def run_dump_ast(input_path: Path, *, json_output: bool = False) -> int:
    """
    Appelle le frontend Python pour parser et afficher les diagnostics.
    """
    if not input_path.is_file():
        print(f"vittec: fichier introuvable: {input_path}")
        return 2

    if run_frontend is None or format_diag is None or diag_to_json is None:
        print("vittec: frontend indisponible: import tools.frontend_host impossible")
        return 2

    rc, diags = run_frontend(input_path)
    if json_output:
        payload = {
            "exit_code": rc,
            "diagnostics": [diag_to_json(d) for d in diags],
            "ast": None,
        }
        print(json.dumps(payload, indent=2))
        return rc

    if diags:
        for diag in diags:
            print(format_diag(diag))
    # TODO : impression AST (non implémenté pour l'instant).
    return rc


def run_parse_only(input_path: Path, *, json_output: bool = False) -> int:
    """
    Mode historique : vittec <fichier.vitte> sans option.
    Échoue si le parseur signale des erreurs.
    """
    if not input_path.is_file():
        print(f"vittec: fichier introuvable: {input_path}")
        return 2

    if run_frontend is None or format_diag is None or diag_to_json is None:
        print("vittec: frontend indisponible: import tools.frontend_host impossible")
        return 2

    rc, diags = run_frontend(input_path)
    if json_output:
        payload = {
            "exit_code": rc,
            "diagnostics": [diag_to_json(d) for d in diags],
        }
        print(json.dumps(payload, indent=2))
        return rc

    if diags:
        for diag in diags:
            print(format_diag(diag))
    return rc


def main(argv: list[str] | None = None) -> int:
    argv = list(argv or [])
    json_output = False
    if "--json" in argv:
        json_output = True
        argv = [a for a in argv if a != "--json"]

    if not argv or argv[0] in ("-h", "--help"):
        print(
            "Utilisation : vittec --dump-ast <fichier.vitte> | <fichier.vitte> | "
            "build <projet.muf> | check <projet.muf> [--json]"
        )
        return 1

    if argv[0] == "--dump-ast":
        if len(argv) != 2:
            print("vittec: argument manquant pour --dump-ast")
            return 2
        return run_dump_ast(Path(argv[1]), json_output=json_output)

    if len(argv) == 1 and argv[0].endswith(".vitte"):
        return run_parse_only(Path(argv[0]), json_output=json_output)

    if argv[0] in ("build", "check"):
        if len(argv) < 2:
            print(f"vittec: manifest .muf manquant pour commande {argv[0]}")
            return 2
        opts = ProjectCommandOptions(
            project=Path(argv[1]),
            out_bin=None,
            log_file=None,
        )
        if argv[0] == "build":
            return cmd_build_project(opts)
        return cmd_check_project(opts)

    print(f"vittec: commande inconnue: {' '.join(argv)}")
    return 2


if __name__ == "__main__":
    sys.exit(main(sys.argv[1:]))
