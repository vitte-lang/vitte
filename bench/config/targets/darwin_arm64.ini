

; ============================================================================
; bench/config/targets/darwin_arm64.ini
;
; Target profile for micro-benchmarks on macOS (Darwin) arm64 (Apple Silicon).
;
; Intended consumer:
;   - a thin bench runner / build wrapper that compiles files in bench/micro/
;   - reuses the same include tree as the main repo (include/)
;
; Philosophy:
;   - Keep the format stable and boring (ini).
;   - Provide both a “system clang” path and an optional “zig cc” override.
;   - Separate debug/release flag sets.
;
; Notes (Darwin specifics):
;   - pthread is part of libSystem; linking -lpthread is usually unnecessary.
;   - clock_gettime is available on modern macOS; otherwise the benches can fall
;     back to mach_absolute_time if you later wire it in.
; ============================================================================

[target]
name = darwin_arm64
os = darwin
arch = arm64
triple = aarch64-apple-darwin
endianness = little
pointer_bits = 64

[toolchain]
; Prefer clang on macOS.
; If you want hermetic builds, use zig:
;   cc = /path/to/zig cc
; You can keep this file as a “default” and override in your runner.
cc = clang
cxx = clang++

; Optional: xcrun helpers (if your runner supports calling these).
; sdk_path_cmd = xcrun --sdk macosx --show-sdk-path
; clang_cmd    = xcrun --sdk macosx clang

[paths]
; Repo-relative paths (runner should resolve relative to workspace root).
include_dir = include
src_root = .
bench_root = bench/micro
out_dir = target/bench
obj_dir = target/bench/obj

[defines]
; Common compile-time defines for benches.
STEEL_POSIX = 1
STEEL_DARWIN = 1
STEEL_ARCH_AARCH64 = 1
STEEL_BENCH = 1

[cflags.common]
; Keep warnings strict but not insane.
std = -std=c11
warnings = -Wall -Wextra -Wshadow -Wstrict-prototypes -Wmissing-prototypes
frameptr = -fno-omit-frame-pointer
includes = -Iinclude

; macOS deployment target: pick a conservative baseline.
; If you need older compatibility, lower it.
macos_min = -mmacosx-version-min=11.0

[cflags.debug]
opt = -O0
dbg = -g
san = ; (optional) -fsanitize=address,undefined

[cflags.release]
opt = -O2
ndebug = -DNDEBUG=1
lto = ; (optional) -flto

[ldflags.common]
; Most micro benches are pure C. Add libs/frameworks here if needed.
libs =
frameworks =

[ldflags.debug]
; Keep empty by default.
extra =

[ldflags.release]
; Keep empty by default.
extra =

[run]
; Runner settings (if your bench harness supports it).
; exe_prefix can be used for tools like "arch -arm64" or env wrappers.
exe_prefix =

; Environment variables to inject when running benchmarks.
; Format: KEY=VALUE (comma-separated) if your runner implements it.
env =

[bench]
; Default arguments (runner can override per bench).
; These map to the microbench CLI flags used in bench/micro/*.c.
lexer_default = --bytes 1048576 --iters 200 --warmup 20
parser_default = --bytes 1048576 --funcs 512 --stmts 6 --iters 200 --warmup 20
backend_c_default = --iters 10000 --warmup 200 --outdir target/bench
pal_fs_default = --iters 2000 --warmup 100 --dir target/bench_fs --payload 4096

; Optional CPU pinning / QoS (macOS): leave empty unless your runner supports it.
; qos = user-interactive|user-initiated|utility|background
qos =

; Notes for later:
; - If you add asm variants (memwipe.S, ct_eq.S), you can enable a feature flag
;   and append the .S objects in your build harness.
; - If you build via zig cc, ensure you propagate -target and -isysroot.