
# ============================================================================
# Vitte Grammar — Core + Phrase (EBNF, canonical)
#
# This file defines the current official syntax reference for Vitte.
# Design goals:
#   - Rust-like core with explicit, deterministic blocks.
#   - User-facing blocks are delimited by `.end` (no braces required).
#   - A small "phrase" surface syntax desugars to core statements.
#
# Notes:
#   - This is a syntax grammar (parse layer). Semantics live elsewhere.
#   - Some legacy brace blocks exist only for backward compatibility.
#   - Whitespace is generally flexible; NEWLINE separates statements.
# ============================================================================

CompilationUnit      = Spacing, { TopLevelDecl, Spacing }, EOF ;

TopLevelDecl         = Comment
                    | EmptyLine
                    | ModuleDecl
                    | UseDecl
                    | ExportDecl
                    | TypeDecl
                    | FnDecl
                    | ScenarioDecl
                    | EntrypointDecl
                    | GlobalDecl
                    ;

# ----------------------------------------------------------------------------
# Modules / imports / exports
# ----------------------------------------------------------------------------

ModuleDecl           = "module", WS1, ModulePath, LineEnd ;

UseDecl              = "use", WS1, ModulePath, [ WS1, "as", WS1, Ident ], LineEnd ;

ExportDecl           = "export", WS1, ( ExportAll | ExportFrom | ExportList ), LineEnd ;
ExportAll            = "all" ;
ExportFrom           = "from", WS1, ModulePath, WS1, ExportListBody ;
ExportList           = ExportListBody ;
ExportListBody       = "[", Spacing, [ Ident, Spacing, { ",", Spacing, Ident, Spacing }, [ ",", Spacing ] ], "]" ;

ModulePath           = Ident, { ("." | "/"), Ident } ;

# ----------------------------------------------------------------------------
# Types
# ----------------------------------------------------------------------------

TypeDecl             = StructDecl
                    | UnionDecl
                    | EnumDecl
                    | TypeAliasDecl
                    ;

StructDecl           = "struct", WS1, Ident, [ GenericsDecl ], LineEnd,
                       TypeBody,
                       EndBlock ;

UnionDecl            = "union", WS1, Ident, [ GenericsDecl ], LineEnd,
                       TypeBody,
                       EndBlock ;

EnumDecl             = "enum", WS1, Ident, [ GenericsDecl ], LineEnd,
                       EnumBody,
                       EndBlock ;

TypeAliasDecl        = "type", WS1, Ident, [ GenericsDecl ], Spacing, "=", Spacing, TypeExpr, LineEnd ;

TypeBody             = { Spacing, ( FieldDecl | Comment | EmptyLine ), Spacing } ;
FieldDecl            = Ident, Spacing, ":", Spacing, TypeExpr, LineEnd ;

EnumBody             = { Spacing, ( EnumEntry | Comment | EmptyLine ), Spacing } ;
EnumEntry            = Ident, [ Spacing, "(", Spacing, [ TypeExpr, Spacing, { ",", Spacing, TypeExpr, Spacing }, [ ",", Spacing ] ], ")" ],
                       LineEnd ;

# ----------------------------------------------------------------------------
# Functions / scenarios / entrypoints
# ----------------------------------------------------------------------------

FnDecl               = "fn", WS1, Ident, [ GenericsDecl ],
                       Spacing, "(", Spacing, [ ParamList ], ")",
                       [ Spacing, "->", Spacing, TypeExpr ],
                       LineEnd,
                       Block ;

ScenarioDecl         = "scn", WS1, Ident, [ GenericsDecl ],
                       Spacing, "(", Spacing, [ ParamList ], ")",
                       [ Spacing, "->", Spacing, TypeExpr ],
                       LineEnd,
                       Block ;

EntrypointDecl       = EntryKind, WS1, ModulePath, LineEnd, Block ;
EntryKind            = "program" | "service" | "kernel" | "driver" | "tool" | "scenario" | "pipeline" ;

GlobalDecl           = ("let" | "const"), WS1, Ident, [ Spacing, ":", Spacing, TypeExpr ],
                       Spacing, "=", Spacing, Expr,
                       LineEnd ;

ParamList            = Param, Spacing, { ",", Spacing, Param, Spacing }, [ ",", Spacing ] ;
Param                = Ident, Spacing, ":", Spacing, TypeExpr ;

# ----------------------------------------------------------------------------
# Blocks
# ----------------------------------------------------------------------------

Block                = EndBlockBody
                    | LegacyBraceBlock
                    ;

# Canonical block form
EndBlockBody         = { Spacing, Statement, Spacing }, EndBlock ;
EndBlock             = ".end", LineEnd ;

# Legacy (keep optional; treat as deprecated in tooling)
LegacyBraceBlock     = "{", Spacing, { Statement, Spacing }, "}" ;

# ----------------------------------------------------------------------------
# Statements (core)
# ----------------------------------------------------------------------------

Statement            = Comment
                    | EmptyLine
                    | LetStmt
                    | ConstStmt
                    | AssignStmt
                    | IfStmt
                    | WhileStmt
                    | ForStmt
                    | MatchStmt
                    | BreakStmt
                    | ContinueStmt
                    | ReturnStmt
                    | ExprStmt
                    | PhraseStmt
                    ;

LetStmt              = "let", WS1, Ident, [ Spacing, ":", Spacing, TypeExpr ],
                       [ Spacing, "=", Spacing, Expr ],
                       LineEnd ;

ConstStmt            = "const", WS1, Ident, [ Spacing, ":", Spacing, TypeExpr ],
                       Spacing, "=", Spacing, Expr,
                       LineEnd ;

AssignStmt           = LValue, Spacing, AssignOp, Spacing, Expr, LineEnd ;
AssignOp             = "=" | "+=" | "-=" | "*=" | "/=" | "%=" | "&=" | "|=" | "^=" | "<<=" | ">>=" ;

IfStmt               = "if", WS1, Expr, LineEnd,
                       Block,
                       { Spacing, ElifClause },
                       [ Spacing, ElseClause ] ;
ElifClause           = "elif", WS1, Expr, LineEnd, Block ;
ElseClause           = "else", LineEnd, Block ;

WhileStmt            = "while", WS1, Expr, LineEnd, Block ;

ForStmt              = "for", WS1, Ident, WS1, "in", WS1, Expr, LineEnd, Block ;

MatchStmt            = "match", WS1, Expr, LineEnd,
                       MatchBody,
                       EndBlock ;

MatchBody            = { Spacing, ( MatchArm | Comment | EmptyLine ), Spacing } ;
MatchArm             = Pattern, Spacing, "=>", Spacing,
                       Block ;

BreakStmt            = "break", [ WS1, Expr ], LineEnd ;
ContinueStmt         = "continue", LineEnd ;
ReturnStmt           = "return", [ WS1, Expr ], LineEnd ;

ExprStmt             = Expr, LineEnd ;

# ----------------------------------------------------------------------------
# Statements (phrase surface syntax) — desugars to core
# ----------------------------------------------------------------------------

PhraseStmt           = SetStmt
                    | SayStmt
                    | DoStmt
                    | RetStmt
                    | WhenStmt
                    | LoopStmt
                    ;

SetStmt              = "set", WS1, LValue, Spacing, "=", Spacing, Expr, LineEnd ;
SayStmt              = "say", WS1, Expr, LineEnd ;
DoStmt               = "do", WS1, Expr, LineEnd ;
RetStmt              = "ret", [ WS1, Expr ], LineEnd ;

WhenStmt             = "when", WS1, Expr, LineEnd,
                       Block,
                       { Spacing, WhenElifClause },
                       [ Spacing, WhenElseClause ] ;
WhenElifClause       = "when", WS1, Expr, LineEnd, Block ;
WhenElseClause       = "else", LineEnd, Block ;

LoopStmt             = "loop", LineEnd, Block ;

# ----------------------------------------------------------------------------
# Expressions
# ----------------------------------------------------------------------------

Expr                 = OrExpr ;

OrExpr               = AndExpr, { Spacing, "or", Spacing, AndExpr } ;
AndExpr              = BitOrExpr, { Spacing, "and", Spacing, BitOrExpr } ;

BitOrExpr            = BitXorExpr, { Spacing, "|", Spacing, BitXorExpr } ;
BitXorExpr           = BitAndExpr, { Spacing, "^", Spacing, BitAndExpr } ;
BitAndExpr           = EqExpr,     { Spacing, "&", Spacing, EqExpr } ;

EqExpr               = CmpExpr, { Spacing, ("==" | "!="), Spacing, CmpExpr } ;
CmpExpr              = ShiftExpr, { Spacing, ("<" | "<=" | ">" | ">="), Spacing, ShiftExpr } ;

ShiftExpr            = AddExpr, { Spacing, ("<<" | ">>"), Spacing, AddExpr } ;

AddExpr              = MulExpr, { Spacing, ("+" | "-"), Spacing, MulExpr } ;
MulExpr              = UnaryExpr, { Spacing, ("*" | "/" | "%"), Spacing, UnaryExpr } ;

UnaryExpr            = { UnaryOp, Spacing }, PostfixExpr ;
UnaryOp              = "!" | "-" | "+" | "~" ;

PostfixExpr          = PrimaryExpr, { Spacing, PostfixOp } ;

PostfixOp            = CallOp
                    | IndexOp
                    | DotOp
                    | CastOp
                    ;

CallOp               = "(", Spacing, [ ArgList ], ")" ;
ArgList              = Expr, Spacing, { ",", Spacing, Expr, Spacing }, [ ",", Spacing ] ;

IndexOp              = "[", Spacing, Expr, Spacing, "]" ;

DotOp                = ".", Ident ;

CastOp               = WS1, "as", WS1, TypeExpr ;

PrimaryExpr          = Literal
                    | Ident
                    | PathExpr
                    | TupleExpr
                    | GroupExpr
                    ;

GroupExpr            = "(", Spacing, Expr, Spacing, ")" ;

TupleExpr            = "(", Spacing,
                       Expr, Spacing, ",", Spacing,
                       [ Expr, Spacing, { ",", Spacing, Expr, Spacing }, [ ",", Spacing ] ],
                       ")" ;

PathExpr             = TypeExpr, "::", Ident ;

LValue               = Ident, { Spacing, ( ".", Ident | "[", Spacing, Expr, Spacing, "]" ) } ;

# ----------------------------------------------------------------------------
# Patterns (match)
# ----------------------------------------------------------------------------

Pattern              = WildcardPat
                    | LiteralPat
                    | IdentPat
                    | TuplePat
                    | VariantPat
                    ;

WildcardPat          = "_" ;
LiteralPat           = Literal ;
IdentPat             = Ident ;

TuplePat             = "(", Spacing,
                       Pattern, Spacing, ",", Spacing,
                       [ Pattern, Spacing, { ",", Spacing, Pattern, Spacing }, [ ",", Spacing ] ],
                       ")" ;

VariantPat           = TypeExpr, "::", Ident,
                       [ Spacing, "(", Spacing, [ Pattern, Spacing, { ",", Spacing, Pattern, Spacing }, [ ",", Spacing ] ], ")" ] ;

# ----------------------------------------------------------------------------
# Types
# ----------------------------------------------------------------------------

TypeExpr             = TypeName, [ TypeArgs ] ;
TypeName             = Ident, { ("." | "/"), Ident } ;

TypeArgs             = "[", Spacing,
                       TypeExpr, Spacing, { ",", Spacing, TypeExpr, Spacing }, [ ",", Spacing ],
                       "]" ;

GenericsDecl          = "[", Spacing,
                        Ident, Spacing, { ",", Spacing, Ident, Spacing }, [ ",", Spacing ],
                        "]" ;

# ----------------------------------------------------------------------------
# Literals
# ----------------------------------------------------------------------------

Literal              = Int
                    | Float
                    | String
                    | Bool
                    | Nil
                    ;

Bool                 = "true" | "false" ;
Nil                  = "nil" ;

Int                  = ["+"|"-"], Digit, { Digit }, [ IntSuffix ] ;
IntSuffix            = "u8" | "u16" | "u32" | "u64" | "i8" | "i16" | "i32" | "i64" ;

Float                = ["+"|"-"], Digit, { Digit }, ".", Digit, { Digit }, [ Exponent ], [ FloatSuffix ]
                    | ["+"|"-"], Digit, { Digit }, Exponent, [ FloatSuffix ] ;

Exponent             = ("e"|"E"), ["+"|"-"], Digit, { Digit } ;
FloatSuffix          = "f32" | "f64" ;

String               = DQString | SQString ;
DQString             = '"', { DQChar }, '"' ;
SQString             = "'", { SQChar }, "'" ;

DQChar               = Escape | ( ? any char except '"' and NEWLINE ? ) ;
SQChar               = Escape | ( ? any char except "'" and NEWLINE ? ) ;

Escape               = "\\", ("\\"|"\""|"'"|"n"|"r"|"t"|"0"|"x", Hex, Hex | "u", Hex, Hex, Hex, Hex) ;

# ----------------------------------------------------------------------------
# Whitespace / comments / line endings
# ----------------------------------------------------------------------------

LineEnd              = Spacing, ( NEWLINE | EOF ) ;

Spacing              = { WS | Comment } ;
WS                   = " " | "\t" ;
WS1                  = WS, { WS } ;

NEWLINE              = "\n" | "\r\n" ;
EOF                  = ? end of input ? ;

Comment              = HashComment | SlashComment ;
HashComment          = "#", { ? any char except NEWLINE ? }, (NEWLINE | EOF) ;
SlashComment         = "//", { ? any char except NEWLINE ? }, (NEWLINE | EOF) ;

EmptyLine            = Spacing, NEWLINE ;

# ----------------------------------------------------------------------------
# Lexical tokens
# ----------------------------------------------------------------------------

Ident                = IdentStart, { IdentCont } ;
IdentStart           = Letter | "_" ;
IdentCont            = Letter | Digit | "_" ;

Letter               = "A".."Z" | "a".."z" ;
Digit                = "0".."9" ;
Hex                  = Digit | "A".."F" | "a".."f" ;

