{"version":3,"file":"semanticTokens.js","sourceRoot":"","sources":["semanticTokens.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * Vitte Language Server — Semantic Tokens Feature\n * ------------------------------------------------\n * Provides a minimal, deterministic tokenizer for Vitte source files.\n * No LSP side effects — pure computation only.\n *\n * Supported token types:\n * - keyword\n * - string\n * - number\n * - function\n * - variable\n * - type\n * - comment\n */\n\n/**\n * Vitte Language Server — Semantic Tokens Feature (Extended)\n * ---------------------------------------------------------\n * Deterministic, side‑effect‑free tokenizer for Vitte source files.\n *\n * Coverage:\n * - Keywords, identifiers with context (function/type/variable).\n * - Numbers (decimal, hex 0x, bin 0b, octal 0o, floats with exponent).\n * - Strings with escapes (single‑line) and block/line comments.\n * - Multiline block comments `/* ... *\\/` supported via state.\n * - Token modifiers: declaration (after fn/struct/enum/trait/type/let/const),\n *   readonly (const), async (async keyword before fn).\n */\n\nimport type { SemanticTokens, SemanticTokensLegend } from 'vscode-languageserver';\n\n\n// Legend kept stable for client expectations.\nexport const legend: SemanticTokensLegend = {\n  tokenTypes: [\n    'namespace', // 0\n    'type',      // 1\n    'class',     // 2\n    'enum',      // 3\n    'interface', // 4\n    'struct',    // 5\n    'typeParameter', // 6\n    'parameter', // 7\n    'variable',  // 8\n    'property',  // 9\n    'enumMember',// 10\n    'event',     // 11\n    'function',  // 12\n    'method',    // 13\n    'macro',     // 14\n    'keyword',   // 15\n    'modifier',  // 16\n    'comment',   // 17\n    'string',    // 18\n    'number',    // 19\n    'regexp',    // 20\n    'operator'   // 21\n  ],\n  tokenModifiers: [\n    'declaration',    // 0 -> 1<<0\n    'definition',     // 1\n    'readonly',       // 2\n    'static',         // 3\n    'deprecated',     // 4\n    'abstract',       // 5\n    'async',          // 6\n    'modification',   // 7\n    'documentation',  // 8\n    'defaultLibrary'  // 9\n  ]\n};\n\n// Fast index lookup.\nconst TI = Object.fromEntries(legend.tokenTypes.map((t, i) => [t, i])) as Record<string, number>;\nconst TM = Object.fromEntries(legend.tokenModifiers.map((t, i) => [t, 1 << i])) as Record<string, number>;\n\nconst KEYWORDS = new Set([\n  'fn','struct','enum','trait','impl','let','const','mut','pub','use','mod','return','if','else','while','for','match',\n  'break','continue','async','await','yield','where','type','alias','true','false','in','of'\n]);\n\n// Simple operator / punct set (we may ignore emitting tokens for these for now).\nconst OPERATORS = new Set(['=>','->','==','!=','<=','>=','&&','||','::',':=','+=','-=','*=','/=','%=',\n  '+','-','*','/','%','<','>','=','!','&','|','^','~',':','.',';',',','(',')','[',']','{','}']);\n\n/** Encodes one token into the semantic tokens `data` using delta encoding. */\nfunction pushToken(\n  data: number[],\n  state: { prevLine: number; prevChar: number },\n  line: number,\n  start: number,\n  length: number,\n  tokenType: number,\n  modifiers = 0\n) {\n  const deltaLine = line - state.prevLine;\n  const deltaStart = deltaLine === 0 ? start - state.prevChar : start;\n  data.push(deltaLine, deltaStart, Math.max(0, length), tokenType, modifiers);\n  state.prevLine = line;\n  state.prevChar = start;\n}\n\n/** Classifies an identifier using its immediate syntactic context. */\nfunction classifyIdent(\n  ident: string,\n  prevSigToken: string | null,\n  nextSigChar: string | null\n): { type: number; mods: number } {\n  // Keywords.\n  if (KEYWORDS.has(ident)) {\n    return { type: TI['keyword'], mods: 0 };\n  }\n\n  // Contextual declarations: name after fn/struct/enum/trait/type/let/const.\n  if (prevSigToken === 'fn') {\n    return { type: TI['function'], mods: TM['declaration'] };\n  }\n  if (prevSigToken === 'struct' || prevSigToken === 'enum' || prevSigToken === 'trait' || prevSigToken === 'type') {\n    return { type: TI['type'], mods: TM['declaration'] };\n  }\n  if (prevSigToken === 'let' || prevSigToken === 'const') {\n    let mods = TM['declaration'];\n    if (prevSigToken === 'const') mods |= TM['readonly'];\n    return { type: TI['variable'], mods };\n  }\n\n  // Heuristic: UpperCamel → type-ish.\n  if (/^[A-Z][A-Za-z0-9_]*$/.test(ident)) {\n    return { type: TI['type'], mods: 0 };\n  }\n\n  // Function hint: next significant char is '('.\n  if (nextSigChar === '(') {\n    return { type: TI['function'], mods: 0 };\n  }\n\n  // Default: variable/identifier.\n  return { type: TI['variable'], mods: 0 };\n}\n\n/** Returns the next non‑space char from a given index in a string, if any. */\nfunction nextNonSpace(s: string, from: number): string | null {\n  for (let i = from; i < s.length; i++) {\n    const c = s[i];\n    if (c !== ' ' && c !== '\\t') return c;\n  }\n  return null;\n}\n\n/** Tokenizes the whole document into `SemanticTokens`. */\nexport function tokenize(text: string): SemanticTokens {\n  const data: number[] = [];\n  const lines = text.split(/\\r?\\n/);\n  const state = { prevLine: 0, prevChar: 0 };\n\n  let inBlockComment = false;\n\n  for (let lineNo = 0; lineNo < lines.length; lineNo++) {\n    const line = lines[lineNo];\n    let i = 0;\n\n    // Track last significant keyword for contextual declarations on this line.\n    let lastSigKeyword: string | null = null;\n    let pendingAsync = false; // Marks async before fn.\n\n    const L = line.length;\n    while (i < L) {\n      // Handle multiline block comments.\n      if (inBlockComment) {\n        const end = line.indexOf('*/', i);\n        if (end === -1) {\n          pushToken(data, state, lineNo, i, L - i, TI['comment']);\n          i = L;\n          continue;\n        } else {\n          pushToken(data, state, lineNo, i, end + 2 - i, TI['comment']);\n          i = end + 2;\n          inBlockComment = false;\n          continue;\n        }\n      }\n\n      const ch = line[i];\n\n      // Whitespace.\n      if (ch === ' ' || ch === '\\t') { i++; continue; }\n\n      // Line comment `//`.\n      if (ch === '/' && i + 1 < L && line[i + 1] === '/') {\n        pushToken(data, state, lineNo, i, L - i, TI['comment']);\n        break; // Rest of the line is a comment.\n      }\n\n      // Block comment start `/*`.\n      if (ch === '/' && i + 1 < L && line[i + 1] === '*') {\n        const end = line.indexOf('*/', i + 2);\n        if (end === -1) {\n          // Continues to next lines.\n          pushToken(data, state, lineNo, i, L - i, TI['comment']);\n          inBlockComment = true;\n          break;\n        } else {\n          pushToken(data, state, lineNo, i, end + 2 - i, TI['comment']);\n          i = end + 2;\n          continue;\n        }\n      }\n\n      // String literal starting with \". Support escapes, single line.\n      if (ch === '\"') {\n        let j = i + 1;\n        while (j < L) {\n          if (line[j] === '\\\\') { j += 2; continue; }\n          if (line[j] === '\"') { j++; break; }\n          j++;\n        }\n        pushToken(data, state, lineNo, i, Math.max(1, j - i), TI['string']);\n        i = j;\n        continue;\n      }\n\n      // Number literal.\n      if (/[0-9]/.test(ch)) {\n        let j = i + 1;\n        if (ch === '0' && j < L && /[xob]/i.test(line[j])) {\n          // 0x, 0o, 0b\n          j++;\n          while (j < L && /[0-9A-Fa-f_]/.test(line[j])) j++;\n        } else {\n          while (j < L && /[0-9_]/.test(line[j])) j++;\n          if (j < L && line[j] === '.') {\n            j++;\n            while (j < L && /[0-9_]/.test(line[j])) j++;\n          }\n          if (j < L && /[eE]/.test(line[j])) {\n            j++;\n            if (j < L && /[+-]/.test(line[j])) j++;\n            while (j < L && /[0-9_]/.test(line[j])) j++;\n          }\n        }\n        pushToken(data, state, lineNo, i, j - i, TI['number']);\n        i = j;\n        continue;\n      }\n\n      // Identifier or keyword.\n      if (/[A-Za-z_]/.test(ch)) {\n        let j = i + 1;\n        while (j < L && /[A-Za-z0-9_]/.test(line[j])) j++;\n        const ident = line.slice(i, j);\n\n        // Track async before fn to add modifier to the function decl.\n        if (ident === 'async') { pendingAsync = true; lastSigKeyword = 'async'; }\n        if (KEYWORDS.has(ident)) {\n          pushToken(data, state, lineNo, i, j - i, TI['keyword']);\n          // Maintain contextual keyword for upcoming declarations.\n          if (ident === 'fn' || ident === 'struct' || ident === 'enum' || ident === 'trait' || ident === 'type' || ident === 'let' || ident === 'const') {\n            lastSigKeyword = ident;\n          }\n          i = j;\n          continue;\n        }\n\n        // Contextual classification.\n        const nextChar = nextNonSpace(line, j);\n        const cls = classifyIdent(ident, lastSigKeyword, nextChar);\n        let mods = cls.mods;\n        if (mods & TM['declaration']) {\n          // If `async` precedes `fn`, mark async on the declaration token (function name).\n          if (lastSigKeyword === 'fn' && pendingAsync) mods |= TM['async'];\n          // Reset after using declaration context.\n          lastSigKeyword = null;\n          pendingAsync = false;\n        }\n        pushToken(data, state, lineNo, i, j - i, cls.type, mods);\n        i = j;\n        continue;\n      }\n\n      // Operators/punct — we currently skip emitting them to keep noise low.\n      // If needed, enable the following to colorize operators as well.\n      /*\n      let matchedOp: string | null = null;\n      for (const op of OPERATORS) {\n        if (line.startsWith(op, i)) { matchedOp = op; break; }\n      }\n      if (matchedOp) {\n        pushToken(data, state, lineNo, i, matchedOp.length, TI['operator']);\n        i += matchedOp.length;\n        continue;\n      }\n      */\n\n      // Fallback: unrecognized single char.\n      i++;\n    }\n  }\n\n  return { data };\n}\n\n/** Provides an empty SemanticTokens result (for fallback or invalid documents). */\nexport function emptyTokens(): SemanticTokens {\n  return { data: [] };\n}\n"]}