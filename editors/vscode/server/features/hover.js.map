{"version":3,"file":"hover.js","sourceRoot":"","sources":["hover.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * Vitte Language Server — Hover Helpers (Extended)\n * ------------------------------------------------\n * Pure helpers with no LSP side effects.\n * - Lightweight symbol indexer (functions, types, variables).\n* - Doc comment extraction (/// and /** ... *\\/).\n * - Heuristic signature preview.\n * - Rich Markdown payload with fenced code and sections.\n * - Accurate hover range (word under cursor).\n *\n * Performance: O(N) single pass over the text (line-by-line).\n */\n\nexport interface Position { line: number; character: number }    // 0-based\nexport interface Range { start: Position; end: Position }\n\nexport interface HoverContext {\n  uri: string;\n  text: string;\n  line: number;       // 0-based\n  character: number;  // 0-based\n}\n\nexport interface HoverPayload {\n  contents: { kind: 'markdown'; value: string };\n  range?: Range;\n}\n\ntype SymbolKind = 'function' | 'struct' | 'enum' | 'trait' | 'type' | 'variable';\n\ninterface SymbolInfo {\n  name: string;\n  kind: SymbolKind;\n  range: Range;           // Name range.\n  signature?: string;     // Single-line signature preview.\n  doc?: string;           // Extracted doc.\n  defLine?: number;       // Definition line.\n  defCol?: number;        // Definition column.\n}\n\n// Minimal keyword set for classification fallback.\nconst KEYWORDS = new Set([\n  'fn','struct','enum','union','trait','impl','let','const','mut','pub','use','mod','return','if','else','while','for','match','break','continue','async','await','yield','where','type','alias'\n]);\n\n/** Extracts the full word at a given position and its [start,end) columns. */\nfunction wordAt(lineText: string, col: number): { word: string; start: number; end: number } | null {\n  if (col < 0) return null;\n  const re = /[A-Za-z0-9_]+/g;\n  let m: RegExpExecArray | null;\n  while ((m = re.exec(lineText))) {\n    if (m.index <= col && re.lastIndex >= col) {\n      return { word: m[0], start: m.index, end: re.lastIndex };\n    }\n  }\n  return null;\n}\n\n/** Escapes Markdown fenced code content safely. */\nfunction fence(lang: string, content: string): string {\n  return '```' + lang + '\\n' + content.replace(/```/g, '``\\u0060') + '\\n```';\n}\n\n/** Trims leading doc comment prefixes and joins lines. */\nfunction normalizeDoc(lines: string[]): string {\n  const cleaned = lines.map(l =>\n    l\n      .replace(/^\\s*\\/\\/\\/\\s?/, '')\n      .replace(/^\\s*\\*\\s?/, '')\n      .replace(/^\\s*\\/\\*\\*?\\s?/, '')\n      .replace(/\\s*\\*\\/\\s*$/, '')\n  );\n  // Collapse multiple blank lines.\n  return cleaned.join('\\n').replace(/\\n{3,}/g, '\\n\\n').trim();\n}\n\n/**\n * Extracts contiguous doc comment block immediately above a given line index.\n * Supports `///` style and `/** ... *\\/` style.\n */\nfunction extractLeadingDoc(sourceLines: string[], defLine: number): string | undefined {\n  const doc: string[] = [];\n  // 1) Try `///` blocks directly above.\n  let i = defLine - 1;\n  let sawSlashDoc = false;\n  while (i >= 0) {\n    const line = sourceLines[i];\n    if (/^\\s*\\/\\/\\//.test(line)) {\n      doc.unshift(line);\n      sawSlashDoc = true;\n      i--;\n      continue;\n    }\n    if (/^\\s*$/.test(line)) {\n      // Allow one blank line between `///` lines (still part of doc).\n      if (sawSlashDoc) { i--; continue; }\n    }\n    break;\n  }\n  if (doc.length > 0) return normalizeDoc(doc);\n\n  // 2) Try a JSDoc-style block `/** ... */` immediately above (ignoring blank line).\n  i = defLine - 1;\n  // Skip one blank line max.\n  if (i >= 0 && /^\\s*$/.test(sourceLines[i])) i--;\n  if (i >= 0 && /\\*\\/\\s*$/.test(sourceLines[i])) {\n    const block: string[] = [];\n    let j = i;\n    while (j >= 0) {\n      const L = sourceLines[j];\n      block.unshift(L);\n      if (/^\\s*\\/\\*\\*/.test(L)) break;\n      j--;\n    }\n    if (block.length > 0 && /^\\s*\\/\\*\\*/.test(block[0])) {\n      return normalizeDoc(block);\n    }\n  }\n  return undefined;\n}\n\n/** Converts [startCol,endCol) to a Range for the given line. */\nfunction rangeForLine(line: number, start: number, end: number): Range {\n  return { start: { line, character: start }, end: { line, character: end } };\n}\n\n/**\n * Builds a lightweight symbol index from source lines.\n * Keeps it intentionally simple and deterministic.\n */\nfunction indexSymbols(text: string): SymbolInfo[] {\n  const symbols: SymbolInfo[] = [];\n  const lines = text.split(/\\r?\\n/);\n  const cap = Math.min(lines.length, 50_000); // Safety cap.\n\n  for (let ln = 0; ln < cap; ln++) {\n    const line = lines[ln];\n\n    // --- Functions: fn name(args).\n    {\n      const m = line.match(/^\\s*fn\\s+([A-Za-z_]\\w*)\\s*\\(([^)]*)\\)?/);\n      if (m) {\n        const name = m[1];\n        const nameStart = line.indexOf(name);\n        const sig = `fn ${name}(${m[2] ?? ''})`;\n        symbols.push({\n          name,\n          kind: 'function',\n          range: rangeForLine(ln, nameStart, nameStart + name.length),\n          signature: sig,\n          doc: extractLeadingDoc(lines, ln),\n          defLine: ln,\n          defCol: nameStart,\n        });\n        continue; // One symbol per line preference.\n      }\n    }\n\n    // --- Structs.\n    {\n      const m = line.match(/^\\s*struct\\s+([A-Za-z_]\\w*)\\b/);\n      if (m) {\n        const name = m[1];\n        const nameStart = line.indexOf(name);\n        symbols.push({\n          name,\n          kind: 'struct',\n          range: rangeForLine(ln, nameStart, nameStart + name.length),\n          signature: `struct ${name} { … }`,\n          doc: extractLeadingDoc(lines, ln),\n          defLine: ln, defCol: nameStart,\n        });\n        continue;\n      }\n    }\n\n    // --- Enums.\n    {\n      const m = line.match(/^\\s*enum\\s+([A-Za-z_]\\w*)\\b/);\n      if (m) {\n        const name = m[1];\n        const nameStart = line.indexOf(name);\n        symbols.push({\n          name,\n          kind: 'enum',\n          range: rangeForLine(ln, nameStart, nameStart + name.length),\n          signature: `enum ${name} { … }`,\n          doc: extractLeadingDoc(lines, ln),\n          defLine: ln, defCol: nameStart,\n        });\n        continue;\n      }\n    }\n\n    // --- Traits.\n    {\n      const m = line.match(/^\\s*trait\\s+([A-Za-z_]\\w*)\\b/);\n      if (m) {\n        const name = m[1];\n        const nameStart = line.indexOf(name);\n        symbols.push({\n          name,\n          kind: 'trait',\n          range: rangeForLine(ln, nameStart, nameStart + name.length),\n          signature: `trait ${name} { … }`,\n          doc: extractLeadingDoc(lines, ln),\n          defLine: ln, defCol: nameStart,\n        });\n        continue;\n      }\n    }\n\n    // --- Type alias.\n    {\n      const m = line.match(/^\\s*type\\s+([A-Za-z_]\\w*)\\b/);\n      if (m) {\n        const name = m[1];\n        const nameStart = line.indexOf(name);\n        symbols.push({\n          name,\n          kind: 'type',\n          range: rangeForLine(ln, nameStart, nameStart + name.length),\n          signature: `type ${name} = …`,\n          doc: extractLeadingDoc(lines, ln),\n          defLine: ln, defCol: nameStart,\n        });\n        continue;\n      }\n    }\n\n    // --- Variables (let [mut] name [: Ty] = …).\n    {\n      const m = line.match(/^\\s*let\\s+(?:mut\\s+)?([A-Za-z_]\\w*)(\\s*:\\s*([^=;]+))?/);\n      if (m) {\n        const name = m[1];\n        const nameStart = line.indexOf(name);\n        const ty = (m[3] ?? '').trim();\n        const sig = ty ? `let ${name}: ${ty}` : `let ${name}: _`;\n        symbols.push({\n          name,\n          kind: 'variable',\n          range: rangeForLine(ln, nameStart, nameStart + name.length),\n          signature: sig,\n          doc: extractLeadingDoc(lines, ln),\n          defLine: ln, defCol: nameStart,\n        });\n        continue;\n      }\n    }\n  }\n\n  return symbols;\n}\n\n/** Basic classifier for non-indexed tokens (fallback). */\nfunction classifyFallback(word: string, before: string, after: string): SymbolKind | 'keyword' {\n  if (KEYWORDS.has(word)) return 'keyword' as any;\n  if (/^[A-Z][A-Za-z0-9_]*$/.test(word)) return 'type';\n  if (/^\\s*\\(/.test(after) || /(^|\\W)fn\\s+$/.test(before)) return 'function';\n  return 'variable';\n}\n\n/** Builds nice Markdown hover from symbol info (or fallback token). */\nfunction buildMarkdown(sym: SymbolInfo | null, fallbackKind?: string): string {\n  if (sym) {\n    const header = `**${sym.name}** — ${sym.kind}`;\n    const sig = sym.signature ? '\\n\\n' + fence('vitte', sym.signature) : '';\n    const doc = sym.doc ? '\\n\\n' + sym.doc : '';\n    const def = typeof sym.defLine === 'number'\n      ? `\\n\\n_Definition: line ${sym.defLine + 1}, col ${ (sym.defCol ?? 0) + 1 }_`\n      : '';\n    return header + sig + doc + def;\n  }\n  // Fallback.\n  return `**${fallbackKind ?? 'symbol'}**`;\n}\n\n/**\n * Provides hover payload for a position.\n * Returns null when nothing meaningful is found.\n */\nexport function provideHover(ctx: HoverContext): HoverPayload | null {\n  const lines = ctx.text.split(/\\r?\\n/);\n  if (ctx.line < 0 || ctx.line >= lines.length) return null;\n  const lineText = lines[ctx.line];\n\n  const w = wordAt(lineText, ctx.character);\n  if (!w || !w.word) return null;\n\n  // Build local range for the hovered word.\n  const hoverRange: Range = rangeForLine(ctx.line, w.start, w.end);\n\n  // Try indexed symbols first.\n  const symbols = indexSymbols(ctx.text);\n\n  // Prefer exact name matches on the same line first, then global.\n  let match: SymbolInfo | null = null;\n  for (const s of symbols) {\n    if (s.name === w.word && s.defLine === ctx.line) { match = s; break; }\n  }\n  if (!match) {\n    for (const s of symbols) {\n      if (s.name === w.word) { match = s; break; }\n    }\n  }\n\n  if (match) {\n    return {\n      contents: { kind: 'markdown', value: buildMarkdown(match) },\n      range: hoverRange,\n    };\n  }\n\n  // Fallback classification (keyword/type/function/variable).\n  const before = lineText.slice(0, w.start);\n  const after = lineText.slice(w.end);\n  const kind = classifyFallback(w.word, before, after);\n  const md = `**${w.word}** — ${kind}` + (kind === 'function'\n    ? '\\n\\n' + fence('vitte', `fn ${w.word}(…)`)\n    : '');\n  return { contents: { kind: 'markdown', value: md }, range: hoverRange };\n}\n"]}