{"version":3,"file":"eol.js","sourceRoot":"","sources":["../../../src/utils/eol.ts"],"names":[],"mappings":"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","sourcesContent":["\n/**\n * Vitte LSP Utils — EOL helpers (ultra complete +++)\n * --------------------------------------------------\n * Pure utilities to detect, normalize, and manage end‑of‑line sequences.\n * Includes stats, policies, streaming transforms, offset/position helpers,\n * and range remapping across LF/CRLF conversions.\n *\n * All functions are dependency‑free and side‑effect‑free.\n */\n\nexport type EolKind = 'lf' | 'crlf' | 'auto';\n\nexport const LF = '\\n' as const;\nexport const CRLF = '\\r\\n' as const;\nexport const CR = '\\r' as const; // Rare; tracked for completeness.\n\n// ---------------------------------------------------------------------------\n// Stats & detection\n// ---------------------------------------------------------------------------\n\nexport interface EolStats {\n  lf: number;          // Count of LF characters that are not part of CRLF.\n  crlf: number;        // Count of CRLF sequences.\n  cr: number;          // Count of lone CR characters (old Mac style).\n  lastLineHasTerminator: boolean; // Whether the last line ends with an EOL.\n}\n\n/** Returns counts of CRLF sequences, standalone LF/CR, and final‑newline flag. */\nexport function measureEol(text: string): EolStats {\n  if (text.length === 0) return { lf: 0, crlf: 0, cr: 0, lastLineHasTerminator: false };\n\n  let lf = 0;\n  let crlf = 0;\n  let cr = 0;\n\n  // Fast path: short‑circuit when there is no CR at all.\n  if (!text.includes('\\r')) {\n    for (let i = 0; i < text.length; i++) if (text.charCodeAt(i) === 10) lf++;\n    return { lf, crlf, cr, lastLineHasTerminator: text.endsWith('\\n') };\n  }\n\n  for (let i = 0; i < text.length; i++) {\n    const ch = text.charCodeAt(i);\n    if (ch === 13 /*\\r*/) {\n      if (i + 1 < text.length && text.charCodeAt(i + 1) === 10 /*\\n*/) {\n        crlf++; i++; // Skip the \\n of CRLF.\n      } else {\n        cr++;\n      }\n    } else if (ch === 10 /*\\n*/) {\n      lf++;\n    }\n  }\n  const lastLineHasTerminator = text.endsWith('\\n') || text.endsWith('\\r');\n  return { lf, crlf, cr, lastLineHasTerminator };\n}\n\n/** True if CRLF and bare LF/CR coexist (mixed file endings). */\nexport function hasMixedEol(text: string): boolean {\n  const s = measureEol(text);\n  const hasBare = s.lf > 0 || s.cr > 0;\n  return s.crlf > 0 && hasBare;\n}\n\n/** Detects dominant EOL with simple majority. Ties favor LF. */\nexport function detectEol(text: string): EolKind {\n  const s = measureEol(text);\n  const bareTotal = s.lf + s.cr;\n  if (s.crlf === 0 && bareTotal === 0) return 'lf';\n  return s.crlf > bareTotal ? 'crlf' : 'lf';\n}\n\n/**\n * Detects dominant EOL using a bias and tiebreaker.\n * @param text Source text.\n * @param bias When absolute difference < `bias`, returns `tiebreak`.\n * @param tiebreak Winner when counts are equal or within `bias` (default 'lf').\n */\nexport function detectEolThreshold(text: string, bias = 0, tiebreak: Exclude<EolKind,'auto'> = 'lf'): Exclude<EolKind,'auto'> {\n  const s = measureEol(text);\n  const lfLike = s.lf + s.cr;\n  const diff = Math.abs(s.crlf - lfLike);\n  if (diff <= bias) return tiebreak;\n  return s.crlf > lfLike ? 'crlf' : 'lf';\n}\n\n/** Counts logical lines regardless of EOL kind. */\nexport function countLines(text: string): number {\n  if (text.length === 0) return 1;\n  // Normalize CRLF/CR to LF for counting; do not allocate per line.\n  let lines = 1;\n  for (let i = 0; i < text.length; i++) {\n    const c = text.charCodeAt(i);\n    if (c === 13 /*\\r*/) {\n      if (i + 1 < text.length && text.charCodeAt(i + 1) === 10 /*\\n*/) i++;\n      lines++;\n    } else if (c === 10 /*\\n*/) {\n      lines++;\n    }\n  }\n  return lines;\n}\n\n/** Whether the last line ends with an EOL terminator. */\nexport function isTerminated(text: string): boolean {\n  return text.endsWith('\\n') || text.endsWith('\\r');\n}\n\n// ---------------------------------------------------------------------------\n// Normalization & policies\n// ---------------------------------------------------------------------------\n\n/**\n * Normalizes EOL sequences to target `eol` (CRLF and CR → LF, then LF → CRLF if needed).\n * If `eol === 'auto'`, returns the input unchanged.\n */\nexport function normalizeEol(text: string, eol: EolKind): string {\n  if (eol === 'auto') return text;\n  const work = text.replace(/\\r\\n/g, '\\n').replace(/\\r/g, '\\n');\n  if (eol === 'lf') return work;\n  return work.replace(/\\n/g, CRLF);\n}\n\n/** Ensures a single final newline if requested. */\nexport function ensureFinalNewline(text: string, eol: EolKind = 'lf'): string {\n  const terminator = eol === 'crlf' ? CRLF : LF;\n  return text.endsWith(terminator) ? text : text + terminator;\n}\n\n/** Removes any trailing newline at the end of the text (LF, CRLF or CR). */\nexport function stripFinalNewline(text: string): string {\n  if (text.endsWith(CRLF)) return text.slice(0, -2);\n  if (text.endsWith(LF) || text.endsWith(CR)) return text.slice(0, -1);\n  return text;\n}\n\n/** Splits text into lines, accepting CRLF, LF and CR. */\nexport function splitLines(text: string): string[] {\n  const endsWithEol = /\\r?\\n|\\r$/.test(text);\n  const parts = text.replace(/\\r\\n/g, '\\n').replace(/\\r/g, '\\n').split('\\n');\n  if (!endsWithEol && parts.length > 0 && parts[parts.length - 1] === '') parts.pop();\n  return parts;\n}\n\n/** Joins lines with the given EOL kind. For 'auto', defaults to LF. */\nexport function joinLines(lines: string[], eol: EolKind): string {\n  const sep = eol === 'crlf' ? CRLF : LF; // auto → LF\n  return lines.join(sep);\n}\n\n/** Quick helper to decide output EOL based on user choice and input text. */\nexport function chooseOutputEol(preferred: EolKind, sourceText: string, fallback: EolKind = 'lf'): EolKind {\n  if (preferred === 'auto') return detectEol(sourceText) || fallback;\n  return preferred;\n}\n\nexport type EolPolicyMode = 'preserve' | 'lf' | 'crlf' | 'auto';\n\nexport interface EolPolicy {\n  mode: EolPolicyMode;            // How to decide output EOL.\n  ensureFinalNewline?: boolean;   // Ensure exactly one final newline.\n  stripFinalNewline?: boolean;    // Force no trailing newline.\n}\n\n/** Applies an EOL policy in a single pass (ensure wins over strip when both). */\nexport function applyEolPolicy(text: string, policy: EolPolicy): string {\n  const target: EolKind = policy.mode === 'preserve' ? 'auto' : (policy.mode as EolKind);\n  let out = normalizeEol(text, target === 'auto' ? detectEol(text) : target);\n  if (policy.stripFinalNewline) out = stripFinalNewline(out);\n  if (policy.ensureFinalNewline) out = ensureFinalNewline(out, target === 'auto' ? detectEol(text) : target);\n  return out;\n}\n\n// ---------------------------------------------------------------------------\n// Streaming normalization (for large texts/chunks)\n// ---------------------------------------------------------------------------\n\nexport interface EolTransformState {\n  /** True if previous chunk ended with a bare CR (\"\\r\"). */\n  carryCR?: boolean;\n}\n\n/**\n * Normalizes a chunk to LF (CRLF/CR → LF). Maintains state for boundaries.\n * Returns normalized output and updated state.\n */\nexport function normalizeChunkToLf(chunk: string, state: EolTransformState = {}): { output: string; state: EolTransformState } {\n  let out = '';\n  let i = 0;\n  if (state.carryCR) {\n    // If this chunk starts with \\n, the boundary was a CRLF.\n    if (chunk.charCodeAt(0) === 10 /*\\n*/) {\n      // Drop the CR from previous chunk; emit a single LF.\n      out += '\\n';\n      i = 1;\n    } else {\n      // Lone CR at boundary → convert to LF.\n      out += '\\n';\n    }\n    state.carryCR = false;\n  }\n\n  for (; i < chunk.length; i++) {\n    const c = chunk.charCodeAt(i);\n    if (c === 13 /*\\r*/) {\n      if (i + 1 < chunk.length && chunk.charCodeAt(i + 1) === 10 /*\\n*/) {\n        out += '\\n';\n        i++; // Skip the \\n.\n      } else {\n        // May be CRLF across boundary; carry.\n        state.carryCR = true;\n      }\n    } else if (c === 10 /*\\n*/) {\n      out += '\\n';\n    } else {\n      out += chunk[i];\n    }\n  }\n\n  return { output: out, state };\n}\n\n/** Converts LF‑normalized chunk to target EOL. */\nexport function expandLfChunk(chunkWithLf: string, target: Exclude<EolKind,'auto'>): string {\n  if (target === 'lf') return chunkWithLf;\n  // Convert LF → CRLF.\n  return chunkWithLf.replace(/\\n/g, CRLF);\n}\n\n// ---------------------------------------------------------------------------\n// Offsets, positions, and range remapping\n// ---------------------------------------------------------------------------\n\nexport interface Position { line: number; character: number }\nexport interface Range { start: Position; end: Position }\n\n/** Returns an array of line start offsets for fast position mapping. */\nexport function indexLineStarts(text: string): number[] {\n  const starts: number[] = [0];\n  for (let i = 0; i < text.length; i++) {\n    const ch = text.charCodeAt(i);\n    if (ch === 13 /*\\r*/) {\n      if (i + 1 < text.length && text.charCodeAt(i + 1) === 10 /*\\n*/) { i++; }\n      starts.push(i + 1);\n    } else if (ch === 10 /*\\n*/) {\n      starts.push(i + 1);\n    }\n  }\n  return starts;\n}\n\n/** Maps a character offset to a Position using a precomputed line index. */\nexport function positionAt(offset: number, lineStarts: number[]): Position {\n  offset = Math.max(0, offset);\n  let lo = 0, hi = lineStarts.length - 1;\n  while (lo <= hi) {\n    const mid = (lo + hi) >>> 1;\n    const lineStart = lineStarts[mid];\n    if (lineStart === offset) return { line: mid, character: 0 };\n    if (lineStart < offset) lo = mid + 1; else hi = mid - 1;\n  }\n  const line = Math.max(0, lo - 1);\n  return { line, character: offset - lineStarts[line] };\n}\n\n/** Maps a Position to a character offset using a precomputed line index. */\nexport function offsetAt(pos: Position, lineStarts: number[]): number {\n  const line = Math.min(Math.max(0, pos.line), Math.max(0, lineStarts.length - 1));\n  return lineStarts[line] + Math.max(0, pos.character);\n}\n\n/**\n * Builds a mapping of CRLF→LF normalization for a given text.\n * Returns the set of offsets (in LF‑normalized text) where an original CR preceded an LF.\n * Useful to remap LF columns back to CRLF columns (add +1 per occurrence before offset).\n */\nexport function buildCrlfToLfMap(text: string): Uint32Array {\n  const marks: number[] = [];\n  for (let i = 0; i + 1 < text.length; i++) {\n    if (text.charCodeAt(i) === 13 /*\\r*/ && text.charCodeAt(i + 1) === 10 /*\\n*/) {\n      // After normalization, only the \\n remains at index i.\n      marks.push(i + 1); // Index of the LF in the normalized text.\n      i++; // Skip LF.\n    }\n  }\n  return Uint32Array.from(marks);\n}\n\n/** Remaps an offset from LF‑normalized back to CRLF view using a mark array. */\nexport function remapLfOffsetToCrlfWithMap(lfOffset: number, crlfMarks: Uint32Array): number {\n  // Binary‑search upper bound of marks < lfOffset.\n  let lo = 0, hi = crlfMarks.length;\n  while (lo < hi) {\n    const mid = (lo + hi) >>> 1;\n    if (crlfMarks[mid] < lfOffset) lo = mid + 1; else hi = mid;\n  }\n  return lfOffset + lo; // Add one extra char per CRLF before the offset.\n}\n\n/** Remaps a Range from LF‑normalized view to CRLF view. */\nexport function remapRangeLfToCrlf(range: Range, crlfMarks: Uint32Array, lineStartsLf: number[]): Range {\n  const startOff = offsetAt(range.start, lineStartsLf);\n  const endOff = offsetAt(range.end, lineStartsLf);\n  const start2 = remapLfOffsetToCrlfWithMap(startOff, crlfMarks);\n  const end2 = remapLfOffsetToCrlfWithMap(endOff, crlfMarks);\n  return {\n    start: positionAt(start2, lineStartsLf),\n    end: positionAt(end2, lineStartsLf),\n  };\n}\n\n/** Normalizes a range to have start <= end and non‑negative values. */\nexport function normalizeRange(a: Range): Range {\n  const s = (a.start.line > a.end.line || (a.start.line === a.end.line && a.start.character > a.end.character))\n    ? { start: a.end, end: a.start }\n    : a;\n  return {\n    start: { line: Math.max(0, s.start.line), character: Math.max(0, s.start.character) },\n    end:   { line: Math.max(0, s.end.line),   character: Math.max(0, s.end.character) },\n  };\n}\n\n// ---------------------------------------------------------------------------\n// Extra helpers\n// ---------------------------------------------------------------------------\n\n/** Splits text and returns pairs [line, delimiter] where delimiter is one of \"\\n\", \"\\r\\n\", \"\\r\" or \"\" for the last line. */\nexport function splitLinesWithDelimiters(text: string): { line: string; delim: '' | typeof LF | typeof CRLF | typeof CR }[] {\n  const out: { line: string; delim: '' | typeof LF | typeof CRLF | typeof CR }[] = [];\n  let buf = '';\n  for (let i = 0; i < text.length; i++) {\n    const c = text.charCodeAt(i);\n    if (c === 13 /*\\r*/) {\n      if (i + 1 < text.length && text.charCodeAt(i + 1) === 10 /*\\n*/) {\n        out.push({ line: buf, delim: CRLF }); buf = ''; i++; continue;\n      }\n      out.push({ line: buf, delim: CR }); buf = ''; continue;\n    }\n    if (c === 10 /*\\n*/) { out.push({ line: buf, delim: LF }); buf = ''; continue; }\n    buf += text[i];\n  }\n  out.push({ line: buf, delim: '' });\n  return out;\n}\n\n/** Joins result of splitLinesWithDelimiters, optionally overriding delimiter kind. */\nexport function joinLinesPreserveLastTerminator(parts: { line: string; delim: '' | typeof LF | typeof CRLF | typeof CR }[], eol: EolKind): string {\n  const sep = eol === 'crlf' ? CRLF : LF; // auto → LF\n  let out = '';\n  for (const part of parts) {\n    const { line, delim } = part;\n    const useDelim = delim === '' ? '' : sep; // Preserve presence of last terminator, but convert kind.\n    out += line + useDelim;\n  }\n  return out;\n}\n\n/** Clamps a position inside [0, maxLine] and [0, +∞) for character. */\nexport function clampPosition(pos: Position, maxLine: number): Position {\n  const l = Math.max(0, Math.min(maxLine, pos.line));\n  const c = Math.max(0, pos.character);\n  return { line: l, character: c };\n}\n\n/** Compares positions; returns -1,0,1. */\nexport function comparePosition(a: Position, b: Position): -1 | 0 | 1 {\n  if (a.line < b.line) return -1; if (a.line > b.line) return 1;\n  if (a.character < b.character) return -1; if (a.character > b.character) return 1;\n  return 0;\n}\n\n/** Merges overlapping or contiguous ranges (LF view). */\nexport function mergeRanges(ranges: Range[]): Range[] {\n  if (ranges.length <= 1) return ranges.slice();\n  const rs = ranges.map(normalizeRange).sort((x, y) => comparePosition(x.start, y.start));\n  const out: Range[] = [];\n  let cur = rs[0];\n  for (let i = 1; i < rs.length; i++) {\n    const r = rs[i];\n    if (comparePosition(r.start, cur.end) <= 0) {\n      // Overlap/adjacent → extend end.\n      if (comparePosition(r.end, cur.end) > 0) cur.end = r.end;\n    } else {\n      out.push(cur); cur = r;\n    }\n  }\n  out.push(cur);\n  return out;\n}\n"]}