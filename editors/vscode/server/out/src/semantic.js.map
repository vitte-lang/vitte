{"version":3,"file":"semantic.js","sourceRoot":"","sources":["../../src/semantic.ts"],"names":[],"mappings":"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","sourcesContent":["// semantic.ts — simple, robuste, et plus complet\r\n// Améliorations clés:\r\n// - Lexer en un seul passage: collecte des plages commentaires et chaînes + masque code\r\n// - Émission triée et sans chevauchement pour respecter LSP SemanticTokens\r\n// - Coloration ciblée des noms de déclarations (module/fn/struct/enum/type/let|const)\r\n// - Paramètres de fonctions et propriétés de struct\r\n// - Mots-clés et nombres uniquement en zones de code\r\n// - Cache par document/version\r\n// - Hover concis sur mots-clés\r\n\r\nimport {\n  MarkupKind,\n  SemanticTokensBuilder,\n} from \"vscode-languageserver/node\";\nimport type {\n  Position,\n  Hover,\n  SemanticTokensLegend,\n  SemanticTokens,\n} from \"vscode-languageserver/node\";\nimport type { TextDocument } from \"vscode-languageserver-textdocument\";\nimport { RESERVED_WORDS } from \"./languageFacts.js\";\n\r\n/* ------------------------------ Legend stable ----------------------------- */\r\n// Garder l’ordre en phase avec server.ts\r\nconst TOKEN_TYPES = [\r\n  \"namespace\", // 0\r\n  \"type\",      // 1\r\n  \"function\",  // 2\r\n  \"variable\",  // 3\r\n  \"parameter\", // 4\r\n  \"property\",  // 5\r\n  \"keyword\",   // 6\r\n  \"number\",    // 7\r\n  \"string\",    // 8\r\n  \"comment\",   // 9\r\n] as const;\r\n\r\nconst TOKEN_MODIFIERS: string[] = [];\r\n\r\nconst TYPE_INDEX = {\r\n  namespace: 0,\r\n  type: 1,\r\n  function: 2,\r\n  variable: 3,\r\n  parameter: 4,\r\n  property: 5,\r\n  keyword: 6,\r\n  number: 7,\r\n  string: 8,\r\n  comment: 9,\r\n} as const;\r\n\r\nexport function getSemanticTokensLegend(): SemanticTokensLegend {\r\n  return { tokenTypes: Array.from(TOKEN_TYPES), tokenModifiers: TOKEN_MODIFIERS };\r\n}\r\n\r\n/* --------------------------------- Hover ---------------------------------- */\r\n\r\nconst HOVER_DOC: Record<string, string> = {\n  module: \"Déclare le module courant.\",\n  import: \"Importe un chemin depuis un autre module.\",\n  as: \"Assigne un alias à un import.\",\n  pub: \"Rend le symbole public.\",\n  struct: \"Définit une structure.\",\n  enum: \"Définit une énumération.\",\n  union: \"Définit une union.\",\n  type: \"Déclare un alias de type.\",\n  fn: \"Déclare une fonction.\",\n  let: \"Déclare une variable locale.\",\n  mut: \"Rend un binding mutable.\",\n  const: \"Déclare une constante.\",\n  static: \"Déclare un symbole statique.\",\n  where: \"Contraintes de type.\",\n  if: \"Instruction conditionnelle.\",\n  else: \"Branche alternative.\",\n  match: \"Branches par motifs.\",\n  while: \"Boucle conditionnelle.\",\n  for: \"Boucle itérative.\",\n  in: \"Itération sur une séquence.\",\n  loop: \"Boucle infinie interrompue par break.\",\n  break: \"Interrompt une boucle.\",\n  continue: \"Passe à l’itération suivante.\",\n  return: \"Retourne depuis une fonction.\",\n  true: \"Booléen vrai.\",\n  false: \"Booléen faux.\",\n  nil: \"Valeur nulle.\",\n};\n\r\nexport function provideHover(doc: TextDocument, position: Position): Hover | null {\r\n  const w = wordAt(doc, position);\r\n  if (!w) return null;\r\n  const info = HOVER_DOC[w];\r\n  if (!info) return null;\r\n  return { contents: { kind: MarkupKind.Markdown, value: `**${w}** — ${info}` } };\r\n}\r\n\r\n/* --------------------------- Semantic tokeniser --------------------------- */\r\n\r\nconst KW = RESERVED_WORDS;\n\r\n// Cache basique par document/version\r\nconst semCache = new WeakMap<TextDocument, { version: number; tokens: SemanticTokens }>();\r\n\r\nexport function buildSemanticTokens(doc: TextDocument): SemanticTokens {\r\n  const cached = semCache.get(doc);\r\n  if (cached && cached.version === doc.version) return cached.tokens;\r\n\r\n  const text = doc.getText();\r\n  const lex = scanLex(text); // { mask, strings, comments }\r\n  const nlIdx = buildLineIndex(text);\r\n\r\n  // On collecte d’abord tous les spans, puis on trie, puis on émet\n  interface Span { start: number; end: number; type: number; }\n  const spans: Span[] = [];\n\r\n  // 1) commentaires et chaînes (priorité forte)\r\n  for (const [s, e] of lex.comments) insertSpan(spans, s, e, TYPE_INDEX.comment);\r\n  for (const [s, e] of lex.strings) insertSpan(spans, s, e, TYPE_INDEX.string);\r\n\r\n  // 2) nombres en zones de code\r\n  for (const m of matchAll(/\\b\\d(?:_?\\d)*(?:\\.(?:\\d(?:_?\\d)*)?)?(?:[eE][+-]?\\d+)?\\b/g, text)) {\r\n    if (!lex.mask[m.index]) continue;\r\n    insertSpan(spans, m.index, m.index + m[0].length, TYPE_INDEX.number);\r\n  }\r\n\r\n  // 3) mots-clés en zones de code\r\n  for (const m of matchAll(/\\b[A-Za-z_]\\w*\\b/g, text)) {\r\n    if (!lex.mask[m.index]) continue;\r\n    if (!KW.has(m[0])) continue;\r\n    insertSpan(spans, m.index, m.index + m[0].length, TYPE_INDEX.keyword);\r\n  }\r\n\r\n  // 4) déclarations: colorer uniquement le nom\r\n  addDeclSpans(text, lex.mask, /\\bmodule\\s+([A-Za-z_][\\w:]*)/g, 1, TYPE_INDEX.namespace, spans);\n  addDeclSpans(text, lex.mask, /\\bstruct\\s+([A-Za-z_]\\w*)/g, 1, TYPE_INDEX.type, spans);\n  addDeclSpans(text, lex.mask, /\\benum\\s+([A-Za-z_]\\w*)/g, 1, TYPE_INDEX.type, spans);\n  addDeclSpans(text, lex.mask, /\\bunion\\s+([A-Za-z_]\\w*)/g, 1, TYPE_INDEX.type, spans);\n  addDeclSpans(text, lex.mask, /\\btype\\s+([A-Za-z_]\\w*)/g, 1, TYPE_INDEX.type, spans);\n  addDeclSpans(text, lex.mask, /\\bfn\\s+([A-Za-z_]\\w*)\\s*\\(/g, 1, TYPE_INDEX.function, spans);\n  addDeclSpans(text, lex.mask, /\\b(?:let|const|static)\\s+(?:mut\\s+)?([A-Za-z_]\\w*)/g, 1, TYPE_INDEX.variable, spans);\n\r\n  // 5) paramètres de fonctions\r\n  for (const m of matchAll(/\\bfn\\s+[A-Za-z_]\\w*\\s*\\(([^)]*)\\)/g, text)) {\r\n    if (!lex.mask[m.index]) continue; // début du fn\r\n    const params = (m[1] ?? \"\").split(\",\");\r\n    const base = m.index + m[0].indexOf(\"(\") + 1;\r\n    let offset = 0;\r\n    for (const p of params) {\r\n      const mm = /\\s*([A-Za-z_]\\w*)/.exec(p);\r\n      if (!mm) { offset += p.length + 1; continue; }\r\n      const name = mm[1];\r\n      const local = p.indexOf(name);\r\n      const off = base + offset + (local >= 0 ? local : 0);\r\n      if (name && lex.mask[off]) insertSpan(spans, off, off + name.length, TYPE_INDEX.parameter);\r\n      offset += p.length + 1; // +1 pour la virgule\r\n    }\r\n  }\r\n\r\n  // 6) propriétés de struct\r\n  for (const m of matchAll(/\\bstruct\\s+[A-Za-z_]\\w*\\s*\\{([\\s\\S]*?)\\}/g, text)) {\r\n    const body = m[1] ?? \"\";\r\n    const bodyStart = m.index + m[0].indexOf(\"{\") + 1;\r\n    for (const fm of matchAll(/(^|\\s)([A-Za-z_]\\w*)\\s*:\\n?\\s*[^,\\n\\r\\}]+/g, body)) {\r\n      const name = fm[2];\r\n      const off = bodyStart + fm.index + fm[0].lastIndexOf(name);\r\n      if (lex.mask[off]) insertSpan(spans, off, off + name.length, TYPE_INDEX.property);\r\n    }\r\n  }\r\n\r\n  // Tri global et émission\r\n  spans.sort((a, b) => a.start - b.start || a.end - b.end);\r\n  const builder = new SemanticTokensBuilder();\r\n  for (const s of spans) pushMultiline(builder, nlIdx, s.start, s.end, s.type);\r\n\r\n  const tokens = builder.build();\r\n  semCache.set(doc, { version: doc.version, tokens });\r\n  return tokens;\r\n}\r\n\r\n/* --------------------------------- utils ---------------------------------- */\r\n\r\nfunction wordAt(doc: TextDocument, pos: Position): string | null {\r\n  const text = doc.getText();\r\n  const off = doc.offsetAt(pos);\r\n  let s = off, e = off;\r\n  while (s > 0 && /[A-Za-z0-9_]/.test(text.charAt(s - 1))) s--;\r\n  while (e < text.length && /[A-Za-z0-9_]/.test(text.charAt(e))) e++;\r\n  return e > s ? text.slice(s, e) : null;\r\n}\r\n\r\n// Scan lexical: collecte commentaires/chaînes et construit un masque code\r\nfunction scanLex(text: string): { mask: Uint8Array; strings: [number, number][]; comments: [number, number][] } {\n  const n = text.length;\n  const mask = new Uint8Array(n); // 1 = code, 0 = non-code\n  const strings: [number, number][] = [];\n  const comments: [number, number][] = [];\n\r\n  let i = 0;\r\n  const markCode = (from: number, to: number) => { for (let k = from; k < to; k++) mask[k] = 1; };\r\n\r\n  while (i < n) {\r\n    const c = text.charCodeAt(i);\r\n    const c2 = i + 1 < n ? text.charCodeAt(i + 1) : 0;\r\n\r\n    // line comment //...\r\n    if (c === 0x2f && c2 === 0x2f) {\r\n      const start = i;\r\n      i += 2;\r\n      while (i < n && text.charCodeAt(i) !== 0x0a) i++;\r\n      comments.push([start, i]);\r\n      continue;\r\n    }\r\n    // block comment /* ... */\r\n    if (c === 0x2f && c2 === 0x2a) {\r\n      const start = i;\r\n      i += 2;\r\n      while (i < n) {\r\n        if (text.charCodeAt(i) === 0x2a && i + 1 < n && text.charCodeAt(i + 1) === 0x2f) { i += 2; break; }\r\n        i++;\r\n      }\r\n      comments.push([start, i]);\r\n      continue;\r\n    }\r\n    // raw string r#*\"...\"#*\r\n    if (c === 0x72 /* r */) {\r\n      let j = i + 1, hashes = 0;\r\n      while (j < n && text.charCodeAt(j) === 0x23 /* # */) { hashes++; j++; }\r\n      if (j < n && text.charCodeAt(j) === 0x22 /* \" */) {\r\n        const start = i; j++;\r\n        for (; j < n; j++) {\r\n          if (text.charCodeAt(j) === 0x22) {\r\n            let k = j + 1, ok = true;\r\n            for (let h = 0; h < hashes; h++) { if (k >= n || text.charCodeAt(k) !== 0x23) { ok = false; break; } k++; }\r\n            if (ok) { j = k; break; }\r\n          }\r\n        }\r\n        strings.push([start, j]);\r\n        i = j;\r\n        continue;\r\n      }\r\n    }\r\n    // normal string \"...\" ou '...'\r\n    if (c === 0x22 || c === 0x27) {\r\n      const start = i;\r\n      const quote = c; i++;\r\n      while (i < n) {\r\n        if (text.charCodeAt(i) === 0x5c /* \\\\ */) { i += 2; continue; }\r\n        if (text.charCodeAt(i) === quote) { i++; break; }\r\n        i++;\r\n      }\r\n      strings.push([start, i]);\r\n      continue;\r\n    }\r\n\r\n    // code chunk jusqu’au prochain début de com/str\r\n    const start = i;\r\n    while (i < n) {\r\n      const a = text.charCodeAt(i);\r\n      const b = i + 1 < n ? text.charCodeAt(i + 1) : 0;\r\n      if ((a === 0x2f && (b === 0x2f || b === 0x2a)) || a === 0x22 || a === 0x27 || a === 0x72) break;\r\n      i++;\r\n    }\r\n    markCode(start, i);\r\n  }\r\n\r\n  return { mask, strings, comments };\r\n}\r\n\r\n// Index des débuts de lignes pour conversion rapide offset→(line, char)\r\nfunction buildLineIndex(text: string): number[] {\r\n  const idx: number[] = [0];\r\n  for (let i = 0; i < text.length; i++) if (text.charCodeAt(i) === 10 /*\\n*/) idx.push(i + 1);\r\n  return idx;\r\n}\r\n\r\nfunction offsetToLC(nlIdx: number[], off: number): [line: number, char: number] {\r\n  let lo = 0, hi = nlIdx.length - 1;\r\n  while (lo <= hi) {\r\n    const mid = (lo + hi) >> 1;\r\n    const v = nlIdx[mid];\r\n    if (v === off) return [mid, 0];\r\n    if (v < off) lo = mid + 1; else hi = mid - 1;\r\n  }\r\n  const line = Math.max(0, lo - 1);\r\n  return [line, off - nlIdx[line]];\r\n}\r\n\r\nfunction pushMultiline(\r\n  builder: SemanticTokensBuilder,\r\n  nlIdx: number[],\r\n  startOff: number,\r\n  endOff: number,\r\n  tokenType: number,\r\n) {\r\n  const [sLine, sChar] = offsetToLC(nlIdx, startOff);\r\n  const [eLine, eChar] = offsetToLC(nlIdx, endOff);\r\n  if (sLine === eLine) {\r\n    builder.push(sLine, sChar, endOff - startOff, tokenType, 0);\r\n    return;\r\n  }\r\n  // première ligne\r\n  const lineEnd = nlIdx[sLine + 1] ?? endOff;\r\n  builder.push(sLine, sChar, lineEnd - startOff, tokenType, 0);\r\n  // lignes intermédiaires\r\n  for (let ln = sLine + 1; ln < eLine; ln++) {\r\n    const ls = nlIdx[ln];\r\n    const le = (nlIdx[ln + 1] ?? endOff) - 1; // exclure saut de ligne\r\n    if (le > ls) builder.push(ln, 0, le - ls, tokenType, 0);\r\n  }\r\n  // dernière ligne\r\n  builder.push(eLine, 0, eChar, tokenType, 0);\r\n}\r\n\r\nfunction addDeclSpans(\n  text: string,\n  mask: Uint8Array,\n  rx: RegExp,\n  group: number,\n  tokenTypeIndex: number,\n  spans: { start: number; end: number; type: number }[]\n) {\n  rx.lastIndex = 0;\r\n  let m: RegExpExecArray | null;\r\n  while ((m = rx.exec(text))) {\r\n    const name = m[group];\r\n    if (!name || !/^[A-Za-z_]\\w*$/.test(name)) continue;\r\n    const nameOff = (m.index ?? 0) + m[0].indexOf(name);\r\n    if (!mask[nameOff]) continue;\r\n    insertSpan(spans, nameOff, nameOff + name.length, tokenTypeIndex);\n  }\n}\n\nfunction insertSpan(spans: { start: number; end: number; type: number }[], start: number, end: number, type: number) {\n  if (end <= start) return;\r\n  // éviter les chevauchements: si recouvrement détecté, on ignore la nouvelle plage\r\n  for (const s of spans) {\r\n    if (!(end <= s.start || start >= s.end)) return;\r\n  }\r\n  spans.push({ start, end, type });\r\n}\r\n\r\nfunction* matchAll(rx: RegExp, s: string): Generator<RegExpMatchArray & { index: number }> {\r\n  const r = new RegExp(rx.source, rx.flags.includes(\"g\") ? rx.flags : rx.flags + \"g\");\r\n  let m: RegExpExecArray | null;\r\n  while ((m = r.exec(s))) {\r\n    const arr = m as RegExpMatchArray & { index: number };\r\n    arr.index = m.index ?? 0;\r\n    if (m[0].length === 0) r.lastIndex++;\r\n    yield arr;\r\n  }\r\n}\r\n\r\n"]}