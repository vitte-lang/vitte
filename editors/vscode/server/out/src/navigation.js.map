{"version":3,"file":"navigation.js","sourceRoot":"","sources":["../../src/navigation.ts"],"names":[],"mappings":"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","sourcesContent":["// navigation.ts — symboles, définitions, références, rename, workspace symbols\r\n// Version enrichie :\r\n// - Parsing tolérant qui ignore commentaires/chaînes\r\n// - Hiérarchie de symboles via pile d’accolades\r\n// - Règles étendues (module, import, fn, struct, enum, union, type, const/static, field)\n// - Références/rename hors commentaires/chaînes\r\n// - Cache par document/version\r\n// - Workspace symbols avec fuzzy match et scoring stable\r\n// - API additionnelle: prepareRename, indexDocument\r\n\r\nimport type { TextDocument } from \"vscode-languageserver-textdocument\";\nimport {\n  Location,\n  Position,\n  Range,\n  SymbolKind,\n} from \"vscode-languageserver/node\";\nimport type {\n  DocumentSymbol,\n  WorkspaceSymbol,\n} from \"vscode-languageserver/node\";\n\r\n/* --------------------------------- Types ---------------------------------- */\r\n\r\ninterface FlatSymbol {\r\n  name: string;\r\n  kind: SymbolKind;\r\n  range: Range;           // entier bloc (ex: de 'fn' à la fin de la signature/ligne)\r\n  selectionRange: Range;  // le nom seul\r\n  containerName?: string; // parent logique (module/impl/struct)\r\n}\r\n\r\ninterface DocIndex {\r\n  flat: FlatSymbol[];\r\n  outline: DocumentSymbol[];\r\n  byName: Map<string, FlatSymbol[]>;\r\n}\r\n\r\n/* -------------------------- Masque code (lexer light) ---------------------- */\r\n// Construit un masque booléen de positions « valides » (hors commentaires et chaînes)\r\n// Supporte //, /* */, \"...\", '...', r\"...\" et r#\"...\"# (style Rust/Vitte). Sans interpolation.\r\n\r\nfunction buildCodeMask(text: string): Uint8Array {\r\n  const n = text.length;\r\n  const mask = new Uint8Array(n);\r\n  let i = 0;\r\n  const setCode = (from: number, to: number) => {\r\n    for (let k = from; k < to; k++) mask[k] = 1;\r\n  };\r\n  while (i < n) {\n    const c = text.charCodeAt(i);\n    const c2 = i + 1 < n ? text.charCodeAt(i + 1) : 0;\n    // Line comment #... (ignore attributes #[...])\n    if (c === 0x23 /* # */ && c2 !== 0x5b /* [ */) {\n      i += 1;\n      while (i < n && text.charCodeAt(i) !== 0x0a) i++;\n      continue;\n    }\n    // Line comment\n    if (c === 0x2f /*/ */ && c2 === 0x2f) {\n      i += 2;\n      while (i < n && text.charCodeAt(i) !== 0x0a) i++;\n      continue;\r\n    }\r\n    // Block comment (supports nesting depth 1 minimal)\r\n    if (c === 0x2f && c2 === 0x2a /* * */) {\r\n      i += 2;\r\n      while (i < n) {\r\n        if (text.charCodeAt(i) === 0x2a && i + 1 < n && text.charCodeAt(i + 1) === 0x2f) {\r\n          i += 2;\r\n          break;\r\n        }\r\n        i++;\r\n      }\r\n      continue;\r\n    }\r\n    // Raw string r#*\" ... \"#*\r\n    if (c === 0x72 /* r */) {\r\n      let j = i + 1;\r\n      let hashes = 0;\r\n      while (j < n && text.charCodeAt(j) === 0x23 /* # */) { hashes++; j++; }\r\n      if (j < n && text.charCodeAt(j) === 0x22 /* \" */) {\r\n        // found r#*\"\r\n        j++;\r\n        // consume until closing \"#*\r\n        for (; j < n; j++) {\r\n          if (text.charCodeAt(j) === 0x22 /* \" */) {\r\n            let k = j + 1;\r\n            let ok = true;\r\n            for (let h = 0; h < hashes; h++) {\r\n              if (k >= n || text.charCodeAt(k) !== 0x23) { ok = false; break; }\r\n              k++;\r\n            }\r\n            if (ok) { i = k; break; }\r\n          }\r\n        }\r\n        continue;\r\n      }\r\n    }\r\n    // Normal string \"...\" ou '...'\r\n    if (c === 0x22 || c === 0x27) {\r\n      const quote = c;\r\n      i++;\r\n      while (i < n) {\r\n        if (text.charCodeAt(i) === 0x5c /* \\\\ */) { i += 2; continue; }\r\n        if (text.charCodeAt(i) === quote) { i++; break; }\r\n        i++;\r\n      }\r\n      continue;\r\n    }\r\n    // Code token\r\n    const start = i;\r\n    // Avance jusqu’à prochain début de com/str pour marquer code en bloc\r\n    while (i < n) {\n      const a = text.charCodeAt(i);\n      const b = i + 1 < n ? text.charCodeAt(i + 1) : 0;\n      if (\n        (a === 0x2f && (b === 0x2f || b === 0x2a)) ||\n        a === 0x22 ||\n        a === 0x27 ||\n        a === 0x72 ||\n        (a === 0x23 && b !== 0x5b)\n      ) break;\n      i++;\n    }\n    setCode(start, i);\r\n  }\r\n  return mask;\r\n}\r\n\r\nfunction isIdentChar(ch: number): boolean {\r\n  return (ch >= 48 && ch <= 57) || // 0-9\r\n         (ch >= 65 && ch <= 90) || // A-Z\r\n         (ch >= 97 && ch <= 122) || // a-z\r\n         ch === 95; // _\r\n}\r\n\r\nfunction wordAt(doc: TextDocument, pos: Position): string | null {\r\n  const text = doc.getText();\r\n  const off = doc.offsetAt(pos);\r\n  let s = off, e = off;\r\n  while (s > 0 && isIdentChar(text.charCodeAt(s - 1))) s--;\r\n  while (e < text.length && isIdentChar(text.charCodeAt(e))) e++;\r\n  return e > s ? text.slice(s, e) : null;\r\n}\r\n\r\nfunction escapeRx(s: string): string {\r\n  return s.replace(/[.*+?^${}()|[\\]\\\\]/g, \"\\\\$&\");\r\n}\r\n\r\nfunction posKey(p: Position): string { return `${p.line}:${p.character}`; }\r\n\r\nfunction dedupeBy<T>(arr: T[], keyFn: (t: T) => string): T[] {\r\n  const seen = new Set<string>();\r\n  const out: T[] = [];\r\n  for (const v of arr) {\r\n    const k = keyFn(v);\r\n    if (seen.has(k)) continue;\r\n    seen.add(k);\r\n    out.push(v);\r\n  }\r\n  return out;\r\n}\r\n\r\nfunction isValidIdent(s: string): boolean { return /^[A-Za-z_]\\w*$/.test(s); }\r\n\r\n/* ------------------------------ Règles symboles ---------------------------- */\r\n// Les regex sont évaluées uniquement sur les positions mask==1\r\n\r\nconst RULES: { rx: RegExp; kind: SymbolKind; nameGroup: number; containerHint?: (m: RegExpExecArray) => string | undefined }[] = [\n  { rx: /\\bmodule\\s+([A-Za-z_][\\w./:]*)/g,                              kind: SymbolKind.Namespace, nameGroup: 1 },\n  { rx: /\\bspace\\s+([A-Za-z_][\\w./:]*)/g,                               kind: SymbolKind.Namespace, nameGroup: 1 },\n  { rx: /\\bimport\\s+([A-Za-z_][\\w./:]*(?:::\\*)?)/g,                     kind: SymbolKind.Namespace, nameGroup: 1 },\n  { rx: /\\buse\\s+([A-Za-z_][\\w./:]*(?:::\\*)?)/g,                        kind: SymbolKind.Namespace, nameGroup: 1 },\n  { rx: /\\b(?:pub\\s+)?(?:fn|proc)\\s+([A-Za-z_]\\w*)\\s*\\(/g,              kind: SymbolKind.Function,  nameGroup: 1 },\n  { rx: /\\b(?:pub\\s+)?struct\\s+([A-Za-z_]\\w*)/g,                        kind: SymbolKind.Struct,    nameGroup: 1 },\n  { rx: /\\b(?:pub\\s+)?form\\s+([A-Za-z_]\\w*)/g,                          kind: SymbolKind.Struct,    nameGroup: 1 },\n  { rx: /\\b(?:pub\\s+)?enum\\s+([A-Za-z_]\\w*)/g,                          kind: SymbolKind.Enum,      nameGroup: 1 },\n  { rx: /\\b(?:pub\\s+)?union\\s+([A-Za-z_]\\w*)/g,                         kind: SymbolKind.Struct,    nameGroup: 1 },\n  { rx: /\\b(?:pub\\s+)?type\\s+([A-Za-z_]\\w*)/g,                          kind: SymbolKind.TypeParameter, nameGroup: 1 },\n  { rx: /\\b(?:pub\\s+)?const\\s+([A-Za-z_]\\w*)/g,                         kind: SymbolKind.Constant,  nameGroup: 1 },\n  { rx: /\\b(?:pub\\s+)?static\\s+([A-Za-z_]\\w*)/g,                        kind: SymbolKind.Variable,  nameGroup: 1 },\n  // champs de struct/form: name: Type\n  { rx: /(^|\\s)([A-Za-z_]\\w*)\\s*:\\s*[^;{},\\n]+(?=,|\\n|\\r|\\})/g, kind: SymbolKind.Field, nameGroup: 2 },\n];\n\r\nfunction* iterMaskedMatches(rx: RegExp, text: string, mask: Uint8Array): Generator<RegExpExecArray> {\r\n  rx.lastIndex = 0;\r\n  let m: RegExpExecArray | null;\r\n  while ((m = rx.exec(text))) {\r\n    const idx = m.index ?? 0;\r\n    // Vérifie que le début du match tombe sur zone code\r\n    if (mask[idx]) {\r\n      yield m;\r\n    }\r\n    if (m[0].length === 0) rx.lastIndex++;\r\n  }\r\n}\r\n\r\n/* ------------------------ Collecte + hiérarchie outline -------------------- */\r\n\r\nfunction collectFlatSymbols(doc: TextDocument): FlatSymbol[] {\r\n  const text = doc.getText();\r\n  const mask = buildCodeMask(text);\r\n  const out: FlatSymbol[] = [];\r\n\r\n  for (const { rx, kind, nameGroup } of RULES) {\r\n    for (const m of iterMaskedMatches(rx, text, mask)) {\r\n      const name = m[nameGroup];\r\n      if (!name) continue;\r\n      const start = doc.positionAt(m.index ?? 0);\r\n      const end = doc.positionAt((m.index ?? 0) + m[0].length);\r\n      const nameOffset = (m.index ?? 0) + m[0].indexOf(name);\r\n      const nameStart = doc.positionAt(nameOffset);\r\n      const nameEnd = doc.positionAt(nameOffset + name.length);\r\n      out.push({\r\n        name,\r\n        kind,\r\n        range: Range.create(start, end),\r\n        selectionRange: Range.create(nameStart, nameEnd),\r\n      });\r\n    }\r\n  }\r\n\r\n  // Déduplication conservatrice\r\n  return dedupeBy(out, s => `${s.kind}:${s.name}:${posKey(s.selectionRange.start)}`);\r\n}\r\n\r\nfunction buildOutline(doc: TextDocument, flat: FlatSymbol[]): DocumentSymbol[] {\r\n  // Trie par position pour associer via une pile d’accolades\r\n  const text = doc.getText();\r\n  type Node = DocumentSymbol & { children: DocumentSymbol[] };\r\n  const nodes: Node[] = flat\r\n    .map(s => ({\r\n      name: s.name,\r\n      kind: s.kind,\r\n      range: s.range,\r\n      selectionRange: s.selectionRange,\r\n      children: [],\r\n    }))\r\n    .sort((a, b) => {\r\n      const da = doc.offsetAt(a.range.start);\r\n      const db = doc.offsetAt(b.range.start);\r\n      return da - db;\r\n    });\r\n\r\n  // Pile de conteneurs basée sur accolades\r\n  const root: Node = { name: \"<root>\", kind: SymbolKind.Namespace, range: Range.create(Position.create(0,0), Position.create(0,0)), selectionRange: Range.create(Position.create(0,0), Position.create(0,0)), children: [] };\r\n  const stack: Node[] = [root];\r\n\r\n  // Prépare positions des '{' et '}' sur zones code\r\n  const mask = buildCodeMask(text);\r\n  const opens: number[] = [];\r\n  for (let i = 0; i < text.length; i++) {\r\n    if (!mask[i]) continue;\r\n    const ch = text.charCodeAt(i);\r\n    if (ch === 0x7b /* { */) opens.push(i);\r\n    else if (ch === 0x7d /* } */) {\r\n      if (opens.length) opens.pop();\r\n    }\r\n  }\r\n  // Index rapide: map startOffset->depth at that point\r\n  // Simplification: nous utilisons l’ordre croissant + heuristique par proximité\r\n\r\n  function pushToBestContainer(node: Node) {\n    // Heuristique: rattacher au dernier symbole dont la position est avant node et qui n’est pas clos avant.\n    for (let j = stack.length - 1; j >= 0; j--) {\n      const top = stack[j];\n      const topStart = doc.offsetAt(top.range.start);\n      const nodeStart = doc.offsetAt(node.range.start);\n      if (nodeStart >= topStart) {\n        top.children.push(node);\n        stack.push(node);\n        return;\n      }\n    }\r\n    root.children.push(node);\r\n    stack.push(node);\r\n  }\r\n\r\n  // On parcourt les nodes et simule la fermeture quand on rencontre '}' avant prochain node\r\n  const bracesPositions: number[] = [];\r\n  const n = text.length;\r\n  for (let i = 0; i < n; i++) if (mask[i] && (text[i] === '{' || text[i] === '}')) bracesPositions.push(i);\r\n\r\n  let bp = 0;\n  for (const node of nodes) {\n    const nodeStart = doc.offsetAt(node.range.start);\n    // ferme conteneurs jusqu’à la position courante\n    while (bp < bracesPositions.length && bracesPositions[bp] < nodeStart) {\n      const ch = text[bracesPositions[bp]];\n      if (ch === '}') {\n        if (stack.length > 1) stack.pop();\n      }\n      bp++;\n    }\n    pushToBestContainer(node);\r\n  }\r\n  // Ferme tout ce qui reste\r\n  while (bp < bracesPositions.length) {\r\n    if (text[bracesPositions[bp]] === '}' && stack.length > 1) stack.pop();\r\n    bp++;\r\n  }\r\n\r\n  return root.children;\r\n}\r\n\r\n/* ------------------------------- Index & cache ----------------------------- */\r\n\r\nconst docCache = new WeakMap<TextDocument, { version: number; index: DocIndex }>();\r\n\r\nfunction indexDocument(doc: TextDocument): DocIndex {\r\n  const cached = docCache.get(doc);\r\n  if (cached && cached.version === doc.version) return cached.index;\r\n\r\n  const flat = collectFlatSymbols(doc);\r\n  const outline = buildOutline(doc, flat);\r\n  const byName = new Map<string, FlatSymbol[]>();\r\n  for (const s of flat) {\r\n    const arr = byName.get(s.name) ?? [];\r\n    arr.push(s);\r\n    byName.set(s.name, arr);\r\n  }\r\n  const index = { flat, outline, byName };\r\n  docCache.set(doc, { version: doc.version, index });\r\n  return index;\r\n}\r\n\r\n/* --------------------------------- API doc --------------------------------- */\r\n\r\nexport function documentSymbols(doc: TextDocument): DocumentSymbol[] {\r\n  return indexDocument(doc).outline;\r\n}\r\n\r\nexport function symbolOutline(doc: TextDocument): DocumentSymbol[] {\r\n  return documentSymbols(doc);\r\n}\r\n\r\n/* --------------------------- Définitions / refs ---------------------------- */\r\n\r\nexport function definitionAtPosition(doc: TextDocument, pos: Position, uri: string): Location[] {\r\n  const word = wordAt(doc, pos);\r\n  if (!word) return [];\r\n  const { byName } = indexDocument(doc);\r\n  const defs = byName.get(word) ?? [];\r\n  // Tri par priorité de kind puis proximité\r\n  const baseOff = doc.offsetAt(pos);\r\n  defs.sort((a, b) => kindPriority(a.kind) - kindPriority(b.kind) || Math.abs(doc.offsetAt(a.selectionRange.start) - baseOff) - Math.abs(doc.offsetAt(b.selectionRange.start) - baseOff));\r\n  return defs.map(d => Location.create(uri, d.selectionRange));\r\n}\r\n\r\nexport function referencesAtPosition(doc: TextDocument, pos: Position, uri: string): Location[] {\r\n  const word = wordAt(doc, pos);\r\n  if (!word) return [];\r\n  const text = doc.getText();\r\n  const mask = buildCodeMask(text);\r\n  const out: Location[] = [];\r\n\r\n  const re = new RegExp(`(?<![A-Za-z0-9_])${escapeRx(word)}(?![A-Za-z0-9_])`, \"g\");\r\n  re.lastIndex = 0;\r\n  let m: RegExpExecArray | null;\r\n  while ((m = re.exec(text))) {\r\n    const idx = m.index ?? 0;\r\n    if (!mask[idx]) { if (m[0].length === 0) re.lastIndex++; continue; }\r\n    const start = doc.positionAt(idx);\r\n    const end = doc.positionAt(idx + m[0].length);\r\n    out.push(Location.create(uri, Range.create(start, end)));\r\n    if (m[0].length === 0) re.lastIndex++;\r\n  }\r\n  return out;\r\n}\r\n\r\n/* --------------------------------- Rename ---------------------------------- */\r\n\r\nexport function prepareRename(doc: TextDocument, pos: Position): { range: Range; placeholder: string } | null {\r\n  const name = wordAt(doc, pos);\r\n  if (!name || !isValidIdent(name)) return null;\r\n  const off = doc.offsetAt(pos);\r\n  const start = doc.positionAt(off - (name.length - (name.lastIndexOf(name) + 1)));\r\n  const end = doc.positionAt(doc.offsetAt(start) + name.length);\r\n  return { range: Range.create(start, end), placeholder: name };\r\n}\r\n\r\nexport function renameSymbol(doc: TextDocument, pos: Position, newName: string): { range: Range; newText: string }[] {\n  const old = wordAt(doc, pos);\r\n  if (!old || !isValidIdent(newName)) return [];\r\n  const text = doc.getText();\r\n  const mask = buildCodeMask(text);\r\n  const edits: { range: Range; newText: string }[] = [];\n  const re = new RegExp(`(?<![A-Za-z0-9_])${escapeRx(old)}(?![A-Za-z0-9_])`, \"g\");\r\n  let m: RegExpExecArray | null;\r\n  while ((m = re.exec(text))) {\r\n    const idx = m.index ?? 0;\r\n    if (!mask[idx]) { if (m[0].length === 0) re.lastIndex++; continue; }\r\n    const start = doc.positionAt(idx);\r\n    const end = doc.positionAt(idx + m[0].length);\r\n    edits.push({ range: Range.create(start, end), newText: newName });\r\n    if (m[0].length === 0) re.lastIndex++;\r\n  }\r\n  return edits;\r\n}\r\n\r\n/* ----------------------------- Workspace symbols --------------------------- */\r\n\r\nexport function workspaceSymbols(\r\n  query: string,\r\n  openDocs: { uri: string; doc: TextDocument }[],\n  limit = 200\r\n): WorkspaceSymbol[] {\r\n  const q = query.trim();\r\n  const result: { ws: WorkspaceSymbol; score: number; idx: number }[] = [];\n  let seq = 0;\r\n  for (const { uri, doc } of openDocs) {\r\n    const { flat } = indexDocument(doc);\r\n    for (const s of flat) {\r\n      const score = q ? fuzzyScore(s.name, q) : 1;\r\n      if (q && score <= 0) continue;\r\n      result.push({\r\n        ws: { name: s.name, kind: s.kind, location: Location.create(uri, s.selectionRange) },\r\n        score,\r\n        idx: seq++,\r\n      });\r\n      if (result.length >= limit * 4) break; // cap intermédiaire avant tri\r\n    }\r\n  }\r\n  result.sort((a, b) => b.score - a.score || a.idx - b.idx);\r\n  return result.slice(0, limit).map(r => r.ws);\r\n}\r\n\r\n/* --------------------------------- Helpers -------------------------------- */\r\n\r\nfunction kindPriority(k: SymbolKind): number {\r\n  switch (k) {\r\n    case SymbolKind.Function: return 0;\r\n    case SymbolKind.Method: return 1;\r\n    case SymbolKind.Variable: return 2;\r\n    case SymbolKind.Constant: return 3;\r\n    case SymbolKind.Struct: return 4;\r\n    case SymbolKind.Class: return 5;\r\n    case SymbolKind.Enum: return 6;\r\n    case SymbolKind.Interface: return 7;\r\n    case SymbolKind.Namespace: return 8;\r\n    case SymbolKind.Field: return 9;\r\n    default: return 10;\r\n  }\r\n}\r\n\r\nfunction fuzzyScore(name: string, query: string): number {\r\n  // subsequence scoring sensible à la casse avec bonus pour débuts de mots et camelCase\r\n  let i = 0, j = 0, score = 0, lastMatch = -2;\r\n  while (i < name.length && j < query.length) {\r\n    const nc = name[i];\r\n    const qc = query[j];\r\n    if (nc.toLowerCase() === qc.toLowerCase()) {\r\n      let s = 1;\r\n      if (i === 0 || !isIdentChar(name.charCodeAt(i - 1))) s += 2; // début de mot\r\n      if (nc === qc) s += 1; // casse exacte\r\n      if (i === lastMatch + 1) s += 2; // consécutif\r\n      score += s;\r\n      lastMatch = i;\r\n      j++; i++;\r\n    } else {\r\n      i++;\r\n    }\r\n  }\r\n  return j === query.length ? score : -1;\r\n}\r\n\r\n/* --------------------------------- Exports -------------------------------- */\r\n\r\nexport function indexDocForTests(doc: TextDocument): DocIndex { return indexDocument(doc); }\r\n"]}