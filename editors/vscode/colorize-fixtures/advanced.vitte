/*! advanced.vitte — fixture avancée alignée sur la grammaire officielle
   Couvre : generics + where, visibility pub, unions, patterns, closures, CLI tokens.
*/

//! Documentation du module avancé
module demo::advanced;

import std::cli;
import std::fs::{Reader, Writer};
import std::math::{pow, sqrt};

pub const MAX_ITERS: u32 = 0b1010_1100;
pub static TARGET: str = "demo";

type Coord = i64;
struct Point<T> where T: Copy {
  pub x: T,
  pub y: T,
}

enum Shape {
  Circle { radius: f64 },
  Rect { width: f64, height: f64 },
  Poly(Vec<Point<f64>>),
}

union Slot {
  as_int: i32,
  as_bytes: [u8; 4],
}

fn area(shape: &Shape) -> f64 {
  match shape {
    Shape::Circle { radius } => pow(*radius, 2.0) * 3.14159,
    Shape::Rect { width, height } => width * height,
    Shape::Poly(points) => {
      let mut acc = 0.0;
      for (idx, p) in points.iter().enumerate() {
        let q = &points[(idx + 1) % points.len()];
        acc += p.x * q.y - p.y * q.x;
      }
      acc.abs() * 0.5
    }
  }
}

fn normalize<T>(point: Point<T>) -> Point<T> where T: Copy {
  Point { x: point.x, y: point.y }
}

fn cli_example(argv: &[str]) -> Result<(), str> {
  if argv.is_empty() {
    return Err("missing command");
  }
  if argv[0] == "compile" {
    return compile_cmd(argv);
  }
  if argv[0] == "run" {
    return run_cmd(argv);
  }
  Err("unknown command")
}

fn compile_cmd(args: &[str]) -> Result<(), str> {
  let mut idx = 1;
  while idx < args.len() {
    match args[idx] {
      "--optimize" => {},
      "--debug" => {},
      _ => {}
    }
    idx += 1;
  }
  Ok(())
}

fn run_cmd(args: &[str]) -> Result<(), str> {
  let mut idx = 1;
  while idx < args.len() {
    if args[idx] == "--" { break }
    idx += 1;
  }
  Ok(())
}

fn patterns() {
  let data = (Point { x: 1, y: 2 }, Shape::Rect { width: 2.0, height: 3.0 });
  let (Point { x, y }, shape) = data;
  let range = 0..=5;
  for item in range {
    match item {
      n if n % 2 == 0 => println("even {n}"),
      _ => println("odd"),
    }
  }
  if let Shape::Rect { width, .. } = shape {
    println("w = {width}");
  }
}

fn closure_demo(mut seed: i32) -> i32 {
  let mut bump = |value: i32| -> i32 { value + 1 };
  seed = bump(seed);
  let double = |value: i32| -> i32 { value * 2 };
  double(seed)
}

fn main() {
  let shapes = [
    Shape::Circle { radius: 2.5 },
    Shape::Rect { width: 4.0, height: 5.0 },
  ];
  for s in shapes.iter() {
    let value = area(s);
    println("area = {value}");
  }
  let count = closure_demo(4);
  println("count = {count}");

  let slot = Slot { as_bytes: [0xDE, 0xAD, 0xBE, 0xEF] };

  patterns();
}
