

module vitte.compiler.progress

import vitte.compiler.collections as coll
import vitte.compiler.diagnostics as diag
import vitte.compiler.language as lang
import vitte.compiler.path as path
import vitte.compiler.pipeline as pipe

# ============================================================================
# Vitte compiler – Progress reporting (maximal, déclaratif, sans I/O)
#
# Objectifs :
#   - Décrire une API de suivi de progression pour le compilateur Vitte :
#       * par phase (lex, parse, hir, ir, link, llvm, codegen),
#       * par unité (fichier, module, workspace),
#       * par événements (start / step / finish / cancel).
#   - Fournir des structures purement fonctionnelles, sans threads ni I/O.
#   - Être utilisable par :
#       * le CLI (barres de progression, logs),
#       * le LSP (workDoneProgress / notifications),
#       * des tests (snapshots de timeline).
#
# Remarques :
#   - Ce module ne sait pas "afficher" la progression : il produit des
#     événements structurés que d'autres couches peuvent sérialiser
#     (JSON, texte, TUI, GUI...).
#   - Il se base sur pipe.PipelinePhase pour rester aligné avec la pipeline.
# ============================================================================

# ----------------------------------------------------------------------------
# Types de base : unité, genre d'événement, snapshot
# ----------------------------------------------------------------------------

pub enum ProgressUnitKind:
    ProgressUnitKindFile
    ProgressUnitKindModule
    ProgressUnitKindWorkspace
    ProgressUnitKindOther
.end

pub struct ProgressUnitId:
    let kind: ProgressUnitKind
    let name: String       # Nom logique (ex: "std.algo.graph" ou "main.vitte")
    let path_display: String  # Chemin affichable (normalisé) ou vide
.end

pub fn progress_unit_file(String file_path) -> ProgressUnitId:
    let disp = path.path_to_display(file_path)
    let u = ProgressUnitId(
        kind = ProgressUnitKind::ProgressUnitKindFile,
        name = disp,
        path_display = disp
    )
    return u
.end

pub fn progress_unit_module(String module_name, String file_path) -> ProgressUnitId:
    let disp = path.path_to_display(file_path)
    let u = ProgressUnitId(
        kind = ProgressUnitKind::ProgressUnitKindModule,
        name = module_name,
        path_display = disp
    )
    return u
.end

pub fn progress_unit_workspace(String root_path) -> ProgressUnitId:
    let disp = path.path_to_display(root_path)
    let u = ProgressUnitId(
        kind = ProgressUnitKind::ProgressUnitKindWorkspace,
        name = "workspace",
        path_display = disp
    )
    return u
.end

pub fn progress_unit_other(String label) -> ProgressUnitId:
    let u = ProgressUnitId(
        kind = ProgressUnitKind::ProgressUnitKindOther,
        name = label,
        path_display = ""
    )
    return u
.end

pub enum ProgressKind:
    ProgressKindStarted
    ProgressKindStep
    ProgressKindFinished
    ProgressKindCanceled
.end

pub struct ProgressStep:
    let phase: pipe.PipelinePhase
    let unit: ProgressUnitId
    let index: u32              # index (0-based) de l'unité dans la phase
    let count: u32              # nombre total d'unités dans la phase
    let percent_in_phase: u32   # 0..100 (approximatif)
    let message: String
.end

pub struct ProgressSnapshot:
    let phase: pipe.PipelinePhase
    let overall_percent: u32    # 0..100 sur l'ensemble de la compilation
    let current_step: Option<ProgressStep>
    let total_errors: u32
    let total_warnings: u32
.end

pub struct ProgressEvent:
    let kind: ProgressKind
    let step: ProgressStep
    let snapshot: ProgressSnapshot
.end

# ----------------------------------------------------------------------------
# Timeline cumulée
# ----------------------------------------------------------------------------

pub struct ProgressTimeline:
    let events: Vec<ProgressEvent>
.end

pub fn progress_timeline_new() -> ProgressTimeline:
    let v: Vec<ProgressEvent> = Vec<ProgressEvent>::new()
    let t = ProgressTimeline(
        events = v
    )
    return t
.end

pub fn progress_timeline_push(ProgressTimeline t, ProgressEvent e) -> ProgressTimeline:
    let v = t.events
    v.push(e)
    let t2 = ProgressTimeline(
        events = v
    )
    return t2
.end

# ----------------------------------------------------------------------------
# Poids des phases et pourcentage global
# ----------------------------------------------------------------------------
# L'idée est de "pondérer" les phases pour fournir un pourcentage global
# monotone : lex (0..10), parse (10..25), hir (25..45), ir (45..65),
# link (65..85), llvm (85..95), codegen (95..100).
# ----------------------------------------------------------------------------

fn progress_phase_span(pipe.PipelinePhase phase) -> (u32, u32):
    # start, end (inclusif sur end logiquement, mais la formule reste simple).
    if phase == pipe.PipelinePhase::PhaseLex:
        return (0u32, 10u32)
    .end
    if phase == pipe.PipelinePhase::PhaseParse:
        return (10u32, 25u32)
    .end
    if phase == pipe.PipelinePhase::PhaseHir:
        return (25u32, 45u32)
    .end
    if phase == pipe.PipelinePhase::PhaseIR:
        return (45u32, 65u32)
    .end
    if phase == pipe.PipelinePhase::PhaseLink:
        return (65u32, 85u32)
    .end
    if phase == pipe.PipelinePhase::PhaseLlvm:
        return (85u32, 95u32)
    .end
    if phase == pipe.PipelinePhase::PhaseCodegen:
        return (95u32, 100u32)
    .end

    # Fallback : toute autre phase hypothétique occupe tout l'espace.
    return (0u32, 100u32)
.end

pub fn progress_compute_overall_percent(
    pipe.PipelinePhase phase,
    u32 percent_in_phase
) -> u32:
    let span = progress_phase_span(phase)
    let start = span.0
    let finish = span.1

    if percent_in_phase >= 100u32:
        return finish
    .end

    if finish <= start:
        return percent_in_phase
    .end

    let width = finish - start
    let scaled = (percent_in_phase * width) / 100u32
    let out = start + scaled
    return out
.end

# ----------------------------------------------------------------------------
# Construction de step / snapshot
# ----------------------------------------------------------------------------

pub fn progress_step_new(
    pipe.PipelinePhase phase,
    ProgressUnitId unit,
    u32 index,
    u32 count,
    u32 percent_in_phase,
    String message
) -> ProgressStep:
    let s = ProgressStep(
        phase = phase,
        unit = unit,
        index = index,
        count = count,
        percent_in_phase = percent_in_phase,
        message = message
    )
    return s
.end

pub fn progress_step_from_index(
    pipe.PipelinePhase phase,
    ProgressUnitId unit,
    u32 index,
    u32 count,
    String message
) -> ProgressStep:
    let percent = if count == 0u32:
        0u32
    else:
        (index * 100u32) / count
    .end

    let s = ProgressStep(
        phase = phase,
        unit = unit,
        index = index,
        count = count,
        percent_in_phase = percent,
        message = message
    )
    return s
.end

fn progress_compute_diag_counters(diag.DiagnosticsSink sink) -> (u32, u32):
    let diags = diag.diagnostics_as_vec(sink)
    let n = diags.len()
    let i = 0usize
    let errors = 0u32
    let warnings = 0u32

    while i < n:
        let d = diags[i]
        if d.severity == diag.Severity::SeverityError:
            let errors = errors + 1u32
        .end
        if d.severity == diag.Severity::SeverityWarning:
            let warnings = warnings + 1u32
        .end
        let i = i + 1usize
    .end

    let out = (errors, warnings)
    return out
.end

pub fn progress_snapshot_new(
    pipe.PipelinePhase phase,
    u32 percent_in_phase,
    Option<ProgressStep> current_step,
    diag.DiagnosticsSink sink
) -> ProgressSnapshot:
    let overall = progress_compute_overall_percent(phase, percent_in_phase)
    let tuple = progress_compute_diag_counters(sink)
    let errors = tuple.0
    let warnings = tuple.1

    let snap = ProgressSnapshot(
        phase = phase,
        overall_percent = overall,
        current_step = current_step,
        total_errors = errors,
        total_warnings = warnings
    )
    return snap
.end

# ----------------------------------------------------------------------------
# Construction d'événements
# ----------------------------------------------------------------------------

pub fn progress_event_started(
    ProgressStep step,
    diag.DiagnosticsSink sink
) -> ProgressEvent:
    let some_step: Option<ProgressStep> = Option<ProgressStep>::Some(step)
    let snap = progress_snapshot_new(
        step.phase,
        step.percent_in_phase,
        some_step,
        sink
    )

    let e = ProgressEvent(
        kind = ProgressKind::ProgressKindStarted,
        step = step,
        snapshot = snap
    )
    return e
.end

pub fn progress_event_step(
    ProgressStep step,
    diag.DiagnosticsSink sink
) -> ProgressEvent:
    let some_step: Option<ProgressStep> = Option<ProgressStep>::Some(step)
    let snap = progress_snapshot_new(
        step.phase,
        step.percent_in_phase,
        some_step,
        sink
    )

    let e = ProgressEvent(
        kind = ProgressKind::ProgressKindStep,
        step = step,
        snapshot = snap
    )
    return e
.end

pub fn progress_event_finished(
    ProgressStep step,
    diag.DiagnosticsSink sink
) -> ProgressEvent:
    # Forcer la phase à 100% pour les événements "finished".
    let final_step = ProgressStep(
        phase = step.phase,
        unit = step.unit,
        index = step.index,
        count = step.count,
        percent_in_phase = 100u32,
        message = step.message
    )

    let some_step: Option<ProgressStep> = Option<ProgressStep>::Some(final_step)
    let snap = progress_snapshot_new(
        final_step.phase,
        final_step.percent_in_phase,
        some_step,
        sink
    )

    let e = ProgressEvent(
        kind = ProgressKind::ProgressKindFinished,
        step = final_step,
        snapshot = snap
    )
    return e
.end

pub fn progress_event_canceled(
    ProgressStep step,
    diag.DiagnosticsSink sink
) -> ProgressEvent:
    let some_step: Option<ProgressStep> = Option<ProgressStep>::Some(step)
    let snap = progress_snapshot_new(
        step.phase,
        step.percent_in_phase,
        some_step,
        sink
    )

    let e = ProgressEvent(
        kind = ProgressKind::ProgressKindCanceled,
        step = step,
        snapshot = snap
    )
    return e
.end

# ----------------------------------------------------------------------------
# API de synthèse : progression simple pour un fichier unique
# ----------------------------------------------------------------------------

pub struct ProgressSingleFileState:
    let file_unit: ProgressUnitId
    let last_phase: pipe.PipelinePhase
    let last_percent_in_phase: u32
.end

pub fn progress_single_file_state_new(String file_path) -> ProgressSingleFileState:
    let unit = progress_unit_file(file_path)
    let st = ProgressSingleFileState(
        file_unit = unit,
        last_phase = pipe.PipelinePhase::PhaseLex,
        last_percent_in_phase = 0u32
    )
    return st
.end

pub fn progress_single_file_next_step(
    ProgressSingleFileState state,
    pipe.PipelinePhase phase,
    u32 percent_in_phase,
    String message,
    diag.DiagnosticsSink sink
) -> (ProgressSingleFileState, ProgressEvent):
    let unit = state.file_unit
    let step = progress_step_new(
        phase,
        unit,
        0u32,
        1u32,
        percent_in_phase,
        message
    )

    # Si on change de phase, on considère cet événement comme un "started"
    # pour cette phase; sinon comme un "step".
    let is_new_phase = phase != state.last_phase
    let ev = if is_new_phase:
        progress_event_started(step, sink)
    else:
        progress_event_step(step, sink)
    .end

    let st2 = ProgressSingleFileState(
        file_unit = unit,
        last_phase = phase,
        last_percent_in_phase = percent_in_phase
    )

    let out = (st2, ev)
    return out
.end

# ----------------------------------------------------------------------------
# Notes
# ----------------------------------------------------------------------------
# - Ce module reste volontairement pur : aucune notion de temps, pas de
#   threads, pas d'I/O. Il sert de socle pour un reporting multi-frontends.
# - Les pourcentages sont approximatifs mais stables; les outils de plus
#   haut niveau peuvent les affiner en fonction d'informations runtime.
# - La timeline peut être utilisée telle quelle pour des tests (snapshot
#   d'une séquence d'événements de compilation).
# ============================================================================