

module vitte.compiler.path

import vitte.compiler.collections as coll
import vitte.compiler.diagnostics as diag
import vitte.compiler.language as lang

# ============================================================================
# Vitte compiler – Path utilities (maximal, déclaratif, sans I/O)
#
# Objectifs :
#   - Fournir un modèle uniforme pour les chemins utilisés par le compilateur
#     Vitte : chemins de fichiers, de modules, de manifestes Muffin, etc.
#   - Rester purement string-based (pas d'accès FS), pour être utilisable
#     dans tous les backends (Vitte-Light, C, Rust, LSP, etc.).
#   - Proposer des helpers complets : join, normalize, split, ext, modulePath.
# ============================================================================

# ----------------------------------------------------------------------------
# Styles de chemins et séparateurs
# ----------------------------------------------------------------------------

pub enum PathStyle:
    PathStylePosix      # "/" (Unix, macOS, Linux, Vitte par défaut)
    PathStyleWindows    # "\\" + lettres de drive optionnelles
    PathStyleMixed      # mélange des deux (souvent entrée utilisateur)
.end

pub enum PathKind:
    PathKindFile
    PathKindDirectory
    PathKindModule
    PathKindMuffin
    PathKindUnknown
.end

pub struct PathBuf:
    let text: String
    let style: PathStyle
.end

pub fn pathbuf_new(String text) -> PathBuf:
    let style = path_detect_style(text)
    let pb = PathBuf(
        text = text,
        style = style
    )
    return pb
.end

pub fn pathbuf_from_parts(String root, String segment) -> PathBuf:
    let joined = path_join(root, segment)
    let pb = pathbuf_new(joined)
    return pb
.end

# ----------------------------------------------------------------------------
# Détection du style et helpers de séparateurs
# ----------------------------------------------------------------------------

pub fn path_detect_style(String text) -> PathStyle:
    let bytes = text.as_bytes()
    let n = bytes.len()
    let i = 0usize
    let has_slash = false
    let has_backslash = false

    while i < n:
        let b = bytes[i]
        if b == 47u8: # '/'
            let has_slash = true
        .end
        if b == 92u8: # '\\'
            let has_backslash = true
        .end
        i = i + 1usize
    .end

    if has_slash and not has_backslash:
        return PathStyle::PathStylePosix
    .end
    if has_backslash and not has_slash:
        return PathStyle::PathStyleWindows
    .end
    if has_slash and has_backslash:
        return PathStyle::PathStyleMixed
    .end

    # Aucun séparateur : par défaut POSIX.
    return PathStyle::PathStylePosix
.end

pub fn path_is_separator_byte(u8 b) -> Bool:
    if b == 47u8:   # '/'
        return true
    .end
    if b == 92u8:   # '\\'
        return true
    .end
    return false
.end

# ----------------------------------------------------------------------------
# Normalisation des séparateurs / suppression des doublons
# ----------------------------------------------------------------------------

pub fn path_unify_separators(String text, PathStyle target) -> String:
    let bytes = text.as_bytes()
    let n = bytes.len()
    let i = 0usize
    let out = ""

    let target_sep: u8 = 47u8
    if target == PathStyle::PathStyleWindows:
        let target_sep = 92u8
    .end

    while i < n:
        let b = bytes[i]
        if path_is_separator_byte(b):
            let out = out + String::from_byte(target_sep)
        .end
        if not path_is_separator_byte(b):
            let out = out + String::from_byte(b)
        .end
        i = i + 1usize
    .end

    return out
.end

pub fn path_collapse_duplicate_separators(String text, PathStyle style) -> String:
    let bytes = text.as_bytes()
    let n = bytes.len()
    let i = 0usize
    let out = ""

    let target_sep: u8 = 47u8
    if style == PathStyle::PathStyleWindows:
        let target_sep = 92u8
    .end

    let last_was_sep = false

    while i < n:
        let b = bytes[i]
        if path_is_separator_byte(b):
            if not last_was_sep:
                let out = out + String::from_byte(target_sep)
                let last_was_sep = true
            .end
        .end
        if not path_is_separator_byte(b):
            let out = out + String::from_byte(b)
            let last_was_sep = false
        .end
        i = i + 1usize
    .end

    return out
.end

# ----------------------------------------------------------------------------
# Split / join
# ----------------------------------------------------------------------------

pub fn path_split_components(String text) -> Vec<String>:
    let out: Vec<String> = Vec<String>::new()
    let bytes = text.as_bytes()
    let n = bytes.len()
    let i = 0usize
    let start = 0usize

    while i < n:
        let b = bytes[i]
        if path_is_separator_byte(b):
            if i > start:
                let part = text.slice(start, i)
                out.push(part)
            .end
            let i = i + 1usize
            let start = i
            continue
        .end
        i = i + 1usize
    .end

    if start < n:
        let part_last = text.slice(start, n)
        out.push(part_last)
    .end

    return out
.end

pub fn path_join(String left, String right) -> String:
    if left == "":
        return right
    .end
    if right == "":
        return left
    .end

    let left_style = path_detect_style(left)
    let right_style = path_detect_style(right)
    let style = left_style
    if left_style == PathStyle::PathStylePosix and right_style == PathStyle::PathStyleWindows:
        let style = PathStyle::PathStyleMixed
    .end
    if left_style == PathStyle::PathStyleWindows and right_style == PathStyle::PathStylePosix:
        let style = PathStyle::PathStyleMixed
    .end

    let sep = "/"
    if style == PathStyle::PathStyleWindows:
        let sep = "\\"
    .end

    # Éviter les doublons de séparateur.
    let left_trim = path_trim_trailing_separators(left)
    let right_trim = path_trim_leading_separators(right)
    let joined = left_trim + sep + right_trim
    let normalized = path_collapse_duplicate_separators(joined, style)
    return normalized
.end

pub fn path_trim_trailing_separators(String text) -> String:
    let bytes = text.as_bytes()
    let n = bytes.len()
    if n == 0usize:
        return text
    .end

    let i = n
    let j = i

    while j > 0usize:
        let k = j - 1usize
        let b = bytes[k]
        if path_is_separator_byte(b):
            let j = k
            continue
        .end
        break
    .end

    if j == 0usize:
        return text
    .end

    let out = text.slice(0usize, j)
    return out
.end

pub fn path_trim_leading_separators(String text) -> String:
    let bytes = text.as_bytes()
    let n = bytes.len()
    let i = 0usize

    while i < n:
        let b = bytes[i]
        if not path_is_separator_byte(b):
            break
        .end
        let i = i + 1usize
    .end

    if i == 0usize:
        return text
    .end

    let out = text.slice(i, n)
    return out
.end

# ----------------------------------------------------------------------------
# Base name, dir name, extension
# ----------------------------------------------------------------------------

pub fn path_basename(String text) -> String:
    let comps = path_split_components(text)
    let n = comps.len()
    if n == 0usize:
        return ""
    .end
    let last = comps[n - 1usize]
    return last
.end

pub fn path_dirname(String text) -> String:
    let comps = path_split_components(text)
    let n = comps.len()
    if n <= 1usize:
        return ""
    .end

    let i = 0usize
    let out = ""

    while i + 1usize < n:
        let c = comps[i]
        if i == 0usize:
            let out = c
        .end
        if i > 0usize:
            let out = out + "/" + c
        .end
        i = i + 1usize
    .end

    return out
.end

pub fn path_extension(String text) -> String:
    let base = path_basename(text)
    let idx_opt = string_last_dot_index(base)
    if idx_opt.is_none():
        return ""
    .end
    let idx = idx_opt.unwrap()
    if idx == 0usize:
        # fichier commençant par '.' (ex: ".gitignore"), pas considéré comme extension.
        return ""
    .end

    let ext = base.slice(idx + 1usize, base.len())
    return ext
.end

pub fn path_stem(String text) -> String:
    let base = path_basename(text)
    let idx_opt = string_last_dot_index(base)
    if idx_opt.is_none():
        return base
    .end
    let idx = idx_opt.unwrap()
    if idx == 0usize:
        # ex: ".gitignore" -> on retourne le nom complet.
        return base
    .end

    let stem = base.slice(0usize, idx)
    return stem
.end

fn string_last_dot_index(String text) -> Option<usize>:
    let bytes = text.as_bytes()
    let n = bytes.len()
    if n == 0usize:
        let none = Option<usize>::None()
        return none
    .end

    let i = n
    while i > 0usize:
        let k = i - 1usize
        let b = bytes[k]
        if b == 46u8: # '.'
            let some = Option<usize>::Some(k)
            return some
        .end
        let i = k
    .end

    let none2 = Option<usize>::None()
    return none2
.end

# ----------------------------------------------------------------------------
# Tests d'absolu / relatif, et PathKind simple
# ----------------------------------------------------------------------------

pub fn path_is_absolute(String text, PathStyle style) -> Bool:
    if style == PathStyle::PathStylePosix:
        # POSIX : commence par '/'
        if text.starts_with("/"):
            return true
        .end
        return false
    .end

    if style == PathStyle::PathStyleWindows:
        # Windows : "C:\\" ou "\\\\server".
        let bytes = text.as_bytes()
        let n = bytes.len()
        if n >= 3usize:
            let b0 = bytes[0usize]
            let b1 = bytes[1usize]
            let b2 = bytes[2usize]
            # lettre + ':' + '\\'
            if ((b0 >= 65u8 and b0 <= 90u8) or (b0 >= 97u8 and b0 <= 122u8)) and
               b1 == 58u8 and path_is_separator_byte(b2):
                return true
            .end
        .end
        if n >= 2usize:
            let b0 = bytes[0usize]
            let b1 = bytes[1usize]
            if path_is_separator_byte(b0) and path_is_separator_byte(b1):
                return true
            .end
        .end
        return false
    .end

    # Mixed : on considère qu'il est absolu si POSIX ou Windows l'est.
    let as_posix = path_is_absolute(text, PathStyle::PathStylePosix)
    if as_posix:
        return true
    .end
    let as_win = path_is_absolute(text, PathStyle::PathStyleWindows)
    return as_win
.end

pub fn path_kind_guess(String text) -> PathKind:
    let ext = path_extension(text)
    if ext == "muf":
        return PathKind::PathKindMuffin
    .end
    if ext == "vitte" or ext == "vit" or ext == "v":
        return PathKind::PathKindModule
    .end
    if ext == "" and path_basename(text) != "":
        return PathKind::PathKindDirectory
    .end
    if ext != "":
        return PathKind::PathKindFile
    .end
    return PathKind::PathKindUnknown
.end

# ----------------------------------------------------------------------------
# Conversion module_name <-> path (style Vitte / Muffin)
# ----------------------------------------------------------------------------

pub fn module_name_to_path(String module_name) -> String:
    # "std.algo.graph" -> "std/algo/graph.vitte"
    let parts = module_name.split(".")
    let n = parts.len()
    let i = 0usize
    let out = ""

    while i < n:
        let p = parts[i]
        if i == 0usize:
            let out = p
        .end
        if i > 0usize:
            let out = out + "/" + p
        .end
        i = i + 1usize
    .end

    if out == "":
        return ""
    .end

    let with_ext = out + ".vitte"
    return with_ext
.end

pub fn module_name_to_muffin_path(String module_name) -> String:
    # "core.graph" -> "core/graph.muf"
    let base = module_name_to_path(module_name)
    let stem = path_stem(base)
    let dir = path_dirname(base)
    if dir == "":
        return stem + ".muf"
    .end
    let combined = path_join(dir, stem + ".muf")
    return combined
.end

pub fn path_to_module_name(String path) -> String:
    # "std/algo/graph.vitte" -> "std.algo.graph"
    let without_ext = path_stem(path)
    let comps = path_split_components(without_ext)
    let n = comps.len()
    if n == 0usize:
        return ""
    .end

    let i = 0usize
    let out = ""

    while i < n:
        let c = comps[i]
        if i == 0usize:
            let out = c
        .end
        if i > 0usize:
            let out = out + "." + c
        .end
        i = i + 1usize
    .end

    return out
.end

# ----------------------------------------------------------------------------
# URI de fichiers (file://) pour LSP / diagnostics
# ----------------------------------------------------------------------------

pub fn path_to_file_uri(String path) -> String:
    # Version simple : file:// + path POSIXifié.
    let unified = path_unify_separators(path, PathStyle::PathStylePosix)
    let has_leading_slash = unified.starts_with("/")

    if has_leading_slash:
        let uri = "file://" + unified
        return uri
    .end

    let uri2 = "file:///" + unified
    return uri2
.end

pub fn file_uri_to_path(String uri) -> String:
    # On retire le préfixe "file://" si présent.
    if not uri.starts_with("file://"):
        return uri
    .end

    let without = uri.slice(7usize, uri.len())
    return without
.end

# ----------------------------------------------------------------------------
# Helpers divers
# ----------------------------------------------------------------------------

pub fn path_change_extension(String path, String new_ext) -> String:
    let dir = path_dirname(path)
    let stem = path_stem(path)
    let ext_part = ""
    if new_ext != "":
        let ext_part = "." + new_ext
    .end

    let new_name = stem + ext_part
    if dir == "":
        return new_name
    .end

    let combined = path_join(dir, new_name)
    return combined
.end

pub fn path_append_segment(String path, String segment) -> String:
    let joined = path_join(path, segment)
    return joined
.end

pub fn path_to_display(String path) -> String:
    # Affichage friendly pour messages de diagnostics.
    # On unifie en POSIX et retourne tel quel.
    let unified = path_unify_separators(path, PathStyle::PathStylePosix)
    return unified
.end

# ----------------------------------------------------------------------------
# Notes
# ----------------------------------------------------------------------------
# - Ce module n'interagit pas avec le système de fichiers : toutes les
#   opérations sont purement basées sur des String, ce qui le rend utilisable
#   en sandbox, dans des tests, ou côté LSP.
# - Il sert de couche commune pour convertir les noms de modules Vitte
#   ("std.algo.graph") en chemins ("std/algo/graph.vitte") et inversement,
#   ainsi que pour manipuler les chemins des manifestes Muffin.
# - Les fonctions ici sont volontairement conservatrices : les règles
#   complètes Windows/POSIX peuvent être affinées dans un module dédié si
#   nécessaire sans casser cette API.
# ============================================================================