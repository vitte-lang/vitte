module vitte.compiler.pipeline_incremental
import vitte.compiler.ast as ast
import vitte.compiler.parser as parser
import vitte.compiler.lexer as lex
import vitte.compiler.ir as lir
import vitte.compiler.diagnostics as diag
import vitte.compiler.span as cspan
import vitte.compiler.vm as vm

# ============================================================================
# Pipeline incrémentale (parse -> AST léger -> LIR -> bytecode -> VM)
#
# Objectifs :
#   - Exposer un chemin clair et testable couvrant chaque étape majeure.
#   - Manipuler des représentations simples pour verrouiller la syntaxe de base
#     (retours d'entiers / additions) sans dépendre d'un backend complet.
#   - Offrir un artefact par étape pour l'instrumentation et les tests.
# ============================================================================

pub enum ReturnExprKind:
    ReturnConst
    ReturnAdd
.end

pub struct ReturnExpr:
    let kind: ReturnExprKind
    let lhs: i64
    let rhs: i64
.end

pub struct AstFunctionSummary:
    let name: String
    let header: String
    let body: String
    let return_expr: ReturnExpr
.end

pub struct AstSummary:
    let module_name: String
    let functions: Vec<AstFunctionSummary>
.end

pub struct BytecodeArtifact:
    let code: Vec<vm.VmInstr>
    let consts: Vec<vm.VmValue>
    let num_regs: u32
    let ret_reg: vm.VmRegIndex
.end

pub struct IncrementalResult:
    let parse: parser.ParseResult
    let ast: AstSummary
    let lir: lir.LModule
    let bytecode: BytecodeArtifact
    let vm_state: vm.VmState
    let return_value: Option<vm.VmValue>
.end

# -----------------------------------------------------------------------------
# Helpers internes
# -----------------------------------------------------------------------------

fn empty_ast_span(String file_name) -> ast.Span:
    let sp = ast.Span(
        file = file_name,
        start_line = 0u32,
        start_col = 0u32,
        end_line = 0u32,
        end_col = 0u32
    )
    return sp
.end

fn empty_vm_span() -> cspan.Span:
    let sp = cspan.span_empty_at((cspan.BytePos) 0)
    return sp
.end

fn parse_i64_literal(String text) -> i64:
    let n = text.len()
    if n == 0usize:
        return 0i64
    .end

    let sign = 1i64
    let idx = 0usize
    let first = text[0usize]
    if first == '-':
        sign = -1i64
        idx = 1usize
    .end

    let acc = 0i64
    let i = idx
    while i < n:
        let c = text[i]
        if c < '0' or c > '9':
            i = i + 1usize
            continue
        .end
        let digit = (i64) (c - '0')
        acc = acc * 10i64 + digit
        i = i + 1usize
    .end

    return acc * sign
.end

fn unwrap_or_i64(Option<i64> opt, i64 fallback) -> i64:
    if opt.is_some():
        return opt.unwrap()
    .end
    return fallback
.end

fn unwrap_or_reg(Option<vm.VmRegIndex> opt, vm.VmRegIndex fallback) -> vm.VmRegIndex:
    if opt.is_some():
        return opt.unwrap()
    .end
    return fallback
.end

fn parse_return_expr(String file_name, String body_text) -> ReturnExpr:
    # Lexe uniquement le corps pour récupérer un retour de la forme
    #   return <int>
    #   return <int> + <int>
    # Tout ce qui ne matche pas retombe sur ReturnConst 0.
    let sink = diag.diagnostics_sink_new()
    let lex_res = lex.lex_source(file_name, body_text, sink)
    let toks = lex_res.tokens
    let len = toks.len()

    let i = 0usize
    while i < len:
        let tok = toks[i]
        if tok.kind != lex.TokenKind::TkKwReturn:
            i = i + 1usize
            continue
        .end

        # Skip trivia immédiat après return
        let j = i + 1usize
        if j >= len:
            break
        .end

        # Première valeur
        let tok_lhs = toks[j]
        if tok_lhs.kind != lex.TokenKind::TkNumber:
            break
        .end
        let lhs_val = parse_i64_literal(tok_lhs.lexeme)

        # Addition éventuelle
        let k = j + 1usize
        if k + 1usize < len:
            let tok_plus = toks[k]
            let tok_rhs = toks[k + 1usize]
            if tok_plus.kind == lex.TokenKind::TkPlus and tok_rhs.kind == lex.TokenKind::TkNumber:
                let rhs_val = parse_i64_literal(tok_rhs.lexeme)
                let expr_add = ReturnExpr(
                    kind = ReturnExprKind::ReturnAdd,
                    lhs = lhs_val,
                    rhs = rhs_val
                )
                return expr_add
            .end
        .end

        let expr_const = ReturnExpr(
            kind = ReturnExprKind::ReturnConst,
            lhs = lhs_val,
            rhs = 0i64
        )
        return expr_const
    .end

    let fallback = ReturnExpr(
        kind = ReturnExprKind::ReturnConst,
        lhs = 0i64,
        rhs = 0i64
    )
    return fallback
.end

fn summarize_functions(parser.ParseResult parse_res) -> AstSummary:
    let funcs = Vec<AstFunctionSummary>::new()
    let items = parse_res.module.items
    let n = items.len()
    let idx = 0usize
    while idx < n:
        let it = items[idx]
        if it.kind == parser.PItemKind::PItemFunction:
            let expr = parse_return_expr(parse_res.module.name, it.body_text)
            let f = AstFunctionSummary(
                name = it.name,
                header = it.header_text,
                body = it.body_text,
                return_expr = expr
            )
            funcs.push(f)
        .end
        idx = idx + 1usize
    .end

    let summary = AstSummary(
        module_name = parse_res.module.name,
        functions = funcs
    )
    return summary
.end

# -----------------------------------------------------------------------------
# Construction LIR minimale
# -----------------------------------------------------------------------------

fn lir_append_const(
    lir.LBuilder b,
    lir.LFuncId fid,
    lir.LBlockId bid,
    i64 value,
    ast.Span sp
) -> (lir.LBuilder, lir.LValueId):
    let pair_val = lir.LBuilder.fresh_value(b)
    let b1 = pair_val.0
    let val_id = pair_val.1

    let pair_instr = lir.LBuilder.fresh_instr(b1)
    let b2 = pair_instr.0
    let instr_id = pair_instr.1

    let ops = Vec<lir.LOperand>::new()
    ops.push(lir.LOperand.imm_i64(value))

    let instr = lir.LInstr(
        id = instr_id,
        kind = lir.LInstrKind::LInstrConst,
        ty = lir.LType.i64(),
        result = Option<lir.LValueId>::Some(val_id),
        operands = ops,
        bin_op = Option<lir.LBinOp>::None(),
        cmp_op = Option<lir.LCmpOp>::None(),
        cast_op = Option<lir.LCastOp>::None(),
        phi_incomings = Vec<lir.LPhiIncoming>::new(),
        target_block = Option<lir.LBlockId>::None(),
        else_block = Option<lir.LBlockId>::None(),
        callee = Option<lir.LValueId>::None(),
        call_args = Vec<lir.LOperand>::new(),
        span = sp
    )

    let b3 = lir.lbuilder_append_instr(b2, fid, bid, instr)
    let out = (b3, val_id)
    return out
.end

fn lir_append_ret_val(
    lir.LBuilder b,
    lir.LFuncId fid,
    lir.LBlockId bid,
    lir.LValueId val_id,
    ast.Span sp
) -> lir.LBuilder:
    let pair_instr = lir.LBuilder.fresh_instr(b)
    let b1 = pair_instr.0
    let instr_id = pair_instr.1

    let ops = Vec<lir.LOperand>::new()
    ops.push(lir.LOperand.value(val_id))

    let instr = lir.LInstr(
        id = instr_id,
        kind = lir.LInstrKind::LInstrRet,
        ty = lir.LType.i64(),
        result = Option<lir.LValueId>::None(),
        operands = ops,
        bin_op = Option<lir.LBinOp>::None(),
        cmp_op = Option<lir.LCmpOp>::None(),
        cast_op = Option<lir.LCastOp>::None(),
        phi_incomings = Vec<lir.LPhiIncoming>::new(),
        target_block = Option<lir.LBlockId>::None(),
        else_block = Option<lir.LBlockId>::None(),
        callee = Option<lir.LValueId>::None(),
        call_args = Vec<lir.LOperand>::new(),
        span = sp
    )

    let b2 = lir.lbuilder_append_instr(b1, fid, bid, instr)
    return b2
.end

fn lir_build_for_function(
    lir.LBuilder b,
    AstFunctionSummary fun,
    ast.Span sp
) -> lir.LBuilder:
    let params = Vec<lir.LParam>::new()
    let (b1, fid, entry_id) = lir.lbuilder_add_function(
        b,
        fun.name,
        lir.LVisibility::LVisPublic,
        lir.LLinkage::LLinkDefault,
        lir.LCallingConv::LCallDefault,
        lir.LType.i64(),
        params
    )

    if fun.return_expr.kind == ReturnExprKind::ReturnConst:
        let pair_const = lir_append_const(b1, fid, entry_id, fun.return_expr.lhs, sp)
        let b2 = pair_const.0
        let val_id = pair_const.1
        let b3 = lir_append_ret_val(b2, fid, entry_id, val_id, sp)
        return b3
    .end

    if fun.return_expr.kind == ReturnExprKind::ReturnAdd:
        let pair_lhs = lir_append_const(b1, fid, entry_id, fun.return_expr.lhs, sp)
        let b2 = pair_lhs.0
        let lhs_id = pair_lhs.1

        let pair_rhs = lir_append_const(b2, fid, entry_id, fun.return_expr.rhs, sp)
        let b3 = pair_rhs.0
        let rhs_id = pair_rhs.1

        let op_lhs = lir.LOperand.value(lhs_id)
        let op_rhs = lir.LOperand.value(rhs_id)
        let pair_bin = lir.lbuilder_build_binop(
            b3,
            fid,
            entry_id,
            lir.LBinOp::LAdd,
            lir.LType.i64(),
            op_lhs,
            op_rhs,
            sp
        )
        let b4 = pair_bin.0
        let sum_id = pair_bin.1
        let b5 = lir_append_ret_val(b4, fid, entry_id, sum_id, sp)
        return b5
    .end

    # Fallback : return 0
    let pair_const2 = lir_append_const(b1, fid, entry_id, 0i64, sp)
    let b_fallback = pair_const2.0
    let zero_id = pair_const2.1
    let b_ret = lir_append_ret_val(b_fallback, fid, entry_id, zero_id, sp)
    return b_ret
.end

fn lir_from_ast(AstSummary summary) -> lir.LModule:
    let b0 = lir.lbuilder_new(summary.module_name)
    let sp = empty_ast_span(summary.module_name)
    let funcs = summary.functions
    let n = funcs.len()
    let i = 0usize
    let b_cur = b0
    while i < n:
        let f = funcs[i]
        let b_next = lir_build_for_function(b_cur, f, sp)
        b_cur = b_next
        i = i + 1usize
    .end
    return b_cur.module
.end

# -----------------------------------------------------------------------------
# Emission bytecode -> VM
# -----------------------------------------------------------------------------

pub struct RegMapping:
    let value: lir.LValueId
    let reg: vm.VmRegIndex
.end

fn lookup_reg(Vec<RegMapping> regs, lir.LValueId id) -> Option<vm.VmRegIndex>:
    let i = 0usize
    let n = regs.len()
    while i < n:
        let m = regs[i]
        if m.value.raw == id.raw:
            let some_reg: Option<vm.VmRegIndex> = Option<vm.VmRegIndex>::Some(m.reg)
            return some_reg
        .end
        i = i + 1usize
    .end
    let none_reg: Option<vm.VmRegIndex> = Option<vm.VmRegIndex>::None()
    return none_reg
.end

fn assign_reg(
    Vec<RegMapping> regs,
    lir.LValueId id,
    vm.VmRegIndex next_reg
) -> (Vec<RegMapping>, vm.VmRegIndex, vm.VmRegIndex):
    let existing = lookup_reg(regs, id)
    if existing.is_some():
        let r = existing.unwrap()
        let out = (regs, next_reg, r)
        return out
    .end

    let mapping = RegMapping(value = id, reg = next_reg)
    regs.push(mapping)
    let out2 = (regs, next_reg + 1u32, next_reg)
    return out2
.end

fn map_binop_opcode(lir.LBinOp op) -> vm.VmOpcode:
    if op == lir.LBinOp::LAdd:
        return vm.VmOpcode::VmOpcodeAdd
    .end
    if op == lir.LBinOp::LSub:
        return vm.VmOpcode::VmOpcodeSub
    .end
    if op == lir.LBinOp::LMul:
        return vm.VmOpcode::VmOpcodeMul
    .end
    if op == lir.LBinOp::LDiv:
        return vm.VmOpcode::VmOpcodeDiv
    .end
    return vm.VmOpcode::VmOpcodeAdd
.end

fn chunk_from_lir(lir.LModule m) -> BytecodeArtifact:
    let code = Vec<vm.VmInstr>::new()
    let consts = Vec<vm.VmValue>::new()
    let regs = Vec<RegMapping>::new()
    let next_reg = 0u32
    let ret_reg: vm.VmRegIndex = 0u32

    if m.functions.is_empty():
        let art_empty = BytecodeArtifact(
            code = code,
            consts = consts,
            num_regs = 0u32,
            ret_reg = ret_reg
        )
        return art_empty
    .end

    let f = m.functions[0usize]
    let blocks = f.blocks
    let entry_idx = f.entry_block.raw as usize
    let entry_block = blocks[entry_idx]
    let instrs = entry_block.instrs

    let vm_span = empty_vm_span()
    let idx = 0usize
    let next_reg_cur = next_reg
    let reg_map = regs
    let ret_reg_cur = ret_reg

    while idx < instrs.len():
        let inst = instrs[idx]
        if inst.kind == lir.LInstrKind::LInstrConst and inst.result.is_some():
            let target_id = inst.result.unwrap()
            let tuple_reg = assign_reg(reg_map, target_id, next_reg_cur)
            let reg_map2 = tuple_reg.0
            let next_reg2 = tuple_reg.1
            let dst_reg = tuple_reg.2

            let op = inst.operands[0usize]
            let val = if op.kind == lir.LOperandKind::LOpImmBool:
                vm.vm_value_bool(op.imm_bool.unwrap())
            else:
                let imm_i64 = unwrap_or_i64(op.imm_int, 0i64)
                vm.vm_value_int(imm_i64)
            .end

            let const_idx: vm.VmConstIndex = (consts.len() as u32)
            consts.push(val)

            let instr_vm = vm.VmInstr(
                opcode = vm.VmOpcode::VmOpcodeConst,
                a = dst_reg,
                b = const_idx,
                c = 0u32,
                imm = 0i32,
                span = vm_span
            )
            code.push(instr_vm)

            reg_map = reg_map2
            next_reg_cur = next_reg2
        .end

        if inst.kind == lir.LInstrKind::LInstrBinOp and inst.result.is_some():
            let dst_id = inst.result.unwrap()
            let tuple_dst = assign_reg(reg_map, dst_id, next_reg_cur)
            let reg_map3 = tuple_dst.0
            let next_reg3 = tuple_dst.1
            let dst_reg2 = tuple_dst.2

            let lhs_op = inst.operands[0usize]
            let rhs_op = inst.operands[1usize]

            let lhs_id = lhs_op.value.unwrap()
            let rhs_id = rhs_op.value.unwrap()

            let lhs_reg_opt = lookup_reg(reg_map3, lhs_id)
            let rhs_reg_opt = lookup_reg(reg_map3, rhs_id)

            let lhs_reg = unwrap_or_reg(lhs_reg_opt, 0u32)
            let rhs_reg = unwrap_or_reg(rhs_reg_opt, 0u32)

            let opcode = map_binop_opcode(inst.bin_op.unwrap())

            let instr_vm2 = vm.VmInstr(
                opcode = opcode,
                a = dst_reg2,
                b = lhs_reg,
                c = rhs_reg,
                imm = 0i32,
                span = vm_span
            )
            code.push(instr_vm2)

            reg_map = reg_map3
            next_reg_cur = next_reg3
        .end

        if inst.kind == lir.LInstrKind::LInstrRet:
            let ret_op = inst.operands[0usize]
            let ret_id = ret_op.value.unwrap()
            let ret_reg_opt = lookup_reg(reg_map, ret_id)
            let reg_final = unwrap_or_reg(ret_reg_opt, 0u32)

            let instr_vm3 = vm.VmInstr(
                opcode = vm.VmOpcode::VmOpcodeRet,
                a = reg_final,
                b = 0u32,
                c = 0u32,
                imm = 0i32,
                span = vm_span
            )
            code.push(instr_vm3)
            ret_reg_cur = reg_final
        .end

        idx = idx + 1usize
    .end

    let art = BytecodeArtifact(
        code = code,
        consts = consts,
        num_regs = next_reg_cur,
        ret_reg = ret_reg_cur
    )
    return art
.end

# -----------------------------------------------------------------------------
# Exécution VM
# -----------------------------------------------------------------------------

fn run_chunk(BytecodeArtifact bc) -> vm.VmState:
    let vm0 = vm.vm_state_new()
    let pair = vm.vm_add_chunk(
        vm0,
        "main",
        bc.code,
        bc.consts,
        bc.num_regs,
        0u32,
        bc.num_regs
    )
    let vm1 = pair.0
    let cid = pair.1
    let vm2 = vm.vm_start(vm1, cid)
    let vm3 = vm.vm_run_n_steps(vm2, 128u32)
    return vm3
.end

fn extract_return(vm.VmState state, vm.VmRegIndex reg) -> Option<vm.VmValue>:
    let frames = state.frames
    if frames.is_empty():
        let none_v: Option<vm.VmValue> = Option<vm.VmValue>::None()
        return none_v
    .end
    let last_idx = frames.len() - 1usize
    let frame = frames[last_idx]
    let regs = frame.regs
    let idx = (reg as usize)
    if idx >= regs.len():
        let none_v2: Option<vm.VmValue> = Option<vm.VmValue>::None()
        return none_v2
    .end
    let v = regs[idx]
    let some_v: Option<vm.VmValue> = Option<vm.VmValue>::Some(v)
    return some_v
.end

# -----------------------------------------------------------------------------
# API principale
# -----------------------------------------------------------------------------

pub fn incremental_compile_and_run(
    String file_name,
    String source
) -> IncrementalResult:
    let sink = diag.diagnostics_sink_new()
    let parse_res = parser.parse_source(file_name, source, sink)
    let ast_summary = summarize_functions(parse_res)
    let lir_mod = lir_from_ast(ast_summary)
    let bc = chunk_from_lir(lir_mod)
    let vm_state = run_chunk(bc)
    let ret_opt = extract_return(vm_state, bc.ret_reg)

    let res = IncrementalResult(
        parse = parse_res,
        ast = ast_summary,
        lir = lir_mod,
        bytecode = bc,
        vm_state = vm_state,
        return_value = ret_opt
    )
    return res
.end
