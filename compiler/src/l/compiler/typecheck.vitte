module vitte.compiler.typecheck

import std.collections as coll
import vitte.compiler.span as span
import vitte.compiler.syntax as syn
import vitte.compiler.symbols as sym
import vitte.compiler.tree as tree
import vitte.compiler.type_infer as ti
import vitte.compiler.stdlib as stdlib
import vitte.compiler.traits as trt

# =============================================================================
# Vitte compiler – Typechecking orchestration (maximal, logique, sans I/O)
# =============================================================================
#
# Objectifs :
#   - Orchestrer le typage d’un projet Vitte côté front-end :
#       * configuration de la passe de typage,
#       * initialisation du contexte d’inférence (InferContext),
#       * boucle de typechecking par unité (SourceUnit),
#       * mise à jour du ProjectTree (stage = TypeChecked, has_errors).
#   - Conserver toute la logique de bas niveau (unification, contraintes) dans
#     `vitte.compiler.type_infer`, en ajoutant uniquement une couche de
#     coordination, de résultats et de statistiques.
#   - Ne faire aucun I/O : pas de lecture/écriture disque, pas de logging.
#
# Remarques :
#   - Ce module ne parcourt PAS en détail le SyntaxTree pour générer les
#     contraintes ; ces passes seront définies dans des modules complémentaires
#     (ex: `typecheck_expr`, `typecheck_items`). Ici, on prépare l’ossature
#     complète, l’API et le modèle de données.
# =============================================================================

# -----------------------------------------------------------------------------
# Configuration et statistiques
# -----------------------------------------------------------------------------

pub struct TypeCheckConfig:
    let enable_traits: Bool              # activer les contraintes de traits
    let enable_implicit_conversions: Bool
    let max_constraint_iterations: u32   # plafond de passes de résolution
    let stop_on_first_error: Bool        # arrêt anticipé si erreur de typage
.end

pub struct TypeCheckStats:
    let units_checked: u32
    let total_constraints: u32
    let total_errors: u32
.end

pub fn typecheck_config_default() -> TypeCheckConfig:
    let cfg = TypeCheckConfig(
        enable_traits = true,
        enable_implicit_conversions = true,
        max_constraint_iterations = 4u32,
        stop_on_first_error = false
    )
    return cfg
.end

pub fn typecheck_stats_empty() -> TypeCheckStats:
    let st = TypeCheckStats(
        units_checked = 0u32,
        total_constraints = 0u32,
        total_errors = 0u32
    )
    return st
.end

# -----------------------------------------------------------------------------
# Mapping des types d’expressions
# -----------------------------------------------------------------------------

pub struct ExprTypeEntry:
    let expr_id: syn.ExprId
    let type_id: ti.TypeId
.end

pub struct ExprTypeMap:
    let entries: Vec<ExprTypeEntry>
.end

pub fn expr_type_map_new() -> ExprTypeMap:
    let v: Vec<ExprTypeEntry> = Vec<ExprTypeEntry>::new()
    let m = ExprTypeMap(
        entries = v
    )
    return m
.end

pub fn expr_type_map_add(
    ExprTypeMap map,
    syn.ExprId expr_id,
    ti.TypeId ty_id
) -> ExprTypeMap:
    let entries = map.entries
    let e = ExprTypeEntry(
        expr_id = expr_id,
        type_id = ty_id
    )
    entries.push(e)
    let m2 = ExprTypeMap(
        entries = entries
    )
    return m2
.end

pub fn expr_type_map_get(
    ExprTypeMap map,
    syn.ExprId expr_id
) -> coll.Option<ti.TypeId>:
    let entries = map.entries
    let n = entries.len()
    let i = 0usize

    while i < n:
        let e = entries[i]
        if e.expr_id == expr_id:
            let some_ty = coll.option_some<ti.TypeId>(e.type_id)
            return some_ty
        .end
        let i = i + 1usize
    .end

    let none_ty = coll.option_none<ti.TypeId>()
    return none_ty
.end

# -----------------------------------------------------------------------------
# Résultats de typage
# -----------------------------------------------------------------------------

pub struct TypeCheckUnitResult:
    let unit_id: tree.UnitId
    let expr_types: ExprTypeMap
    let has_type_errors: Bool
.end

pub struct TypeCheckProjectResult:
    let config: TypeCheckConfig
    let stats: TypeCheckStats
    let units: Vec<TypeCheckUnitResult>
    let infer_context: ti.InferContext
.end

pub fn typecheck_project_result_empty(
    TypeCheckConfig cfg,
    ti.InferContext ctx
) -> TypeCheckProjectResult:
    let v: Vec<TypeCheckUnitResult> = Vec<TypeCheckUnitResult>::new()
    let st = typecheck_stats_empty()
    let res = TypeCheckProjectResult(
        config = cfg,
        stats = st,
        units = v,
        infer_context = ctx
    )
    return res
.end

pub fn typecheck_project_result_add_unit(
    TypeCheckProjectResult acc,
    TypeCheckUnitResult unit_res,
    ti.InferContext ctx_after_unit
) -> TypeCheckProjectResult:
    let cfg = acc.config
    let stats = acc.stats
    let units = acc.units

    let new_units = units
    new_units.push(unit_res)

    let new_stats = TypeCheckStats(
        units_checked = stats.units_checked + 1u32,
        total_constraints = stats.total_constraints,   # mis à jour ailleurs si besoin
        total_errors = stats.total_errors              # mis à jour ailleurs si besoin
    )

    let res = TypeCheckProjectResult(
        config = cfg,
        stats = new_stats,
        units = new_units,
        infer_context = ctx_after_unit
    )
    return res
.end

# -----------------------------------------------------------------------------
# Helpers d’interrogation des résultats
# -----------------------------------------------------------------------------

pub fn typecheck_find_unit_result(
    TypeCheckProjectResult proj_res,
    tree.UnitId unit_id
) -> coll.Option<TypeCheckUnitResult>:
    let v = proj_res.units
    let n = v.len()
    let i = 0usize

    while i < n:
        let u = v[i]
        if u.unit_id == unit_id:
            let some_res = coll.option_some<TypeCheckUnitResult>(u)
            return some_res
        .end
        let i = i + 1usize
    .end

    let none_res = coll.option_none<TypeCheckUnitResult>()
    return none_res
.end

pub fn typecheck_find_expr_type(
    TypeCheckProjectResult proj_res,
    tree.UnitId unit_id,
    syn.ExprId expr_id
) -> coll.Option<ti.TypeId>:
    let opt_unit_res = typecheck_find_unit_result(proj_res, unit_id)
    if coll.option_is_none<TypeCheckUnitResult>(opt_unit_res):
        let none_ty = coll.option_none<ti.TypeId>()
        return none_ty
    .end

    let unit_res = coll.option_unwrap_unsafe<TypeCheckUnitResult>(opt_unit_res)
    let ty_opt = expr_type_map_get(unit_res.expr_types, expr_id)
    return ty_opt
.end

# -----------------------------------------------------------------------------
# Initialisation du contexte d’inférence pour un projet
# -----------------------------------------------------------------------------

pub fn typecheck_init_infer_context_for_project(
    tree.ProjectTree proj
) -> ti.InferContext:
    let stdcat = tree.project_tree_get_stdlib(proj)
    let trait_cat = trt.trait_catalog_new()   # traits projet fusionnés plus tard si besoin

    let ctx = ti.infer_context_new(
        stdcat,
        trait_cat
    )
    return ctx
.end

# -----------------------------------------------------------------------------
# Typage d’une unité (ossature)
# -----------------------------------------------------------------------------
#
# Remarque :
#   - Les fonctions ci-dessous posent l’ossature du typechecking pour une
#     SourceUnit :
#       * construction/extension de l’environnement de typage,
#       * génération de contraintes (TODO dans des modules spécialisés),
#       * appel à `ti.infer_solve_constraints`.
#   - Le marcheur détaillé sur le SyntaxTree (items/exprs) sera branché sur
#     cette API, sans I/O.

# Extension minimale de l’environnement avec les symboles d’une unité.
# Pour l’instant, on ne fait qu’un squelette : les schémas de types doivent
# être construits par des passes séparées, à partir de déclarations.
pub fn typecheck_build_env_for_unit(
    ti.InferContext ctx,
    tree.SourceUnit unit
) -> ti.InferContext:
    # TODO: parcourir unit.symbols pour créer les TypeScheme correspondants
    # et les binder dans ctx.env via ti.infer_env_bind_symbol.
    #
    # Actuellement, on retourne le contexte inchangé (ossature uniquement).
    let ctx2 = ctx
    return ctx2
.end

# Marcheur minimal sur les expressions pour générer des placeholders
# dans ExprTypeMap. La vraie génération de contraintes sera ajoutée ici
# ou dans des modules dédiés.
pub fn typecheck_collect_expr_placeholders(
    ti.InferContext ctx,
    tree.SourceUnit unit
) -> (ti.InferContext, ExprTypeMap):
    let syn_tree = unit.syntax
    let exprs = syn_tree.exprs
    let n = exprs.len()
    let i = 0usize

    let map = expr_type_map_new()
    let ctx_cur = ctx

    # Pour chaque expression, on crée une variable de type (placeholder).
    while i < n:
        let e = exprs[i]
        let sp = e.span

        let (ctx_next, _var_id, ty_id) = ti.infer_add_type_var(
            ctx_cur,
            "E",
            false,
            sp
        )

        let map2 = expr_type_map_add(
            map,
            e.id,
            ty_id
        )

        let map = map2
        let ctx_cur = ctx_next
        let i = i + 1usize
    .end

    let out = (ctx_cur, map)
    return out
.end

# Applique la résolution des contraintes sur l’InferContext.
# Pour l’instant, on délègue simplement à ti.infer_solve_constraints.
pub fn typecheck_solve_for_unit(
    ti.InferContext ctx
) -> ti.InferContext:
    let ctx2 = ti.infer_solve_constraints(ctx)
    return ctx2
.end

# Typage complet d’une unité :
#   - construit l’environnement,
#   - génère des placeholders de types pour les expressions,
#   - résout les contraintes,
#   - renvoie un TypeCheckUnitResult et le contexte mis à jour.
pub fn typecheck_unit(
    TypeCheckConfig cfg,
    ti.InferContext ctx,
    tree.SourceUnit unit
) -> (ti.InferContext, TypeCheckUnitResult):
    # 1) Construire/étendre l’environnement
    let ctx1 = typecheck_build_env_for_unit(ctx, unit)

    # 2) Placeholders d’expressions (génération future de contraintes)
    let (ctx2, expr_map) = typecheck_collect_expr_placeholders(ctx1, unit)

    # 3) Résolution des contraintes (unification, traits, etc.)
    let ctx3 = typecheck_solve_for_unit(ctx2)

    # 4) Diagnostic : y a-t-il des erreurs de typage ?
    let has_err = ti.infer_has_errors(ctx3)

    let unit_res = TypeCheckUnitResult(
        unit_id = unit.id,
        expr_types = expr_map,
        has_type_errors = has_err
    )

    let out = (ctx3, unit_res)
    return out
.end

# -----------------------------------------------------------------------------
# Typage de projet complet
# -----------------------------------------------------------------------------

pub fn typecheck_project(
    TypeCheckConfig cfg,
    tree.ProjectTree proj
) -> (tree.ProjectTree, TypeCheckProjectResult):
    # 1) Initialisation du contexte d’inférence projet.
    let ctx0 = typecheck_init_infer_context_for_project(proj)
    let proj_res0 = typecheck_project_result_empty(cfg, ctx0)

    # 2) Itération sur toutes les unités (ordre naïf ; un scheduler
    #    topologique pourra être ajouté plus tard).
    let units = proj.units
    let unit_count = units.len()
    let i = 0usize

    let proj_cur = proj
    let res_cur = proj_res0

    while i < unit_count:
        let u = units[i]

        # 2.1) Typage de l’unité
        let ctx_before = res_cur.infer_context
        let (ctx_after, unit_res) = typecheck_unit(
            cfg,
            ctx_before,
            u
        )

        # 2.2) Mise à jour des stats & accumulation des résultats
        let res_next = typecheck_project_result_add_unit(
            res_cur,
            unit_res,
            ctx_after
        )

        # 2.3) Mise à jour du ProjectTree : stage + flag d’erreur
        let stage_checked = tree.SourceUnitStage::SourceUnitStageTypeChecked
        let proj_next = tree.project_tree_update_unit_stage_and_errors(
            proj_cur,
            u.id,
            stage_checked,
            unit_res.has_type_errors
        )

        # 2.4) Si cfg.stop_on_first_error et erreurs présente, on pourrait
        #      arrêter ici (mais on choisit de continuer pour l’instant).
        let proj_cur = proj_next
        let res_cur = res_next

        let i = i + 1usize
    .end

    # 3) Rafraîchir les compteurs globaux (constraints, errors).
    let final_ctx = res_cur.infer_context
    let final_errors_count = final_ctx.errors.len()
    let final_constraints_count = final_ctx.constraints.len()

    let st_prev = res_cur.stats
    let st_final = TypeCheckStats(
        units_checked = st_prev.units_checked,
        total_constraints = (u32) final_constraints_count,
        total_errors = (u32) final_errors_count
    )

    let cfg_final = res_cur.config
    let units_final = res_cur.units

    let final_res = TypeCheckProjectResult(
        config = cfg_final,
        stats = st_final,
        units = units_final,
        infer_context = final_ctx
    )

    let out = (proj_cur, final_res)
    return out
.end

# -----------------------------------------------------------------------------
# Helpers de debug et scenario de test
# -----------------------------------------------------------------------------

pub fn typecheck_config_debug(cfg: TypeCheckConfig) -> String:
    let s = "TypeCheckConfig{traits="
    let s = s + (if cfg.enable_traits then "on" else "off")
    let s = s + ", implicit="
    let s = s + (if cfg.enable_implicit_conversions then "on" else "off")
    let s = s + ", max_iter="
    let s = s + "?"      # TODO: formatter u32 -> String quand dispo
    let s = s + "}"
    return s
.end

scenario typecheck_smoke_test():
    # Construction d’un ProjectTree et d’un config par défaut.
    let proj0 = tree.project_tree_new_default()
    let cfg = typecheck_config_default()

    # Ajout d’une unité fictive.
    let file_main = span.file_id_new(0)
    let path_main = "src/main.vitte"
    let module_main = "core.main"

    let (proj1, unit_main) = tree.project_tree_add_empty_unit(
        proj0,
        file_main,
        path_main,
        module_main,
        tree.SourceUnitKind::SourceUnitKindUser,
        true
    )

    # Typage du projet (dans l’état actuel, ne génère que des placeholders).
    let (proj2, res) = typecheck_project(cfg, proj1)

    let stats = res.stats
    let has_any_errors = stats.total_errors > 0u32

    let _ = proj2
    let _ = unit_main
    let _ = has_any_errors
.end
