

module vitte.compiler.language

import vitte.compiler.collections as coll
import vitte.compiler.diagnostics as diag

# ============================================================================
# Vitte compiler – Language description & configuration (max)
#
# Rôle de ce module :
#   - Centraliser la description du langage Vitte tel que vu par le compilateur
#     (édition, dialecte, mode, cible, options, features).
#   - Fournir des presets : core, phrase, full, experimental.
#   - Décrire les mots-clés réservés sous forme de données (pour le lexer,
#     la coloration, les outils).
#
# Tout est purement déclaratif : pas d’accès FS ni I/O ici.
# ============================================================================

# ----------------------------------------------------------------------------
# Editions du langage (type d’édition Vitte/Muffin)
# ----------------------------------------------------------------------------

pub enum LanguageEdition:
    LanguageEdition2024
    LanguageEdition2025
    LanguageEditionNightly
.end

pub struct EditionInfo:
    let name: String
    let year: u32
    let is_stable: Bool
.end

pub fn edition_info(LanguageEdition edition) -> EditionInfo:
    if edition == LanguageEdition::LanguageEdition2024:
        let info = EditionInfo(
            name = "2024",
            year = 2024u32,
            is_stable = true
        )
        return info
    .end

    if edition == LanguageEdition::LanguageEdition2025:
        let info = EditionInfo(
            name = "2025",
            year = 2025u32,
            is_stable = true
        )
        return info
    .end

    # Nightly
    let info_n = EditionInfo(
        name = "nightly",
        year = 0u32,
        is_stable = false
    )
    return info_n
.end

# ----------------------------------------------------------------------------
# Dialectes et modes de compilation
# ----------------------------------------------------------------------------

pub enum LanguageDialect:
    LanguageDialectCore        # Syntaxe noyau Vitte (module / struct / fn / .end)
    LanguageDialectPhrase      # Syntaxe phrase (mod/use/type/fn/scn/prog... .end)
    LanguageDialectFull        # Core + Phrase, tout activé
    LanguageDialectMuffinOnly  # Lecture de manifestes Muffin uniquement
.end

pub enum CompileMode:
    CompileModeCheck     # simple vérification (typecheck, diagnostics)
    CompileModeBuild     # génération de code / artefacts
    CompileModeRepl      # mode REPL / interactive
    CompileModeLsp       # serveur de langage / analyse incrémentale
.end

pub enum TargetKind:
    TargetKindNative        # binaire natif via backend (C/Rust/LLVM)
    TargetKindBytecode      # VM Vitte / Vitte-Light
    TargetKindWasm          # WebAssembly
    TargetKindC             # génération de C
    TargetKindRust          # génération de Rust
    TargetKindHeaderOnly    # headers (C/Vitte) uniquement
.end

pub enum ModuleKind:
    ModuleKindLibrary
    ModuleKindBinary
    ModuleKindTest
    ModuleKindTool
    ModuleKindKernel
    ModuleKindService
    ModuleKindScenario
.end

# ----------------------------------------------------------------------------
# Niveaux d’optimisation, debug, warnings
# ----------------------------------------------------------------------------

pub enum OptimizationLevel:
    OptimizationLevelNone
    OptimizationLevelDebug
    OptimizationLevelRelease
    OptimizationLevelAggressive
.end

pub enum DebugInfoLevel:
    DebugInfoNone
    DebugInfoLine
    DebugInfoFull
.end

pub enum WarningPolicy:
    WarningPolicyDefault          # warnings affichés, non bloquants
    WarningPolicySilent           # warnings masqués
    WarningPolicyTreatAsError     # warnings -> erreurs
.end

# ----------------------------------------------------------------------------
# Features du langage (flags)
# ----------------------------------------------------------------------------

pub struct LanguageFeatureFlags:
    let enable_phrase_syntax: Bool
    let enable_traits: Bool
    let enable_impls: Bool
    let enable_generics: Bool
    let enable_match_expr: Bool
    let enable_pipeline_operator: Bool      # expr |> f(...)
    let enable_alias_types: Bool           # typedef
    let enable_scenarios: Bool             # scenario ident (...) : ... .end
    let enable_muffin_manifests: Bool
    let enable_experimental_keywords: Bool
    let enable_cfg_export: Bool            # export CFG/HIR pour debug
    let enable_unsafe_blocks: Bool         # réservé : futurs blocs "unsafe"
.end

pub fn language_feature_flags_core() -> LanguageFeatureFlags:
    let flags = LanguageFeatureFlags(
        enable_phrase_syntax = false,
        enable_traits = true,
        enable_impls = true,
        enable_generics = true,
        enable_match_expr = true,
        enable_pipeline_operator = true,
        enable_alias_types = true,
        enable_scenarios = true,
        enable_muffin_manifests = true,
        enable_experimental_keywords = false,
        enable_cfg_export = false,
        enable_unsafe_blocks = false
    )
    return flags
.end

pub fn language_feature_flags_phrase() -> LanguageFeatureFlags:
    let flags = LanguageFeatureFlags(
        enable_phrase_syntax = true,
        enable_traits = true,
        enable_impls = true,
        enable_generics = true,
        enable_match_expr = true,
        enable_pipeline_operator = true,
        enable_alias_types = true,
        enable_scenarios = true,
        enable_muffin_manifests = true,
        enable_experimental_keywords = false,
        enable_cfg_export = false,
        enable_unsafe_blocks = false
    )
    return flags
.end

pub fn language_feature_flags_full_experimental() -> LanguageFeatureFlags:
    let flags = LanguageFeatureFlags(
        enable_phrase_syntax = true,
        enable_traits = true,
        enable_impls = true,
        enable_generics = true,
        enable_match_expr = true,
        enable_pipeline_operator = true,
        enable_alias_types = true,
        enable_scenarios = true,
        enable_muffin_manifests = true,
        enable_experimental_keywords = true,
        enable_cfg_export = true,
        enable_unsafe_blocks = true
    )
    return flags
.end

pub fn language_features_phrase_enabled(LanguageFeatureFlags f) -> Bool:
    return f.enable_phrase_syntax
.end

pub fn language_features_traits_enabled(LanguageFeatureFlags f) -> Bool:
    return f.enable_traits
.end

pub fn language_features_unsafe_allowed(LanguageFeatureFlags f) -> Bool:
    return f.enable_unsafe_blocks
.end

# ----------------------------------------------------------------------------
# Groupe de mots-clés (données pour lexer / IDE)
# ----------------------------------------------------------------------------

pub struct KeywordGroup:
    let name: String
    let words: Vec<String>
.end

pub struct ReservedKeywords:
    let core: KeywordGroup
    let phrase: KeywordGroup
    let types: KeywordGroup
    let control_flow: KeywordGroup
    let literals: KeywordGroup
    let modifiers: KeywordGroup
.end

pub fn keyword_group_new(String name, Vec<String> words) -> KeywordGroup:
    let g = KeywordGroup(
        name = name,
        words = words
    )
    return g
.end

pub fn reserved_keywords_default() -> ReservedKeywords:
    # core
    let core_words: Vec<String> = Vec<String>::new()
    core_words.push("module")
    core_words.push("import")
    core_words.push("export")
    core_words.push("muffin")

    core_words.push("program")
    core_words.push("service")
    core_words.push("kernel")
    core_words.push("driver")
    core_words.push("tool")
    core_words.push("scenario")
    core_words.push("pipeline")

    let core_group = keyword_group_new("core", core_words)

    # phrase
    let phrase_words: Vec<String> = Vec<String>::new()
    phrase_words.push("mod")
    phrase_words.push("use")
    phrase_words.push("type")
    phrase_words.push("field")
    phrase_words.push("fn")
    phrase_words.push("scn")
    phrase_words.push("prog")
    phrase_words.push("set")
    phrase_words.push("say")
    phrase_words.push("do")
    phrase_words.push("ret")
    phrase_words.push("when")
    phrase_words.push("loop")
    phrase_words.push("from")
    phrase_words.push("to")
    phrase_words.push("step")
    phrase_words.push("end")

    let phrase_group = keyword_group_new("phrase", phrase_words)

    # types
    let type_words: Vec<String> = Vec<String>::new()
    type_words.push("struct")
    type_words.push("union")
    type_words.push("enum")
    type_words.push("typedef")
    type_words.push("trait")
    type_words.push("impl")
    type_words.push("where")
    type_words.push("inline")
    type_words.push("extern")
    type_words.push("static")

    let types_group = keyword_group_new("types", type_words)

    # control flow
    let cf_words: Vec<String> = Vec<String>::new()
    cf_words.push("if")
    cf_words.push("elif")
    cf_words.push("else")
    cf_words.push("while")
    cf_words.push("for")
    cf_words.push("in")
    cf_words.push("match")
    cf_words.push("break")
    cf_words.push("continue")
    cf_words.push("return")

    let control_group = keyword_group_new("control_flow", cf_words)

    # literals / bools / null
    let lit_words: Vec<String> = Vec<String>::new()
    lit_words.push("true")
    lit_words.push("false")
    lit_words.push("null")

    let lit_group = keyword_group_new("literals", lit_words)

    # modifiers & operators
    let mod_words: Vec<String> = Vec<String>::new()
    mod_words.push("let")
    mod_words.push("const")
    mod_words.push("and")
    mod_words.push("or")
    mod_words.push("not")
    mod_words.push("as")
    mod_words.push("all")
    mod_words.push("volatile")
    mod_words.push("restrict")
    mod_words.push("pub")
    mod_words.push("sizeof")
    mod_words.push("alignof")

    let mod_group = keyword_group_new("modifiers", mod_words)

    let r = ReservedKeywords(
        core = core_group,
        phrase = phrase_group,
        types = types_group,
        control_flow = control_group,
        literals = lit_group,
        modifiers = mod_group
    )
    return r
.end

pub fn reserved_keywords_contains(ReservedKeywords r, String word) -> Bool:
    if keyword_group_contains(r.core, word):
        return true
    .end

    if keyword_group_contains(r.phrase, word):
        return true
    .end

    if keyword_group_contains(r.types, word):
        return true
    .end

    if keyword_group_contains(r.control_flow, word):
        return true
    .end

    if keyword_group_contains(r.literals, word):
        return true
    .end

    if keyword_group_contains(r.modifiers, word):
        return true
    .end

    return false
.end

pub fn keyword_group_contains(KeywordGroup g, String word) -> Bool:
    let v = g.words
    let n = v.len()
    let i = 0usize
    while i < n:
        let w = v[i]
        if w == word:
            return true
        .end
        i = i + 1usize
    .end
    return false
.end

# ----------------------------------------------------------------------------
# Config globale du langage
# ----------------------------------------------------------------------------

pub struct LanguageConfig:
    let edition: LanguageEdition
    let dialect: LanguageDialect
    let compile_mode: CompileMode
    let target_kind: TargetKind
    let module_kind: ModuleKind
    let features: LanguageFeatureFlags
    let optimization: OptimizationLevel
    let debug_info: DebugInfoLevel
    let warning_policy: WarningPolicy
    let warnings_as_errors: Bool
    let allow_deprecated_syntax: Bool
    let default_charset: String
    let default_newline: String
.end

pub fn language_config_core_default() -> LanguageConfig:
    let flags = language_feature_flags_core()
    let cfg = LanguageConfig(
        edition = LanguageEdition::LanguageEdition2025,
        dialect = LanguageDialect::LanguageDialectCore,
        compile_mode = CompileMode::CompileModeBuild,
        target_kind = TargetKind::TargetKindNative,
        module_kind = ModuleKind::ModuleKindLibrary,
        features = flags,
        optimization = OptimizationLevel::OptimizationLevelDebug,
        debug_info = DebugInfoLevel::DebugInfoLine,
        warning_policy = WarningPolicy::WarningPolicyDefault,
        warnings_as_errors = false,
        allow_deprecated_syntax = false,
        default_charset = "utf-8",
        default_newline = "\n"
    )
    return cfg
.end

pub fn language_config_phrase_default() -> LanguageConfig:
    let flags = language_feature_flags_phrase()
    let cfg = LanguageConfig(
        edition = LanguageEdition::LanguageEdition2025,
        dialect = LanguageDialect::LanguageDialectPhrase,
        compile_mode = CompileMode::CompileModeBuild,
        target_kind = TargetKind::TargetKindBytecode,
        module_kind = ModuleKind::ModuleKindBinary,
        features = flags,
        optimization = OptimizationLevel::OptimizationLevelDebug,
        debug_info = DebugInfoLevel::DebugInfoLine,
        warning_policy = WarningPolicy::WarningPolicyDefault,
        warnings_as_errors = false,
        allow_deprecated_syntax = false,
        default_charset = "utf-8",
        default_newline = "\n"
    )
    return cfg
.end

pub fn language_config_full_experimental() -> LanguageConfig:
    let flags = language_feature_flags_full_experimental()
    let cfg = LanguageConfig(
        edition = LanguageEdition::LanguageEditionNightly,
        dialect = LanguageDialect::LanguageDialectFull,
        compile_mode = CompileMode::CompileModeBuild,
        target_kind = TargetKind::TargetKindBytecode,
        module_kind = ModuleKind::ModuleKindLibrary,
        features = flags,
        optimization = OptimizationLevel::OptimizationLevelAggressive,
        debug_info = DebugInfoLevel::DebugInfoFull,
        warning_policy = WarningPolicy::WarningPolicyTreatAsError,
        warnings_as_errors = true,
        allow_deprecated_syntax = true,
        default_charset = "utf-8",
        default_newline = "\n"
    )
    return cfg
.end

# ----------------------------------------------------------------------------
# Helpers de requête sur LanguageConfig
# ----------------------------------------------------------------------------

pub fn language_config_is_phrase(LanguageConfig cfg) -> Bool:
    return cfg.dialect == LanguageDialect::LanguageDialectPhrase or
           cfg.dialect == LanguageDialect::LanguageDialectFull
.end

pub fn language_config_is_core_only(LanguageConfig cfg) -> Bool:
    return cfg.dialect == LanguageDialect::LanguageDialectCore
.end

pub fn language_config_wants_debug_info(LanguageConfig cfg) -> Bool:
    return cfg.debug_info != DebugInfoLevel::DebugInfoNone
.end

pub fn language_config_is_nightly(LanguageConfig cfg) -> Bool:
    return cfg.edition == LanguageEdition::LanguageEditionNightly
.end

pub fn language_config_warnings_are_errors(LanguageConfig cfg) -> Bool:
    if cfg.warnings_as_errors:
        return true
    .end
    return cfg.warning_policy == WarningPolicy::WarningPolicyTreatAsError
.end

pub fn language_config_supports_muffin(LanguageConfig cfg) -> Bool:
    return cfg.features.enable_muffin_manifests
.end

pub fn language_config_supports_traits(LanguageConfig cfg) -> Bool:
    return cfg.features.enable_traits
.end

pub fn language_config_supports_generics(LanguageConfig cfg) -> Bool:
    return cfg.features.enable_generics
.end

pub fn language_config_supports_unsafe(LanguageConfig cfg) -> Bool:
    return cfg.features.enable_unsafe_blocks
.end

# ----------------------------------------------------------------------------
# Profil complet : config + mots-clés
# ----------------------------------------------------------------------------

pub struct LanguageProfile:
    let config: LanguageConfig
    let reserved: ReservedKeywords
.end

pub fn language_profile_core() -> LanguageProfile:
    let cfg = language_config_core_default()
    let kw = reserved_keywords_default()
    let p = LanguageProfile(
        config = cfg,
        reserved = kw
    )
    return p
.end

pub fn language_profile_phrase() -> LanguageProfile:
    let cfg = language_config_phrase_default()
    let kw = reserved_keywords_default()
    let p = LanguageProfile(
        config = cfg,
        reserved = kw
    )
    return p
.end

pub fn language_profile_full_experimental() -> LanguageProfile:
    let cfg = language_config_full_experimental()
    let kw = reserved_keywords_default()
    let p = LanguageProfile(
        config = cfg,
        reserved = kw
    )
    return p
.end

# ----------------------------------------------------------------------------
# Notes
# ----------------------------------------------------------------------------
# - Ce module ne fait aucune hypothèse sur la représentation interne des AST / HIR,
#   il fournit seulement les paramètres globaux du langage et les mots-clés
#   réservés de manière déclarative.
# - Les backends (Vitte-Light, C, Rust, WASM) peuvent interroger LanguageConfig
#   pour adapter leur comportement (debug info, optimisation, cible).
# - Les outils (LSP, formatter, docgen) peuvent interroger ReservedKeywords /
#   LanguageProfile pour la coloration, l’autocomplétion, ou des messages
#   contextualisés selon l’édition/dialecte.
# ============================================================================