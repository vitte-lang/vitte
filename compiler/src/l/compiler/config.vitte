

module vitte.compiler.config

import vitte.compiler.backends as backends
import vitte.compiler.collections as coll

# ============================================================================
# Vitte compiler – Configuration globale (ultra complet, mais sobre)
#
# Objectifs :
#   - Décrire la configuration complète du compilateur Vitte :
#       * entrées (fichiers, stdin, REPL),
#       * sorties (binaire, lib, IR, etc.),
#       * chemins (root, build, cache, out),
#       * warnings / erreurs / couleur / verbosité,
#       * frontend (parsing, borrowck, lints),
#       * optimisation / debug,
#       * backend (cible + backend Vitte).
#   - Offrir des helpers pour construire une config par défaut et appliquer des
#     surcharges simples (ex: CLI > fichier muffin > défauts).
# ============================================================================

# ----------------------------------------------------------------------------
# Entrées / sorties / affichage
# ----------------------------------------------------------------------------

pub enum InputKind:
    InputSourceFiles      # liste de fichiers source Vitte
    InputModuleName       # nom logique de module, résolution via manifest
    InputStdin            # source lue depuis stdin
    InputRepl             # mode REPL interactif
.end

pub enum OutputFormat:
    OutputExecutable
    OutputStaticLibrary
    OutputSharedLibrary
    OutputObject
    OutputIR
    OutputAssembly
.end

pub enum ColorMode:
    ColorAuto
    ColorAlways
    ColorNever
.end

pub enum Verbosity:
    VerbosityQuiet
    VerbosityNormal
    VerbosityVerbose
    VerbosityTrace
.end

pub enum WarningPolicy:
    WarningAllow
    WarningWarn
    WarningDeny
    WarningForbid
.end

# ----------------------------------------------------------------------------
# Chemins
# ----------------------------------------------------------------------------

pub struct PathConfig:
    let project_root: String   # racine logique du projet
    let build_dir: String     # répertoire de build (obj, intermédiaires)
    let cache_dir: String     # répertoire de cache (index, metadata)
    let out_dir: String       # répertoire des artefacts finaux
    let temp_dir: String      # fichiers temporaires
.end

pub fn path_config_default() -> PathConfig:
    let cfg = PathConfig(
        project_root = ".",
        build_dir = "./build",
        cache_dir = "./.vitte-cache",
        out_dir = "./build/out",
        temp_dir = "./build/tmp"
    )
    return cfg
.end

# ----------------------------------------------------------------------------
# Warnings / lints
# ----------------------------------------------------------------------------

pub struct WarningsConfig:
    let default_policy: WarningPolicy

    let unused_imports: WarningPolicy
    let unused_variables: WarningPolicy
    let dead_code: WarningPolicy
    let deprecated: WarningPolicy
    let shadowing: WarningPolicy
    let unreachable_code: WarningPolicy

    let treat_warnings_as_errors: Bool
.end

pub fn warnings_config_default() -> WarningsConfig:
    let p = WarningPolicy::WarningWarn
    let p_allow = WarningPolicy::WarningAllow

    let cfg = WarningsConfig(
        default_policy = p,
        unused_imports = p,
        unused_variables = p,
        dead_code = p,
        deprecated = p,
        shadowing = p_allow,
        unreachable_code = p,
        treat_warnings_as_errors = false
    )
    return cfg
.end

# ----------------------------------------------------------------------------
# Debug / optimisation
# ----------------------------------------------------------------------------

pub enum LtoMode:
    LtoOff
    LtoThin
    LtoFull
.end

pub struct DebugConfig:
    let debug_info: Bool          # générer des symboles de débogage
    let debug_assertions: Bool    # garder les assertions debug
    let backtrace: Bool           # activer la collecte de backtraces
    let profile_instrumentation: Bool
.end

pub fn debug_config_default() -> DebugConfig:
    let cfg = DebugConfig(
        debug_info = true,
        debug_assertions = true,
        backtrace = false,
        profile_instrumentation = false
    )
    return cfg
.end

pub struct OptimizationConfig:
    let opt_level: backends.OptimizationLevel
    let lto: LtoMode
    let codegen_units: u32
    let incremental: Bool
.end

pub fn optimization_config_default() -> OptimizationConfig:
    let cfg = OptimizationConfig(
        opt_level = backends.OptimizationLevel::Opt0,
        lto = LtoMode::LtoOff,
        codegen_units = 1u32,
        incremental = false
    )
    return cfg
.end

# ----------------------------------------------------------------------------
# Frontend (parsing, borrowck, lints)
# ----------------------------------------------------------------------------

pub struct FrontendConfig:
    let edition: String                    # ex: "2025"
    let enable_borrowck: Bool
    let enable_flow_analysis: Bool
    let enable_lints: Bool

    let max_errors: u32
    let enable_color_spans: Bool

    let experimental_features: Vec<String>
.end

pub fn frontend_config_default() -> FrontendConfig:
    let feats = Vec<String>::new()
    let cfg = FrontendConfig(
        edition = "2025",
        enable_borrowck = true,
        enable_flow_analysis = true,
        enable_lints = true,
        max_errors = 50u32,
        enable_color_spans = true,
        experimental_features = feats
    )
    return cfg
.end

# ----------------------------------------------------------------------------
# Backend (cible + backend choisi)
# ----------------------------------------------------------------------------

pub struct BackendConfig:
    let backend_kind: backends.BackendKind
    let backend_options: backends.BackendOptions
.end

pub fn backend_config_default() -> BackendConfig:
    let opts = backends.backend_default_options()
    let cfg = BackendConfig(
        backend_kind = backends.BackendKind::BackendNull,
        backend_options = opts
    )
    return cfg
.end

# ----------------------------------------------------------------------------
# Projet / modules / manifets
# ----------------------------------------------------------------------------

pub struct ProjectConfig:
    let module_roots: Vec<String>       # racines logiques de modules
    let include_paths: Vec<String>      # chemins include (headers, etc.)
    let library_paths: Vec<String>      # chemins de libs natives
    let muffin_files: Vec<String>       # manifestes Muffin connus
.end

pub fn project_config_default() -> ProjectConfig:
    let roots = Vec<String>::new()
    let incs = Vec<String>::new()
    let libs = Vec<String>::new()
    let muffins = Vec<String>::new()

    let cfg = ProjectConfig(
        module_roots = roots,
        include_paths = incs,
        library_paths = libs,
        muffin_files = muffins
    )
    return cfg
.end

# ----------------------------------------------------------------------------
# Configuration principale du compilateur
# ----------------------------------------------------------------------------

pub struct CompilerConfig:
    let input_files: Vec<String>
    let input_kind: InputKind

    let output_format: OutputFormat
    let output_name: String

    let paths: PathConfig
    let warnings: WarningsConfig
    let debug: DebugConfig
    let optimization: OptimizationConfig
    let frontend: FrontendConfig
    let backend: BackendConfig
    let project: ProjectConfig

    let color: ColorMode
    let verbosity: Verbosity
.end

pub fn compiler_config_default() -> CompilerConfig:
    let files = Vec<String>::new()

    let paths = path_config_default()
    let warns = warnings_config_default()
    let debug_cfg = debug_config_default()
    let opt_cfg = optimization_config_default()
    let front_cfg = frontend_config_default()
    let back_cfg = backend_config_default()
    let proj_cfg = project_config_default()

    let cfg = CompilerConfig(
        input_files = files,
        input_kind = InputKind::InputSourceFiles,
        output_format = OutputFormat::OutputExecutable,
        output_name = "a.out",
        paths = paths,
        warnings = warns,
        debug = debug_cfg,
        optimization = opt_cfg,
        frontend = front_cfg,
        backend = back_cfg,
        project = proj_cfg,
        color = ColorMode::ColorAuto,
        verbosity = Verbosity::VerbosityNormal
    )
    return cfg
.end

# ----------------------------------------------------------------------------
# Helpers de construction (config de ligne de commande)
# ----------------------------------------------------------------------------

pub fn compiler_config_with_input_files(
    CompilerConfig base,
    Vec<String> files
) -> CompilerConfig:
    let cfg = CompilerConfig(
        input_files = files,
        input_kind = InputKind::InputSourceFiles,
        output_format = base.output_format,
        output_name = base.output_name,
        paths = base.paths,
        warnings = base.warnings,
        debug = base.debug,
        optimization = base.optimization,
        frontend = base.frontend,
        backend = base.backend,
        project = base.project,
        color = base.color,
        verbosity = base.verbosity
    )
    return cfg
.end

pub fn compiler_config_with_output_name(
    CompilerConfig base,
    String name
) -> CompilerConfig:
    let cfg = CompilerConfig(
        input_files = base.input_files,
        input_kind = base.input_kind,
        output_format = base.output_format,
        output_name = name,
        paths = base.paths,
        warnings = base.warnings,
        debug = base.debug,
        optimization = base.optimization,
        frontend = base.frontend,
        backend = base.backend,
        project = base.project,
        color = base.color,
        verbosity = base.verbosity
    )
    return cfg
.end

pub fn compiler_config_with_output_format(
    CompilerConfig base,
    OutputFormat fmt
) -> CompilerConfig:
    let cfg = CompilerConfig(
        input_files = base.input_files,
        input_kind = base.input_kind,
        output_format = fmt,
        output_name = base.output_name,
        paths = base.paths,
        warnings = base.warnings,
        debug = base.debug,
        optimization = base.optimization,
        frontend = base.frontend,
        backend = base.backend,
        project = base.project,
        color = base.color,
        verbosity = base.verbosity
    )
    return cfg
.end

pub fn compiler_config_with_paths(
    CompilerConfig base,
    PathConfig paths
) -> CompilerConfig:
    let cfg = CompilerConfig(
        input_files = base.input_files,
        input_kind = base.input_kind,
        output_format = base.output_format,
        output_name = base.output_name,
        paths = paths,
        warnings = base.warnings,
        debug = base.debug,
        optimization = base.optimization,
        frontend = base.frontend,
        backend = base.backend,
        project = base.project,
        color = base.color,
        verbosity = base.verbosity
    )
    return cfg
.end

pub fn compiler_config_with_backend(
    CompilerConfig base,
    BackendConfig backend
) -> CompilerConfig:
    let cfg = CompilerConfig(
        input_files = base.input_files,
        input_kind = base.input_kind,
        output_format = base.output_format,
        output_name = base.output_name,
        paths = base.paths,
        warnings = base.warnings,
        debug = base.debug,
        optimization = base.optimization,
        frontend = base.frontend,
        backend = backend,
        project = base.project,
        color = base.color,
        verbosity = base.verbosity
    )
    return cfg
.end

pub fn compiler_config_with_verbosity(
    CompilerConfig base,
    Verbosity v
) -> CompilerConfig:
    let cfg = CompilerConfig(
        input_files = base.input_files,
        input_kind = base.input_kind,
        output_format = base.output_format,
        output_name = base.output_name,
        paths = base.paths,
        warnings = base.warnings,
        debug = base.debug,
        optimization = base.optimization,
        frontend = base.frontend,
        backend = base.backend,
        project = base.project,
        color = base.color,
        verbosity = v
    )
    return cfg
.end

pub fn compiler_config_with_color(
    CompilerConfig base,
    ColorMode c
) -> CompilerConfig:
    let cfg = CompilerConfig(
        input_files = base.input_files,
        input_kind = base.input_kind,
        output_format = base.output_format,
        output_name = base.output_name,
        paths = base.paths,
        warnings = base.warnings,
        debug = base.debug,
        optimization = base.optimization,
        frontend = base.frontend,
        backend = base.backend,
        project = base.project,
        color = c,
        verbosity = base.verbosity
    )
    return cfg
.end

# ----------------------------------------------------------------------------
# Helpers de fusion de configuration
# ----------------------------------------------------------------------------

pub struct CompilerConfigLayer:
    let files: Vec<String>
    let override_output_name: coll.SmallMap<String, Bool>
    let override_paths: Bool
    let paths: PathConfig
.end

pub fn compiler_config_layer_empty() -> CompilerConfigLayer:
    let files = Vec<String>::new()
    let m = coll.small_map_new<String, Bool>()
    let paths = path_config_default()
    let layer = CompilerConfigLayer(
        files = files,
        override_output_name = m,
        override_paths = false,
        paths = paths
    )
    return layer
.end

pub fn compiler_config_layer_with_file(
    CompilerConfigLayer layer,
    String file
) -> CompilerConfigLayer:
    let v = layer.files
    v.push(file)
    let new_layer = CompilerConfigLayer(
        files = v,
        override_output_name = layer.override_output_name,
        override_paths = layer.override_paths,
        paths = layer.paths
    )
    return new_layer
.end

pub fn compiler_config_merge_layer(
    CompilerConfig base,
    CompilerConfigLayer layer
) -> CompilerConfig:
    let files = if coll.vec_is_empty<String>(layer.files):
        base.input_files
    else:
        layer.files
    .end

    let paths = if layer.override_paths:
        layer.paths
    else:
        base.paths
    .end

    let cfg = CompilerConfig(
        input_files = files,
        input_kind = base.input_kind,
        output_format = base.output_format,
        output_name = base.output_name,
        paths = paths,
        warnings = base.warnings,
        debug = base.debug,
        optimization = base.optimization,
        frontend = base.frontend,
        backend = base.backend,
        project = base.project,
        color = base.color,
        verbosity = base.verbosity
    )
    return cfg
.end

# ----------------------------------------------------------------------------
# Notes
# ----------------------------------------------------------------------------
# - Ce module ne gère pas (volontairement) le parsing de fichiers de config.
#   C'est la responsabilité d'une couche plus haute (CLI, Muffin, etc.).
# - L'API est assez stable pour être utilisée par la pipeline front-end,
#   les backends, ou un serveur LSP.
# - CompilerConfigLayer montre comment tu peux empiler des surcharges sans
#   introduire de logique trop complexe ici; d'autres champs peuvent être
#   ajoutés au besoin.
# ----------------------------------------------------------------------------