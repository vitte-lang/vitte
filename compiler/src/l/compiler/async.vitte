module vitte.compiler.async

import vitte.compiler.diagnostics as diag

# ============================================================================
# Vitte compiler – Async utilities ultra complets
#
# Objectifs :
#   - Fournir une abstraction d'exécution asynchrone coopérative pour le
#     compilateur Vitte (et, à terme, la stdlib du langage).
#   - Gérer :
#       * identifiants de tâches (AsyncTaskId),
#       * états de tâches (Pending / Running / Completed / Failed / Cancelled),
#       * résultats typés avec erreurs (AsyncResult<T>),
#       * file de tâches (AsyncQueue<T>),
#       * opérations de base : spawn, cancel, complete, fail, poll.
#   - API purement fonctionnelle (à la Vitte) : les structures sont passées et
#     renvoyées, sans mutabilité implicite.
#
# Remarques importantes :
#   - Aucune gestion de threads ni de parallélisme réel ici : il s'agit d'un
#     modèle coopératif et portable. Les runtimes futurs pourront le mapper sur
#     des primitives système si nécessaire.
#   - Ce module est écrit pour être indépendant de la plateforme et ne dépend
#     que de types de base (String, Bool, u64, Vec, Option) et de Diagnostics.
# ============================================================================

# ----------------------------------------------------------------------------
# Types de base pour l'async
# ----------------------------------------------------------------------------

pub typedef u64 AsyncTaskId

pub enum AsyncTaskState:
    AsyncPending
    AsyncRunning
    AsyncCompleted
    AsyncFailed
    AsyncCancelled
.end

pub struct AsyncError:
    let message: String
.end

pub struct AsyncResult<T>:
    let is_done: Bool
    let value: Option<T>
    let error: Option<AsyncError>
.end

pub fn async_result_ok<T>(T v) -> AsyncResult<T>:
    let some_v: Option<T> = Option<T>::Some(v)
    let none_err: Option<AsyncError> = Option<AsyncError>::None()
    let res = AsyncResult<T>(
        is_done = true,
        value = some_v,
        error = none_err
    )
    return res
.end

pub fn async_result_err<T>(String msg) -> AsyncResult<T>:
    let err = AsyncError(message = msg)
    let none_v: Option<T> = Option<T>::None()
    let some_err: Option<AsyncError> = Option<AsyncError>::Some(err)
    let res = AsyncResult<T>(
        is_done = true,
        value = none_v,
        error = some_err
    )
    return res
.end

pub fn async_result_pending<T>() -> AsyncResult<T>:
    let none_v: Option<T> = Option<T>::None()
    let none_err: Option<AsyncError> = Option<AsyncError>::None()
    let res = AsyncResult<T>(
        is_done = false,
        value = none_v,
        error = none_err
    )
    return res
.end

# ----------------------------------------------------------------------------
# Tâche asynchrone et file de tâches
# ----------------------------------------------------------------------------

pub struct AsyncTask<T>:
    let id: AsyncTaskId
    let name: String
    let state: AsyncTaskState
    let result: AsyncResult<T>
.end

pub struct AsyncQueue<T>:
    let next_id: AsyncTaskId
    let tasks: Vec<AsyncTask<T>>
.end

pub fn async_queue_new<T>() -> AsyncQueue<T>:
    let empty_tasks = Vec<AsyncTask<T>>::new()
    let q = AsyncQueue<T>(
        next_id = 1u64,
        tasks = empty_tasks
    )
    return q
.end

# ----------------------------------------------------------------------------
# Recherche de tâches dans la file
# ----------------------------------------------------------------------------

fn async_queue_find_index<T>(AsyncQueue<T> q, AsyncTaskId id) -> Option<usize>:
    let i = 0usize
    let len = q.tasks.len()

    while i < len:
        let t = q.tasks[i]
        if t.id == id:
            let some_i: Option<usize> = Option<usize>::Some(i)
            return some_i
        .end
        i = i + 1usize
    .end

    let none_i: Option<usize> = Option<usize>::None()
    return none_i
.end

fn async_queue_get_task<T>(AsyncQueue<T> q, AsyncTaskId id) -> Option<AsyncTask<T>>:
    let maybe_idx = async_queue_find_index<T>(q, id)
    if not maybe_idx.is_some():
        let none_t: Option<AsyncTask<T>> = Option<AsyncTask<T>>::None()
        return none_t
    .end

    let idx = maybe_idx.unwrap()
    let t = q.tasks[idx]
    let some_t: Option<AsyncTask<T>> = Option<AsyncTask<T>>::Some(t)
    return some_t
.end

# ----------------------------------------------------------------------------
# Création de tâches
# ----------------------------------------------------------------------------

pub fn async_spawn<T>(AsyncQueue<T> q, String name) -> (AsyncQueue<T>, AsyncTask<T>):
    let id = q.next_id

    let init_result = async_result_pending<T>()
    let task = AsyncTask<T>(
        id = id,
        name = name,
        state = AsyncTaskState::AsyncPending,
        result = init_result
    )

    let new_tasks = q.tasks
    new_tasks.push(task)

    let new_queue = AsyncQueue<T>(
        next_id = id + 1u64,
        tasks = new_tasks
    )

    return (new_queue, task)
.end

# ----------------------------------------------------------------------------
# Mise à jour d'une tâche dans la file
# ----------------------------------------------------------------------------

fn async_queue_update_task<T>(AsyncQueue<T> q, AsyncTask<T> updated) -> AsyncQueue<T>:
    let new_tasks = q.tasks
    let len = new_tasks.len()
    let i = 0usize

    while i < len:
        let t = new_tasks[i]
        if t.id == updated.id:
            new_tasks[i] = updated
        .end
        i = i + 1usize
    .end

    let new_q = AsyncQueue<T>(
        next_id = q.next_id,
        tasks = new_tasks
    )
    return new_q
.end

pub fn async_mark_running<T>(AsyncQueue<T> q, AsyncTaskId id) -> AsyncQueue<T>:
    let maybe_t = async_queue_get_task<T>(q, id)
    if not maybe_t.is_some():
        return q
    .end

    let t = maybe_t.unwrap()
    let new_t = AsyncTask<T>(
        id = t.id,
        name = t.name,
        state = AsyncTaskState::AsyncRunning,
        result = t.result
    )

    let new_q = async_queue_update_task<T>(q, new_t)
    return new_q
.end

pub fn async_mark_completed<T>(AsyncQueue<T> q, AsyncTaskId id, T value) -> AsyncQueue<T>:
    let maybe_t = async_queue_get_task<T>(q, id)
    if not maybe_t.is_some():
        return q
    .end

    let t = maybe_t.unwrap()
    let res = async_result_ok<T>(value)

    let new_t = AsyncTask<T>(
        id = t.id,
        name = t.name,
        state = AsyncTaskState::AsyncCompleted,
        result = res
    )

    let new_q = async_queue_update_task<T>(q, new_t)
    return new_q
.end

pub fn async_mark_failed<T>(AsyncQueue<T> q, AsyncTaskId id, String msg) -> AsyncQueue<T>:
    let maybe_t = async_queue_get_task<T>(q, id)
    if not maybe_t.is_some():
        return q
    .end

    let t = maybe_t.unwrap()
    let res = async_result_err<T>(msg)

    let new_t = AsyncTask<T>(
        id = t.id,
        name = t.name,
        state = AsyncTaskState::AsyncFailed,
        result = res
    )

    let new_q = async_queue_update_task<T>(q, new_t)
    return new_q
.end

pub fn async_cancel<T>(AsyncQueue<T> q, AsyncTaskId id) -> AsyncQueue<T>:
    let maybe_t = async_queue_get_task<T>(q, id)
    if not maybe_t.is_some():
        return q
    .end

    let t = maybe_t.unwrap()
    let res = async_result_pending<T>()

    let new_t = AsyncTask<T>(
        id = t.id,
        name = t.name,
        state = AsyncTaskState::AsyncCancelled,
        result = res
    )

    let new_q = async_queue_update_task<T>(q, new_t)
    return new_q
.end

# ----------------------------------------------------------------------------
# Observation / polling
# ----------------------------------------------------------------------------

pub fn async_poll<T>(AsyncQueue<T> q, AsyncTaskId id) -> AsyncResult<T>:
    let maybe_t = async_queue_get_task<T>(q, id)
    if not maybe_t.is_some():
        # Tâche inconnue : on renvoie un résultat d'erreur.
        let msg = "unknown async task id"
        let res = async_result_err<T>(msg)
        return res
    .end

    let t = maybe_t.unwrap()
    return t.result
.end

pub fn async_is_done<T>(AsyncQueue<T> q, AsyncTaskId id) -> Bool:
    let res = async_poll<T>(q, id)
    return res.is_done
.end

pub fn async_is_ok<T>(AsyncQueue<T> q, AsyncTaskId id) -> Bool:
    let res = async_poll<T>(q, id)
    if not res.is_done:
        return false
    .end
    if not res.error.is_some():
        return true
    .end
    return false
.end

pub fn async_error_message<T>(AsyncQueue<T> q, AsyncTaskId id) -> Option<String>:
    let res = async_poll<T>(q, id)
    if not res.error.is_some():
        let none_s: Option<String> = Option<String>::None()
        return none_s
    .end

    let e = res.error.unwrap()
    let some_s: Option<String> = Option<String>::Some(e.message)
    return some_s
.end

# ----------------------------------------------------------------------------
# Intégration minimale avec Diagnostics
# ----------------------------------------------------------------------------

pub fn async_report_failed_task<T>(AsyncQueue<T> q, AsyncTaskId id, diag.DiagnosticsSink sink) -> diag.DiagnosticsSink:
    let maybe_t = async_queue_get_task<T>(q, id)
    if not maybe_t.is_some():
        return sink
    .end

    let t = maybe_t.unwrap()
    if t.state != AsyncTaskState::AsyncFailed:
        return sink
    .end

    if not t.result.error.is_some():
        return sink
    .end

    let err = t.result.error.unwrap()

    # On crée un diagnostic générique sans span précis (à adapter selon
    # l'appelant : on peut lui fournir un Span approximatif si besoin).
    let diag_msg = "async task '" + t.name + "' failed: " + err.message
    let dummy_span = diag.make_dummy_span()
    let d = diag.make_async_error(diag_msg, dummy_span)
    sink.push(d)
    return sink
.end

# ----------------------------------------------------------------------------
# Helpers de composition (join simple)
# ----------------------------------------------------------------------------

pub fn async_all_done<T>(AsyncQueue<T> q) -> Bool:
    let len = q.tasks.len()
    let i = 0usize

    while i < len:
        let t = q.tasks[i]
        if t.state == AsyncTaskState::AsyncPending or
           t.state == AsyncTaskState::AsyncRunning:
            return false
        .end
        i = i + 1usize
    .end

    return true
.end

pub fn async_any_failed<T>(AsyncQueue<T> q) -> Bool:
    let len = q.tasks.len()
    let i = 0usize

    while i < len:
        let t = q.tasks[i]
        if t.state == AsyncTaskState::AsyncFailed:
            return true
        .end
        i = i + 1usize
    .end

    return false
.end

pub fn async_task_state<T>(AsyncQueue<T> q, AsyncTaskId id) -> Option<AsyncTaskState>:
    let maybe_t = async_queue_get_task<T>(q, id)
    if not maybe_t.is_some():
        let none_state: Option<AsyncTaskState> = Option<AsyncTaskState>::None()
        return none_state
    .end

    let t = maybe_t.unwrap()
    let some_state: Option<AsyncTaskState> = Option<AsyncTaskState>::Some(t.state)
    return some_state
.end

pub struct AsyncTaskSnapshot<T>:
    let id: AsyncTaskId
    let name: String
    let state: AsyncTaskState
    let is_done: Bool
.end

pub fn async_snapshot_all<T>(AsyncQueue<T> q) -> Vec<AsyncTaskSnapshot<T>>:
    let snaps = Vec<AsyncTaskSnapshot<T>>::new()
    let len = q.tasks.len()
    let i = 0usize

    while i < len:
        let t = q.tasks[i]
        let snap = AsyncTaskSnapshot<T>(
            id = t.id,
            name = t.name,
            state = t.state,
            is_done = t.result.is_done
        )
        snaps.push(snap)
        i = i + 1usize
    .end

    return snaps
.end

pub fn async_ids_with_state<T>(AsyncQueue<T> q, AsyncTaskState state) -> Vec<AsyncTaskId>:
    let ids = Vec<AsyncTaskId>::new()
    let len = q.tasks.len()
    let i = 0usize

    while i < len:
        let t = q.tasks[i]
        if t.state == state:
            ids.push(t.id)
        .end
        i = i + 1usize
    .end

    return ids
.end

pub fn async_clear_completed<T>(AsyncQueue<T> q) -> AsyncQueue<T>:
    let kept = Vec<AsyncTask<T>>::new()
    let len = q.tasks.len()
    let i = 0usize

    while i < len:
        let t = q.tasks[i]
        if t.state != AsyncTaskState::AsyncCompleted and
           t.state != AsyncTaskState::AsyncCancelled:
            kept.push(t)
        .end
        i = i + 1usize
    .end

    let new_q = AsyncQueue<T>(
        next_id = q.next_id,
        tasks = kept
    )
    return new_q
.end

pub fn async_report_all_failed<T>(AsyncQueue<T> q, diag.DiagnosticsSink sink) -> diag.DiagnosticsSink:
    let ds = sink
    let len = q.tasks.len()
    let i = 0usize

    while i < len:
        let t = q.tasks[i]
        if t.state == AsyncTaskState::AsyncFailed:
            ds = async_report_failed_task<T>(q, t.id, ds)
        .end
        i = i + 1usize
    .end

    return ds
.end

# ----------------------------------------------------------------------------
# Notes
# ----------------------------------------------------------------------------
# - Ce module fournit un modèle d'async coopératif minimal mais complet.
# - L'intégration avec un vrai scheduler OS ou un runtime de tâches pourra se
#   faire en mappant AsyncTaskId sur des handles système.
# - Du point de vue du compilateur, ce modèle permet déjà de décrire des
#   passes potentiellement parallélisables (par ex. lecture de fichiers,
#   parsing de modules) sans s'engager sur un backend de threads.
# ----------------------------------------------------------------------------