module vitte.compiler.scope

import std.collections as coll
import vitte.compiler.diagnostics as diag

# ============================================================================
# Vitte compiler – Scope & symbol table core (maximal, déclaratif, sans I/O)
#
# Objectifs :
#   - Fournir une représentation purement logique des scopes lexicaux Vitte :
#       * scopes imbriqués (root, module, fichier, fonction, bloc, type, générique),
#       * symboles (variables, constantes, fonctions, types, modules, paramètres),
#       * visibilité (pub / privé / module),
#       * résolution lexicale ascendante (shadowing correct).
#   - Ne dépendre d’aucun backend ni runtime :
#       * les structures servent au front-end / HIR / analyse sémantique,
#       * aucun accès disque, aucun appel système, aucun I/O.
#   - Rester simple à sérialiser (JSON / Muffin / autres).
# ============================================================================

# ----------------------------------------------------------------------------
# Kinds et visibilité
# ----------------------------------------------------------------------------

pub enum ScopeKind:
    ScopeKindRoot
    ScopeKindFile
    ScopeKindModule
    ScopeKindFunction
    ScopeKindBlock
    ScopeKindType
    ScopeKindGeneric
.end

pub enum SymbolKind:
    SymbolKindVariable
    SymbolKindConstant
    SymbolKindFunction
    SymbolKindType
    SymbolKindModule
    SymbolKindParameter
    SymbolKindField
    SymbolKindGeneric
.end

pub enum SymbolVisibility:
    SymbolVisibilityPublic
    SymbolVisibilityPrivate
    SymbolVisibilityModule       # visible dans le module, pas exporté
.end

# ----------------------------------------------------------------------------
# Symboles et scopes
# ----------------------------------------------------------------------------

pub struct Symbol:
    let id: u32
    let name: String
    let kind: SymbolKind
    let visibility: SymbolVisibility
    let is_mutable: Bool
    let defined_in: u32          # scope id
    let span: diag.Span
    let type_name: String        # représentation textuelle (optionnelle)
.end

pub struct Scope:
    let id: u32
    let parent: coll.Option<u32> # None pour root
    let kind: ScopeKind
    let name: String
    let is_closure_boundary: Bool
.end

# Table globale : tous les scopes + tous les symboles
pub struct ScopeTree:
    let scopes: Vec<Scope>
    let symbols: Vec<Symbol>
    let root_scope: u32
.end

# ----------------------------------------------------------------------------
# Helpers de conversion vers String
# ----------------------------------------------------------------------------

pub fn scope_kind_to_string(ScopeKind k) -> String:
    if k == ScopeKind::ScopeKindRoot:
        return "root"
    .end
    if k == ScopeKind::ScopeKindFile:
        return "file"
    .end
    if k == ScopeKind::ScopeKindModule:
        return "module"
    .end
    if k == ScopeKind::ScopeKindFunction:
        return "function"
    .end
    if k == ScopeKind::ScopeKindBlock:
        return "block"
    .end
    if k == ScopeKind::ScopeKindType:
        return "type"
    .end
    if k == ScopeKind::ScopeKindGeneric:
        return "generic"
    .end
    return "unknown"
.end

pub fn symbol_kind_to_string(SymbolKind k) -> String:
    if k == SymbolKind::SymbolKindVariable:
        return "var"
    .end
    if k == SymbolKind::SymbolKindConstant:
        return "const"
    .end
    if k == SymbolKind::SymbolKindFunction:
        return "fn"
    .end
    if k == SymbolKind::SymbolKindType:
        return "type"
    .end
    if k == SymbolKind::SymbolKindModule:
        return "module"
    .end
    if k == SymbolKind::SymbolKindParameter:
        return "param"
    .end
    if k == SymbolKind::SymbolKindField:
        return "field"
    .end
    if k == SymbolKind::SymbolKindGeneric:
        return "generic"
    .end
    return "unknown"
.end

pub fn symbol_visibility_to_string(SymbolVisibility v) -> String:
    if v == SymbolVisibility::SymbolVisibilityPublic:
        return "pub"
    .end
    if v == SymbolVisibility::SymbolVisibilityPrivate:
        return "priv"
    .end
    if v == SymbolVisibility::SymbolVisibilityModule:
        return "mod"
    .end
    return "unknown"
.end

# ----------------------------------------------------------------------------
# Construction de la table de scopes
# ----------------------------------------------------------------------------

pub fn scope_tree_new() -> ScopeTree:
    let scopes: Vec<Scope> = Vec<Scope>::new()
    let symbols: Vec<Symbol> = Vec<Symbol>::new()

    let parent_none = coll.option_none<u32>()
    let root = Scope(
        id = 0u32,
        parent = parent_none,
        kind = ScopeKind::ScopeKindRoot,
        name = "root",
        is_closure_boundary = false
    )
    scopes.push(root)

    let tree = ScopeTree(
        scopes = scopes,
        symbols = symbols,
        root_scope = 0u32
    )
    return tree
.end

pub fn scope_tree_root(ScopeTree tree) -> u32:
    return tree.root_scope
.end

pub fn scope_tree_scope_count(ScopeTree tree) -> u32:
    let n = tree.scopes.len()
    return n as u32
.end

pub fn scope_tree_symbol_count(ScopeTree tree) -> u32:
    let n = tree.symbols.len()
    return n as u32
.end

# ----------------------------------------------------------------------------
# Accès direct aux scopes / symboles
# ----------------------------------------------------------------------------

pub fn scope_tree_get_scope(ScopeTree tree, u32 scope_id) -> Scope:
    let idx = scope_id as usize
    let sc = tree.scopes[idx]
    return sc
.end

pub fn scope_tree_get_symbol(ScopeTree tree, u32 symbol_id) -> Symbol:
    let idx = symbol_id as usize
    let s = tree.symbols[idx]
    return s
.end

# ----------------------------------------------------------------------------
# Création de scopes
# ----------------------------------------------------------------------------

pub fn scope_tree_add_child_scope(
    ScopeTree tree,
    u32 parent_id,
    ScopeKind kind,
    String name,
    Bool is_closure_boundary
) -> (ScopeTree, u32):
    let scopes = tree.scopes
    let symbols = tree.symbols
    let root = tree.root_scope

    let new_id_u32 = scopes.len() as u32
    let parent_opt = coll.option_some<u32>(parent_id)

    let sc = Scope(
        id = new_id_u32,
        parent = parent_opt,
        kind = kind,
        name = name,
        is_closure_boundary = is_closure_boundary
    )

    scopes.push(sc)

    let tree2 = ScopeTree(
        scopes = scopes,
        symbols = symbols,
        root_scope = root
    )

    let out = (tree2, new_id_u32)
    return out
.end

pub fn scope_tree_add_child_block_scope(
    ScopeTree tree,
    u32 parent_id,
    String name
) -> (ScopeTree, u32):
    let res = scope_tree_add_child_scope(
        tree,
        parent_id,
        ScopeKind::ScopeKindBlock,
        name,
        false
    )
    return res
.end

pub fn scope_tree_add_child_function_scope(
    ScopeTree tree,
    u32 parent_id,
    String name,
    Bool is_closure_boundary
) -> (ScopeTree, u32):
    let res = scope_tree_add_child_scope(
        tree,
        parent_id,
        ScopeKind::ScopeKindFunction,
        name,
        is_closure_boundary
    )
    return res
.end

pub fn scope_tree_add_child_module_scope(
    ScopeTree tree,
    u32 parent_id,
    String name
) -> (ScopeTree, u32):
    let res = scope_tree_add_child_scope(
        tree,
        parent_id,
        ScopeKind::ScopeKindModule,
        name,
        false
    )
    return res
.end

# ----------------------------------------------------------------------------
# Création de symboles
# ----------------------------------------------------------------------------

fn scope_tree_next_symbol_id(ScopeTree tree) -> u32:
    let n = tree.symbols.len()
    return n as u32
.end

pub fn scope_tree_add_symbol(
    ScopeTree tree,
    u32 scope_id,
    String name,
    SymbolKind kind,
    SymbolVisibility visibility,
    Bool is_mutable,
    diag.Span span,
    String type_name
) -> (ScopeTree, u32):
    let scopes = tree.scopes
    let symbols = tree.symbols
    let root = tree.root_scope

    let new_id_u32 = scope_tree_next_symbol_id(tree)

    let sym = Symbol(
        id = new_id_u32,
        name = name,
        kind = kind,
        visibility = visibility,
        is_mutable = is_mutable,
        defined_in = scope_id,
        span = span,
        type_name = type_name
    )

    symbols.push(sym)

    let tree2 = ScopeTree(
        scopes = scopes,
        symbols = symbols,
        root_scope = root
    )

    let out = (tree2, new_id_u32)
    return out
.end

pub fn scope_tree_add_var(
    ScopeTree tree,
    u32 scope_id,
    String name,
    Bool is_mutable,
    SymbolVisibility visibility,
    diag.Span span,
    String type_name
) -> (ScopeTree, u32):
    let res = scope_tree_add_symbol(
        tree,
        scope_id,
        name,
        SymbolKind::SymbolKindVariable,
        visibility,
        is_mutable,
        span,
        type_name
    )
    return res
.end

pub fn scope_tree_add_const(
    ScopeTree tree,
    u32 scope_id,
    String name,
    SymbolVisibility visibility,
    diag.Span span,
    String type_name
) -> (ScopeTree, u32):
    let res = scope_tree_add_symbol(
        tree,
        scope_id,
        name,
        SymbolKind::SymbolKindConstant,
        visibility,
        false,
        span,
        type_name
    )
    return res
.end

pub fn scope_tree_add_function(
    ScopeTree tree,
    u32 scope_id,
    String name,
    SymbolVisibility visibility,
    diag.Span span
) -> (ScopeTree, u32):
    let res = scope_tree_add_symbol(
        tree,
        scope_id,
        name,
        SymbolKind::SymbolKindFunction,
        visibility,
        false,
        span,
        ""
    )
    return res
.end

pub fn scope_tree_add_type(
    ScopeTree tree,
    u32 scope_id,
    String name,
    SymbolVisibility visibility,
    diag.Span span
) -> (ScopeTree, u32):
    let res = scope_tree_add_symbol(
        tree,
        scope_id,
        name,
        SymbolKind::SymbolKindType,
        visibility,
        false,
        span,
        ""
    )
    return res
.end

pub fn scope_tree_add_param(
    ScopeTree tree,
    u32 scope_id,
    String name,
    Bool is_mutable,
    diag.Span span,
    String type_name
) -> (ScopeTree, u32):
    let res = scope_tree_add_symbol(
        tree,
        scope_id,
        name,
        SymbolKind::SymbolKindParameter,
        SymbolVisibility::SymbolVisibilityPrivate,
        is_mutable,
        span,
        type_name
    )
    return res
.end

# ----------------------------------------------------------------------------
# Résolution dans un scope et résolution lexicale
# ----------------------------------------------------------------------------

pub fn scope_tree_resolve_in_scope(
    ScopeTree tree,
    u32 scope_id,
    String name
) -> coll.Option<u32>:
    let syms = tree.symbols
    let n = syms.len()
    let i = 0usize

    while i < n:
        let s = syms[i]
        if s.defined_in == scope_id and s.name == name:
            let some_id = coll.option_some<u32>(s.id)
            return some_id
        .end
        let i = i + 1usize
    .end

    let none_id = coll.option_none<u32>()
    return none_id
.end

pub fn scope_tree_symbols_in_scope(
    ScopeTree tree,
    u32 scope_id
) -> Vec<u32>:
    let syms = tree.symbols
    let n = syms.len()
    let i = 0usize
    let out: Vec<u32> = Vec<u32>::new()

    while i < n:
        let s = syms[i]
        if s.defined_in == scope_id:
            out.push(s.id)
        .end
        let i = i + 1usize
    .end

    return out
.end

pub fn scope_tree_children_of(
    ScopeTree tree,
    u32 parent_id
) -> Vec<u32>:
    let scopes = tree.scopes
    let n = scopes.len()
    let i = 0usize
    let out: Vec<u32> = Vec<u32>::new()

    while i < n:
        let sc = scopes[i]
        let p = sc.parent
        if coll.option_is_some<u32>(p):
            let pid = coll.option_unwrap_unsafe<u32>(p)
            if pid == parent_id:
                out.push(sc.id)
            .end
        .end
        let i = i + 1usize
    .end

    return out
.end

pub fn scope_tree_resolve_lexical(
    ScopeTree tree,
    u32 start_scope_id,
    String name
) -> coll.Option<u32>:
    let mut_current = coll.option_some<u32>(start_scope_id)

    while coll.option_is_some<u32>(mut_current):
        let current_id = coll.option_unwrap_unsafe<u32>(mut_current)

        # 1) chercher dans le scope courant
        let found = scope_tree_resolve_in_scope(tree, current_id, name)
        if coll.option_is_some<u32>(found):
            return found
        .end

        # 2) remonter vers le parent
        let sc = scope_tree_get_scope(tree, current_id)
        let parent_opt = sc.parent
        if coll.option_is_none<u32>(parent_opt):
            let none_id = coll.option_none<u32>()
            return none_id
        .end

        let mut_current = parent_opt
    .end

    let none2 = coll.option_none<u32>()
    return none2
.end

# ----------------------------------------------------------------------------
# Helpers de debug : chemin complet d’un scope ou symbole
# ----------------------------------------------------------------------------

pub fn scope_tree_scope_path(
    ScopeTree tree,
    u32 scope_id
) -> String:
    let parts: Vec<String> = Vec<String>::new()

    let current_opt = coll.option_some<u32>(scope_id)

    while coll.option_is_some<u32>(current_opt):
        let sid = coll.option_unwrap_unsafe<u32>(current_opt)
        let sc = scope_tree_get_scope(tree, sid)

        # On insère en tête : on reconstruira plus tard par concat.
        let label = sc.name
        parts.push(label)

        let parent = sc.parent
        if coll.option_is_none<u32>(parent):
            let break_opt = coll.option_none<u32>()
            let current_opt = break_opt
        else:
            let current_opt = parent
        .end
    .end

    # Reconstruction naïve "root::module::inner"
    let n = parts.len()
    if n == 0usize:
        return ""
    .end

    let i = n
    let out = ""
    # on reconstruit à l’envers
    while i > 0usize:
        let j = i - 1usize
        let p = parts[j]
        if out == "":
            let out = p
        else:
            let out = out + "::" + p
        .end
        let i = j
    .end

    return out
.end

pub fn scope_tree_symbol_qualified_name(
    ScopeTree tree,
    u32 symbol_id
) -> String:
    let s = scope_tree_get_symbol(tree, symbol_id)
    let sc = scope_tree_get_scope(tree, s.defined_in)
    let path = scope_tree_scope_path(tree, sc.id)
    if path == "":
        return s.name
    .end

    let full = path + "::" + s.name
    return full
.end

# ----------------------------------------------------------------------------
# Notes
# ----------------------------------------------------------------------------
# - Les IDs (u32) de scope / symbole correspondent à l’index dans leurs
#   vecteurs respectifs (scopes / symbols). Les fonctions utilitaires
#   construisent toujours les éléments en fin de vecteur.
# - Les fonctions *_add_* prennent un ScopeTree par valeur et renvoient
#   une nouvelle valeur (pattern immuable, mais facile à optimiser
#   par le compilateur / runtime).
# - La résolution lexicale `scope_tree_resolve_lexical` remonte uniquement
#   la chaîne parentale. La gestion des imports / modules externes /
#   namespaces avancés peut être ajoutée dans d’autres unités (ex: un
#   "resolver" séparé) en s’appuyant sur ces primitives.
# ============================================================================
