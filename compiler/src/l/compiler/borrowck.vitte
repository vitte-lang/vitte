module vitte.compiler.borrowck

import vitte.compiler.diagnostics as diag
import vitte.compiler.ast as ast

# ============================================================================
# Vitte compiler – Emprunts / Borrow Checker (ultra complet, modèle simplifié)
#
# Objectifs :
#   - Offrir un modèle d'analyse d'emprunts inspiré de Rust, mais adapté à
#     Vitte et à un IR plus simple.
#   - Gérer :
#       * les places (BorrowPlace / BorrowKey) ;
#       * les types d'emprunts (immutable, mutable, move) ;
#       * les événements d'emprunt (BorrowEvent) ;
#       * l'état des emprunts (BorrowState) ;
#       * la production d'erreurs de borrow-checking.
#   - API indépendante du détail du IR : un module séparé pourra mapper un
#     IR concret vers une séquence de BorrowEvent.
# ============================================================================

# ----------------------------------------------------------------------------
# Types de base
# ----------------------------------------------------------------------------

# Un BorrowKey est une représentation textuelle d'une "place" (variable,
# champ, index...), par ex. "x", "x.field", "arr[0]", etc.

pub typedef String BorrowKey

pub enum BorrowKind:
    BorrowImmutable    # &T  / partageable
    BorrowMutable      # &mut T / exclusif
    BorrowMove         # move (transfert de propriété)
.end

pub enum BorrowEventKind:
    EventBorrow        # création d'un emprunt
    EventUse           # utilisation (lecture ou écriture)
    EventMove          # move de la valeur
    EventDrop          # destruction / fin de vie
    EventReborrow      # emprunt à partir d'un emprunt existant
.end

pub enum BorrowUseKind:
    UseRead
    UseWrite
.end

pub struct BorrowEvent:
    let kind: BorrowEventKind
    let place: BorrowKey
    let borrow_kind: BorrowKind     # pertinent pour EventBorrow / EventReborrow
    let use_kind: BorrowUseKind     # pertinent pour EventUse
    let span: ast.Span
.end

# ----------------------------------------------------------------------------
# Erreurs de borrow-checking
# ----------------------------------------------------------------------------

pub enum BorrowErrorKind:
    BorrowErrorAliasMut
    BorrowErrorMutWhileBorrowed
    BorrowErrorUseAfterMove
    BorrowErrorDoubleMove
    BorrowErrorInvalidReborrow
    BorrowErrorUnknownPlace
.end

pub struct BorrowError:
    let kind: BorrowErrorKind
    let message: String
    let span: ast.Span
    let place: BorrowKey
.end

fn borrow_error_message(BorrowErrorKind k, BorrowKey place) -> String:
    if k == BorrowErrorKind::BorrowErrorAliasMut:
        return "cannot alias mutable borrow on place '" + place + "'"
    .end
    if k == BorrowErrorKind::BorrowErrorMutWhileBorrowed:
        return "place '" + place + "' is already borrowed"
    .end
    if k == BorrowErrorKind::BorrowErrorUseAfterMove:
        return "use after move of place '" + place + "'"
    .end
    if k == BorrowErrorKind::BorrowErrorDoubleMove:
        return "value of place '" + place + "' has already been moved"
    .end
    if k == BorrowErrorKind::BorrowErrorInvalidReborrow:
        return "invalid reborrow from place '" + place + "'"
    .end
    if k == BorrowErrorKind::BorrowErrorUnknownPlace:
        return "borrow-check on unknown place '" + place + "'"
    .end

    return "borrow error on place '" + place + "'"
.end

fn make_borrow_error(BorrowErrorKind kind, BorrowKey place, ast.Span span) -> BorrowError:
    let msg = borrow_error_message(kind, place)
    let err = BorrowError(
        kind = kind,
        message = msg,
        span = span,
        place = place
    )
    return err
.end

# ----------------------------------------------------------------------------
# État d'emprunt : entrées et base
# ----------------------------------------------------------------------------

pub struct BorrowEntry:
    let place: BorrowKey
    let kind: BorrowKind
    let active: Bool
    let moved: Bool
.end

pub struct BorrowState:
    let entries: Vec<BorrowEntry>
.end

pub fn borrow_state_new() -> BorrowState:
    let v = Vec<BorrowEntry>::new()
    let st = BorrowState(entries = v)
    return st
.end

fn borrow_state_find_index(BorrowState st, BorrowKey place) -> Option<usize>:
    let len = st.entries.len()
    let i = 0usize

    while i < len:
        let e = st.entries[i]
        if e.place == place:
            let some_i: Option<usize> = Option<usize>::Some(i)
            return some_i
        .end
        i = i + 1usize
    .end

    let none_i: Option<usize> = Option<usize>::None()
    return none_i
.end

fn borrow_state_get_entry(BorrowState st, BorrowKey place) -> Option<BorrowEntry>:
    let maybe_idx = borrow_state_find_index(st, place)
    if not maybe_idx.is_some():
        let none_e: Option<BorrowEntry> = Option<BorrowEntry>::None()
        return none_e
    .end

    let idx = maybe_idx.unwrap()
    let e = st.entries[idx]
    let some_e: Option<BorrowEntry> = Option<BorrowEntry>::Some(e)
    return some_e
.end

fn borrow_state_set_entry(BorrowState st, BorrowEntry entry) -> BorrowState:
    let v = st.entries
    let len = v.len()
    let maybe_idx = borrow_state_find_index(st, entry.place)

    if maybe_idx.is_some():
        let idx = maybe_idx.unwrap()
        v[idx] = entry
    .end

    if not maybe_idx.is_some():
        v.push(entry)
    .end

    let st2 = BorrowState(entries = v)
    return st2
.end

# ----------------------------------------------------------------------------
# Règles d'emprunt (noyau)
# ----------------------------------------------------------------------------

fn borrow_state_check_borrow(
    BorrowState st,
    BorrowKey place,
    BorrowKind kind
) -> Option<BorrowErrorKind>:
    let maybe_e = borrow_state_get_entry(st, place)
    if not maybe_e.is_some():
        let none_k: Option<BorrowErrorKind> = Option<BorrowErrorKind>::None()
        return none_k
    .end

    let e = maybe_e.unwrap()

    if kind == BorrowKind::BorrowImmutable:
        if e.kind == BorrowKind::BorrowMutable and e.active:
            let some_err: Option<BorrowErrorKind> = Option<BorrowErrorKind>::Some(
                BorrowErrorKind::BorrowErrorAliasMut
            )
            return some_err
        .end
        let none_ok: Option<BorrowErrorKind> = Option<BorrowErrorKind>::None()
        return none_ok
    .end

    if kind == BorrowKind::BorrowMutable:
        if e.active:
            let some_err2: Option<BorrowErrorKind> = Option<BorrowErrorKind>::Some(
                BorrowErrorKind::BorrowErrorMutWhileBorrowed
            )
            return some_err2
        .end
        let none_ok2: Option<BorrowErrorKind> = Option<BorrowErrorKind>::None()
        return none_ok2
    .end

    if kind == BorrowKind::BorrowMove:
        if e.moved:
            let some_err3: Option<BorrowErrorKind> = Option<BorrowErrorKind>::Some(
                BorrowErrorKind::BorrowErrorDoubleMove
            )
            return some_err3
        .end
        let none_ok3: Option<BorrowErrorKind> = Option<BorrowErrorKind>::None()
        return none_ok3
    .end

    let none_default: Option<BorrowErrorKind> = Option<BorrowErrorKind>::None()
    return none_default
.end

fn borrow_state_apply_borrow(BorrowState st, BorrowKey place, BorrowKind kind) -> BorrowState:
    let maybe_e = borrow_state_get_entry(st, place)
    if not maybe_e.is_some():
        let e0 = BorrowEntry(
            place = place,
            kind = kind,
            active = true,
            moved = false
        )
        let st0 = borrow_state_set_entry(st, e0)
        return st0
    .end

    let e = maybe_e.unwrap()
    let e2 = BorrowEntry(
        place = place,
        kind = kind,
        active = true,
        moved = e.moved
    )
    let st2 = borrow_state_set_entry(st, e2)
    return st2
.end

fn borrow_state_apply_move(BorrowState st, BorrowKey place) -> BorrowState:
    let maybe_e = borrow_state_get_entry(st, place)
    if not maybe_e.is_some():
        let e0 = BorrowEntry(
            place = place,
            kind = BorrowKind::BorrowMove,
            active = false,
            moved = true
        )
        let st0 = borrow_state_set_entry(st, e0)
        return st0
    .end

    let e = maybe_e.unwrap()
    let e2 = BorrowEntry(
        place = place,
        kind = e.kind,
        active = false,
        moved = true
    )
    let st2 = borrow_state_set_entry(st, e2)
    return st2
.end

fn borrow_state_check_use(
    BorrowState st,
    BorrowKey place,
    BorrowUseKind use_kind
) -> Option<BorrowErrorKind>:
    let maybe_e = borrow_state_get_entry(st, place)
    if not maybe_e.is_some():
        let none_u: Option<BorrowErrorKind> = Option<BorrowErrorKind>::None()
        return none_u
    .end

    let e = maybe_e.unwrap()

    if e.moved:
        let some_err: Option<BorrowErrorKind> = Option<BorrowErrorKind>::Some(
            BorrowErrorKind::BorrowErrorUseAfterMove
        )
        return some_err
    .end

    let none_ok: Option<BorrowErrorKind> = Option<BorrowErrorKind>::None()
    return none_ok
.end

fn borrow_state_apply_drop(BorrowState st, BorrowKey place) -> BorrowState:
    let maybe_e = borrow_state_get_entry(st, place)
    if not maybe_e.is_some():
        return st
    .end

    let e = maybe_e.unwrap()
    let e2 = BorrowEntry(
        place = place,
        kind = e.kind,
        active = false,
        moved = e.moved
    )
    let st2 = borrow_state_set_entry(st, e2)
    return st2
.end

# ----------------------------------------------------------------------------
# Options et résultat global
# ----------------------------------------------------------------------------

pub struct BorrowCheckOptions:
    let allow_two_phase_borrows: Bool
    let allow_partial_moves: Bool
    let allow_unsafe: Bool
.end

pub fn borrow_check_default_options() -> BorrowCheckOptions:
    let opts = BorrowCheckOptions(
        allow_two_phase_borrows = false,
        allow_partial_moves = false,
        allow_unsafe = false
    )
    return opts
.end

pub struct BorrowCheckResult:
    let ok: Bool
    let diagnostics: diag.DiagnosticsSink
.end

fn push_borrow_error_diag(BorrowError err, diag.DiagnosticsSink sink) -> diag.DiagnosticsSink:
    let msg = err.message
    let d = diag.make_borrowck_error(msg, err.span)
    sink.push(d)
    return sink
.end

# ----------------------------------------------------------------------------
# Application d'une séquence d'événements d'emprunt
# ----------------------------------------------------------------------------

pub fn borrow_check_events(
    Vec<BorrowEvent> events,
    BorrowCheckOptions opts,
    diag.DiagnosticsSink sink
) -> BorrowCheckResult:
    let st0 = borrow_state_new()
    let st = st0
    let ds = sink

    let len = events.len()
    let i = 0usize

    let had_error = false

    while i < len:
        let ev = events[i]
        let place = ev.place

        if ev.kind == BorrowEventKind::EventBorrow or
           ev.kind == BorrowEventKind::EventReborrow:
            let maybe_err_k = borrow_state_check_borrow(st, place, ev.borrow_kind)
            if maybe_err_k.is_some():
                let k = maybe_err_k.unwrap()
                let err = make_borrow_error(k, place, ev.span)
                let ds2 = push_borrow_error_diag(err, ds)
                ds = ds2
                had_error = true
            .end

            let st2 = borrow_state_apply_borrow(st, place, ev.borrow_kind)
            let st3 = st2
            let tmp_st = st3
        .end

        if ev.kind == BorrowEventKind::EventMove:
            let maybe_err_k2 = borrow_state_check_borrow(st, place, BorrowKind::BorrowMove)
            if maybe_err_k2.is_some():
                let k2 = maybe_err_k2.unwrap()
                let err2 = make_borrow_error(k2, place, ev.span)
                let ds3 = push_borrow_error_diag(err2, ds)
                ds = ds3
                had_error = true
            .end

            let st4 = borrow_state_apply_move(st, place)
            let tmp_st2 = st4
        .end

        if ev.kind == BorrowEventKind::EventUse:
            let maybe_err_k3 = borrow_state_check_use(st, place, ev.use_kind)
            if maybe_err_k3.is_some():
                let k3 = maybe_err_k3.unwrap()
                let err3 = make_borrow_error(k3, place, ev.span)
                let ds4 = push_borrow_error_diag(err3, ds)
                ds = ds4
                had_error = true
            .end
        .end

        if ev.kind == BorrowEventKind::EventDrop:
            let st5 = borrow_state_apply_drop(st, place)
            let tmp_st3 = st5
        .end

        i = i + 1usize
    .end

    let res = BorrowCheckResult(
        ok = not had_error,
        diagnostics = ds
    )
    return res
.end

# ----------------------------------------------------------------------------
# API de haut niveau (IR-agnostique)
# ----------------------------------------------------------------------------

pub struct BorrowFunctionInfo:
    let name: String
    let events: Vec<BorrowEvent>
.end

pub fn borrow_check_functions(
    Vec<BorrowFunctionInfo> functions,
    BorrowCheckOptions opts,
    diag.DiagnosticsSink sink
) -> BorrowCheckResult:
    let ds = sink
    let len = functions.len()
    let i = 0usize
    let had_error = false

    while i < len:
        let f = functions[i]
        let res_f = borrow_check_events(f.events, opts, ds)
        ds = res_f.diagnostics
        if not res_f.ok:
            had_error = true
        .end
        i = i + 1usize
    .end

    let res = BorrowCheckResult(
        ok = not had_error,
        diagnostics = ds
    )
    return res
.end

# ----------------------------------------------------------------------------
# Notes
# ----------------------------------------------------------------------------
# - Ce module n'est pas lié à un IR particulier : une passe séparée peut
#   traduire un IR (ou l'AST typé) en une séquence de BorrowEvent. Cela
#   permet d'expérimenter sur le modèle d'emprunts sans figer le IR.
# - Pour un modèle plus proche de Rust, on pourra enrichir BorrowPlace,
#   introduire des régions / lifetimes explicites, et affiner les règles
#   dans borrow_state_check_borrow / borrow_state_check_use.
# - Les helpers diag.make_borrowck_error / make_dummy_span sont supposés
#   exister dans vitte.compiler.diagnostics et peuvent être adaptés.
# ----------------------------------------------------------------------------
