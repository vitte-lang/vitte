

module vitte.compiler.unify

import std.collections as coll
import vitte.compiler.span as span

# =============================================================================
# Vitte compiler – Generic term unification core (maximal, logique, sans I/O)
# =============================================================================
#
# Objectifs :
#   - Fournir un moteur générique de unification à la Robinson :
#       * variables de unification (α, β, ...),
#       * termes (constantes, symboles de fonction, wildcards),
#       * substitution VarId -> TermId,
#       * occurs-check, unification structurelle,
#       * contraintes "T == U" et collecte d’erreurs.
#   - Être totalement indépendant des types concrets :
#       * utilisable pour les types, les schémas de patterns, les signatures,
#       * les couches supérieures adaptent String/symboles/ids à ce moteur.
#   - Ne faire aucun I/O (pas de disque, pas de logs).
#
# Ce module ne dépend pas de `type_infer` ni des AST ; il est volontairement
# générique. Les passes de typage ou de résolution peuvent se baser dessus
# pour des scénarios avancés (unification structurelle, matching de schémas).
# =============================================================================

# -----------------------------------------------------------------------------
# Identifiants
# -----------------------------------------------------------------------------

typedef u32 UnifyVarId
typedef u32 UnifyTermId
typedef u32 UnifyConstraintId
typedef u32 UnifyErrorId

# -----------------------------------------------------------------------------
# Kinds de termes / contraintes / erreurs
# -----------------------------------------------------------------------------

pub enum UnifyTermKind:
    UnifyTermKindVar        # variable logique
    UnifyTermKindConst      # constante (symbole 0-aire)
    UnifyTermKindFunc       # symbole de fonction f(t1,...,tn)
    UnifyTermKindWildcard   # wildcard "_" qui matche tout
.end

pub enum UnifyConstraintKind:
    UnifyConstraintKindEquals   # t1 == t2
.end

pub enum UnifyErrorKind:
    UnifyErrorKindOccursCheck       # occurs-check échoué
    UnifyErrorKindSymbolMismatch    # symboles incompatibles
    UnifyErrorKindArityMismatch     # arité de fonction différente
    UnifyErrorKindKindMismatch      # kinds de terme incompatibles
    UnifyErrorKindOther             # autre erreur générique
.end

# -----------------------------------------------------------------------------
# Structures de base
# -----------------------------------------------------------------------------

pub struct UnifyVar:
    let id: UnifyVarId
    let name: String
    let rank: u32
    let span: span.Span
.end

pub struct UnifyTerm:
    let id: UnifyTermId
    let kind: UnifyTermKind
    let symbol: String                   # nom du symbole (const/func), vide pour wildcard
    let var_id: coll.Option<UnifyVarId>  # présent si kind == Var
    let args: Vec<UnifyTermId>           # enfants si kind == Func
    let span: span.Span
.end

pub struct UnifySubstEntry:
    let var_id: UnifyVarId
    let term_id: UnifyTermId
.end

pub struct UnifySubst:
    let entries: Vec<UnifySubstEntry>
.end

pub struct UnifyConstraint:
    let id: UnifyConstraintId
    let kind: UnifyConstraintKind
    let left: UnifyTermId
    let right: UnifyTermId
    let span: span.Span
.end

pub struct UnifyError:
    let id: UnifyErrorId
    let kind: UnifyErrorKind
    let message: String
    let primary_span: span.Span
    let left_term: coll.Option<UnifyTermId>
    let right_term: coll.Option<UnifyTermId>
    let constraint_id: coll.Option<UnifyConstraintId>
.end

# -----------------------------------------------------------------------------
# Contexte global de unification
# -----------------------------------------------------------------------------

pub struct UnifyContext:
    let vars: Vec<UnifyVar>
    let terms: Vec<UnifyTerm>
    let subst: UnifySubst
    let constraints: Vec<UnifyConstraint>
    let errors: Vec<UnifyError>
    let next_rank: u32
.end

# -----------------------------------------------------------------------------
# Helpers internes : next_id
# -----------------------------------------------------------------------------

fn unify_next_var_id(ctx: UnifyContext) -> UnifyVarId:
    let n = ctx.vars.len()
    return n as u32
.end

fn unify_next_term_id(ctx: UnifyContext) -> UnifyTermId:
    let n = ctx.terms.len()
    return n as u32
.end

fn unify_next_constraint_id(ctx: UnifyContext) -> UnifyConstraintId:
    let n = ctx.constraints.len()
    return n as u32
.end

fn unify_next_error_id(ctx: UnifyContext) -> UnifyErrorId:
    let n = ctx.errors.len()
    return n as u32
.end

# -----------------------------------------------------------------------------
# Construction du contexte
# -----------------------------------------------------------------------------

pub fn unify_context_new() -> UnifyContext:
    let vars: Vec<UnifyVar> = Vec<UnifyVar>::new()
    let terms: Vec<UnifyTerm> = Vec<UnifyTerm>::new()
    let entries: Vec<UnifySubstEntry> = Vec<UnifySubstEntry>::new()
    let subst = UnifySubst(
        entries = entries
    )
    let constraints: Vec<UnifyConstraint> = Vec<UnifyConstraint>::new()
    let errors: Vec<UnifyError> = Vec<UnifyError>::new()

    let ctx = UnifyContext(
        vars = vars,
        terms = terms,
        subst = subst,
        constraints = constraints,
        errors = errors,
        next_rank = 0u32
    )
    return ctx
.end

# -----------------------------------------------------------------------------
# Création de variables et de termes
# -----------------------------------------------------------------------------

pub fn unify_add_var(
    UnifyContext ctx,
    String name,
    span.Span sp
) -> (UnifyContext, UnifyVarId, UnifyTermId):
    let vars = ctx.vars
    let terms = ctx.terms
    let subst = ctx.subst
    let constraints = ctx.constraints
    let errors = ctx.errors

    let vid = unify_next_var_id(ctx)
    let rank = ctx.next_rank

    let v = UnifyVar(
        id = vid,
        name = name,
        rank = rank,
        span = sp
    )
    vars.push(v)

    let tid = unify_next_term_id(ctx)
    let some_vid = coll.option_some<UnifyVarId>(vid)
    let empty_args: Vec<UnifyTermId> = Vec<UnifyTermId>::new()

    let t = UnifyTerm(
        id = tid,
        kind = UnifyTermKind::UnifyTermKindVar,
        symbol = name,
        var_id = some_vid,
        args = empty_args,
        span = sp
    )
    terms.push(t)

    let ctx2 = UnifyContext(
        vars = vars,
        terms = terms,
        subst = subst,
        constraints = constraints,
        errors = errors,
        next_rank = rank
    )

    let out = (ctx2, vid, tid)
    return out
.end

pub fn unify_add_const(
    UnifyContext ctx,
    String symbol,
    span.Span sp
) -> (UnifyContext, UnifyTermId):
    let vars = ctx.vars
    let terms = ctx.terms
    let subst = ctx.subst
    let constraints = ctx.constraints
    let errors = ctx.errors

    let tid = unify_next_term_id(ctx)
    let none_vid = coll.option_none<UnifyVarId>()
    let empty_args: Vec<UnifyTermId> = Vec<UnifyTermId>::new()

    let t = UnifyTerm(
        id = tid,
        kind = UnifyTermKind::UnifyTermKindConst,
        symbol = symbol,
        var_id = none_vid,
        args = empty_args,
        span = sp
    )
    terms.push(t)

    let ctx2 = UnifyContext(
        vars = vars,
        terms = terms,
        subst = subst,
        constraints = constraints,
        errors = errors,
        next_rank = ctx.next_rank
    )

    let out = (ctx2, tid)
    return out
.end

pub fn unify_add_func(
    UnifyContext ctx,
    String symbol,
    Vec<UnifyTermId> args,
    span.Span sp
) -> (UnifyContext, UnifyTermId):
    let vars = ctx.vars
    let terms = ctx.terms
    let subst = ctx.subst
    let constraints = ctx.constraints
    let errors = ctx.errors

    let tid = unify_next_term_id(ctx)
    let none_vid = coll.option_none<UnifyVarId>()

    let t = UnifyTerm(
        id = tid,
        kind = UnifyTermKind::UnifyTermKindFunc,
        symbol = symbol,
        var_id = none_vid,
        args = args,
        span = sp
    )
    terms.push(t)

    let ctx2 = UnifyContext(
        vars = vars,
        terms = terms,
        subst = subst,
        constraints = constraints,
        errors = errors,
        next_rank = ctx.next_rank
    )

    let out = (ctx2, tid)
    return out
.end

pub fn unify_add_wildcard(
    UnifyContext ctx,
    span.Span sp
) -> (UnifyContext, UnifyTermId):
    let vars = ctx.vars
    let terms = ctx.terms
    let subst = ctx.subst
    let constraints = ctx.constraints
    let errors = ctx.errors

    let tid = unify_next_term_id(ctx)
    let none_vid = coll.option_none<UnifyVarId>()
    let empty_args: Vec<UnifyTermId> = Vec<UnifyTermId>::new()

    let t = UnifyTerm(
        id = tid,
        kind = UnifyTermKind::UnifyTermKindWildcard,
        symbol = "_",
        var_id = none_vid,
        args = empty_args,
        span = sp
    )
    terms.push(t)

    let ctx2 = UnifyContext(
        vars = vars,
        terms = terms,
        subst = subst,
        constraints = constraints,
        errors = errors,
        next_rank = ctx.next_rank
    )

    let out = (ctx2, tid)
    return out
.end

# -----------------------------------------------------------------------------
# Substitution : helpers
# -----------------------------------------------------------------------------

fn unify_subst_find(
    UnifySubst subst,
    UnifyVarId vid
) -> coll.Option<UnifyTermId>:
    let entries = subst.entries
    let n = entries.len()
    let i = 0usize

    while i < n:
        let e = entries[i]
        if e.var_id == vid:
            let some_tid = coll.option_some<UnifyTermId>(e.term_id)
            return some_tid
        .end
        let i = i + 1usize
    .end

    let none_tid = coll.option_none<UnifyTermId>()
    return none_tid
.end

fn unify_subst_add(
    UnifySubst subst,
    UnifyVarId vid,
    UnifyTermId tid
) -> UnifySubst:
    let entries = subst.entries
    let e = UnifySubstEntry(
        var_id = vid,
        term_id = tid
    )
    entries.push(e)
    let subst2 = UnifySubst(
        entries = entries
    )
    return subst2
.end

# Applique la substitution (une seule étape) pour suivre les variables.
fn unify_repr_term(
    UnifyContext ctx,
    UnifyTermId tid
) -> UnifyTermId:
    let terms = ctx.terms
    let t = terms[tid as usize]

    if t.kind != UnifyTermKind::UnifyTermKindVar:
        return tid
    .end

    let opt_vid = t.var_id
    if coll.option_is_none<UnifyVarId>(opt_vid):
        return tid
    .end

    let vid = coll.option_unwrap_unsafe<UnifyVarId>(opt_vid)
    let opt_tid2 = unify_subst_find(ctx.subst, vid)
    if coll.option_is_none<UnifyTermId>(opt_tid2):
        return tid
    .end

    let tid2 = coll.option_unwrap_unsafe<UnifyTermId>(opt_tid2)
    return tid2
.end

# -----------------------------------------------------------------------------
# Occurs-check
# -----------------------------------------------------------------------------

fn unify_term_contains_var(
    UnifyContext ctx,
    UnifyTermId tid,
    UnifyVarId vid
) -> Bool:
    let rep = unify_repr_term(ctx, tid)
    let terms = ctx.terms
    let t = terms[rep as usize]

    if t.kind == UnifyTermKind::UnifyTermKindVar:
        let opt_vid = t.var_id
        if coll.option_is_some<UnifyVarId>(opt_vid):
            let v2 = coll.option_unwrap_unsafe<UnifyVarId>(opt_vid)
            return v2 == vid
        .end
        return false
    .end

    if t.kind == UnifyTermKind::UnifyTermKindFunc:
        let args = t.args
        let n = args.len()
        let i = 0usize
        while i < n:
            let cid = args[i]
            let has = unify_term_contains_var(ctx, cid, vid)
            if has:
                return true
            .end
            let i = i + 1usize
        .end
        return false
    .end

    # Const / wildcard : pas de contenu récursif.
    return false
.end

# -----------------------------------------------------------------------------
# Gestion des erreurs
# -----------------------------------------------------------------------------

fn unify_add_error(
    UnifyContext ctx,
    UnifyErrorKind kind,
    String message,
    span.Span sp,
    coll.Option<UnifyTermId> left_opt,
    coll.Option<UnifyTermId> right_opt,
    coll.Option<UnifyConstraintId> cid_opt
) -> UnifyContext:
    let vars = ctx.vars
    let terms = ctx.terms
    let subst = ctx.subst
    let constraints = ctx.constraints
    let errors = ctx.errors

    let eid = unify_next_error_id(ctx)

    let err = UnifyError(
        id = eid,
        kind = kind,
        message = message,
        primary_span = sp,
        left_term = left_opt,
        right_term = right_opt,
        constraint_id = cid_opt
    )

    errors.push(err)

    let ctx2 = UnifyContext(
        vars = vars,
        terms = terms,
        subst = subst,
        constraints = constraints,
        errors = errors,
        next_rank = ctx.next_rank
    )
    return ctx2
.end

pub fn unify_has_errors(
    UnifyContext ctx
) -> Bool:
    let n = ctx.errors.len()
    return n > 0usize
.end

# -----------------------------------------------------------------------------
# Ajout de contraintes
# -----------------------------------------------------------------------------

pub fn unify_add_constraint_equals(
    UnifyContext ctx,
    UnifyTermId left,
    UnifyTermId right,
    span.Span sp
) -> (UnifyContext, UnifyConstraintId):
    let vars = ctx.vars
    let terms = ctx.terms
    let subst = ctx.subst
    let constraints = ctx.constraints
    let errors = ctx.errors

    let cid = unify_next_constraint_id(ctx)

    let c = UnifyConstraint(
        id = cid,
        kind = UnifyConstraintKind::UnifyConstraintKindEquals,
        left = left,
        right = right,
        span = sp
    )
    constraints.push(c)

    let ctx2 = UnifyContext(
        vars = vars,
        terms = terms,
        subst = subst,
        constraints = constraints,
        errors = errors,
        next_rank = ctx.next_rank
    )

    let out = (ctx2, cid)
    return out
.end

# -----------------------------------------------------------------------------
# Unification de base
# -----------------------------------------------------------------------------

fn unify_unify_var(
    UnifyContext ctx,
    UnifyVarId vid,
    UnifyTermId tid,
    span.Span sp
) -> (UnifyContext, Bool):
    # Si la variable a déjà une substitution, unifier la cible existante.
    let cur = unify_subst_find(ctx.subst, vid)
    if coll.option_is_some<UnifyTermId>(cur):
        let tid2 = coll.option_unwrap_unsafe<UnifyTermId>(cur)
        let (ctx2, ok2) = unify_unify_terms(ctx, tid2, tid, sp)
        return (ctx2, ok2)
    .end

    # Occurs-check
    let occurs = unify_term_contains_var(ctx, tid, vid)
    if occurs:
        let msg = "occurs-check failed in unification"
        let left_opt = coll.option_none<UnifyTermId>()
        let right_opt = coll.option_none<UnifyTermId>()
        let cid_opt = coll.option_none<UnifyConstraintId>()
        let ctx_err = unify_add_error(
            ctx,
            UnifyErrorKind::UnifyErrorKindOccursCheck,
            msg,
            sp,
            left_opt,
            right_opt,
            cid_opt
        )
        return (ctx_err, false)
    .end

    # Ajout de la substitution vid ↦ tid
    let vars = ctx.vars
    let terms = ctx.terms
    let constraints = ctx.constraints
    let errors = ctx.errors

    let subst2 = unify_subst_add(ctx.subst, vid, tid)

    let ctx2 = UnifyContext(
        vars = vars,
        terms = terms,
        subst = subst2,
        constraints = constraints,
        errors = errors,
        next_rank = ctx.next_rank
    )
    return (ctx2, true)
.end

fn unify_unify_terms_structural(
    UnifyContext ctx,
    UnifyTerm a,
    UnifyTerm b,
    span.Span sp
) -> (UnifyContext, Bool):
    # Wildcard : accepte tout.
    if a.kind == UnifyTermKind::UnifyTermKindWildcard:
        return (ctx, true)
    .end
    if b.kind == UnifyTermKind::UnifyTermKindWildcard:
        return (ctx, true)
    .end

    # Constantes : même symbole.
    if a.kind == UnifyTermKind::UnifyTermKindConst and
       b.kind == UnifyTermKind::UnifyTermKindConst:
        if a.symbol == b.symbol:
            return (ctx, true)
        .end
        let msg = "constant symbol mismatch in unification"
        let left_opt = coll.option_some<UnifyTermId>(a.id)
        let right_opt = coll.option_some<UnifyTermId>(b.id)
        let cid_opt = coll.option_none<UnifyConstraintId>()
        let ctx_err = unify_add_error(
            ctx,
            UnifyErrorKind::UnifyErrorKindSymbolMismatch,
            msg,
            sp,
            left_opt,
            right_opt,
            cid_opt
        )
        return (ctx_err, false)
    .end

    # Fonctions : même symbole + même arité, puis unification des arguments.
    if a.kind == UnifyTermKind::UnifyTermKindFunc and
       b.kind == UnifyTermKind::UnifyTermKindFunc:
        if a.symbol != b.symbol:
            let msg2 = "function symbol mismatch in unification"
            let left_opt2 = coll.option_some<UnifyTermId>(a.id)
            let right_opt2 = coll.option_some<UnifyTermId>(b.id)
            let cid_opt2 = coll.option_none<UnifyConstraintId>()
            let ctx_err2 = unify_add_error(
                ctx,
                UnifyErrorKind::UnifyErrorKindSymbolMismatch,
                msg2,
                sp,
                left_opt2,
                right_opt2,
                cid_opt2
            )
            return (ctx_err2, false)
        .end

        let args_a = a.args
        let args_b = b.args
        let na = args_a.len()
        let nb = args_b.len()
        if na != nb:
            let msg3 = "function arity mismatch in unification"
            let left_opt3 = coll.option_some<UnifyTermId>(a.id)
            let right_opt3 = coll.option_some<UnifyTermId>(b.id)
            let cid_opt3 = coll.option_none<UnifyConstraintId>()
            let ctx_err3 = unify_add_error(
                ctx,
                UnifyErrorKind::UnifyErrorKindArityMismatch,
                msg3,
                sp,
                left_opt3,
                right_opt3,
                cid_opt3
            )
            return (ctx_err3, false)
        .end

        let i = 0usize
        let ctx_cur = ctx

        while i < na:
            let ta = args_a[i]
            let tb = args_b[i]
            let (ctx_next, okp) = unify_unify_terms(ctx_cur, ta, tb, sp)
            let ctx_cur = ctx_next
            if not okp:
                return (ctx_cur, false)
            .end
            let i = i + 1usize
        .end

        return (ctx_cur, true)
    .end

    # Kinds incompatibles (const vs func, etc.)
    let msg4 = "term kind mismatch in unification"
    let left_opt4 = coll.option_some<UnifyTermId>(a.id)
    let right_opt4 = coll.option_some<UnifyTermId>(b.id)
    let cid_opt4 = coll.option_none<UnifyConstraintId>()
    let ctx_err4 = unify_add_error(
        ctx,
        UnifyErrorKind::UnifyErrorKindKindMismatch,
        msg4,
        sp,
        left_opt4,
        right_opt4,
        cid_opt4
    )
    return (ctx_err4, false)
.end

pub fn unify_unify_terms(
    UnifyContext ctx,
    UnifyTermId left,
    UnifyTermId right,
    span.Span sp
) -> (UnifyContext, Bool):
    let a_rep = unify_repr_term(ctx, left)
    let b_rep = unify_repr_term(ctx, right)

    if a_rep == b_rep:
        return (ctx, true)
    .end

    let terms = ctx.terms
    let a = terms[a_rep as usize]
    let b = terms[b_rep as usize]

    # Variables
    if a.kind == UnifyTermKind::UnifyTermKindVar:
        let opt_vid = a.var_id
        if coll.option_is_some<UnifyVarId>(opt_vid):
            let vid = coll.option_unwrap_unsafe<UnifyVarId>(opt_vid)
            let (ctx2, ok2) = unify_unify_var(ctx, vid, b_rep, sp)
            return (ctx2, ok2)
        .end
    .end

    if b.kind == UnifyTermKind::UnifyTermKindVar:
        let opt_vid2 = b.var_id
        if coll.option_is_some<UnifyVarId>(opt_vid2):
            let vid2 = coll.option_unwrap_unsafe<UnifyVarId>(opt_vid2)
            let (ctx3, ok3) = unify_unify_var(ctx, vid2, a_rep, sp)
            return (ctx3, ok3)
        .end
    .end

    # Structurelle
    let (ctx4, ok4) = unify_unify_terms_structural(ctx, a, b, sp)
    return (ctx4, ok4)
.end

# -----------------------------------------------------------------------------
# Résolution des contraintes
# -----------------------------------------------------------------------------

pub fn unify_solve_constraints(
    UnifyContext ctx
) -> UnifyContext:
    let constraints = ctx.constraints
    let n = constraints.len()
    let i = 0usize
    let ctx_cur = ctx

    while i < n:
        let c = constraints[i]
        if c.kind == UnifyConstraintKind::UnifyConstraintKindEquals:
            let (ctx_next, _ok) = unify_unify_terms(
                ctx_cur,
                c.left,
                c.right,
                c.span
            )
            let ctx_cur = ctx_next
        .end
        let i = i + 1usize
    .end

    return ctx_cur
.end

# -----------------------------------------------------------------------------
# Helpers de debug
# -----------------------------------------------------------------------------

pub fn unify_term_kind_to_string(
    UnifyTermKind k
) -> String:
    if k == UnifyTermKind::UnifyTermKindVar:
        return "var"
    .end
    if k == UnifyTermKind::UnifyTermKindConst:
        return "const"
    .end
    if k == UnifyTermKind::UnifyTermKindFunc:
        return "func"
    .end
    if k == UnifyTermKind::UnifyTermKindWildcard:
        return "wildcard"
    .end
    return "?"
.end

pub fn unify_error_kind_to_string(
    UnifyErrorKind k
) -> String:
    if k == UnifyErrorKind::UnifyErrorKindOccursCheck:
        return "occurs_check"
    .end
    if k == UnifyErrorKind::UnifyErrorKindSymbolMismatch:
        return "symbol_mismatch"
    .end
    if k == UnifyErrorKind::UnifyErrorKindArityMismatch:
        return "arity_mismatch"
    .end
    if k == UnifyErrorKind::UnifyErrorKindKindMismatch:
        return "kind_mismatch"
    .end
    if k == UnifyErrorKind::UnifyErrorKindOther:
        return "other"
    .end
    return "?"
.end

pub fn unify_term_to_string(
    UnifyContext ctx,
    UnifyTermId tid
) -> String:
    let rep = unify_repr_term(ctx, tid)
    let terms = ctx.terms
    let t = terms[rep as usize]

    if t.kind == UnifyTermKind::UnifyTermKindVar:
        return t.symbol
    .end

    if t.kind == UnifyTermKind::UnifyTermKindConst:
        return t.symbol
    .end

    if t.kind == UnifyTermKind::UnifyTermKindWildcard:
        return "_"
    .end

    if t.kind == UnifyTermKind::UnifyTermKindFunc:
        let args = t.args
        let n = args.len()
        let i = 0usize

        let out = t.symbol + "("
        while i < n:
            let aid = args[i]
            let part = unify_term_to_string(ctx, aid)
            if i == 0usize:
                let out = out + part
            else:
                let out = out + ", " + part
            .end
            let i = i + 1usize
        .end
        let out = out + ")"
        return out
    .end

    return "?"
.end

# -----------------------------------------------------------------------------
# Scenario de smoke test
# -----------------------------------------------------------------------------

scenario unify_smoke_test():
    let ctx0 = unify_context_new()

    # Construction des termes :
    #   f(X, a)   unifié avec   f(b, a)
    let sp_x = span.span_from_len(
        (span.BytePos) 0,
        (span.ByteLen) 1
    )
    let (ctx1, _x_id, term_x) = unify_add_var(
        ctx0,
        "X",
        sp_x
    )

    let sp_a = span.span_from_len(
        (span.BytePos) 1,
        (span.ByteLen) 1
    )
    let (ctx2, term_a) = unify_add_const(
        ctx1,
        "a",
        sp_a
    )

    let sp_b = span.span_from_len(
        (span.BytePos) 2,
        (span.ByteLen) 1
    )
    let (ctx3, term_b) = unify_add_const(
        ctx2,
        "b",
        sp_b
    )

    let sp_f1 = span.span_from_len(
        (span.BytePos) 3,
        (span.ByteLen) 1
    )
    let args_f1: Vec<UnifyTermId> = Vec<UnifyTermId>::new()
    args_f1.push(term_x)
    args_f1.push(term_a)

    let (ctx4, term_f1) = unify_add_func(
        ctx3,
        "f",
        args_f1,
        sp_f1
    )

    let sp_f2 = span.span_from_len(
        (span.BytePos) 4,
        (span.ByteLen) 1
    )
    let args_f2: Vec<UnifyTermId> = Vec<UnifyTermId>::new()
    args_f2.push(term_b)
    args_f2.push(term_a)

    let (ctx5, term_f2) = unify_add_func(
        ctx4,
        "f",
        args_f2,
        sp_f2
    )

    # Contrainte f(X, a) == f(b, a)
    let sp_c = span.span_from_len(
        (span.BytePos) 5,
        (span.ByteLen) 1
    )
    let (ctx6, _cid) = unify_add_constraint_equals(
        ctx5,
        term_f1,
        term_f2,
        sp_c
    )

    # Résolution
    let ctx7 = unify_solve_constraints(ctx6)
    let has_err = unify_has_errors(ctx7)

    let s1 = unify_term_to_string(ctx7, term_f1)
    let s2 = unify_term_to_string(ctx7, term_f2)

    let _ = has_err
    let _ = s1
    let _ = s2
.end