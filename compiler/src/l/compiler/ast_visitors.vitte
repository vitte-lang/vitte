module vitte.compiler.ast_visitors

# ============================================================================
# Vitte compiler – infrastructure générique de visiteurs d'AST
#
# Objectif :
#   - fournir une base neutre et réutilisable pour traverser un graphe d'AST ;
#   - ne pas dépendre d'une forme précise d'AST : uniquement d'identifiants
#     de nœuds (`AstNodeId`) et d'un "store" abstrait (`AstStore`) ;
#   - permettre différents styles de visiteurs :
#       * visite préfixe (pre-order),
#       * visite suffixe (post-order),
#       * visite en profondeur (DFS),
#       * visite en largeur (BFS) ;
#   - rester fidèle à la syntaxe Vitte (blocs `:` + indentation + `.end`).
#
# Intégration :
#   - implémente `AstStore` dans ton module AST concret (par ex. vitte.compiler.ast) ;
#   - implémente `AstVisitor` pour les passes d'analyse, de collecte, etc. ;
#   - utilise les fonctions `walk_*` pour la traversée.
# ============================================================================

# ----------------------------------------------------------------------------
# Types de base : identifiant de nœud et profondeur
# ----------------------------------------------------------------------------

pub struct AstNodeId:
    let raw: u32
.end

pub struct Depth:
    let value: u32
.end

fn Depth.new(u32 value) -> Depth:
    let d = Depth(value = value)
    return d
.end

fn Depth.zero() -> Depth:
    return Depth.new(0u32)
.end

fn Depth.next(Depth self) -> Depth:
    return Depth.new(self.value + 1u32)
.end

fn Depth.is_root(Depth self) -> Bool:
    return self.value == 0u32
.end

# ----------------------------------------------------------------------------
# AstStore – abstraction d'un stockage d'AST indexé par AstNodeId
# ----------------------------------------------------------------------------
#
# Ce trait représente :
#   - la structure qui sait :
#       * récupérer les enfants d'un nœud,
#       * tester si un nœud est valide,
#       * éventuellement donner un "genre" (kind) symbolique.
#   - généralement, ce sera ton "Arena", "ModuleAst", "AstGraph", etc.
# ----------------------------------------------------------------------------

pub trait AstStore:
    # Retourne vrai si l'identifiant pointe vers un nœud valide.
    fn is_valid(self, AstNodeId id) -> Bool

    # Retourne les enfants immédiats (ordre logique / syntaxique).
    fn children_of(self, AstNodeId id) -> Vec<AstNodeId>

    # Optionnel : donne un nom/genre lisible pour debug/logs.
    fn kind_of(self, AstNodeId id) -> String
.end

# ----------------------------------------------------------------------------
# AstVisitor – interface de visite générique
# ----------------------------------------------------------------------------
#
# Un visiteur peut surcharger :
#   - `pre_visit`   : appelé avant de descendre dans les enfants ;
#   - `post_visit`  : appelé après avoir visité les enfants ;
#   - `should_walk` : permet de couper la descente dans certains sous-arbres.
#
# Par défaut :
#   - `pre_visit` et `post_visit` ne font rien ;
#   - `should_walk` renvoie vrai (on visite tout).
# ----------------------------------------------------------------------------

pub trait AstVisitor:
    fn pre_visit(self, AstStore store, AstNodeId id, Depth depth):
        # Défaut : ne rien faire.
        let _ = store
        let _ = id
        let _ = depth
    .end

    fn post_visit(self, AstStore store, AstNodeId id, Depth depth):
        # Défaut : ne rien faire.
        let _ = store
        let _ = id
        let _ = depth
    .end

    fn should_walk(self, AstStore store, AstNodeId id, Depth depth) -> Bool:
        let _ = store
        let _ = id
        let _ = depth
        return true
    .end
.end

# ----------------------------------------------------------------------------
# Walkers DFS (profondeur) – préfixe et suffixe
# ----------------------------------------------------------------------------

pub fn walk_pre_order(AstStore store, AstVisitor visitor, AstNodeId root):
    walk_pre_order_with_depth(store, visitor, root, Depth.zero())
.end

pub fn walk_pre_order_with_depth(AstStore store, AstVisitor visitor, AstNodeId root, Depth depth):
    if not store.is_valid(root):
        return
    .end

    if not visitor.should_walk(store, root, depth):
        return
    .end

    # Visite préfixe : on visite le nœud avant ses enfants.
    visitor.pre_visit(store, root, depth)

    # Descente récursive dans les enfants.
    let children = store.children_of(root)
    let child_depth = Depth.next(depth)

    for child in children:
        walk_pre_order_with_depth(store, visitor, child, child_depth)
    .end

    # On laisse la post-visite pour walk_post_order.
.end

pub fn walk_post_order(AstStore store, AstVisitor visitor, AstNodeId root):
    walk_post_order_with_depth(store, visitor, root, Depth.zero())
.end

pub fn walk_post_order_with_depth(AstStore store, AstVisitor visitor, AstNodeId root, Depth depth):
    if not store.is_valid(root):
        return
    .end

    if not visitor.should_walk(store, root, depth):
        return
    .end

    let children = store.children_of(root)
    let child_depth = Depth.next(depth)

    for child in children:
        walk_post_order_with_depth(store, visitor, child, child_depth)
    .end

    # Visite suffixe : on visite le nœud après ses enfants.
    visitor.post_visit(store, root, depth)
.end

# ----------------------------------------------------------------------------
# Walkers DFS “complet” (pré + post dans un même passage)
# ----------------------------------------------------------------------------

pub fn walk_full_dfs(AstStore store, AstVisitor visitor, AstNodeId root):
    walk_full_dfs_with_depth(store, visitor, root, Depth.zero())
.end

pub fn walk_full_dfs_with_depth(AstStore store, AstVisitor visitor, AstNodeId root, Depth depth):
    if not store.is_valid(root):
        return
    .end

    if not visitor.should_walk(store, root, depth):
        return
    .end

    visitor.pre_visit(store, root, depth)

    let children = store.children_of(root)
    let child_depth = Depth.next(depth)

    for child in children:
        walk_full_dfs_with_depth(store, visitor, child, child_depth)
    .end

    visitor.post_visit(store, root, depth)
.end

# ----------------------------------------------------------------------------
# Walkers BFS (largeur) – itératif
# ----------------------------------------------------------------------------
#
# On utilise une file simple basée sur Vec<AstNodeId>.
# Dans un runtime plus riche, tu pourras remplacer ça par une queue dédiée.
# ----------------------------------------------------------------------------

# Élément de file pour BFS : on garde l'identifiant et la profondeur.
pub struct QueueItem:
    let id: AstNodeId
    let depth: Depth
.end

pub struct Queue:
    let items: Vec<QueueItem>
.end

fn Queue.new() -> Queue:
    let items = Vec<QueueItem>::new()
    let q = Queue(items = items)
    return q
.end

fn Queue.is_empty(Queue self) -> Bool:
    return self.items.len() == 0usize
.end

fn Queue.push(Queue self, AstNodeId id, Depth depth) -> Queue:
    let item = QueueItem(id = id, depth = depth)
    self.items.push(item)
    return self
.end

fn Queue.pop_front(Queue self) -> (Queue, Option<QueueItem>):
    if self.items.len() == 0usize:
        let none: Option<QueueItem> = Option<QueueItem>::None()
        return (self, none)
    .end

    # Stratégie simple : on prend le premier élément et on "shift" le reste.
    let first = self.items[0usize]
    let mut rest = Vec<QueueItem>::new()

    let len = self.items.len()
    let mut i = 1usize
    while i < len:
        rest.push(self.items[i])
        i = i + 1usize
    .end

    let some: Option<QueueItem> = Option<QueueItem>::Some(first)
    let q = Queue(items = rest)
    return (q, some)
.end

pub fn walk_breadth_first(AstStore store, AstVisitor visitor, AstNodeId root):
    if not store.is_valid(root):
        return
    .end

    let mut queue = Queue.new()
    let depth0 = Depth.zero()

    # On met la racine dans la file avec profondeur 0.
    queue = Queue.push(queue, root, depth0)

    # Boucle BFS.
    while not Queue.is_empty(queue):
        let pair = Queue.pop_front(queue)
        let next_queue = pair.0
        let maybe_item = pair.1
        queue = next_queue

        # Si aucun élément, on continue.
        let has_item = maybe_item.is_some()
        if not has_item:
            continue
        .end

        let item = maybe_item.unwrap()
        let id = item.id
        let depth = item.depth

        if not store.is_valid(id):
            continue
        .end

        if not visitor.should_walk(store, id, depth):
            continue
        .end

        visitor.pre_visit(store, id, depth)

        let children = store.children_of(id)
        let child_depth = Depth.next(depth)
        for child in children:
            queue = Queue.push(queue, child, child_depth)
        .end

        visitor.post_visit(store, id, depth)
    .end
.end

# ----------------------------------------------------------------------------
# Helpers de commodité pour plusieurs racines
# ----------------------------------------------------------------------------

pub fn walk_pre_order_many(AstStore store, AstVisitor visitor, Vec<AstNodeId> roots):
    for root in roots:
        walk_pre_order(store, visitor, root)
    .end
.end

pub fn walk_post_order_many(AstStore store, AstVisitor visitor, Vec<AstNodeId> roots):
    for root in roots:
        walk_post_order(store, visitor, root)
    .end
.end

pub fn walk_full_dfs_many(AstStore store, AstVisitor visitor, Vec<AstNodeId> roots):
    for root in roots:
        walk_full_dfs(store, visitor, root)
    .end
.end

pub fn walk_breadth_first_many(AstStore store, AstVisitor visitor, Vec<AstNodeId> roots):
    for root in roots:
        walk_breadth_first(store, visitor, root)
    .end
.end
