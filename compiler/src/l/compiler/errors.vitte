module vitte.compiler.diagnostics

# ============================================================================
# Vitte compiler – Diagnostics & Errors (ultra complet)
#
# Objectifs :
#   - Centraliser la représentation des spans, labels et diagnostics.
#   - Fournir un alias DiagnosticsSink exploitable partout dans le compilateur
#     (pipeline front-end, borrowck, async, backends, etc.).
#   - Proposer quelques constructeurs spécialisés (backend, borrowck, async).
#
# Design :
#   - Diagnostic = sévérité + code + message + span principal + labels + notes.
#   - DiagnosticsSink = Vec<Diagnostic> (pour que `sink.push(d)` soit valide).
# ============================================================================

# ----------------------------------------------------------------------------
# Span & labels
# ----------------------------------------------------------------------------

pub struct Span:
    let file_id: String   # identifiant logique du fichier (chemin ou ID)
    let start_line: u32
    let start_column: u32
    let end_line: u32
    let end_column: u32
.end

pub struct Label:
    let is_primary: Bool
    let span: Span
    let message: String
.end

pub enum Severity:
    SeverityInfo
    SeverityWarning
    SeverityError
    SeverityBug
.end

pub struct Diagnostic:
    let severity: Severity
    let code: String
    let message: String

    let primary_span: Span
    let labels: Vec<Label>
    let notes: Vec<String>
.end

# ----------------------------------------------------------------------------
# DiagnosticsSink – alias simple
# ----------------------------------------------------------------------------

pub typedef Vec<Diagnostic> DiagnosticsSink

# ----------------------------------------------------------------------------
# Helpers de base : Span, Label
# ----------------------------------------------------------------------------

pub fn make_span(String file_id, u32 sl, u32 sc, u32 el, u32 ec) -> Span:
    let sp = Span(
        file_id = file_id,
        start_line = sl,
        start_column = sc,
        end_line = el,
        end_column = ec
    )
    return sp
.end

pub fn make_dummy_span() -> Span:
    let sp = Span(
        file_id = "<dummy>",
        start_line = 0u32,
        start_column = 0u32,
        end_line = 0u32,
        end_column = 0u32
    )
    return sp
.end

pub fn make_primary_label(Span span, String message) -> Label:
    let lab = Label(
        is_primary = true,
        span = span,
        message = message
    )
    return lab
.end

pub fn make_secondary_label(Span span, String message) -> Label:
    let lab = Label(
        is_primary = false,
        span = span,
        message = message
    )
    return lab
.end

# ----------------------------------------------------------------------------
# Helpers sur DiagnosticsSink
# ----------------------------------------------------------------------------

pub fn diagnostics_new() -> DiagnosticsSink:
    let v = Vec<Diagnostic>::new()
    return v
.end

pub fn diagnostics_is_empty(DiagnosticsSink sink) -> Bool:
    return sink.len() == 0usize
.end

pub fn diagnostics_len(DiagnosticsSink sink) -> usize:
    let n = sink.len()
    return n
.end

pub fn diagnostics_has_errors(DiagnosticsSink sink) -> Bool:
    let n = sink.len()
    let i = 0usize

    while i < n:
        let d = sink[i]
        if d.severity == Severity::SeverityError or d.severity == Severity::SeverityBug:
            return true
        .end
        i = i + 1usize
    .end

    return false
.end

pub fn diagnostics_error_count(DiagnosticsSink sink) -> u32:
    let n = sink.len()
    let i = 0usize
    let count = 0u32

    while i < n:
        let d = sink[i]
        if d.severity == Severity::SeverityError or d.severity == Severity::SeverityBug:
            count = count + 1u32
        .end
        i = i + 1usize
    .end

    return count
.end

pub fn diagnostics_warning_count(DiagnosticsSink sink) -> u32:
    let n = sink.len()
    let i = 0usize
    let count = 0u32

    while i < n:
        let d = sink[i]
        if d.severity == Severity::SeverityWarning:
            count = count + 1u32
        .end
        i = i + 1usize
    .end

    return count
.end

# ----------------------------------------------------------------------------
# Constructeurs génériques de Diagnostic
# ----------------------------------------------------------------------------

fn diag_new(
    Severity sev,
    String code,
    String message,
    Span span
) -> Diagnostic:
    let labels = Vec<Label>::new()
    let notes = Vec<String>::new()

    let d = Diagnostic(
        severity = sev,
        code = code,
        message = message,
        primary_span = span,
        labels = labels,
        notes = notes
    )
    return d
.end

pub fn make_info(String message, Span span) -> Diagnostic:
    let d = diag_new(Severity::SeverityInfo, "I-000", message, span)
    return d
.end

pub fn make_warning(String message, Span span) -> Diagnostic:
    let d = diag_new(Severity::SeverityWarning, "W-000", message, span)
    return d
.end

pub fn make_error(String message, Span span) -> Diagnostic:
    let d = diag_new(Severity::SeverityError, "E-000", message, span)
    return d
.end

pub fn make_bug(String message, Span span) -> Diagnostic:
    let d = diag_new(Severity::SeverityBug, "B-000", message, span)
    return d
.end

# ----------------------------------------------------------------------------
# Constructeurs spécialisés pour les sous-systèmes du compilateur
# ----------------------------------------------------------------------------

# Backends -------------------------------------------------------------------

pub fn make_backend_error(String message, Span span) -> Diagnostic:
    let d = diag_new(Severity::SeverityError, "E-Backend", message, span)
    return d
.end

pub fn make_backend_info(String message, Span span) -> Diagnostic:
    let d = diag_new(Severity::SeverityInfo, "I-Backend", message, span)
    return d
.end

# Borrow checker -------------------------------------------------------------

pub fn make_borrowck_error(String message, Span span) -> Diagnostic:
    let d = diag_new(Severity::SeverityError, "E-Borrowck", message, span)
    return d
.end

# Async / tâches -------------------------------------------------------------

pub fn make_async_error(String message, Span span) -> Diagnostic:
    let d = diag_new(Severity::SeverityError, "E-Async", message, span)
    return d
.end

# ----------------------------------------------------------------------------
# Helpers pour ajouter des labels / notes à un Diagnostic
# ----------------------------------------------------------------------------

pub fn diagnostic_add_label(Diagnostic d, Label lab) -> Diagnostic:
    let labs = d.labels
    labs.push(lab)

    let out = Diagnostic(
        severity = d.severity,
        code = d.code,
        message = d.message,
        primary_span = d.primary_span,
        labels = labs,
        notes = d.notes
    )
    return out
.end

pub fn diagnostic_add_note(Diagnostic d, String note) -> Diagnostic:
    let notes = d.notes
    notes.push(note)

    let out = Diagnostic(
        severity = d.severity,
        code = d.code,
        message = d.message,
        primary_span = d.primary_span,
        labels = d.labels,
        notes = notes
    )
    return out
.end

# ----------------------------------------------------------------------------
# Notes
# ----------------------------------------------------------------------------
# - DiagnosticsSink est un simple alias vers Vec<Diagnostic> afin de pouvoir
#   utiliser directement les méthodes de Vec, notamment `push` dans l'ensemble
#   du compilateur.
# - Les codes "I-000", "W-000", "E-000" servent de valeurs par défaut; les
#   couches supérieures peuvent définir des conventions plus riches (E0001,
#   W1234, etc.).
# - Les helpers spécialisés (make_backend_error, make_borrowck_error,
#   make_async_error) sont pensés pour s'aligner avec les modules backends,
#   borrowck et async que tu as ajoutés.
# ----------------------------------------------------------------------------

# ----------------------------------------------------------------------------
# Constructeurs spécialisés supplémentaires (lexing, parsing, typage, Muffin)
# ----------------------------------------------------------------------------

pub fn make_lex_error(String message, Span span) -> Diagnostic:
    let d = diag_new(Severity::SeverityError, "E-Lex", message, span)
    return d
.end

pub fn make_parse_error(String message, Span span) -> Diagnostic:
    let d = diag_new(Severity::SeverityError, "E-Parse", message, span)
    return d
.end

pub fn make_name_resolution_error(String message, Span span) -> Diagnostic:
    let d = diag_new(Severity::SeverityError, "E-Name", message, span)
    return d
.end

pub fn make_type_error(String message, Span span) -> Diagnostic:
    let d = diag_new(Severity::SeverityError, "E-Type", message, span)
    return d
.end

pub fn make_muffin_error(String message, Span span) -> Diagnostic:
    let d = diag_new(Severity::SeverityError, "E-Muffin", message, span)
    return d
.end

pub fn make_frontend_error(String message, Span span) -> Diagnostic:
    let d = diag_new(Severity::SeverityError, "E-Frontend", message, span)
    return d
.end

pub fn make_frontend_info(String message, Span span) -> Diagnostic:
    let d = diag_new(Severity::SeverityInfo, "I-Frontend", message, span)
    return d
.end

# ----------------------------------------------------------------------------
# Helpers génériques sur Diagnostic
# ----------------------------------------------------------------------------

pub fn diagnostic_is_error(Diagnostic d) -> Bool:
    if d.severity == Severity::SeverityError or d.severity == Severity::SeverityBug:
        return true
    .end
    return false
.end

pub fn diagnostic_is_warning(Diagnostic d) -> Bool:
    return d.severity == Severity::SeverityWarning
.end

pub fn diagnostic_is_info(Diagnostic d) -> Bool:
    return d.severity == Severity::SeverityInfo
.end

pub fn severity_to_string(Severity s) -> String:
    if s == Severity::SeverityInfo:
        return "info"
    .end

    if s == Severity::SeverityWarning:
        return "warning"
    .end

    if s == Severity::SeverityError:
        return "error"
    .end

    if s == Severity::SeverityBug:
        return "bug"
    .end

    return "unknown"
.end

pub fn severity_is_strictly_worse(Severity a, Severity b) -> Bool:
    # Convention de sévérité croissante : Info < Warning < Error < Bug
    let rank_a = severity_rank(a)
    let rank_b = severity_rank(b)
    return rank_a > rank_b
.end

fn severity_rank(Severity s) -> u32:
    if s == Severity::SeverityInfo:
        return 0u32
    .end

    if s == Severity::SeverityWarning:
        return 1u32
    .end

    if s == Severity::SeverityError:
        return 2u32
    .end

    if s == Severity::SeverityBug:
        return 3u32
    .end

    return 4u32
.end

# ----------------------------------------------------------------------------
# Helpers avancés sur DiagnosticsSink (fusion, max severity, filtrage)
# ----------------------------------------------------------------------------

pub fn diagnostics_merge(DiagnosticsSink a, DiagnosticsSink b) -> DiagnosticsSink:
    let out = a
    let n = b.len()
    let i = 0usize

    while i < n:
        let d = b[i]
        out.push(d)
        i = i + 1usize
    .end

    return out
.end

pub fn diagnostics_max_severity(DiagnosticsSink sink) -> Option<Severity>:
    let n = sink.len()
    if n == 0usize:
        let none_s: Option<Severity> = Option<Severity>::None()
        return none_s
    .end

    let i = 0usize
    let current = sink[0usize].severity

    while i < n:
        let d = sink[i]
        if severity_is_strictly_worse(d.severity, current):
            let current2 = d.severity
            # On écrase la valeur courante
            let current = current2
        .end
        i = i + 1usize
    .end

    let some_s: Option<Severity> = Option<Severity>::Some(current)
    return some_s
.end

pub fn diagnostics_filter_by_severity(DiagnosticsSink sink, Severity threshold) -> DiagnosticsSink:
    # Conserve uniquement les diagnostics dont la sévérité est >= threshold.
    let out = diagnostics_new()
    let n = sink.len()
    let i = 0usize

    while i < n:
        let d = sink[i]
        let r_d = severity_rank(d.severity)
        let r_t = severity_rank(threshold)
        if r_d >= r_t:
            out.push(d)
        .end
        i = i + 1usize
    .end

    return out
.end

pub fn diagnostics_info_only(DiagnosticsSink sink) -> DiagnosticsSink:
    let out = diagnostics_new()
    let n = sink.len()
    let i = 0usize

    while i < n:
        let d = sink[i]
        if diagnostic_is_info(d):
            out.push(d)
        .end
        i = i + 1usize
    .end

    return out
.end

pub fn diagnostics_warnings_only(DiagnosticsSink sink) -> DiagnosticsSink:
    let out = diagnostics_new()
    let n = sink.len()
    let i = 0usize

    while i < n:
        let d = sink[i]
        if diagnostic_is_warning(d):
            out.push(d)
        .end
        i = i + 1usize
    .end

    return out
.end

pub fn diagnostics_errors_only(DiagnosticsSink sink) -> DiagnosticsSink:
    let out = diagnostics_new()
    let n = sink.len()
    let i = 0usize

    while i < n:
        let d = sink[i]
        if diagnostic_is_error(d):
            out.push(d)
        .end
        i = i + 1usize
    .end

    return out
.end