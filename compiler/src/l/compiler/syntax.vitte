module vitte.compiler.syntax

import std.collections as coll
import vitte.compiler.span as span

# =============================================================================
# Vitte compiler – Syntax tree / HIR model (maximal, logique, sans I/O)
# =============================================================================
#
# Objectifs :
#   - Fournir une représentation logique des éléments syntaxiques/HIR
#     correspondant à la grammaire Vitte (noyau + scénarios).
#   - Indexation par IDs (arena-based) pour un accès rapide et stable :
#       * ItemId, StmtId, ExprId, PatternId, TypeExprId, AttributeId, PathId.
#   - Aucune dépendance I/O, pas de backend, pas de runtime spécifique.
#   - Données faciles à sérialiser (JSON / Muffin / autre).
# =============================================================================

# -----------------------------------------------------------------------------
# Identifiants de nœuds
# -----------------------------------------------------------------------------

typedef u32 ItemId
typedef u32 StmtId
typedef u32 ExprId
typedef u32 PatternId
typedef u32 TypeExprId
typedef u32 AttributeId
typedef u32 PathId
typedef u32 ParameterId
typedef u32 FieldId
typedef u32 VariantId

# -----------------------------------------------------------------------------
# Kinds de haut niveau
# -----------------------------------------------------------------------------

pub enum ItemKind:
    ItemKindModule
    ItemKindImport
    ItemKindExport
    ItemKindMuffinManifest
    ItemKindStruct
    ItemKindUnion
    ItemKindEnum
    ItemKindTypedef
    ItemKindTrait
    ItemKindImpl
    ItemKindFunction
    ItemKindScenario
    ItemKindEntryPoint
    ItemKindTopLevelLet
    ItemKindTopLevelConst
    ItemKindTopLevelExpr
.end

pub enum EntryPointKind:
    EntryPointProgram
    EntryPointService
    EntryPointKernel
    EntryPointDriver
    EntryPointTool
    EntryPointScenario
    EntryPointPipeline
.end

pub enum StmtKind:
    StmtKindLet
    StmtKindConst
    StmtKindAssign
    StmtKindExpr
    StmtKindIf
    StmtKindWhile
    StmtKindFor
    StmtKindMatch
    StmtKindBreak
    StmtKindContinue
    StmtKindReturn
.end

pub enum ExprKind:
    ExprKindLiteral
    ExprKindPath
    ExprKindCall
    ExprKindUnary
    ExprKindBinary
    ExprKindCast
    ExprKindSizeOf
    ExprKindAlignOf
    ExprKindList
    ExprKindMap
    ExprKindIndex
    ExprKindFieldAccess
    ExprKindArrowFieldAccess
    ExprKindTuple
.end

pub enum PatternKind:
    PatternKindWildcard
    PatternKindLiteral
    PatternKindName
    PatternKindTuple
    PatternKindList
.end

pub enum TypeExprKind:
    TypeExprKindNamed
    TypeExprKindPointer
    TypeExprKindReference
    TypeExprKindArray
    TypeExprKindFunctionPointer
.end

pub enum LiteralKind:
    LiteralKindInteger
    LiteralKindFloat
    LiteralKindString
    LiteralKindBool
    LiteralKindNull
.end

pub enum UnaryOp:
    UnaryOpNegate          # -
    UnaryOpLogicalNot      # not
    UnaryOpAddressOf       # &
    UnaryOpDeref           # *
    UnaryOpBitNot          # ~
.end

pub enum BinaryOp:
    BinaryOpAdd
    BinaryOpSub
    BinaryOpMul
    BinaryOpDiv
    BinaryOpRem
    BinaryOpEq
    BinaryOpNe
    BinaryOpLt
    BinaryOpLe
    BinaryOpGt
    BinaryOpGe
    BinaryOpAnd
    BinaryOpOr
    BinaryOpBitAnd
    BinaryOpBitOr
    BinaryOpBitXor
    BinaryOpShl
    BinaryOpShr
    BinaryOpPipeForward    # |>
.end

pub enum AssignmentOp:
    AssignmentOpAssign      # =
    AssignmentOpAddAssign   # +=
    AssignmentOpSubAssign   # -=
    AssignmentOpMulAssign   # *=
    AssignmentOpDivAssign   # /=
    AssignmentOpBitAndAssign # &=
    AssignmentOpBitOrAssign  # |=
    AssignmentOpBitXorAssign # ^=
    AssignmentOpShlAssign    # <<=
    AssignmentOpShrAssign    # >>=
.end

# -----------------------------------------------------------------------------
# Chemins qualifiés, attributs, paramètres
# -----------------------------------------------------------------------------

pub struct PathSegment:
    let name: String
    let generic_args: Vec<TypeExprId>   # arguments de type optionnels
.end

pub struct Path:
    let id: PathId
    let segments: Vec<PathSegment>
    let span: span.Span
.end

pub struct AttributeArg:
    let expr: ExprId
.end

pub struct Attribute:
    let id: AttributeId
    let name: PathId               # chemin de l'attribut : @foo, @mod.foo, ...
    let args: Vec<AttributeArg>
    let span: span.Span
.end

pub enum Visibility:
    VisibilityPublic
    VisibilityPrivate
.end

pub enum StorageSpecifier:
    StorageSpecifierNone
    StorageSpecifierExtern
    StorageSpecifierStatic
.end

pub struct Parameter:
    let id: ParameterId
    let name: String
    let type_expr: TypeExprId
    let span: span.Span
.end

# -----------------------------------------------------------------------------
# Représentation des types
# -----------------------------------------------------------------------------

pub struct TypeExprNamed:
    let path: PathId
.end

pub struct TypeExprPointer:
    let is_const: bool
    let is_volatile: bool
    let is_restrict: bool
    let base: TypeExprId
.end

pub struct TypeExprReference:
    let is_const: bool
    let is_volatile: bool
    let is_restrict: bool
    let base: TypeExprId
.end

pub struct TypeExprArray:
    let element: TypeExprId
    let length: coll.Option<ExprId>   # length optionnelle (constant expr)
.end

pub struct TypeExprFunctionPointer:
    let params: Vec<ParameterId>
    let result: coll.Option<TypeExprId>
.end

pub struct TypeExpr:
    let id: TypeExprId
    let kind: TypeExprKind
    let span: span.Span
    let named: TypeExprNamed
    let ptr: TypeExprPointer
    let reference: TypeExprReference
    let array: TypeExprArray
    let fn_ptr: TypeExprFunctionPointer
.end

# -----------------------------------------------------------------------------
# Littéraux et expressions
# -----------------------------------------------------------------------------

pub struct Literal:
    let kind: LiteralKind
    let text: String           # représentation textuelle (ex: "123", "1.2e3")
    let span: span.Span
.end

pub struct ExprLiteral:
    let value: Literal
.end

pub struct ExprPath:
    let path: PathId
.end

pub struct ExprCall:
    let callee: ExprId
    let args: Vec<ExprId>
.end

pub struct ExprUnary:
    let op: UnaryOp
    let operand: ExprId
.end

pub struct ExprBinary:
    let op: BinaryOp
    let left: ExprId
    let right: ExprId
.end

pub struct ExprCast:
    let expr: ExprId
    let target_type: TypeExprId
.end

pub struct ExprSizeOf:
    let type_expr: TypeExprId
.end

pub struct ExprAlignOf:
    let type_expr: TypeExprId
.end

pub struct ExprList:
    let elements: Vec<ExprId>
.end

pub struct MapEntry:
    let key: ExprId
    let value: ExprId
.end

pub struct ExprMap:
    let entries: Vec<MapEntry>
.end

pub struct ExprIndex:
    let target: ExprId
    let index: ExprId
.end

pub struct ExprFieldAccess:
    let target: ExprId
    let field_name: String
.end

pub struct ExprArrowFieldAccess:
    let target: ExprId
    let field_name: String
.end

pub struct ExprTuple:
    let elements: Vec<ExprId>
.end

pub struct Expr:
    let id: ExprId
    let kind: ExprKind
    let span: span.Span
    let lit: ExprLiteral
    let path: ExprPath
    let call: ExprCall
    let unary: ExprUnary
    let binary: ExprBinary
    let cast: ExprCast
    let sizeof: ExprSizeOf
    let alignof: ExprAlignOf
    let list: ExprList
    let map: ExprMap
    let index: ExprIndex
    let field: ExprFieldAccess
    let arrow_field: ExprArrowFieldAccess
    let tuple_: ExprTuple
.end

# -----------------------------------------------------------------------------
# Patterns
# -----------------------------------------------------------------------------

pub struct PatternWildcard:
    let underscore_span: span.Span
.end

pub struct PatternLiteral:
    let literal: Literal
.end

pub struct PatternName:
    let name: String
.end

pub struct PatternTuple:
    let elements: Vec<PatternId>
.end

pub struct PatternList:
    let elements: Vec<PatternId>
.end

pub struct Pattern:
    let id: PatternId
    let kind: PatternKind
    let span: span.Span
    let wildcard: PatternWildcard
    let lit: PatternLiteral
    let name: PatternName
    let tuple_: PatternTuple
    let list: PatternList
.end

# -----------------------------------------------------------------------------
# Instructions / blocs
# -----------------------------------------------------------------------------

pub struct StmtLet:
    let name: String
    let value: ExprId
.end

pub struct StmtConst:
    let name: String
    let value: ExprId
.end

pub struct AssignTarget:
    let base: ExprId              # expression cible (path/index/field)
.end

pub struct StmtAssign:
    let target: AssignTarget
    let op: AssignmentOp
    let value: ExprId
.end

pub struct StmtExpr:
    let expr: ExprId
.end

pub struct StmtIfBranch:
    let condition: ExprId
    let block: Vec<StmtId>
.end

pub struct StmtIf:
    let if_branch: StmtIfBranch
    let elif_branches: Vec<StmtIfBranch>
    let else_block: Vec<StmtId>
    let has_else: bool
.end

pub struct StmtWhile:
    let condition: ExprId
    let body: Vec<StmtId>
.end

pub struct StmtFor:
    let pattern: PatternId
    let iterable: ExprId
    let body: Vec<StmtId>
.end

pub struct MatchArm:
    let pattern: PatternId
    let block: Vec<StmtId>
.end

pub struct StmtMatch:
    let scrutinee: ExprId
    let arms: Vec<MatchArm>
.end

pub struct StmtReturn:
    let value: coll.Option<ExprId>
.end

pub struct Stmt:
    let id: StmtId
    let kind: StmtKind
    let span: span.Span
    let let_: StmtLet
    let const_: StmtConst
    let assign: StmtAssign
    let expr: StmtExpr
    let if_: StmtIf
    let while_: StmtWhile
    let for_: StmtFor
    let match_: StmtMatch
    let ret: StmtReturn
.end

# -----------------------------------------------------------------------------
# Déclarations de types / traits / impl
# -----------------------------------------------------------------------------

pub struct Field:
    let id: FieldId
    let name: String
    let type_expr: TypeExprId
    let init_expr: coll.Option<ExprId>
    let span: span.Span
.end

pub struct Variant:
    let id: VariantId
    let name: String
    let value_expr: coll.Option<ExprId>
    let span: span.Span
.end

pub struct StructDecl:
    let name: String
    let fields: Vec<FieldId>
    let attributes: Vec<AttributeId>
.end

pub struct UnionDecl:
    let name: String
    let fields: Vec<FieldId>
    let attributes: Vec<AttributeId>
.end

pub struct EnumDecl:
    let name: String
    let variants: Vec<VariantId>
    let attributes: Vec<AttributeId>
.end

pub struct TypedefDecl:
    let name: String
    let aliased_type: TypeExprId
    let attributes: Vec<AttributeId>
.end

pub struct TraitDecl:
    let name: String
    let items: Vec<ItemId>            # méthodes / types associés
    let attributes: Vec<AttributeId>
.end

pub struct ImplDecl:
    let target_type: TypeExprId
    let trait_path: coll.Option<PathId>
    let items: Vec<ItemId>            # fonctions / types associés
    let attributes: Vec<AttributeId>
.end

# -----------------------------------------------------------------------------
# Fonctions, scénarios, points d'entrée
# -----------------------------------------------------------------------------

pub struct FnDecl:
    let name: String
    let visibility: Visibility
    let storage: StorageSpecifier
    let is_inline: bool
    let params: Vec<ParameterId>
    let result_type: coll.Option<TypeExprId>
    let body: Vec<StmtId>
    let attributes: Vec<AttributeId>
.end

pub struct ScenarioDecl:
    let name: String
    let body: Vec<StmtId>
    let attributes: Vec<AttributeId>
.end

pub struct EntryPointDecl:
    let kind: EntryPointKind
    let module_path: PathId
    let body: Vec<StmtId>
    let attributes: Vec<AttributeId>
.end

# -----------------------------------------------------------------------------
# Modules, imports, exports, manifestes Muffin
# -----------------------------------------------------------------------------

pub struct ModuleDecl:
    let path: PathId
.end

pub struct ImportAlias:
    let name: String
    let span: span.Span
.end

pub struct ImportItem:
    let module_path: PathId
    let alias: coll.Option<ImportAlias>
.end

pub struct ImportDecl:
    let items: Vec<ImportItem>
.end

pub enum ExportItemKind:
    ExportItemKindAll
    ExportItemKindNames
.end

pub struct ExportItem:
    let name: String
    let span: span.Span
.end

pub struct ExportDecl:
    let kind: ExportItemKind
    let names: Vec<ExportItem>
    let from_module: coll.Option<PathId>
.end

pub struct MuffinProperty:
    let key: String
    let value_expr: ExprId        # littéral, liste, map, ...
.end

pub struct MuffinManifestDecl:
    let file_path_literal: ExprId # string literal path
    let properties: Vec<MuffinProperty>
.end

# -----------------------------------------------------------------------------
# Item racine
# -----------------------------------------------------------------------------

pub struct Item:
    let id: ItemId
    let kind: ItemKind
    let span: span.Span
    let attributes: Vec<AttributeId>
    let module_: ModuleDecl
    let import_: ImportDecl
    let export_: ExportDecl
    let muffin: MuffinManifestDecl
    let struct_: StructDecl
    let union_: UnionDecl
    let enum_: EnumDecl
    let typedef_: TypedefDecl
    let trait_: TraitDecl
    let impl_: ImplDecl
    let fn_: FnDecl
    let scenario_: ScenarioDecl
    let entry_point: EntryPointDecl
    let top_level_let: StmtLet
    let top_level_const: StmtConst
    let top_level_expr: StmtExpr
.end

# -----------------------------------------------------------------------------
# Arbre global de syntaxe / HIR
# -----------------------------------------------------------------------------

pub struct SyntaxTree:
    let items: Vec<Item>
    let stmts: Vec<Stmt>
    let exprs: Vec<Expr>
    let patterns: Vec<Pattern>
    let types: Vec<TypeExpr>
    let attributes: Vec<Attribute>
    let paths: Vec<Path>
    let parameters: Vec<Parameter>
    let fields: Vec<Field>
    let variants: Vec<Variant>
.end

# -----------------------------------------------------------------------------
# Helpers de construction simples
# -----------------------------------------------------------------------------

pub fn syntax_tree_new() -> SyntaxTree:
    let items = Vec<Item>::new()
    let stmts = Vec<Stmt>::new()
    let exprs = Vec<Expr>::new()
    let patterns = Vec<Pattern>::new()
    let types = Vec<TypeExpr>::new()
    let attrs = Vec<Attribute>::new()
    let paths = Vec<Path>::new()
    let params = Vec<Parameter>::new()
    let fields = Vec<Field>::new()
    let variants = Vec<Variant>::new()

    let tree = SyntaxTree {
        items: items,
        stmts: stmts,
        exprs: exprs,
        patterns: patterns,
        types: types,
        attributes: attrs,
        paths: paths,
        parameters: params,
        fields: fields,
        variants: variants
    }
    return tree
.end

fn next_item_id(tree: SyntaxTree) -> ItemId:
    let n = tree.items.len()
    return (ItemId) n
.end

fn next_stmt_id(tree: SyntaxTree) -> StmtId:
    let n = tree.stmts.len()
    return (StmtId) n
.end

fn next_expr_id(tree: SyntaxTree) -> ExprId:
    let n = tree.exprs.len()
    return (ExprId) n
.end

fn next_pattern_id(tree: SyntaxTree) -> PatternId:
    let n = tree.patterns.len()
    return (PatternId) n
.end

fn next_type_expr_id(tree: SyntaxTree) -> TypeExprId:
    let n = tree.types.len()
    return (TypeExprId) n
.end

fn next_attribute_id(tree: SyntaxTree) -> AttributeId:
    let n = tree.attributes.len()
    return (AttributeId) n
.end

fn next_path_id(tree: SyntaxTree) -> PathId:
    let n = tree.paths.len()
    return (PathId) n
.end

fn next_parameter_id(tree: SyntaxTree) -> ParameterId:
    let n = tree.parameters.len()
    return (ParameterId) n
.end

fn next_field_id(tree: SyntaxTree) -> FieldId:
    let n = tree.fields.len()
    return (FieldId) n
.end

fn next_variant_id(tree: SyntaxTree) -> VariantId:
    let n = tree.variants.len()
    return (VariantId) n
.end

# -----------------------------------------------------------------------------
# Ajout de chemins & attributs
# -----------------------------------------------------------------------------

pub fn syntax_tree_add_path(
    tree: SyntaxTree,
    segments: Vec<PathSegment>,
    span_value: span.Span
) -> (SyntaxTree, PathId):
    let items = tree.items
    let stmts = tree.stmts
    let exprs = tree.exprs
    let patterns = tree.patterns
    let types = tree.types
    let attrs = tree.attributes
    let paths = tree.paths
    let params = tree.parameters
    let fields = tree.fields
    let variants = tree.variants

    let new_id = next_path_id(tree)

    let p = Path {
        id: new_id,
        segments: segments,
        span: span_value
    }

    paths.push(p)

    let tree2 = SyntaxTree {
        items: items,
        stmts: stmts,
        exprs: exprs,
        patterns: patterns,
        types: types,
        attributes: attrs,
        paths: paths,
        parameters: params,
        fields: fields,
        variants: variants
    }

    let out = (tree2, new_id)
    return out
.end

pub fn syntax_tree_add_attribute(
    tree: SyntaxTree,
    name_path: PathId,
    args: Vec<AttributeArg>,
    span_value: span.Span
) -> (SyntaxTree, AttributeId):
    let items = tree.items
    let stmts = tree.stmts
    let exprs = tree.exprs
    let patterns = tree.patterns
    let types = tree.types
    let attrs = tree.attributes
    let paths = tree.paths
    let params = tree.parameters
    let fields = tree.fields
    let variants = tree.variants

    let new_id = next_attribute_id(tree)

    let a = Attribute {
        id: new_id,
        name: name_path,
        args: args,
        span: span_value
    }

    attrs.push(a)

    let tree2 = SyntaxTree {
        items: items,
        stmts: stmts,
        exprs: exprs,
        patterns: patterns,
        types: types,
        attributes: attrs,
        paths: paths,
        parameters: params,
        fields: fields,
        variants: variants
    }

    let out = (tree2, new_id)
    return out
.end

# -----------------------------------------------------------------------------
# Scénario interne de smoke-test
# -----------------------------------------------------------------------------

scenario syntax_smoke_test():
    let tree0 = syntax_tree_new()

    # Création d'un chemin "core.math/point"
    let seg1 = PathSegment { name: "core", generic_args: Vec<TypeExprId>::new() }
    let seg2 = PathSegment { name: "math", generic_args: Vec<TypeExprId>::new() }
    let seg3 = PathSegment { name: "point", generic_args: Vec<TypeExprId>::new() }

    let segs = Vec<PathSegment>::new()
    segs.push(seg1)
    segs.push(seg2)
    segs.push(seg3)

    let sp = span.span_empty_at((span.BytePos) 0)
    let (tree1, path_id) = syntax_tree_add_path(tree0, segs, sp)

    # Création d'un attribut @inline
    let seg_inline = PathSegment { name: "inline", generic_args: Vec<TypeExprId>::new() }
    let segs_inline = Vec<PathSegment>::new()
    segs_inline.push(seg_inline)

    let sp_inline = span.span_empty_at((span.BytePos) 1)
    let (tree2, inline_path) = syntax_tree_add_path(tree1, segs_inline, sp_inline)

    let attr_args = Vec<AttributeArg>::new()
    let (tree3, _attr_id) = syntax_tree_add_attribute(tree2, inline_path, attr_args, sp_inline)

    let _ = path_id
    let _ = tree3
.end
