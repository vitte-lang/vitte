module vitte.compiler.lsp

import vitte.compiler.collections as coll
import vitte.compiler.diagnostics as diag
import vitte.compiler.language as lang
import vitte.compiler.hir as hir
import vitte.compiler.linker as link
import vitte.compiler.llvm as llvm

# ============================================================================
# Vitte compiler – LSP core (maximal, déclaratif)
#
# Objectifs :
#   - Représenter les structures de base du protocole LSP (positions, ranges,
#     diagnostics, documents, workspace).
#   - Modéliser l'état du serveur LSP pour Vitte et son interaction avec
#     la pipeline de compilation (analyse, HIR, link, LLVM).
#   - Fournir des handlers purement logiques pour les requêtes LSP de haut
#     niveau (initialize, didOpen, didChange, diagnostics).
#
# Remarque : ce module ne gère pas le transport JSON-RPC; il sert de noyau
# logique pour un serveur LSP implémenté ailleurs (bindings C/Rust, etc.).
# ============================================================================

# ----------------------------------------------------------------------------
# Positions, ranges, locations
# ----------------------------------------------------------------------------

pub struct LspPosition:
    let line: u32
    let character: u32
.end

pub struct LspRange:
    let start: LspPosition
    let end: LspPosition
.end

pub struct LspLocation:
    let uri: String
    let range: LspRange
.end

pub fn lsp_position_new(u32 line, u32 character) -> LspPosition:
    let p = LspPosition(
        line = line,
        character = character
    )
    return p
.end

pub fn lsp_range_new(LspPosition start, LspPosition end) -> LspRange:
    let r = LspRange(
        start = start,
        end = end
    )
    return r
.end

# ----------------------------------------------------------------------------
# Diagnostics LSP
# ----------------------------------------------------------------------------

pub enum LspDiagnosticSeverity:
    LspDiagnosticSeverityError
    LspDiagnosticSeverityWarning
    LspDiagnosticSeverityInformation
    LspDiagnosticSeverityHint
.end

pub struct LspDiagnostic:
    let range: LspRange
    let severity: LspDiagnosticSeverity
    let code: String
    let source: String
    let message: String
.end

pub fn lsp_diagnostic_new(
    LspRange range,
    LspDiagnosticSeverity severity,
    String code,
    String source,
    String message
) -> LspDiagnostic:
    let d = LspDiagnostic(
        range = range,
        severity = severity,
        code = code,
        source = source,
        message = message
    )
    return d
.end

pub fn lsp_diagnostic_severity_from_diag(diag.Severity s) -> LspDiagnosticSeverity:
    if s == diag.Severity::SeverityError:
        return LspDiagnosticSeverity::LspDiagnosticSeverityError
    .end
    if s == diag.Severity::SeverityWarning:
        return LspDiagnosticSeverity::LspDiagnosticSeverityWarning
    .end
    if s == diag.Severity::SeverityInfo:
        return LspDiagnosticSeverity::LspDiagnosticSeverityInformation
    .end
    if s == diag.Severity::SeverityHint:
        return LspDiagnosticSeverity::LspDiagnosticSeverityHint
    .end
    return LspDiagnosticSeverity::LspDiagnosticSeverityInformation
.end

# Placeholder : la conversion Span -> Range dépend de la gestion fine des
# offsets. On met en place un stub conservatif pour l'instant.
pub fn lsp_range_from_span(diag.Span span) -> LspRange:
    let start = lsp_position_new(span.start_line, span.start_col)
    let end = lsp_position_new(span.end_line, span.end_col)
    let r = lsp_range_new(start, end)
    return r
.end

pub fn lsp_diagnostics_from_sink(diag.DiagnosticsSink sink) -> Vec<LspDiagnostic>:
    let out: Vec<LspDiagnostic> = Vec<LspDiagnostic>::new()
    let diags = diag.diagnostics_as_vec(sink)
    let n = diags.len()
    let i = 0usize
    let out_acc = out

    while i < n:
        let d = diags[i]
        let range = lsp_range_from_span(d.span)
        let severity = lsp_diagnostic_severity_from_diag(d.severity)
        let code = d.code
        let source = "vitte"
        let ld = lsp_diagnostic_new(range, severity, code, source, d.message)
        out_acc.push(ld)
        i = i + 1usize
    .end

    return out_acc
.end

# ----------------------------------------------------------------------------
# Text documents et workspace
# ----------------------------------------------------------------------------

pub struct LspTextDocumentIdentifier:
    let uri: String
.end

pub struct LspVersionedTextDocumentIdentifier:
    let uri: String
    let version: i32
.end

pub struct LspTextDocument:
    let uri: String
    let language_id: String
    let version: i32
    let text: String
    let line_offsets: Vec<usize>    # offset byte du début de chaque ligne
.end

pub fn lsp_text_document_new(
    String uri,
    String language_id,
    i32 version,
    String text
) -> LspTextDocument:
    let offsets = lsp_compute_line_offsets(text)
    let doc = LspTextDocument(
        uri = uri,
        language_id = language_id,
        version = version,
        text = text,
        line_offsets = offsets
    )
    return doc
.end

# Calcule les offsets de début de ligne dans une chaîne UTF-8.
pub fn lsp_compute_line_offsets(String text) -> Vec<usize>:
    let offsets: Vec<usize> = Vec<usize>::new()
    offsets.push(0usize)

    let bytes = text.as_bytes()
    let n = bytes.len()
    let i = 0usize

    while i < n:
        let b = bytes[i]
        if b == 10u8: # '\n'
            let next = i + 1usize
            if next < n:
                offsets.push(next)
            .end
        .end
        i = i + 1usize
    .end

    return offsets
.end

pub fn lsp_document_offset_from_position(LspTextDocument doc, LspPosition pos) -> usize:
    let line = pos.line as usize
    let col = pos.character as usize
    let offsets = doc.line_offsets
    let line_count = offsets.len()

    if line >= line_count:
        # position hors range -> clamp à la fin du texte
        return doc.text.len()
    .end

    let base = offsets[line]
    let offset = base + col
    let len = doc.text.len()
    if offset > len:
        return len
    .end
    return offset
.end

pub fn lsp_document_position_from_offset(LspTextDocument doc, usize offset) -> LspPosition:
    let len = doc.text.len()
    let off = offset
    if off > len:
        let off = len
    .end

    let offsets = doc.line_offsets
    let n = offsets.len()
    let i = 0usize
    let line = 0usize

    while i + 1usize < n and offsets[i + 1usize] <= off:
        let i = i + 1usize
    .end

    let line = i
    let base = offsets[line]
    let col = off - base

    let p = lsp_position_new(line as u32, col as u32)
    return p
.end

pub struct LspWorkspaceFile:
    let uri: String
    let language_id: String
    let version: i32
.end

pub struct LspWorkspace:
    let documents: coll.SmallMap<String, LspTextDocument>
    let config: lang.LanguageConfig
.end

pub fn lsp_workspace_new(lang.LanguageConfig cfg) -> LspWorkspace:
    let docs = coll.small_map_new<String, LspTextDocument>()
    let ws = LspWorkspace(
        documents = docs,
        config = cfg
    )
    return ws
.end

pub fn lsp_workspace_open_document(
    LspWorkspace ws,
    String uri,
    String language_id,
    i32 version,
    String text
) -> LspWorkspace:
    let doc = lsp_text_document_new(uri, language_id, version, text)
    let docs = ws.documents
    let docs2 = coll.small_map_insert<String, LspTextDocument>(docs, doc.uri, doc)
    let ws2 = LspWorkspace(
        documents = docs2,
        config = ws.config
    )
    return ws2
.end

pub fn lsp_workspace_close_document(
    LspWorkspace ws,
    String uri
) -> LspWorkspace:
    let docs = ws.documents
    let docs2 = coll.small_map_remove<String, LspTextDocument>(docs, uri)
    let ws2 = LspWorkspace(
        documents = docs2,
        config = ws.config
    )
    return ws2
.end

pub fn lsp_workspace_get_document(
    LspWorkspace ws,
    String uri
) -> Option<LspTextDocument>:
    let docs = ws.documents
    let doc_opt = coll.small_map_get<String, LspTextDocument>(docs, uri)
    return doc_opt
.end

# ----------------------------------------------------------------------------
# État du serveur LSP
# ----------------------------------------------------------------------------

pub struct LspServerCapabilities:
    let supports_diagnostics: Bool
    let supports_hover: Bool
    let supports_completion: Bool
    let supports_definition: Bool
    let supports_semantic_tokens: Bool
    let supports_workspace_folders: Bool
.end

pub struct LspServerState:
    let workspace: LspWorkspace
    let language_profile: lang.LanguageProfile
    let last_diagnostics: coll.SmallMap<String, Vec<LspDiagnostic>>
    let capabilities: LspServerCapabilities
.end

pub fn lsp_server_capabilities_default() -> LspServerCapabilities:
    let caps = LspServerCapabilities(
        supports_diagnostics = true,
        supports_hover = true,
        supports_completion = true,
        supports_definition = true,
        supports_semantic_tokens = false,
        supports_workspace_folders = false
    )
    return caps
.end

pub fn lsp_server_state_new(lang.LanguageProfile profile) -> LspServerState:
    let cfg = profile.config
    let ws = lsp_workspace_new(cfg)
    let caps = lsp_server_capabilities_default()
    let diags = coll.small_map_new<String, Vec<LspDiagnostic>>()

    let st = LspServerState(
        workspace = ws,
        language_profile = profile,
        last_diagnostics = diags,
        capabilities = caps
    )
    return st
.end

# ----------------------------------------------------------------------------
# Initialize / capabilities
# ----------------------------------------------------------------------------

pub struct LspInitializeParams:
    let root_uri: String
    let client_name: String
    let client_version: String
.end

pub struct LspInitializeResult:
    let server_name: String
    let server_version: String
    let capabilities: LspServerCapabilities
.end

pub fn lsp_handle_initialize(
    LspServerState state,
    LspInitializeParams params
) -> (LspServerState, LspInitializeResult):
    let server_name = "Vitte LSP"
    let server_version = "0.1.0-dev"
    let caps = state.capabilities

    let res = LspInitializeResult(
        server_name = server_name,
        server_version = server_version,
        capabilities = caps
    )

    let out = (state, res)
    return out
.end

# ----------------------------------------------------------------------------
# Notifications de documents : didOpen / didChange / didClose
# ----------------------------------------------------------------------------

pub struct LspDidOpenTextDocumentParams:
    let text_document: LspTextDocument
.end

pub struct LspDidChangeTextDocumentParams:
    let uri: String
    let version: i32
    let text: String
.end

pub struct LspDidCloseTextDocumentParams:
    let uri: String
.end

pub fn lsp_handle_did_open(
    LspServerState state,
    LspDidOpenTextDocumentParams params
) -> LspServerState:
    let ws = state.workspace
    let doc = params.text_document
    let ws2 = lsp_workspace_open_document(ws, doc.uri, doc.language_id, doc.version, doc.text)

    let st2 = LspServerState(
        workspace = ws2,
        language_profile = state.language_profile,
        last_diagnostics = state.last_diagnostics,
        capabilities = state.capabilities
    )
    return st2
.end

pub fn lsp_handle_did_change(
    LspServerState state,
    LspDidChangeTextDocumentParams params
) -> LspServerState:
    let ws = state.workspace
    let ws2 = lsp_workspace_open_document(ws, params.uri, "vitte", params.version, params.text)

    let st2 = LspServerState(
        workspace = ws2,
        language_profile = state.language_profile,
        last_diagnostics = state.last_diagnostics,
        capabilities = state.capabilities
    )
    return st2
.end

pub fn lsp_handle_did_close(
    LspServerState state,
    LspDidCloseTextDocumentParams params
) -> LspServerState:
    let ws = state.workspace
    let ws2 = lsp_workspace_close_document(ws, params.uri)

    let st2 = LspServerState(
        workspace = ws2,
        language_profile = state.language_profile,
        last_diagnostics = state.last_diagnostics,
        capabilities = state.capabilities
    )
    return st2
.end

# ----------------------------------------------------------------------------
# Analyse / diagnostics pour un document (squelette)
# ----------------------------------------------------------------------------

pub struct LspDocumentDiagnosticsResult:
    let uri: String
    let diagnostics: Vec<LspDiagnostic>
.end

pub fn lsp_run_full_analysis_for_document(
    LspServerState state,
    String uri
) -> (LspServerState, LspDocumentDiagnosticsResult):
    # TODO : brancher ici le pipeline réel :
    #   - parser / AST
    #   - HIR
    #   - typecheck
    #   - link local / global
    #   - backends (optionnel) pour vérifier la génération
    #
    # Pour l'instant, on renvoie une liste vide de diagnostics.
    let ws = state.workspace
    let doc_opt = lsp_workspace_get_document(ws, uri)

    let diags: Vec<LspDiagnostic> = Vec<LspDiagnostic>::new()

    let result = LspDocumentDiagnosticsResult(
        uri = uri,
        diagnostics = diags
    )

    let st2 = state
    let out = (st2, result)
    return out
.end

pub fn lsp_record_diagnostics(
    LspServerState state,
    LspDocumentDiagnosticsResult res
) -> LspServerState:
    let last = state.last_diagnostics
    let m2 = coll.small_map_insert<String, Vec<LspDiagnostic>>(last, res.uri, res.diagnostics)

    let st2 = LspServerState(
        workspace = state.workspace,
        language_profile = state.language_profile,
        last_diagnostics = m2,
        capabilities = state.capabilities
    )
    return st2
.end

# ----------------------------------------------------------------------------
# Helpers LSP divers
# ----------------------------------------------------------------------------

pub fn lsp_server_state_with_config(
    LspServerState state,
    lang.LanguageConfig cfg
) -> LspServerState:
    let profile = state.language_profile
    # On reconstruit un profile avec même mots-clés mais config à jour.
    let prof2 = lang.LanguageProfile(
        config = cfg,
        reserved = profile.reserved
    )
    let ws = lsp_workspace_new(cfg)

    let st2 = LspServerState(
        workspace = ws,
        language_profile = prof2,
        last_diagnostics = state.last_diagnostics,
        capabilities = state.capabilities
    )
    return st2
.end

# ----------------------------------------------------------------------------
# Notes
# ----------------------------------------------------------------------------
# - Ce module se contente de définir l'état logique du serveur LSP Vitte et
#   les transitions de base pour l'ouverture / modification / fermeture de
#   documents, ainsi que la conversion diagnostics internes -> LSP.
# - Le transport JSON-RPC et la logique de parsing des messages ne sont pas
#   ici : un module séparé (vitte-lspd en C/Rust) pourra réutiliser ces
#   structures en FFI ou génération de bindings.
# ============================================================================
