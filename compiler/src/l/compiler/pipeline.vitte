module vitte.compiler.pipeline

import vitte.compiler.lexer as lex
import vitte.compiler.parser as parser
import vitte.compiler.ir as lir
import vitte.compiler.hir as hir
import vitte.compiler.diagnostics as diag
import vitte.compiler.ast as ast
import vitte.compiler.language as lang
import vitte.compiler.path as path
import vitte.compiler.linker as link
import vitte.compiler.llvm as llvm

# ============================================================================
# Vitte compiler – Pipeline de compilation (orchestrateur maximal)
#
# Rôle :
#   - Orchestration des grandes phases du compilateur Vitte :
#       * lexing    : texte source -> tokens,
#       * parsing   : tokens -> AST (ParseResult),
#       * HIR       : AST -> HirModule,
#       * IR        : HirModule/AST -> LModule (IR interne),
#       * link      : HirModule -> LinkedArtifact (link logique),
#       * LLVM      : HirModule -> LlvmModule + IR texte,
#       * codegen   : phase finale (placeholder ici).
#   - Centraliser les options de compilation front-end / middle-end.
#   - Offrir une API simple pour CLI, LSP, IDE, tests.
#
# Remarques :
#   - Les phases HIR / IR / link / LLVM sont partiellement stubées pour
#     permettre une intégration progressive sans tout implémenter d’un coup.
#   - Le module ne fait aucun I/O direct : les artefacts (IR texte, paths)
#     sont décrits comme des Strings ou structures pures.
# ============================================================================

# ----------------------------------------------------------------------------
# Phases et options
# ----------------------------------------------------------------------------

pub enum PipelinePhase:
    PhaseLex
    PhaseParse
    PhaseHir
    PhaseIR
    PhaseLink
    PhaseLlvm
    PhaseCodegen
.end

pub struct PipelineOptions:
    let language_config: lang.LanguageConfig
    let stop_after: PipelinePhase
    let collect_hir: Bool
    let collect_ir: Bool
    let collect_link: Bool
    let collect_llvm_ir: Bool
    let debug_dump_lex: Bool
    let debug_dump_parse: Bool
    let debug_dump_hir: Bool
    let debug_dump_ir: Bool
    let debug_dump_link: Bool
    let debug_dump_llvm_ir: Bool
.end

pub fn pipeline_default_options() -> PipelineOptions:
    let cfg = lang.language_config_core_default()
    let opts = PipelineOptions(
        language_config = cfg,
        stop_after = PipelinePhase::PhaseCodegen,
        collect_hir = false,
        collect_ir = false,
        collect_link = false,
        collect_llvm_ir = false,
        debug_dump_lex = false,
        debug_dump_parse = false,
        debug_dump_hir = false,
        debug_dump_ir = false,
        debug_dump_link = false,
        debug_dump_llvm_ir = false
    )
    return opts
.end

# ----------------------------------------------------------------------------
# Artéfacts de pipeline
# ----------------------------------------------------------------------------

pub struct PipelineArtifacts:
    let lex: Option<lex.LexResult>
    let parse: Option<parser.ParseResult>
    let hir: Option<hir.HirModule>
    let ir: Option<lir.LModule>
    let link: Option<link.LinkResult>
    let llvm_module: Option<llvm.LlvmModule>
    let llvm_ir_text: Option<String>
.end

pub struct PipelineResult:
    let ok: Bool
    let diagnostics: diag.DiagnosticsSink
    let artifacts: PipelineArtifacts
.end

fn empty_artifacts() -> PipelineArtifacts:
    let none_lex: Option<lex.LexResult> = Option<lex.LexResult>::None()
    let none_parse: Option<parser.ParseResult> = Option<parser.ParseResult>::None()
    let none_hir: Option<hir.HirModule> = Option<hir.HirModule>::None()
    let none_ir: Option<lir.LModule> = Option<lir.LModule>::None()
    let none_link: Option<link.LinkResult> = Option<link.LinkResult>::None()
    let none_llvm_mod: Option<llvm.LlvmModule> = Option<llvm.LlvmModule>::None()
    let none_llvm_text: Option<String> = Option<String>::None()

    let arts = PipelineArtifacts(
        lex = none_lex,
        parse = none_parse,
        hir = none_hir,
        ir = none_ir,
        link = none_link,
        llvm_module = none_llvm_mod,
        llvm_ir_text = none_llvm_text
    )
    return arts
.end

# ----------------------------------------------------------------------------
# Helpers internes : wrappers de phase front-end
# ----------------------------------------------------------------------------

pub fn pipeline_lex(String file_name, String text, diag.DiagnosticsSink sink) -> lex.LexResult:
    # Enveloppe fine autour de lex.lex_source, utile pour instrumentation.
    let res = lex.lex_source(file_name, text, sink)
    return res
.end

pub fn pipeline_parse(String file_name, String text, diag.DiagnosticsSink sink) -> parser.ParseResult:
    # Enveloppe fine autour de parser.parse_source.
    let res = parser.parse_source(file_name, text, sink)
    return res
.end

# Stub pour la phase HIR : fournira plus tard la vraie construction HirModule.

pub fn pipeline_build_hir(
    parser.ParseResult parse_res,
    lang.LanguageConfig cfg,
    diag.DiagnosticsSink sink
) -> Option<hir.HirModule>:
    # TODO: connecter un vrai builder AST -> HIR, avec typage.
    let none_hir: Option<hir.HirModule> = Option<hir.HirModule>::None()
    return none_hir
.end

# Stub pour la phase IR : fournira plus tard la vraie construction LModule.

pub fn pipeline_build_ir(
    parser.ParseResult parse_res,
    lang.LanguageConfig cfg,
    diag.DiagnosticsSink sink
) -> Option<lir.LModule>:
    # TODO: connecter un vrai builder HIR/AST -> IR interne.
    let none_ir: Option<lir.LModule> = Option<lir.LModule>::None()
    return none_ir
.end

# ----------------------------------------------------------------------------
# Helpers : link / LLVM (intégration légère)
# ----------------------------------------------------------------------------

fn pipeline_link_single_module(
    String file_name,
    String module_name,
    Option<hir.HirModule> hir_opt,
    lang.LanguageConfig cfg
) -> link.LinkResult:
    let inputs: Vec<link.LinkInputModule> = Vec<link.LinkInputModule>::new()

    let name = if module_name != "":
        module_name
    else:
        file_name
    .end

    let out_path_o = path.path_change_extension(file_name, "o")

    let mk = lang.ModuleKind::ModuleKindBinary

    let input = link.link_input_module_new(
        name,
        file_name,
        true,
        mk,
        cfg,
        hir_opt
    )

    inputs.push(input)

    let link_opts = link.LinkOptions(
        config = cfg,
        output_path = out_path_o,
        emit_debug_info = lang.language_config_wants_debug_info(cfg),
        optimize = true,
        emit_map_file = false,
        incremental = false
    )

    let res = link.linker_link_all(inputs, link_opts)
    return res
.end

fn pipeline_build_llvm_from_hir(
    String module_name,
    hir.HirModule hm,
    lang.LanguageConfig cfg,
    diag.DiagnosticsSink sink_in
) -> (Option<llvm.LlvmModule>, Option<String>, diag.DiagnosticsSink, Bool):
    let opts_lower = llvm.llvm_lowering_options_from_language(cfg)
    let lower_res = llvm.llvm_lower_hir_module_to_llvm(hm, opts_lower, sink_in)

    if not lower_res.ok:
        let none_mod: Option<llvm.LlvmModule> = Option<llvm.LlvmModule>::None()
        let none_text: Option<String> = Option<String>::None()
        let out_err = (none_mod, none_text, lower_res.diagnostics, false)
        return out_err
    .end

    let m_opt = lower_res.module
    if m_opt.is_none():
        let none_mod2: Option<llvm.LlvmModule> = Option<llvm.LlvmModule>::None()
        let none_text2: Option<String> = Option<String>::None()
        let out_err2 = (none_mod2, none_text2, lower_res.diagnostics, false)
        return out_err2
    .end

    let m = m_opt.unwrap()
    let ir_text = llvm.llvm_module_render_ir(m)

    let some_mod: Option<llvm.LlvmModule> = Option<llvm.LlvmModule>::Some(m)
    let some_text: Option<String> = Option<String>::Some(ir_text)

    let out_ok = (some_mod, some_text, lower_res.diagnostics, true)
    return out_ok
.end

# ----------------------------------------------------------------------------
# Pipeline complet : texte -> artefacts
# ----------------------------------------------------------------------------

pub fn pipeline_frontend(
    String file_name,
    String text,
    PipelineOptions opts,
    diag.DiagnosticsSink sink
) -> PipelineResult:
    let arts0 = empty_artifacts()
    let cfg = opts.language_config

    # Phase 1 : lexing -------------------------------------------------------
    let lex_res = pipeline_lex(file_name, text, sink)
    let ds1 = lex_res.diagnostics

    let some_lex: Option<lex.LexResult> = Option<lex.LexResult>::Some(lex_res)
    let arts1 = PipelineArtifacts(
        lex = some_lex,
        parse = arts0.parse,
        hir = arts0.hir,
        ir = arts0.ir,
        link = arts0.link,
        llvm_module = arts0.llvm_module,
        llvm_ir_text = arts0.llvm_ir_text
    )

    if opts.stop_after == PipelinePhase::PhaseLex:
        let res_lex = PipelineResult(
            ok = true,
            diagnostics = ds1,
            artifacts = arts1
        )
        return res_lex
    .end

    # Phase 2 : parsing ------------------------------------------------------
    let parse_res = pipeline_parse(file_name, text, ds1)
    let ds2 = parse_res.diagnostics

    let some_parse: Option<parser.ParseResult> = Option<parser.ParseResult>::Some(parse_res)
    let arts2 = PipelineArtifacts(
        lex = arts1.lex,
        parse = some_parse,
        hir = arts1.hir,
        ir = arts1.ir,
        link = arts1.link,
        llvm_module = arts1.llvm_module,
        llvm_ir_text = arts1.llvm_ir_text
    )

    if opts.stop_after == PipelinePhase::PhaseParse:
        let res_parse = PipelineResult(
            ok = true,
            diagnostics = ds2,
            artifacts = arts2
        )
        return res_parse
    .end

    # Phase 3 : HIR ----------------------------------------------------------
    let hir_opt = pipeline_build_hir(parse_res, cfg, ds2)
    let arts3 = PipelineArtifacts(
        lex = arts2.lex,
        parse = arts2.parse,
        hir = hir_opt,
        ir = arts2.ir,
        link = arts2.link,
        llvm_module = arts2.llvm_module,
        llvm_ir_text = arts2.llvm_ir_text
    )

    if opts.stop_after == PipelinePhase::PhaseHir:
        let res_hir = PipelineResult(
            ok = true,
            diagnostics = ds2,
            artifacts = arts3
        )
        return res_hir
    .end

    # Phase 4 : IR (stub) ----------------------------------------------------
    let ir_opt = if opts.collect_ir:
        pipeline_build_ir(parse_res, cfg, ds2)
    else:
        arts3.ir
    .end

    let arts4 = PipelineArtifacts(
        lex = arts3.lex,
        parse = arts3.parse,
        hir = arts3.hir,
        ir = ir_opt,
        link = arts3.link,
        llvm_module = arts3.llvm_module,
        llvm_ir_text = arts3.llvm_ir_text
    )

    if opts.stop_after == PipelinePhase::PhaseIR:
        let res_ir = PipelineResult(
            ok = true,
            diagnostics = ds2,
            artifacts = arts4
        )
        return res_ir
    .end

    # Phase 5 : link (logique, via vitte.compiler.linker) --------------------
    let module_name = path.path_to_module_name(file_name)
    let link_res = if opts.collect_link or opts.stop_after == PipelinePhase::PhaseLink or opts.stop_after == PipelinePhase::PhaseLlvm or opts.stop_after == PipelinePhase::PhaseCodegen:
        pipeline_link_single_module(file_name, module_name, hir_opt, cfg)
    else:
        # Pas de link : on crée un résultat synthétique OK avec les diagnostics actuels.
        let link_opts = link.LinkOptions(
            config = cfg,
            output_path = path.path_change_extension(file_name, "o"),
            emit_debug_info = lang.language_config_wants_debug_info(cfg),
            optimize = true,
            emit_map_file = false,
            incremental = false
        )
        let inputs_empty: Vec<link.LinkInputModule> = Vec<link.LinkInputModule>::new()
        let dummy = link.LinkResult(
            ok = true,
            artifact = Option<link.LinkedArtifact>::None(),
            diagnostics = ds2
        )
        dummy
    .end

    let ds_link = link_res.diagnostics
    let some_link_res: Option<link.LinkResult> = Option<link.LinkResult>::Some(link_res)

    let arts5 = PipelineArtifacts(
        lex = arts4.lex,
        parse = arts4.parse,
        hir = arts4.hir,
        ir = arts4.ir,
        link = some_link_res,
        llvm_module = arts4.llvm_module,
        llvm_ir_text = arts4.llvm_ir_text
    )

    if opts.stop_after == PipelinePhase::PhaseLink:
        let res_link = PipelineResult(
            ok = link_res.ok,
            diagnostics = ds_link,
            artifacts = arts5
        )
        return res_link
    .end

    # Phase 6 : LLVM (baisse HIR -> LlvmModule + IR texte) -------------------
    let llvm_mod_opt: Option<llvm.LlvmModule> = Option<llvm.LlvmModule>::None()
    let llvm_text_opt: Option<String> = Option<String>::None()
    let ds_llvm = ds_link
    let ok_llvm = true

    let tuple_llvm = if hir_opt.is_some():
        let hm = hir_opt.unwrap()
        pipeline_build_llvm_from_hir(module_name, hm, cfg, ds_link)
    else:
        (llvm_mod_opt, llvm_text_opt, ds_link, false)
    .end

    let llvm_module_final = tuple_llvm.0
    let llvm_text_final = tuple_llvm.1
    let ds_final = tuple_llvm.2
    let ok_llvm_final = tuple_llvm.3

    let arts6 = PipelineArtifacts(
        lex = arts5.lex,
        parse = arts5.parse,
        hir = arts5.hir,
        ir = arts5.ir,
        link = arts5.link,
        llvm_module = llvm_module_final,
        llvm_ir_text = llvm_text_final
    )

    if opts.stop_after == PipelinePhase::PhaseLlvm:
        let res_llvm = PipelineResult(
            ok = ok_llvm_final,
            diagnostics = ds_final,
            artifacts = arts6
        )
        return res_llvm
    .end

    # Phase 7 : codegen (non implémentée ici) --------------------------------
    # Le pipeline s'arrête ici pour l'instant. Un module vitte.compiler.codegen
    # pourra être branché pour consommer :
    #   - hir.HirModule,
    #   - lir.LModule,
    #   - link.LinkResult,
    #   - llvm.LlvmModule / IR texte.
    #
    # On renvoie l'état après la phase LLVM.

    let result = PipelineResult(
        ok = ok_llvm_final and link_res.ok,
        diagnostics = ds_final,
        artifacts = arts6
    )
    return result
.end

# ----------------------------------------------------------------------------
# API de convenance
# ----------------------------------------------------------------------------

pub fn pipeline_frontend_default(String file_name, String text, diag.DiagnosticsSink sink) -> PipelineResult:
    let opts = pipeline_default_options()
    let res = pipeline_frontend(file_name, text, opts, sink)
    return res
.end

pub fn pipeline_parse_only(String file_name, String text, diag.DiagnosticsSink sink) -> parser.ParseResult:
    # Pipeline complet avec options par défaut, puis extraction
    # du résultat de parsing uniquement.
    let opts = pipeline_default_options()
    let res = pipeline_frontend(file_name, text, opts, sink)

    let arts = res.artifacts
    if arts.parse.is_some():
        return arts.parse.unwrap()
    .end

    # Fallback : aucun résultat de parsing (cas pathologique).
    let empty_span = ast.Span(
        file = file_name,
        start_line = 0u32,
        start_col = 0u32,
        end_line = 0u32,
        end_col = 0u32
    )
    let empty_pmod = parser.PModule(
        name = "",
        items = Vec<parser.PItem>::new(),
        span = empty_span
    )
    let empty_res = parser.ParseResult(
        module = empty_pmod,
        diagnostics = res.diagnostics
    )
    return empty_res
.end

# ----------------------------------------------------------------------------
# Notes
# ----------------------------------------------------------------------------
# - Ce module ne fige pas la structure interne de HIR / IR / codegen :
#   il fournit un squelette riche d'orchestration, extensible.
# - Les stubs HIR/IR peuvent être implémentés dans des modules dédiés
#   sans briser les appels existants (API stable via PipelineArtifacts).
# - Les artefacts collectés (link/LLVM) sont purement déclaratifs et
#   conviennent aussi bien pour un CLI que pour un serveur LSP.
# ----------------------------------------------------------------------------
