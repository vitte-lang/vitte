

module vitte.compiler.backends

import vitte.compiler.ir as lir
import vitte.compiler.diagnostics as diag

# ============================================================================
# Vitte compiler – Backends / codegen abstraction (ultra complet)
#
# Objectifs :
#   - Décrire de manière unifiée les backends de génération de code pour Vitte.
#   - Centraliser :
#       * la notion de cible (TargetTriple) ;
#       * les options de compilation (BackendOptions) ;
#       * les résultats de codegen (BackendArtifact / BackendResult) ;
#       * un registre de backends déclarés (BackendRegistry) ;
#       * une fonction d'invocation générique (backend_invoke).
#   - Rester purement déclaratif côté API : les impls réelles (C, LLVM, WASM…)
#     peuvent vivre dans d'autres modules (`vitte.compiler.backend.c`, etc.).
# ============================================================================

# ----------------------------------------------------------------------------
# Cible et optimisation
# ----------------------------------------------------------------------------

pub struct TargetTriple:
    let arch: String      # e.g. "x86_64", "aarch64"
    let vendor: String    # e.g. "apple", "unknown"
    let os: String        # e.g. "macos", "linux", "windows"
    let abi: String       # e.g. "gnu", "msvc", "none"
.end

pub enum OptimizationLevel:
    Opt0   # pas d'optimisation
    Opt1
    Opt2
    Opt3
    OptSize
    OptSizeMin
.end

pub enum CodegenMode:
    CodegenBuild   # build binaire ou lib
    CodegenCheck   # vérif (typecheck/codegen léger) sans sortie
    CodegenEmitIR  # n'émettre que l'IR intermédiaire
.end

pub enum RelocationModel:
    RelocStatic
    RelocPIC
    RelocPIE
.end

pub enum CodeModel:
    CodeModelSmall
    CodeModelMedium
    CodeModelLarge
.end

pub fn target_triple_to_string(TargetTriple t) -> String:
    # Format classique : arch-vendor-os-abi
    let s = t.arch + "-" + t.vendor + "-" + t.os + "-" + t.abi
    return s
.end

pub fn target_default() -> TargetTriple:
    # Valeur générique portable ; un runtime spécifique pourra la surcharger.
    let t = TargetTriple(
        arch = "generic",
        vendor = "unknown",
        os = "unknown",
        abi = "none"
    )
    return t
.end

# ----------------------------------------------------------------------------
# Types de backend, artefacts et options
# ----------------------------------------------------------------------------

pub enum BackendKind:
    BackendNull      # backend de test / no-op
    BackendC         # génération de C
    BackendLLVM      # IR LLVM / code natif via LLVM
    BackendWasm      # WebAssembly
    BackendBytecode  # VM/bytecode propriétaire
    BackendJit       # JIT interne
.end

pub fn backend_kind_to_string(BackendKind k) -> String:
    if k == BackendKind::BackendNull:
        return "null"
    .end
    if k == BackendKind::BackendC:
        return "c"
    .end
    if k == BackendKind::BackendLLVM:
        return "llvm"
    .end
    if k == BackendKind::BackendWasm:
        return "wasm"
    .end
    if k == BackendKind::BackendBytecode:
        return "bytecode"
    .end
    if k == BackendKind::BackendJit:
        return "jit"
    .end

    return "unknown"
.end

pub enum BackendOutputKind:
    BackendOutputIR
    BackendOutputAssembly
    BackendOutputObject
    BackendOutputBinary
    BackendOutputLibrary
.end

pub fn backend_output_kind_to_string(BackendOutputKind k) -> String:
    if k == BackendOutputKind::BackendOutputIR:
        return "ir"
    .end
    if k == BackendOutputKind::BackendOutputAssembly:
        return "asm"
    .end
    if k == BackendOutputKind::BackendOutputObject:
        return "obj"
    .end
    if k == BackendOutputKind::BackendOutputBinary:
        return "bin"
    .end
    if k == BackendOutputKind::BackendOutputLibrary:
        return "lib"
    .end

    return "unknown"
.end

pub typedef u64 BackendId

pub struct BackendArtifact:
    let kind: BackendOutputKind
    let path: String           # chemin du fichier généré (ou "-" pour stdout)
    let is_primary: Bool       # artefact principal (binaire, lib, etc.)
.end

pub struct BackendOptions:
    let target: TargetTriple
    let opt_level: OptimizationLevel
    let mode: CodegenMode
    let reloc_model: RelocationModel
    let code_model: CodeModel
    let debug_symbols: Bool
    let warnings_as_errors: Bool
    let emit_ir: Bool
    let emit_asm: Bool
    let emit_obj: Bool
    let emit_bin: Bool
    let extra_flags: Vec<String>
.end

pub fn backend_default_options() -> BackendOptions:
    let t = target_default()
    let flags = Vec<String>::new()
    let opts = BackendOptions(
        target = t,
        opt_level = OptimizationLevel::Opt0,
        mode = CodegenMode::CodegenBuild,
        reloc_model = RelocationModel::RelocStatic,
        code_model = CodeModel::CodeModelSmall,
        debug_symbols = true,
        warnings_as_errors = false,
        emit_ir = false,
        emit_asm = false,
        emit_obj = true,
        emit_bin = true,
        extra_flags = flags
    )
    return opts
.end

# ----------------------------------------------------------------------------
# Résultat et requête de backend
# ----------------------------------------------------------------------------

pub struct BackendResult:
    let ok: Bool
    let diagnostics: diag.DiagnosticsSink
    let artifacts: Vec<BackendArtifact>
.end

pub enum BackendRequestKind:
    BackendRequestCompileModule
    BackendRequestEmitIR
    BackendRequestEmitAssembly
    BackendRequestEmitObject
    BackendRequestEmitBinary
    BackendRequestJitRun
.end

pub fn backend_request_kind_to_string(BackendRequestKind k) -> String:
    if k == BackendRequestKind::BackendRequestCompileModule:
        return "compile-module"
    .end
    if k == BackendRequestKind::BackendRequestEmitIR:
        return "emit-ir"
    .end
    if k == BackendRequestKind::BackendRequestEmitAssembly:
        return "emit-asm"
    .end
    if k == BackendRequestKind::BackendRequestEmitObject:
        return "emit-obj"
    .end
    if k == BackendRequestKind::BackendRequestEmitBinary:
        return "emit-bin"
    .end
    if k == BackendRequestKind::BackendRequestJitRun:
        return "jit-run"
    .end

    return "unknown"
.end

pub struct BackendRequest:
    let kind: BackendRequestKind
    let module_name: String      # nom logique du module
    let output_dir: String       # dossier de sortie
    let output_basename: String  # préfixe commun (ex: "main")
    let main_symbol: String      # symbole d'entrée (pour JIT ou binaire)
    let extra_flags: Vec<String>
.end

pub fn backend_request_default(String module_name) -> BackendRequest:
    let flags = Vec<String>::new()
    let req = BackendRequest(
        kind = BackendRequestKind::BackendRequestCompileModule,
        module_name = module_name,
        output_dir = "./build",
        output_basename = "main",
        main_symbol = "main",
        extra_flags = flags
    )
    return req
.end

# ----------------------------------------------------------------------------
# Descripteurs et registre de backends
# ----------------------------------------------------------------------------

pub struct BackendDescriptor:
    let id: BackendId
    let kind: BackendKind
    let name: String
    let version: String
    let supported_outputs: Vec<BackendOutputKind>
    let supports_jit: Bool
.end

pub struct BackendRegistry:
    let next_id: BackendId
    let backends: Vec<BackendDescriptor>
.end

pub fn backend_registry_new() -> BackendRegistry:
    let v = Vec<BackendDescriptor>::new()
    let reg = BackendRegistry(
        next_id = 1u64,
        backends = v
    )
    return reg
.end

fn backend_registry_register(
    BackendRegistry reg,
    BackendKind kind,
    String name,
    String version,
    Vec<BackendOutputKind> outputs,
    Bool supports_jit
) -> (BackendRegistry, BackendDescriptor):
    let id = reg.next_id

    let desc = BackendDescriptor(
        id = id,
        kind = kind,
        name = name,
        version = version,
        supported_outputs = outputs,
        supports_jit = supports_jit
    )

    let v = reg.backends
    v.push(desc)

    let reg2 = BackendRegistry(
        next_id = id + 1u64,
        backends = v
    )

    return (reg2, desc)
.end

pub fn backend_registry_builtin() -> BackendRegistry:
    let reg0 = backend_registry_new()

    # Backend null -----------------------------------------------------------
    let outs_null = Vec<BackendOutputKind>::new()
    outs_null.push(BackendOutputKind::BackendOutputIR)
    let pair_null = backend_registry_register(
        reg0,
        BackendKind::BackendNull,
        "null",
        "0.1.0",
        outs_null,
        false
    )
    let reg1 = pair_null.0

    # Backend C --------------------------------------------------------------
    let outs_c = Vec<BackendOutputKind>::new()
    outs_c.push(BackendOutputKind::BackendOutputIR)
    outs_c.push(BackendOutputKind::BackendOutputAssembly)
    outs_c.push(BackendOutputKind::BackendOutputObject)
    outs_c.push(BackendOutputKind::BackendOutputBinary)
    let pair_c = backend_registry_register(
        reg1,
        BackendKind::BackendC,
        "c",
        "0.1.0",
        outs_c,
        false
    )
    let reg2 = pair_c.0

    # Backend LLVM -----------------------------------------------------------
    let outs_llvm = Vec<BackendOutputKind>::new()
    outs_llvm.push(BackendOutputKind::BackendOutputIR)
    outs_llvm.push(BackendOutputKind::BackendOutputAssembly)
    outs_llvm.push(BackendOutputKind::BackendOutputObject)
    outs_llvm.push(BackendOutputKind::BackendOutputBinary)
    let pair_llvm = backend_registry_register(
        reg2,
        BackendKind::BackendLLVM,
        "llvm",
        "0.1.0",
        outs_llvm,
        true
    )
    let reg3 = pair_llvm.0

    # Backend WASM -----------------------------------------------------------
    let outs_wasm = Vec<BackendOutputKind>::new()
    outs_wasm.push(BackendOutputKind::BackendOutputBinary)
    let pair_wasm = backend_registry_register(
        reg3,
        BackendKind::BackendWasm,
        "wasm",
        "0.1.0",
        outs_wasm,
        false
    )
    let reg4 = pair_wasm.0

    # Backend bytecode -------------------------------------------------------
    let outs_bc = Vec<BackendOutputKind>::new()
    outs_bc.push(BackendOutputKind::BackendOutputBinary)
    let pair_bc = backend_registry_register(
        reg4,
        BackendKind::BackendBytecode,
        "bytecode",
        "0.1.0",
        outs_bc,
        false
    )
    let reg5 = pair_bc.0

    return reg5
.end

pub fn backend_find_by_kind(BackendRegistry reg, BackendKind kind) -> Option<BackendDescriptor>:
    let len = reg.backends.len()
    let i = 0usize

    while i < len:
        let d = reg.backends[i]
        if d.kind == kind:
            let some_d: Option<BackendDescriptor> = Option<BackendDescriptor>::Some(d)
            return some_d
        .end
        i = i + 1usize
    .end

    let none_d: Option<BackendDescriptor> = Option<BackendDescriptor>::None()
    return none_d
.end

pub fn backend_find_by_name(BackendRegistry reg, String name) -> Option<BackendDescriptor>:
    let len = reg.backends.len()
    let i = 0usize

    while i < len:
        let d = reg.backends[i]
        if d.name == name:
            let some_d: Option<BackendDescriptor> = Option<BackendDescriptor>::Some(d)
            return some_d
        .end
        i = i + 1usize
    .end

    let none_d: Option<BackendDescriptor> = Option<BackendDescriptor>::None()
    return none_d
.end

# ----------------------------------------------------------------------------
# Invocation générique d'un backend
# ----------------------------------------------------------------------------

fn backend_result_empty(diag.DiagnosticsSink sink) -> BackendResult:
    let arts = Vec<BackendArtifact>::new()
    let res = BackendResult(
        ok = false,
        diagnostics = sink,
        artifacts = arts
    )
    return res
.end

fn backend_result_ok(diag.DiagnosticsSink sink, Vec<BackendArtifact> arts) -> BackendResult:
    let res = BackendResult(
        ok = true,
        diagnostics = sink,
        artifacts = arts
    )
    return res
.end

fn backend_push_not_implemented_diags(
    BackendDescriptor desc,
    BackendRequest req,
    diag.DiagnosticsSink sink
) -> diag.DiagnosticsSink:
    let kind_str = backend_kind_to_string(desc.kind)
    let req_str = backend_request_kind_to_string(req.kind)
    let msg = "backend '" + desc.name + "' (" + kind_str + ") does not implement request '" + req_str + "' yet"
    let span = diag.make_dummy_span()
    let d = diag.make_backend_error(msg, span)
    sink.push(d)
    return sink
.end

fn backend_invoke_null(
    BackendDescriptor desc,
    lir.LModule module,
    BackendOptions opts,
    BackendRequest req,
    diag.DiagnosticsSink sink
) -> BackendResult:
    # Backend de test : ne génère aucun fichier, se contente de signaler
    # l'appel dans les diagnostics.
    let kind_str = backend_kind_to_string(desc.kind)
    let req_str = backend_request_kind_to_string(req.kind)
    let msg = "null backend invoked for module '" + req.module_name + "' (" + kind_str + ", request=" + req_str + ")"
    let span = diag.make_dummy_span()
    let d = diag.make_backend_info(msg, span)
    sink.push(d)

    let arts = Vec<BackendArtifact>::new()
    let res = BackendResult(
        ok = true,
        diagnostics = sink,
        artifacts = arts
    )
    return res
.end

fn backend_invoke_not_implemented(
    BackendDescriptor desc,
    lir.LModule module,
    BackendOptions opts,
    BackendRequest req,
    diag.DiagnosticsSink sink
) -> BackendResult:
    let sink2 = backend_push_not_implemented_diags(desc, req, sink)
    let res = backend_result_empty(sink2)
    return res
.end

pub fn backend_invoke(
    BackendDescriptor desc,
    lir.LModule module,
    BackendOptions opts,
    BackendRequest req,
    diag.DiagnosticsSink sink
) -> BackendResult:
    if desc.kind == BackendKind::BackendNull:
        let res_null = backend_invoke_null(desc, module, opts, req, sink)
        return res_null
    .end

    if desc.kind == BackendKind::BackendC:
        # TODO: appeler vitte.compiler.backend.c.codegen(...) quand dispo.
        let res_c = backend_invoke_not_implemented(desc, module, opts, req, sink)
        return res_c
    .end

    if desc.kind == BackendKind::BackendLLVM:
        # TODO: appeler vitte.compiler.backend.llvm.codegen(...) quand dispo.
        let res_llvm = backend_invoke_not_implemented(desc, module, opts, req, sink)
        return res_llvm
    .end

    if desc.kind == BackendKind::BackendWasm:
        # TODO: appeler vitte.compiler.backend.wasm.codegen(...) quand dispo.
        let res_wasm = backend_invoke_not_implemented(desc, module, opts, req, sink)
        return res_wasm
    .end

    if desc.kind == BackendKind::BackendBytecode:
        # TODO: appeler vitte.compiler.backend.bytecode.codegen(...) quand dispo.
        let res_bc = backend_invoke_not_implemented(desc, module, opts, req, sink)
        return res_bc
    .end

    if desc.kind == BackendKind::BackendJit:
        # TODO: appeler vitte.compiler.backend.jit.run(...) quand dispo.
        let res_jit = backend_invoke_not_implemented(desc, module, opts, req, sink)
        return res_jit
    .end

    # Fallback : type de backend inconnu
    let sink3 = backend_push_not_implemented_diags(desc, req, sink)
    let res = backend_result_empty(sink3)
    return res
.end

# ----------------------------------------------------------------------------
# API de haut niveau
# ----------------------------------------------------------------------------

pub fn backends_default_registry() -> BackendRegistry:
    let reg = backend_registry_builtin()
    return reg
.end

pub fn backend_compile_module(
    BackendRegistry reg,
    BackendKind kind,
    lir.LModule module,
    BackendOptions opts,
    BackendRequest req,
    diag.DiagnosticsSink sink
) -> BackendResult:
    let maybe_desc = backend_find_by_kind(reg, kind)
    if not maybe_desc.is_some():
        let kind_str = backend_kind_to_string(kind)
        let msg = "no backend registered for kind '" + kind_str + "'"
        let span = diag.make_dummy_span()
        let d = diag.make_backend_error(msg, span)
        sink.push(d)
        let res = backend_result_empty(sink)
        return res
    .end

    let desc = maybe_desc.unwrap()
    let res2 = backend_invoke(desc, module, opts, req, sink)
    return res2
.end

# ----------------------------------------------------------------------------
# Notes
# ----------------------------------------------------------------------------
# - Ce module ne fournit pas encore d'implémentations réelles pour C/LLVM/WASM
#   mais définit une API stable pour la pipeline de compilation.
# - Les modules concrets pourront exposer des fonctions ciblées (par ex.
#   `c_codegen_module`, `llvm_codegen_module`, etc.) et être branchés dans
#   `backend_invoke_*`.
# - Les diagnostics utilisent des helpers supposés dans `vitte.compiler.diagnostics` :
#   `make_dummy_span`, `make_backend_error`, `make_backend_info`. Il suffira de
#   les ajouter dans ce module pour obtenir une intégration cohérente.
# ----------------------------------------------------------------------------