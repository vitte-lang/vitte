

module vitte.compiler.linker

import vitte.compiler.collections as coll
import vitte.compiler.diagnostics as diag
import vitte.compiler.language as lang
import vitte.compiler.hir as hir
import vitte.compiler.graph as g

# ============================================================================
# Vitte compiler – Linker (maximal mais encore générique)
#
# Rôle de ce module :
#   - Décrire les structures de données de haut niveau pour l'étape de link.
#   - Centraliser la logique de "link" de modules Vitte/HIR vers un artefact :
#       * vérification de base des symboles (duplicates, undefined),
#       * construction d'un graphe de dépendances entre modules,
#       * calcul du type d'artefact attendu (binaire, lib, bytecode...),
#       * production d'un résultat déclaratif (LinkedArtifact).
#
# Remarque :
#   - Ce module ne fait volontairement pas d'I/O direct (pas d'écriture de
#     fichiers binaires). L'émission réelle est confiée au backend ciblé
#     (C/Rust/VM, etc.) qui consommera LinkedArtifact.
# ============================================================================

# ----------------------------------------------------------------------------
# Erreurs de link
# ----------------------------------------------------------------------------

pub enum LinkErrorKind:
    LinkErrorKindNone
    LinkErrorKindDuplicateSymbol
    LinkErrorKindUndefinedSymbol
    LinkErrorKindMissingHir
    LinkErrorKindIo
    LinkErrorKindUnsupportedTarget
    LinkErrorKindInvalidUnit
    LinkErrorKindCycle
    LinkErrorKindInternal
.end

pub struct LinkError:
    let kind: LinkErrorKind
    let message: String
    let span: diag.Span
.end

pub fn link_error_new(LinkErrorKind kind, String message, diag.Span span) -> LinkError:
    let e = LinkError(
        kind = kind,
        message = message,
        span = span
    )
    return e
.end

# Diagnostic wrapper

pub fn link_error_to_diagnostic(LinkError err) -> diag.Diagnostic:
    let d = diag.diag_new(
        diag.Severity::SeverityError,
        "E-Link",
        err.message,
        err.span
    )
    return d
.end

# ----------------------------------------------------------------------------
# Options de link et artefacts
# ----------------------------------------------------------------------------

pub struct LinkOptions:
    let config: lang.LanguageConfig
    let output_path: String
    let emit_debug_info: Bool
    let optimize: Bool
    let emit_map_file: Bool
    let incremental: Bool
.end

pub enum LinkedArtifactKind:
    LinkedArtifactKindExecutable
    LinkedArtifactKindStaticLibrary
    LinkedArtifactKindSharedLibrary
    LinkedArtifactKindObject
    LinkedArtifactKindBytecodeImage
    LinkedArtifactKindWasmModule
.end

pub struct LinkedArtifact:
    let kind: LinkedArtifactKind
    let path: String
    let config: lang.LanguageConfig
    let diagnostics: diag.DiagnosticsSink
.end

pub struct LinkResult:
    let ok: Bool
    let artifact: Option<LinkedArtifact>
    let diagnostics: diag.DiagnosticsSink
.end

pub fn link_result_ok(LinkedArtifact artifact) -> LinkResult:
    let some_art: Option<LinkedArtifact> = Option<LinkedArtifact>::Some(artifact)
    let sink = artifact.diagnostics
    let r = LinkResult(
        ok = true,
        artifact = some_art,
        diagnostics = sink
    )
    return r
.end

pub fn link_result_err(diag.DiagnosticsSink diagnostics) -> LinkResult:
    let none_art: Option<LinkedArtifact> = Option<LinkedArtifact>::None()
    let r = LinkResult(
        ok = false,
        artifact = none_art,
        diagnostics = diagnostics
    )
    return r
.end

# ----------------------------------------------------------------------------
# Description des modules d'entrée pour le linker
# ----------------------------------------------------------------------------

pub struct LinkInputModule:
    let name: String
    let path: String
    let is_root: Bool
    let module_kind: lang.ModuleKind
    let config: lang.LanguageConfig
    let hir: Option<hir.HirModule>
.end

pub fn link_input_module_new(
    String name,
    String path,
    Bool is_root,
    lang.ModuleKind module_kind,
    lang.LanguageConfig config,
    Option<hir.HirModule> hir_opt
) -> LinkInputModule:
    let m = LinkInputModule(
        name = name,
        path = path,
        is_root = is_root,
        module_kind = module_kind,
        config = config,
        hir = hir_opt
    )
    return m
.end

# ----------------------------------------------------------------------------
# Symboles globaux vus par le linker
# ----------------------------------------------------------------------------

pub enum LinkSymbolKind:
    LinkSymbolKindFunction
    LinkSymbolKindStruct
    LinkSymbolKindEnum
    LinkSymbolKindConst
    LinkSymbolKindGlobal
    LinkSymbolKindExtern
.end

pub struct LinkSymbol:
    let name: String
    let kind: LinkSymbolKind
    let defining_module_index: usize
    let span: diag.Span
.end

pub struct LinkSymbolTable:
    let symbols: coll.SmallMap<String, LinkSymbol>
.end

pub fn link_symbol_table_new() -> LinkSymbolTable:
    let sm = coll.small_map_new<String, LinkSymbol>()
    let t = LinkSymbolTable(
        symbols = sm
    )
    return t
.end

pub fn link_symbol_table_insert(
    LinkSymbolTable table,
    LinkSymbol sym
) -> LinkSymbolTable:
    let sm = table.symbols
    let sm2 = coll.small_map_insert<String, LinkSymbol>(sm, sym.name, sym)
    let t2 = LinkSymbolTable(
        symbols = sm2
    )
    return t2
.end

pub fn link_symbol_table_try_insert(
    LinkSymbolTable table,
    LinkSymbol sym
) -> (LinkSymbolTable, Option<LinkError>):
    let sm = table.symbols
    let existing_opt = coll.small_map_get<String, LinkSymbol>(sm, sym.name)

    if existing_opt.is_some():
        let existing = existing_opt.unwrap()
        let msg = "duplicate symbol: " + sym.name
        let err = link_error_new(
            LinkErrorKind::LinkErrorKindDuplicateSymbol,
            msg,
            existing.span
        )
        let some_err: Option<LinkError> = Option<LinkError>::Some(err)
        let out = (table, some_err)
        return out
    .end

    let sm2 = coll.small_map_insert<String, LinkSymbol>(sm, sym.name, sym)
    let t2 = LinkSymbolTable(
        symbols = sm2
    )
    let none_err: Option<LinkError> = Option<LinkError>::None()
    let out_ok = (t2, none_err)
    return out_ok
.end

pub fn link_symbol_table_lookup(
    LinkSymbolTable table,
    String name
) -> Option<LinkSymbol>:
    let sm = table.symbols
    let found = coll.small_map_get<String, LinkSymbol>(sm, name)
    return found
.end

# ----------------------------------------------------------------------------
# Graphe de dépendances entre modules
# ----------------------------------------------------------------------------

pub struct LinkDependencyGraph:
    let graph: g.Graph<usize, ()>
.end

pub fn link_dependency_graph_new(Vec<LinkInputModule> inputs) -> LinkDependencyGraph:
    let g0 = g.graph_new<usize, ()>()
    let count = inputs.len()
    let i = 0usize
    let g_acc = g0

    while i < count:
        let pair = g.graph_add_node(g_acc, i)
        let g2 = pair.0
        let g_acc = g2
        i = i + 1usize
    .end

    # Pour l'instant, aucun edge n'est construit ici; un passe ultérieur
    # pourra analyser les imports/uses pour créer les arêtes.
    let dg = LinkDependencyGraph(
        graph = g_acc
    )
    return dg
.end

# ----------------------------------------------------------------------------
# Linker – pipeline principal
# ----------------------------------------------------------------------------

pub fn linker_link_all(
    Vec<LinkInputModule> inputs,
    LinkOptions opts
) -> LinkResult:
    let sink = diag.diagnostics_new()
    let has_error = false

    let n = inputs.len()
    if n == 0usize:
        # Pas de module d'entrée, rien à linker.
        return link_result_err(sink)
    .end

    # 1) Construire la table des symboles globaux.
    let symbols = link_symbol_table_new()
    let pair = linker_build_symbol_table(inputs, symbols, sink, has_error)
    let symbols2 = pair.0
    let sink2 = pair.1
    let has_error2 = pair.2

    let sink_curr = sink2
    let has_error_curr = has_error2

    if has_error_curr:
        # Erreurs bloquantes lors de la collecte des symboles.
        return link_result_err(sink_curr)
    .end

    # 2) Construire le graphe de dépendances (modules).
    let dep_graph = link_dependency_graph_new(inputs)

    # 3) Vérifications simples de cohérence des unités (placeholder).
    let pair2 = linker_validate_units(inputs, symbols2, dep_graph, sink_curr, has_error_curr)
    let sink3 = pair2.0
    let has_error3 = pair2.1

    if has_error3:
        return link_result_err(sink3)
    .end

    # 4) Choisir le genre d'artefact en fonction de la config.
    let art_kind = linker_choose_artifact_kind(opts.config)

    # 5) Construire un artefact logique : le backend s'occupera de l'émission réelle.
    let artifact = LinkedArtifact(
        kind = art_kind,
        path = opts.output_path,
        config = opts.config,
        diagnostics = sink3
    )

    let result = link_result_ok(artifact)
    return result
.end

# ----------------------------------------------------------------------------
# Construction de la table des symboles
# ----------------------------------------------------------------------------

fn linker_build_symbol_table(
    Vec<LinkInputModule> inputs,
    LinkSymbolTable table,
    diag.DiagnosticsSink sink,
    Bool has_error_in
) -> (LinkSymbolTable, diag.DiagnosticsSink, Bool):
    let t_acc = table
    let sink_acc = sink
    let has_err = has_error_in

    let count = inputs.len()
    let i = 0usize

    while i < count:
        let input = inputs[i]
        let hir_opt = input.hir

        if hir_opt.is_none():
            # Module sans HIR : on note une erreur de link.
            let msg = "missing HIR for module: " + input.name
            let span = diag.span_unknown()
            let err = link_error_new(
                LinkErrorKind::LinkErrorKindMissingHir,
                msg,
                span
            )
            let d = link_error_to_diagnostic(err)
            let sink_new = diag.diagnostics_push(sink_acc, d)
            let sink_acc = sink_new
            let has_err = true

            i = i + 1usize
            continue
        .end

        let hm = hir_opt.unwrap()

        # Fonctions publiques
        let fn_count = hm.fns.len()
        let fi = 0usize
        let t_fn = t_acc
        let sink_fn = sink_acc
        let has_err_fn = has_err

        while fi < fn_count:
            let f = hm.fns[fi]
            if f.visibility == hir.HirVisibility::HirVisibilityPublic:
                let sym = LinkSymbol(
                    name = f.name,
                    kind = LinkSymbolKind::LinkSymbolKindFunction,
                    defining_module_index = i,
                    span = f.span
                )
                let pair_sym = link_symbol_table_try_insert(t_fn, sym)
                let t_fn2 = pair_sym.0
                let err_opt = pair_sym.1

                let t_fn = t_fn2

                if err_opt.is_some():
                    let err = err_opt.unwrap()
                    let d = link_error_to_diagnostic(err)
                    let sink_new2 = diag.diagnostics_push(sink_fn, d)
                    let sink_fn = sink_new2
                    let has_err_fn = true
                .end
            .end
            fi = fi + 1usize
        .end

        # Structs publiques
        let struct_count = hm.structs.len()
        let si = 0usize
        let t_struct = t_fn
        let sink_struct = sink_fn
        let has_err_struct = has_err_fn

        while si < struct_count:
            let s = hm.structs[si]
            if s.visibility == hir.HirVisibility::HirVisibilityPublic:
                let sym_s = LinkSymbol(
                    name = s.name,
                    kind = LinkSymbolKind::LinkSymbolKindStruct,
                    defining_module_index = i,
                    span = s.span
                )
                let pair_s = link_symbol_table_try_insert(t_struct, sym_s)
                let t_struct2 = pair_s.0
                let err_opt_s = pair_s.1

                let t_struct = t_struct2
                if err_opt_s.is_some():
                    let err_s = err_opt_s.unwrap()
                    let d_s = link_error_to_diagnostic(err_s)
                    let sink_new_s = diag.diagnostics_push(sink_struct, d_s)
                    let sink_struct = sink_new_s
                    let has_err_struct = true
                .end
            .end
            si = si + 1usize
        .end

        # Enums publiques
        let enum_count = hm.enums.len()
        let ei = 0usize
        let t_enum = t_struct
        let sink_enum = sink_struct
        let has_err_enum = has_err_struct

        while ei < enum_count:
            let e = hm.enums[ei]
            if e.visibility == hir.HirVisibility::HirVisibilityPublic:
                let sym_e = LinkSymbol(
                    name = e.name,
                    kind = LinkSymbolKind::LinkSymbolKindEnum,
                    defining_module_index = i,
                    span = e.span
                )
                let pair_e = link_symbol_table_try_insert(t_enum, sym_e)
                let t_enum2 = pair_e.0
                let err_opt_e = pair_e.1

                let t_enum = t_enum2
                if err_opt_e.is_some():
                    let err_e = err_opt_e.unwrap()
                    let d_e = link_error_to_diagnostic(err_e)
                    let sink_new_e = diag.diagnostics_push(sink_enum, d_e)
                    let sink_enum = sink_new_e
                    let has_err_enum = true
                .end
            .end
            ei = ei + 1usize
        .end

        # Consts publiques
        let const_count = hm.consts.len()
        let ci = 0usize
        let t_const = t_enum
        let sink_const = sink_enum
        let has_err_const = has_err_enum

        while ci < const_count:
            let c = hm.consts[ci]
            if c.visibility == hir.HirVisibility::HirVisibilityPublic:
                let sym_c = LinkSymbol(
                    name = c.name,
                    kind = LinkSymbolKind::LinkSymbolKindConst,
                    defining_module_index = i,
                    span = c.span
                )
                let pair_c = link_symbol_table_try_insert(t_const, sym_c)
                let t_const2 = pair_c.0
                let err_opt_c = pair_c.1

                let t_const = t_const2
                if err_opt_c.is_some():
                    let err_c = err_opt_c.unwrap()
                    let d_c = link_error_to_diagnostic(err_c)
                    let sink_new_c = diag.diagnostics_push(sink_const, d_c)
                    let sink_const = sink_new_c
                    let has_err_const = true
                .end
            .end
            ci = ci + 1usize
        .end

        let t_acc = t_const
        let sink_acc = sink_const
        let has_err = has_err_const

        i = i + 1usize
    .end

    let out = (t_acc, sink_acc, has_err)
    return out
.end

# ----------------------------------------------------------------------------
# Validation simple des unités liées
# ----------------------------------------------------------------------------

fn linker_validate_units(
    Vec<LinkInputModule> inputs,
    LinkSymbolTable symbols,
    LinkDependencyGraph dep_graph,
    diag.DiagnosticsSink sink,
    Bool has_error_in
) -> (diag.DiagnosticsSink, Bool):
    let has_err = has_error_in
    let sink_acc = sink

    # Placeholder : ici, on pourrait vérifier par exemple qu'il y a au moins
    # un module racine exécutable si la cible est un binaire natif.
    # Pour l'instant, on laisse ce passe trivial et sans erreur.
    let out = (sink_acc, has_err)
    return out
.end

# ----------------------------------------------------------------------------
# Choix du type d'artefact
# ----------------------------------------------------------------------------

fn linker_choose_artifact_kind(lang.LanguageConfig config) -> LinkedArtifactKind:
    let target = config.target_kind

    if target == lang.TargetKind::TargetKindNative:
        # Binaire natif par défaut
        return LinkedArtifactKind::LinkedArtifactKindExecutable
    .end

    if target == lang.TargetKind::TargetKindBytecode:
        return LinkedArtifactKind::LinkedArtifactKindBytecodeImage
    .end

    if target == lang.TargetKind::TargetKindWasm:
        return LinkedArtifactKind::LinkedArtifactKindWasmModule
    .end

    if target == lang.TargetKind::TargetKindC or
       target == lang.TargetKind::TargetKindHeaderOnly:
        # Pour C/header-only, on considère que l'artefact principal est un
        # ensemble d'objets, même si l'émission est textuelle.
        return LinkedArtifactKind::LinkedArtifactKindObject
    .end

    if target == lang.TargetKind::TargetKindRust:
        # Idem C : artefact logique = objets.
        return LinkedArtifactKind::LinkedArtifactKindObject
    .end

    # Fallback
    return LinkedArtifactKind::LinkedArtifactKindObject
.end

# ----------------------------------------------------------------------------
# Notes
# ----------------------------------------------------------------------------
# - Ce module fournit une couche de link purement déclarative, basée sur :
#     * LinkInputModule : description HIR + config d'un module,
#     * LinkSymbolTable : table des symboles globaux publics,
#     * LinkDependencyGraph : graphe de dépendances à partir des imports.
# - La construction fine du graphe, la résolution de symboles externes et
#   l'émission de binaire/bytecode sont attendues dans des modules dédiés
#   (backends ou passes ultérieurs), qui s'appuient sur ces structures.
# ============================================================================