


# ----------------------------------------------------------------------------
# Métadonnées avancées : génériques, contraintes, signatures
# ----------------------------------------------------------------------------

pub struct HirGenericParam:
    let name: String
    let span: diag.Span
.end

pub struct HirWherePredicate:
    let type_id: HirTypeId
    let constraint: String      # ex: "T: TraitA + TraitB"
    let span: diag.Span
.end

pub struct HirFnSignature:
    let fn_id: HirFnId
    let generics: Vec<HirGenericParam>
    let where_clauses: Vec<HirWherePredicate>
    let param_types: Vec<HirTypeId>
    let return_type: Option<HirTypeId>
    let span: diag.Span
.end

pub fn hir_fn_signature_new(
    HirFnId fn_id,
    Vec<HirGenericParam> generics,
    Vec<HirWherePredicate> where_clauses,
    Vec<HirTypeId> param_types,
    Option<HirTypeId> return_type,
    diag.Span span
) -> HirFnSignature:
    let s = HirFnSignature(
        fn_id = fn_id,
        generics = generics,
        where_clauses = where_clauses,
        param_types = param_types,
        return_type = return_type,
        span = span
    )
    return s
.end

# ----------------------------------------------------------------------------
# Contrôle de flux : CFG par fonction
# ----------------------------------------------------------------------------

pub struct HirControlFlowEdge:
    let from: HirBlockId
    let to: HirBlockId
.end

pub struct HirControlFlowGraph:
    let fn_id: HirFnId
    let blocks: Vec<HirBlockId>
    let edges: Vec<HirControlFlowEdge>
.end

pub fn cfg_new(HirFnId fn_id) -> HirControlFlowGraph:
    let blocks: Vec<HirBlockId> = Vec<HirBlockId>::new()
    let edges: Vec<HirControlFlowEdge> = Vec<HirControlFlowEdge>::new()

    let g = HirControlFlowGraph(
        fn_id = fn_id,
        blocks = blocks,
        edges = edges
    )
    return g
.end

pub fn cfg_add_block(HirControlFlowGraph cfg, HirBlockId block) -> HirControlFlowGraph:
    let blocks = cfg.blocks
    blocks.push(block)
    let g2 = HirControlFlowGraph(
        fn_id = cfg.fn_id,
        blocks = blocks,
        edges = cfg.edges
    )
    return g2
.end

pub fn cfg_add_edge(HirControlFlowGraph cfg, HirBlockId from, HirBlockId to) -> HirControlFlowGraph:
    let edges = cfg.edges
    let e = HirControlFlowEdge(from = from, to = to)
    edges.push(e)

    let g2 = HirControlFlowGraph(
        fn_id = cfg.fn_id,
        blocks = cfg.blocks,
        edges = edges
    )
    return g2
.end

# ----------------------------------------------------------------------------
# Environnement de symboles HIR (résolution de noms)
# ----------------------------------------------------------------------------

pub enum HirSymbolTag:
    HirSymbolTagLocal
    HirSymbolTagParam
    HirSymbolTagFn
    HirSymbolTagStruct
    HirSymbolTagEnum
    HirSymbolTagConst
.end

pub struct HirSymbol:
    let name: String
    let tag: HirSymbolTag
    let span: diag.Span

    # ID associé selon le tag (un seul est pertinent à la fois)
    let local_id: Option<HirLocalId>
    let param_id: Option<HirParamId>
    let fn_id: Option<HirFnId>
    let struct_id: Option<HirStructId>
    let enum_id: Option<HirEnumId>
    let const_id: Option<HirConstId>
.end

pub struct HirScope:
    let parent: Option<u32>                     # index vers un scope parent
    let symbols: coll.SmallMap<String, HirSymbol>
.end

pub struct HirSymbolTable:
    let scopes: Vec<HirScope>
.end

pub fn hir_symbol_table_new() -> HirSymbolTable:
    let scopes: Vec<HirScope> = Vec<HirScope>::new()
    let table = HirSymbolTable(scopes = scopes)
    return table
.end

pub fn hir_scope_new(Option<u32> parent) -> HirScope:
    let syms = coll.small_map_new<String, HirSymbol>()
    let scope = HirScope(
        parent = parent,
        symbols = syms
    )
    return scope
.end

pub fn hir_symbol_table_push_scope(HirSymbolTable table, Option<u32> parent) -> (HirSymbolTable, u32):
    let scopes = table.scopes
    let new_index: u32 = (scopes.len() as u32)
    let scope = hir_scope_new(parent)
    scopes.push(scope)

    let t2 = HirSymbolTable(scopes = scopes)
    let out = (t2, new_index)
    return out
.end

pub fn hir_symbol_table_insert(HirSymbolTable table, u32 scope_index, HirSymbol sym) -> HirSymbolTable:
    let scopes = table.scopes
    let scope = scopes[scope_index]
    let sm = scope.symbols
    let sm2 = coll.small_map_insert<String, HirSymbol>(sm, sym.name, sym)

    let scope2 = HirScope(
        parent = scope.parent,
        symbols = sm2
    )
    scopes[scope_index] = scope2

    let t2 = HirSymbolTable(scopes = scopes)
    return t2
.end

pub fn hir_symbol_table_lookup(HirSymbolTable table, u32 scope_index, String name) -> Option<HirSymbol>:
    let scopes = table.scopes
    let current = scope_index

    while true:
        let scope = scopes[current]
        let sm = scope.symbols
        let found = coll.small_map_get<String, HirSymbol>(sm, name)
        if found.is_some():
            return found
        .end

        let parent_opt = scope.parent
        if parent_opt.is_none():
            let none_sym: Option<HirSymbol> = Option<HirSymbol>::None()
            return none_sym
        .end

        let parent = parent_opt.unwrap()
        let current = parent
    .end

    let none_sym2: Option<HirSymbol> = Option<HirSymbol>::None()
    return none_sym2
.end

# ----------------------------------------------------------------------------
# Helpers de création de symboles typés
# ----------------------------------------------------------------------------

pub fn hir_symbol_local(String name, HirLocalId id, diag.Span span) -> HirSymbol:
    let none_param: Option<HirParamId> = Option<HirParamId>::None()
    let none_fn: Option<HirFnId> = Option<HirFnId>::None()
    let none_struct: Option<HirStructId> = Option<HirStructId>::None()
    let none_enum: Option<HirEnumId> = Option<HirEnumId>::None()
    let none_const: Option<HirConstId> = Option<HirConstId>::None()

    let some_local: Option<HirLocalId> = Option<HirLocalId>::Some(id)

    let s = HirSymbol(
        name = name,
        tag = HirSymbolTag::HirSymbolTagLocal,
        span = span,
        local_id = some_local,
        param_id = none_param,
        fn_id = none_fn,
        struct_id = none_struct,
        enum_id = none_enum,
        const_id = none_const
    )
    return s
.end

pub fn hir_symbol_param(String name, HirParamId id, diag.Span span) -> HirSymbol:
    let none_local: Option<HirLocalId> = Option<HirLocalId>::None()
    let none_fn: Option<HirFnId> = Option<HirFnId>::None()
    let none_struct: Option<HirStructId> = Option<HirStructId>::None()
    let none_enum: Option<HirEnumId> = Option<HirEnumId>::None()
    let none_const: Option<HirConstId> = Option<HirConstId>::None()

    let some_param: Option<HirParamId> = Option<HirParamId>::Some(id)

    let s = HirSymbol(
        name = name,
        tag = HirSymbolTag::HirSymbolTagParam,
        span = span,
        local_id = none_local,
        param_id = some_param,
        fn_id = none_fn,
        struct_id = none_struct,
        enum_id = none_enum,
        const_id = none_const
    )
    return s
.end

pub fn hir_symbol_fn(String name, HirFnId id, diag.Span span) -> HirSymbol:
    let none_local: Option<HirLocalId> = Option<HirLocalId>::None()
    let none_param: Option<HirParamId> = Option<HirParamId>::None()
    let none_struct: Option<HirStructId> = Option<HirStructId>::None()
    let none_enum: Option<HirEnumId> = Option<HirEnumId>::None()
    let none_const: Option<HirConstId> = Option<HirConstId>::None()

    let some_fn: Option<HirFnId> = Option<HirFnId>::Some(id)

    let s = HirSymbol(
        name = name,
        tag = HirSymbolTag::HirSymbolTagFn,
        span = span,
        local_id = none_local,
        param_id = none_param,
        fn_id = some_fn,
        struct_id = none_struct,
        enum_id = none_enum,
        const_id = none_const
    )
    return s
.end

# ----------------------------------------------------------------------------
# Notes complémentaires
# ----------------------------------------------------------------------------
# - Ces métadonnées (signatures, CFG, symbol table) ne sont pas nécessaires à
#   un premier HIR minimal, mais permettent d’outiller proprement :
#       * un vérificateur de types génériques (via HirFnSignature + HirTypeId),
#       * un résolveur de noms hiérarchique (HirSymbolTable),
#       * des analyses de flux (CFG) pour la détection de paths non terminants
#         ou la préparation d’un MIR.
# - L’objectif est de garder toutes ces structures optionnelles et séparées
#   du cœur HIR pour ne pas complexifier les backends simples.
# ----------------------------------------------------------------------------


# ----------------------------------------------------------------------------
# Environnement générique HIR (paramètres & where-clauses)
# ----------------------------------------------------------------------------

pub struct HirGenericEnv:
    let params: Vec<HirGenericParam>
    let where_clauses: Vec<HirWherePredicate>
.end

pub fn hir_generic_env_new(
    Vec<HirGenericParam> params,
    Vec<HirWherePredicate> where_clauses
) -> HirGenericEnv:
    let env = HirGenericEnv(
        params = params,
        where_clauses = where_clauses
    )
    return env
.end

pub fn hir_generic_env_empty() -> HirGenericEnv:
    let params: Vec<HirGenericParam> = Vec<HirGenericParam>::new()
    let clauses: Vec<HirWherePredicate> = Vec<HirWherePredicate>::new()
    let env = HirGenericEnv(
        params = params,
        where_clauses = clauses
    )
    return env
.end

# Création naïve de signature à partir d'une fonction existante dans le module.
# (Les génériques / where-clauses sont laissées vides pour l'instant.)

pub fn hir_fn_signature_from_fn(HirModule m, HirFnId fn_id) -> Option<HirFnSignature>:
    let f = m.fns[fn_id]
    let generics: Vec<HirGenericParam> = Vec<HirGenericParam>::new()
    let where_clauses: Vec<HirWherePredicate> = Vec<HirWherePredicate>::new()

    let param_types: Vec<HirTypeId> = Vec<HirTypeId>::new()
    let ps = f.params
    let n = ps.len()
    let i = 0usize

    while i < n:
        let pid = ps[i]
        let p = m.params[pid]
        param_types.push(p.ty)
        i = i + 1usize
    .end

    let sig = hir_fn_signature_new(
        fn_id,
        generics,
        where_clauses,
        param_types,
        f.return_type,
        f.span
    )

    let some_sig: Option<HirFnSignature> = Option<HirFnSignature>::Some(sig)
    return some_sig
.end

# ----------------------------------------------------------------------------
# Utilitaires CFG supplémentaires
# ----------------------------------------------------------------------------

pub fn cfg_block_count(HirControlFlowGraph cfg) -> usize:
    return cfg.blocks.len()
.end

pub fn cfg_edge_count(HirControlFlowGraph cfg) -> usize:
    return cfg.edges.len()
.end

pub fn cfg_successors(HirControlFlowGraph cfg, HirBlockId block) -> Vec<HirBlockId>:
    let out: Vec<HirBlockId> = Vec<HirBlockId>::new()
    let edges = cfg.edges
    let n = edges.len()
    let i = 0usize

    while i < n:
        let e = edges[i]
        if e.from == block:
            out.push(e.to)
        .end
        i = i + 1usize
    .end

    return out
.end

pub fn cfg_predecessors(HirControlFlowGraph cfg, HirBlockId block) -> Vec<HirBlockId>:
    let out: Vec<HirBlockId> = Vec<HirBlockId>::new()
    let edges = cfg.edges
    let n = edges.len()
    let i = 0usize

    while i < n:
        let e = edges[i]
        if e.to == block:
            out.push(e.from)
        .end
        i = i + 1usize
    .end

    return out
.end

pub fn cfg_has_edge(HirControlFlowGraph cfg, HirBlockId from, HirBlockId to) -> Bool:
    let edges = cfg.edges
    let n = edges.len()
    let i = 0usize

    while i < n:
        let e = edges[i]
        if e.from == from and e.to == to:
            return true
        .end
        i = i + 1usize
    .end

    return false
.end

# ----------------------------------------------------------------------------
# Helpers de création de symboles supplémentaires (struct, enum, const)
# ----------------------------------------------------------------------------

pub fn hir_symbol_struct(String name, HirStructId id, diag.Span span) -> HirSymbol:
    let none_local: Option<HirLocalId> = Option<HirLocalId>::None()
    let none_param: Option<HirParamId> = Option<HirParamId>::None()
    let none_fn: Option<HirFnId> = Option<HirFnId>::None()
    let none_enum: Option<HirEnumId> = Option<HirEnumId>::None()
    let none_const: Option<HirConstId> = Option<HirConstId>::None()

    let some_struct: Option<HirStructId> = Option<HirStructId>::Some(id)

    let s = HirSymbol(
        name = name,
        tag = HirSymbolTag::HirSymbolTagStruct,
        span = span,
        local_id = none_local,
        param_id = none_param,
        fn_id = none_fn,
        struct_id = some_struct,
        enum_id = none_enum,
        const_id = none_const
    )
    return s
.end

pub fn hir_symbol_enum(String name, HirEnumId id, diag.Span span) -> HirSymbol:
    let none_local: Option<HirLocalId> = Option<HirLocalId>::None()
    let none_param: Option<HirParamId> = Option<HirParamId>::None()
    let none_fn: Option<HirFnId> = Option<HirFnId>::None()
    let none_struct: Option<HirStructId> = Option<HirStructId>::None()
    let none_const: Option<HirConstId> = Option<HirConstId>::None()

    let some_enum: Option<HirEnumId> = Option<HirEnumId>::Some(id)

    let s = HirSymbol(
        name = name,
        tag = HirSymbolTag::HirSymbolTagEnum,
        span = span,
        local_id = none_local,
        param_id = none_param,
        fn_id = none_fn,
        struct_id = none_struct,
        enum_id = some_enum,
        const_id = none_const
    )
    return s
.end

pub fn hir_symbol_const(String name, HirConstId id, diag.Span span) -> HirSymbol:
    let none_local: Option<HirLocalId> = Option<HirLocalId>::None()
    let none_param: Option<HirParamId> = Option<HirParamId>::None()
    let none_fn: Option<HirFnId> = Option<HirFnId>::None()
    let none_struct: Option<HirStructId> = Option<HirStructId>::None()
    let none_enum: Option<HirEnumId> = Option<HirEnumId>::None()

    let some_const: Option<HirConstId> = Option<HirConstId>::Some(id)

    let s = HirSymbol(
        name = name,
        tag = HirSymbolTag::HirSymbolTagConst,
        span = span,
        local_id = none_local,
        param_id = none_param,
        fn_id = none_fn,
        struct_id = none_struct,
        enum_id = none_enum,
        const_id = some_const
    )
    return s
.end

# ----------------------------------------------------------------------------
# Utilitaires sur la table de symboles
# ----------------------------------------------------------------------------

pub fn hir_symbol_table_has(HirSymbolTable table, u32 scope_index, String name) -> Bool:
    let found = hir_symbol_table_lookup(table, scope_index, name)
    return found.is_some()
.end

pub fn hir_scope_parent_index(HirSymbolTable table, u32 scope_index) -> Option<u32>:
    let scopes = table.scopes
    let scope = scopes[scope_index]
    return scope.parent
.end