module vitte.compiler.tools

import std.collections as coll
import vitte.compiler.span as span
import vitte.compiler.tokens as tok
import vitte.compiler.syntax as syn
import vitte.compiler.symbols as sym
import vitte.compiler.scope as sc
import vitte.compiler.stdlib as stdlib

# =============================================================================
# Vitte compiler – Tools & high-level utilities (maximal, logique, sans I/O)
# =============================================================================
#
# Objectifs :
#   - Regrouper des helpers transverses pour le front-end Vitte :
#       * requêtes par position (token / syntax / symbole),
#       * classification simple d’items / symboles,
#       * utilitaires de formatage (paths, spans),
#       * petites opérations de navigation sur le SyntaxTree.
#   - Ne dépendre que des modules logiques :
#       span, tokens, syntax, symbols, scope, stdlib.
#   - Ne faire aucun I/O (pas de disque, pas de stdout/stderr).
#
# Ce module joue un rôle de "boîte à outils" ; il ne contient ni parsing
# ni typage complet, seulement des opérations de haut niveau sur les
# structures déjà construites par le lexer / parseur / résolveur.
# =============================================================================

# -----------------------------------------------------------------------------
# Résultats de lookup par position
# -----------------------------------------------------------------------------

pub struct ToolsLookupByPosResult:
    let token_id: coll.Option<tok.TokenId>
    let item_id: coll.Option<syn.ItemId>
    let stmt_id: coll.Option<syn.StmtId>
    let expr_id: coll.Option<syn.ExprId>
    let pattern_id: coll.Option<syn.PatternId>
    let type_id: coll.Option<syn.TypeExprId>
    let path_id: coll.Option<syn.PathId>
    let symbol_id: coll.Option<sym.SymbolId>
.end

# -----------------------------------------------------------------------------
# Helpers privés : "plus petit span contenant la position"
# -----------------------------------------------------------------------------

fn tools_best_item_at_pos(
    tree: syn.SyntaxTree,
    pos: span.BytePos
) -> coll.Option<syn.ItemId>:
    let items = tree.items
    let n = items.len()
    let i = (usize) 0

    let found = false
    let best_len = (span.ByteLen) 0
    let best_id = (syn.ItemId) 0

    while i < n:
        let it = items[i]
        let sp = it.span
        let contains = span.span_contains_pos(sp, pos)
        if contains:
            let len = span.span_len(sp)
            if not found:
                let found = true
                let best_len = len
                let best_id = it.id
            else:
                if len <= best_len:
                    let best_len = len
                    let best_id = it.id
                .end
            .end
        .end
        let i = i + (usize) 1
    .end

    let out = coll.option_none<syn.ItemId>()
    if found:
        out = coll.option_some<syn.ItemId>(best_id)
    .end
    return out
.end

fn tools_best_stmt_at_pos(
    tree: syn.SyntaxTree,
    pos: span.BytePos
) -> coll.Option<syn.StmtId>:
    let stmts = tree.stmts
    let n = stmts.len()
    let i = (usize) 0

    let found = false
    let best_len = (span.ByteLen) 0
    let best_id = (syn.StmtId) 0

    while i < n:
        let st = stmts[i]
        let sp = st.span
        let contains = span.span_contains_pos(sp, pos)
        if contains:
            let len = span.span_len(sp)
            if not found:
                let found = true
                let best_len = len
                let best_id = st.id
            else:
                if len <= best_len:
                    let best_len = len
                    let best_id = st.id
                .end
            .end
        .end
        let i = i + (usize) 1
    .end

    let out = coll.option_none<syn.StmtId>()
    if found:
        out = coll.option_some<syn.StmtId>(best_id)
    .end
    return out
.end

fn tools_best_expr_at_pos(
    tree: syn.SyntaxTree,
    pos: span.BytePos
) -> coll.Option<syn.ExprId>:
    let exprs = tree.exprs
    let n = exprs.len()
    let i = (usize) 0

    let found = false
    let best_len = (span.ByteLen) 0
    let best_id = (syn.ExprId) 0

    while i < n:
        let e = exprs[i]
        let sp = e.span
        let contains = span.span_contains_pos(sp, pos)
        if contains:
            let len = span.span_len(sp)
            if not found:
                let found = true
                let best_len = len
                let best_id = e.id
            else:
                if len <= best_len:
                    let best_len = len
                    let best_id = e.id
                .end
            .end
        .end
        let i = i + (usize) 1
    .end

    let out = coll.option_none<syn.ExprId>()
    if found:
        out = coll.option_some<syn.ExprId>(best_id)
    .end
    return out
.end

fn tools_best_pattern_at_pos(
    tree: syn.SyntaxTree,
    pos: span.BytePos
) -> coll.Option<syn.PatternId>:
    let pats = tree.patterns
    let n = pats.len()
    let i = (usize) 0

    let found = false
    let best_len = (span.ByteLen) 0
    let best_id = (syn.PatternId) 0

    while i < n:
        let p = pats[i]
        let sp = p.span
        let contains = span.span_contains_pos(sp, pos)
        if contains:
            let len = span.span_len(sp)
            if not found:
                let found = true
                let best_len = len
                let best_id = p.id
            else:
                if len <= best_len:
                    let best_len = len
                    let best_id = p.id
                .end
            .end
        .end
        let i = i + (usize) 1
    .end

    let out = coll.option_none<syn.PatternId>()
    if found:
        out = coll.option_some<syn.PatternId>(best_id)
    .end
    return out
.end

fn tools_best_type_at_pos(
    tree: syn.SyntaxTree,
    pos: span.BytePos
) -> coll.Option<syn.TypeExprId>:
    let types = tree.types
    let n = types.len()
    let i = (usize) 0

    let found = false
    let best_len = (span.ByteLen) 0
    let best_id = (syn.TypeExprId) 0

    while i < n:
        let t = types[i]
        let sp = t.span
        let contains = span.span_contains_pos(sp, pos)
        if contains:
            let len = span.span_len(sp)
            if not found:
                let found = true
                let best_len = len
                let best_id = t.id
            else:
                if len <= best_len:
                    let best_len = len
                    let best_id = t.id
                .end
            .end
        .end
        let i = i + (usize) 1
    .end

    let out = coll.option_none<syn.TypeExprId>()
    if found:
        out = coll.option_some<syn.TypeExprId>(best_id)
    .end
    return out
.end

fn tools_best_path_at_pos(
    tree: syn.SyntaxTree,
    pos: span.BytePos
) -> coll.Option<syn.PathId>:
    let paths = tree.paths
    let n = paths.len()
    let i = (usize) 0

    let found = false
    let best_len = (span.ByteLen) 0
    let best_id = (syn.PathId) 0

    while i < n:
        let p = paths[i]
        let sp = p.span
        let contains = span.span_contains_pos(sp, pos)
        if contains:
            let len = span.span_len(sp)
            if not found:
                let found = true
                let best_len = len
                let best_id = p.id
            else:
                if len <= best_len:
                    let best_len = len
                    let best_id = p.id
                .end
            .end
        .end
        let i = i + (usize) 1
    .end

    let out = coll.option_none<syn.PathId>()
    if found:
        out = coll.option_some<syn.PathId>(best_id)
    .end
    return out
.end

# -----------------------------------------------------------------------------
# Lookup global par position
# -----------------------------------------------------------------------------

pub fn tools_lookup_by_pos(
    lex: tok.LexResult,
    tree: syn.SyntaxTree,
    symbol_spans: sym.SpanSymbolMap,
    pos: span.BytePos
) -> ToolsLookupByPosResult:
    # 1) Token au point pos
    let stream = lex.stream
    let token_opt = tok.token_stream_find_token_at_pos(stream, pos)

    # 2) Nœuds syntaxiques les plus "profonds" (span minimal contenant pos)
    let item_opt = tools_best_item_at_pos(tree, pos)
    let stmt_opt = tools_best_stmt_at_pos(tree, pos)
    let expr_opt = tools_best_expr_at_pos(tree, pos)
    let pat_opt = tools_best_pattern_at_pos(tree, pos)
    let ty_opt = tools_best_type_at_pos(tree, pos)
    let path_opt = tools_best_path_at_pos(tree, pos)

    # 3) Symbole associé via map Span -> SymbolId
    let sym_opt = sym.span_symbol_map_find_first_containing_pos(symbol_spans, pos)

    let res = ToolsLookupByPosResult {
        token_id: token_opt,
        item_id: item_opt,
        stmt_id: stmt_opt,
        expr_id: expr_opt,
        pattern_id: pat_opt,
        type_id: ty_opt,
        path_id: path_opt,
        symbol_id: sym_opt
    }
    return res
.end

# -----------------------------------------------------------------------------
# Helpers de classification / info
# -----------------------------------------------------------------------------

pub fn tools_item_kind_to_string(kind: syn.ItemKind) -> String:
    if kind == syn.ItemKind::ItemKindModule:
        return "module"
    .end
    if kind == syn.ItemKind::ItemKindImport:
        return "import"
    .end
    if kind == syn.ItemKind::ItemKindExport:
        return "export"
    .end
    if kind == syn.ItemKind::ItemKindMuffinManifest:
        return "muffin"
    .end
    if kind == syn.ItemKind::ItemKindStruct:
        return "struct"
    .end
    if kind == syn.ItemKind::ItemKindUnion:
        return "union"
    .end
    if kind == syn.ItemKind::ItemKindEnum:
        return "enum"
    .end
    if kind == syn.ItemKind::ItemKindTypedef:
        return "typedef"
    .end
    if kind == syn.ItemKind::ItemKindTrait:
        return "trait"
    .end
    if kind == syn.ItemKind::ItemKindImpl:
        return "impl"
    .end
    if kind == syn.ItemKind::ItemKindFunction:
        return "fn"
    .end
    if kind == syn.ItemKind::ItemKindScenario:
        return "scenario"
    .end
    if kind == syn.ItemKind::ItemKindEntryPoint:
        return "entry"
    .end
    if kind == syn.ItemKind::ItemKindTopLevelLet:
        return "top_let"
    .end
    if kind == syn.ItemKind::ItemKindTopLevelConst:
        return "top_const"
    .end
    if kind == syn.ItemKind::ItemKindTopLevelExpr:
        return "top_expr"
    .end
    return "unknown"
.end

pub fn tools_symbol_origin_to_string(origin: sym.SymbolOrigin) -> String:
    if origin == sym.SymbolOrigin::SymbolOriginUserCode:
        return "user"
    .end
    if origin == sym.SymbolOrigin::SymbolOriginStdlib:
        return "stdlib"
    .end
    if origin == sym.SymbolOrigin::SymbolOriginBuiltin:
        return "builtin"
    .end
    return "unknown"
.end

pub fn tools_symbol_is_from_std_or_builtin(symb: sym.ResolvedSymbol) -> bool:
    if symb.origin == sym.SymbolOrigin::SymbolOriginStdlib:
        return true
    .end
    if symb.origin == sym.SymbolOrigin::SymbolOriginBuiltin:
        return true
    .end
    return false
.end

# -----------------------------------------------------------------------------
# Collecte d’éléments dans le SyntaxTree
# -----------------------------------------------------------------------------

pub fn tools_items_of_kind(
    tree: syn.SyntaxTree,
    kind: syn.ItemKind
) -> Vec<syn.ItemId>:
    let items = tree.items
    let n = items.len()
    let i = (usize) 0
    let out = Vec<syn.ItemId>::new()

    while i < n:
        let it = items[i]
        if it.kind == kind:
            out.push(it.id)
        .end
        let i = i + (usize) 1
    .end

    return out
.end

pub fn tools_collect_functions(tree: syn.SyntaxTree) -> Vec<syn.ItemId>:
    let out = tools_items_of_kind(tree, syn.ItemKind::ItemKindFunction)
    return out
.end

pub fn tools_collect_structs(tree: syn.SyntaxTree) -> Vec<syn.ItemId>:
    let out = tools_items_of_kind(tree, syn.ItemKind::ItemKindStruct)
    return out
.end

pub fn tools_collect_enums(tree: syn.SyntaxTree) -> Vec<syn.ItemId>:
    let out = tools_items_of_kind(tree, syn.ItemKind::ItemKindEnum)
    return out
.end

pub fn tools_collect_traits(tree: syn.SyntaxTree) -> Vec<syn.ItemId>:
    let out = tools_items_of_kind(tree, syn.ItemKind::ItemKindTrait)
    return out
.end

# -----------------------------------------------------------------------------
# Utils paths / spans / types builtin
# -----------------------------------------------------------------------------

# Concatène les segments d’un Path avec "::".
pub fn tools_path_to_string(tree: syn.SyntaxTree, path_id: syn.PathId) -> String:
    let paths = tree.paths
    let idx = (usize) path_id
    let p = paths[idx]
    let segs = p.segments
    let n = segs.len()
    let i = (usize) 0

    let out = ""

    while i < n:
        let seg = segs[i]
        if out == "":
            out = seg.name
        else:
            out = out + "::" + seg.name
        .end
        let i = i + (usize) 1
    .end

    return out
.end

# Wrapper simple autour du span debug string (défini dans vitte.compiler.span).
pub fn tools_span_debug(sp: span.Span) -> String:
    let s = span.span_to_debug_string(sp)
    return s
.end

# Vérifie si un nom de type correspond à un type builtin dans le StdlibCatalog.
pub fn tools_is_builtin_type(
    catalog: stdlib.StdlibCatalog,
    type_name: String
) -> bool:
    let ok = stdlib.stdlib_is_builtin_type_name(catalog, type_name)
    return ok
.end

# -----------------------------------------------------------------------------
# Helpers Scope / Symbol
# -----------------------------------------------------------------------------

# Retourne la chaîne de scope complète pour un symbole (via ScopeTree).
# On délègue la reconstruction du chemin aux helpers de scope.
pub fn tools_symbol_full_scope_path(
    scopes: sc.ScopeTree,
    symbol: sym.ResolvedSymbol
) -> String:
    let scope_id = symbol.scope_id
    let scp = sc.scope_tree_get_scope(scopes, scope_id)
    let path = sc.scope_tree_scope_path(scopes, scp.id)
    return path
.end

# -----------------------------------------------------------------------------
# Scénario interne de smoke-test
# -----------------------------------------------------------------------------

scenario tools_smoke_test():
    # 1) Stdlib + spans
    let catalog = stdlib.stdlib_catalog_new_default()
    let is_i32_builtin = tools_is_builtin_type(catalog, "i32")
    let is_foo_builtin = tools_is_builtin_type(catalog, "Foo")

    let sp0 = span.span_from_len((span.BytePos) 0, (span.ByteLen) 10)
    let _dbg = tools_span_debug(sp0)

    # 2) Tokens / lex result minimal
    let file = span.file_id_new(0)
    let lex0 = tok.lex_result_new(file)

    let sp_kw = span.span_from_len((span.BytePos) 0, (span.ByteLen) 6)
    let tok_kw = tok.Token {
        id: (tok.TokenId) 0,
        kind: tok.TokenKind::TokenKeyword,
        keyword: coll.option_some<tok.KeywordKind>(tok.KeywordKind::KeywordModule),
        literal_kind: coll.option_none<tok.LiteralTokenKind>(),
        punct: coll.option_none<tok.PunctKind>(),
        op: coll.option_none<tok.OperatorKind>(),
        trivia_kind: coll.option_none<tok.TriviaKind>(),
        text: "module",
        span: sp_kw
    }

    let lex1 = tok.lex_result_add_token(lex0, tok_kw)

    # 3) SyntaxTree vide + SpanSymbolMap vide
    let syn0 = syn.syntax_tree_new()
    let span_map = sym.span_symbol_map_new()

    # 4) Lookup combiné
    let pos = (span.BytePos) 1
    let lookup = tools_lookup_by_pos(lex1, syn0, span_map, pos)
    let _tok = lookup.token_id
    let _item = lookup.item_id
    let _sym = lookup.symbol_id

    # 5) Collecteurs sur SyntaxTree vide
    let funs = tools_collect_functions(syn0)
    let structs = tools_collect_structs(syn0)
    let enums = tools_collect_enums(syn0)
    let traits = tools_collect_traits(syn0)

    let _ = is_i32_builtin
    let _ = is_foo_builtin
    let _ = funs
    let _ = structs
    let _ = enums
    let _ = traits
.end
