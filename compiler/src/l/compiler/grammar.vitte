module vitte.compiler.grammar

import vitte.compiler.collections as coll

# ============================================================================
# Vitte compiler – Grammaire officielle (ultra ultra ultra complet)
#
# Objectifs :
#   - Centraliser une version textuelle, canonique, de la grammaire Vitte
#     (noyau + syntaxe Phrase) au format EBNF commenté.
#   - Rendre cette grammaire accessible au compilateur, aux outils (LSP,
#     docgen, playground) et aux tests (doctests de grammaire).
#   - Ne PAS parser cette grammaire ici : ce module ne contient que des
#     chaînes; le parseur concret est ailleurs.
#
# Design :
#   - GrammarKind distingue noyau, Phrase, combiné, etc.
#   - GrammarBlock représente un bloc de grammaire (id, titre, lignes).
#   - Les lignes contiennent de l'EBNF fidèle à la spécification Vitte.
# ============================================================================

# ----------------------------------------------------------------------------
# Types de base
# ----------------------------------------------------------------------------

pub enum GrammarKind:
    GrammarCore          # noyau Vitte (avec pub/trait/impl, blocs .end)
    GrammarPhrase        # syntaxe Phrase (mod/use/type/fn/scn/prog)
    GrammarCombined      # vue combinée (core + phrase)
.end

pub struct GrammarBlock:
    let id: String
    let title: String
    let kind: GrammarKind
    let description: String
    let lines: Vec<String>
.end

fn mk_block(
    String id,
    String title,
    GrammarKind kind,
    String description,
    Vec<String> lines
) -> GrammarBlock:
    let b = GrammarBlock(
        id = id,
        title = title,
        kind = kind,
        description = description,
        lines = lines
    )
    return b
.end

fn push_line(Vec<String> v, String s) -> Vec<String>:
    v.push(s)
    return v
.end

fn append_blocks(Vec<GrammarBlock> dst, Vec<GrammarBlock> src) -> Vec<GrammarBlock>:
    let out = dst
    let n = src.len()
    let i = 0usize

    while i < n:
        let b = src[i]
        out.push(b)
        i = i + 1usize
    .end

    return out
.end

# ----------------------------------------------------------------------------
# Bloc : grammaire noyau Vitte (EBNF fidèle, avec pub/trait/impl, .end)
# ----------------------------------------------------------------------------

fn grammar_block_core_full() -> GrammarBlock:
    let lines = Vec<String>::new()
    let lines = push_line(lines, "(* =============================================================================")
    let lines = push_line(lines, "   Grammaire Vitte – noyau simple, lisible et authentique")
    let lines = push_line(lines, "")
    let lines = push_line(lines, "   Objectifs :")
    let lines = push_line(lines, "   - syntaxe accessible (lycée / licence), inspirée de Python et des langages")
    let lines = push_line(lines, "     modernes, avec indentation significative et mots-clés de fin explicites (\".end\") ;")
    let lines = push_line(lines, "   - noyau de mots-clés réduit mais expressif ;")
    let lines = push_line(lines, "   - séparation claire entre :")
    let lines = push_line(lines, "       • code source Vitte (modules, types, fonctions, scénarios),")
    let lines = push_line(lines, "       • manifestes Muffin (.muf) pour la build / les dépendances.")
    let lines = push_line(lines, "")
    let lines = push_line(lines, "   Ce fichier décrit UNIQUEMENT le langage Vitte \"cœur\" + les manifestes Muffin")
    let lines = push_line(lines, "   de base. Les extensions (build avancée, packaging complexe, etc.) peuvent être")
    let lines = push_line(lines, "   décrites dans des EBNF séparés (vitte-build.ebnf, vitte-pack.ebnf, ...).")
    let lines = push_line(lines, " ============================================================================= *)")
    let lines = push_line(lines, "")
    let lines = push_line(lines, "(* ----------------------------------------------------------------------------- *)")
    let lines = push_line(lines, "(* Mots-clés réservés                                                            *)")
    let lines = push_line(lines, "(* ----------------------------------------------------------------------------- *)")
    let lines = push_line(lines, "reserved_keyword =")
    let lines = push_line(lines, "      \"module\" | \"import\" | \"export\" | \"muffin\"")
    let lines = push_line(lines, "    | \"program\" | \"service\" | \"kernel\" | \"driver\" | \"tool\" | \"scenario\" | \"pipeline\"")
    let lines = push_line(lines, "    | \"struct\" | \"union\" | \"enum\" | \"typedef\" | \"inline\" | \"fn\"")
    let lines = push_line(lines, "    | \"extern\" | \"static\" | \"sizeof\" | \"alignof\"")
    let lines = push_line(lines, "    | \"let\" | \"const\"")
    let lines = push_line(lines, "    | \"if\" | \"elif\" | \"else\" | \"while\" | \"for\" | \"in\" | \"match\"")
    let lines = push_line(lines, "    | \"break\" | \"continue\" | \"return\"")
    let lines = push_line(lines, "    | \"and\" | \"or\" | \"not\"")
    let lines = push_line(lines, "    | \"true\" | \"false\" | \"null\"")
    let lines = push_line(lines, "    | \"as\" | \"all\"")
    let lines = push_line(lines, "    | \"volatile\" | \"restrict\"")
    let lines = push_line(lines, "    | \"pub\"")
    let lines = push_line(lines, "    | \"trait\" | \"impl\" | \"where\" ;")
    let lines = push_line(lines, "")
    let lines = push_line(lines, "(* Les identifiants ne peuvent pas être un mot-clé réservé. *)")
    let lines = push_line(lines, "")
    let lines = push_line(lines, "(* ----------------------------------------------------------------------------- *)")
    let lines = push_line(lines, "(* Racine de la grammaire                                                        *)")
    let lines = push_line(lines, "(* ----------------------------------------------------------------------------- *)")
    let lines = push_line(lines, "program = { annotated_top_level_declaration } ;")
    let lines = push_line(lines, "")
    let lines = push_line(lines, "annotated_top_level_declaration =")
    let lines = push_line(lines, "      { attribute } top_level_declaration ;")
    let lines = push_line(lines, "")
    let lines = push_line(lines, "top_level_declaration =")
    let lines = push_line(lines, "      module_declaration")
    let lines = push_line(lines, "    | import_declaration")
    let lines = push_line(lines, "    | export_declaration")
    let lines = push_line(lines, "    | muffin_manifest")
    let lines = push_line(lines, "    | type_declaration")
    let lines = push_line(lines, "    | trait_declaration")
    let lines = push_line(lines, "    | impl_declaration")
    let lines = push_line(lines, "    | function_declaration")
    let lines = push_line(lines, "    | scenario_declaration")
    let lines = push_line(lines, "    | entry_point_declaration")
    let lines = push_line(lines, "    | top_level_declaration_local ;")
    let lines = push_line(lines, "")
    let lines = push_line(lines, "top_level_declaration_local =")
    let lines = push_line(lines, "      declaration          (* let/const globales *)")
    let lines = push_line(lines, "    | expression_statement (* code exécutable au top-level, optionnel *) ;")
    let lines = push_line(lines, "")
    let lines = push_line(lines, "(* ----------------------------------------------------------------------------- *)")
    let lines = push_line(lines, "(* Modules, import, export                                                       *)")
    let lines = push_line(lines, "(* ----------------------------------------------------------------------------- *)")
    let lines = push_line(lines, "module_declaration = \"module\" module_name newline ;")
    let lines = push_line(lines, "")
    let lines = push_line(lines, "module_name = identifier { \".\" identifier } ;")
    let lines = push_line(lines, "")
    let lines = push_line(lines, "import_declaration =")
    let lines = push_line(lines, "      \"import\" module_name [ \"as\" alias ] newline")
    let lines = push_line(lines, "    | \"import\" \"{\" module_name [ \"as\" alias ] { \",\" module_name [ \"as\" alias ] } \"}\" newline ;")
    let lines = push_line(lines, "")
    let lines = push_line(lines, "export_declaration =")
    let lines = push_line(lines, "      \"export\" \"all\" [ \"from\" module_name ] newline")
    let lines = push_line(lines, "    | \"export\" export_list [ \"from\" module_name ] newline ;")
    let lines = push_line(lines, "")
    let lines = push_line(lines, "export_list = identifier { \",\" identifier } ;")
    let lines = push_line(lines, "")
    let lines = push_line(lines, "alias = identifier ;")
    let lines = push_line(lines, "")
    let lines = push_line(lines, "(* Attributs et visibilité *)")
    let lines = push_line(lines, "attribute =")
    let lines = push_line(lines, "    \"@\" identifier [ \"(\" attribute_argument_list \")\" ] ;")
    let lines = push_line(lines, "")
    let lines = push_line(lines, "attribute_argument_list =")
    let lines = push_line(lines, "    attribute_argument { \",\" attribute_argument } ;")
    let lines = push_line(lines, "")
    let lines = push_line(lines, "attribute_argument =")
    let lines = push_line(lines, "      literal")
    let lines = push_line(lines, "    | identifier")
    let lines = push_line(lines, "    | list_expression")
    let lines = push_line(lines, "    | map_expression ;")
    let lines = push_line(lines, "")
    let lines = push_line(lines, "visibility_modifier = \"pub\" ;")
    let lines = push_line(lines, "")
    let lines = push_line(lines, "(* ----------------------------------------------------------------------------- *)")
    let lines = push_line(lines, "(* Manifestes Muffin (.muf) – version minimale                                   *)")
    let lines = push_line(lines, "(* ----------------------------------------------------------------------------- *)")
    let lines = push_line(lines, "muffin_manifest =")
    let lines = push_line(lines, "    \"muffin\" file_path newline")
    let lines = push_line(lines, "        INDENT { muffin_entry } DEDENT")
    let lines = push_line(lines, "    \".end\" newline? ;")
    let lines = push_line(lines, "")
    let lines = push_line(lines, "file_path = string_literal ;")
    let lines = push_line(lines, "")
    let lines = push_line(lines, "muffin_entry = property_name \":\" property_value newline ;")
    let lines = push_line(lines, "")
    let lines = push_line(lines, "property_name  = identifier ;")
    let lines = push_line(lines, "property_value = literal | list_literal | map_expression ;")
    let lines = push_line(lines, "")
    let lines = push_line(lines, "list_literal   = \"[\" [ literal { \",\" literal } ] \"]\" ;")
    let lines = push_line(lines, "")
    let lines = push_line(lines, "(* ----------------------------------------------------------------------------- *)")
    let lines = push_line(lines, "(* Types et fonctions                                                            *)")
    let lines = push_line(lines, "(* ----------------------------------------------------------------------------- *)")
    let lines = push_line(lines, "type_declaration =")
    let lines = push_line(lines, "      struct_declaration")
    let lines = push_line(lines, "    | union_declaration")
    let lines = push_line(lines, "    | enum_declaration")
    let lines = push_line(lines, "    | typedef_declaration ;")
    let lines = push_line(lines, "")
    let lines = push_line(lines, "generic_param_list =")
    let lines = push_line(lines, "    \"<\" generic_param { \",\" generic_param } \">\" ;")
    let lines = push_line(lines, "")
    let lines = push_line(lines, "generic_param =")
    let lines = push_line(lines, "    identifier [ \":\" generic_bound_list ] ;")
    let lines = push_line(lines, "")
    let lines = push_line(lines, "generic_bound_list =")
    let lines = push_line(lines, "    named_type { \"+\" named_type } ;")
    let lines = push_line(lines, "")
    let lines = push_line(lines, "struct_declaration = [ visibility_modifier ] \"struct\" identifier [ generic_param_list ] type_body ;")
    let lines = push_line(lines, "union_declaration  = [ visibility_modifier ] \"union\"  identifier [ generic_param_list ] type_body ;")
    let lines = push_line(lines, "")
    let lines = push_line(lines, "type_body =")
    let lines = push_line(lines, "      \":\" newline")
    let lines = push_line(lines, "          INDENT { field_declaration } DEDENT")
    let lines = push_line(lines, "      \".end\" newline? ;")
    let lines = push_line(lines, "")
    let lines = push_line(lines, "field_declaration = \"let\" identifier \":\" type_expression [ \"=\" expression ] newline ;")
    let lines = push_line(lines, "")
    let lines = push_line(lines, "enum_declaration = [ visibility_modifier ] \"enum\" identifier [ generic_param_list ] enum_body ;")
    let lines = push_line(lines, "")
    let lines = push_line(lines, "enum_body =")
    let lines = push_line(lines, "      \":\" newline")
    let lines = push_line(lines, "          INDENT { enum_entry newline } DEDENT")
    let lines = push_line(lines, "      \".end\" newline? ;")
    let lines = push_line(lines, "")
    let lines = push_line(lines, "enum_entry = identifier [ \"=\" expression ] ;")
    let lines = push_line(lines, "")
    let lines = push_line(lines, "typedef_declaration = [ visibility_modifier ] \"typedef\" type_expression identifier newline ;")
    let lines = push_line(lines, "")
    let lines = push_line(lines, "(* Traits et implémentations – modèle inspiré de Rust, syntaxe Vitte *)")
    let lines = push_line(lines, "trait_declaration =")
    let lines = push_line(lines, "    [ visibility_modifier ] \"trait\" identifier [ generic_param_list ]")
    let lines = push_line(lines, "    [ trait_super_bounds ]")
    let lines = push_line(lines, "    trait_body ;")
    let lines = push_line(lines, "")
    let lines = push_line(lines, "trait_super_bounds =")
    let lines = push_line(lines, "    \":\" named_type { \"+\" named_type } ;")
    let lines = push_line(lines, "")
    let lines = push_line(lines, "trait_body =")
    let lines = push_line(lines, "      \":\" newline")
    let lines = push_line(lines, "          INDENT { trait_member } DEDENT")
    let lines = push_line(lines, "      \".end\" newline? ;")
    let lines = push_line(lines, "")
    let lines = push_line(lines, "trait_member =")
    let lines = push_line(lines, "      function_declaration")
    let lines = push_line(lines, "    | typedef_declaration")
    let lines = push_line(lines, "    | declaration ;")
    let lines = push_line(lines, "")
    let lines = push_line(lines, "impl_declaration =")
    let lines = push_line(lines, "    \"impl\" [ generic_param_list ]")
    let lines = push_line(lines, "    impl_target")
    let lines = push_line(lines, "    [ \"for\" named_type ]")
    let lines = push_line(lines, "    [ where_clause ]")
    let lines = push_line(lines, "    impl_body ;")
    let lines = push_line(lines, "")
    let lines = push_line(lines, "impl_target = named_type ;")
    let lines = push_line(lines, "")
    let lines = push_line(lines, "impl_body =")
    let lines = push_line(lines, "      \":\" newline")
    let lines = push_line(lines, "          INDENT { impl_member } DEDENT")
    let lines = push_line(lines, "      \".end\" newline? ;")
    let lines = push_line(lines, "")
    let lines = push_line(lines, "impl_member =")
    let lines = push_line(lines, "      function_declaration")
    let lines = push_line(lines, "    | typedef_declaration")
    let lines = push_line(lines, "    | declaration ;")
    let lines = push_line(lines, "")
    let lines = push_line(lines, "where_clause =")
    let lines = push_line(lines, "    \"where\" where_predicate { \",\" where_predicate } ;")
    let lines = push_line(lines, "")
    let lines = push_line(lines, "where_predicate =")
    let lines = push_line(lines, "    type_expression \":\" generic_bound_list ;")
    let lines = push_line(lines, "")
    let lines = push_line(lines, "scenario_declaration =")
    let lines = push_line(lines, "    [ visibility_modifier ] \"scenario\" identifier \"(\" [ parameter_list ] \")\" block ;")
    let lines = push_line(lines, "")
    let lines = push_line(lines, "function_declaration =")
    let lines = push_line(lines, "    [ visibility_modifier ]")
    let lines = push_line(lines, "    [ storage_specifier ] [ \"inline\" ] \"fn\" identifier")
    let lines = push_line(lines, "    [ generic_param_list ]")
    let lines = push_line(lines, "    \"(\" parameter_list \")\"")
    let lines = push_line(lines, "    [ \"->\" type_expression ]")
    let lines = push_line(lines, "    [ where_clause ]")
    let lines = push_line(lines, "    block ;")
    let lines = push_line(lines, "")
    let lines = push_line(lines, "storage_specifier = \"extern\" | \"static\" ;")
    let lines = push_line(lines, "")
    let lines = push_line(lines, "parameter_list = [ parameter { \",\" parameter } ] ;")
    let lines = push_line(lines, "parameter      = type_expression identifier ;")
    let lines = push_line(lines, "")
    let lines = push_line(lines, "type_expression =")
    let lines = push_line(lines, "    [ type_qualifier { type_qualifier } ]")
    let lines = push_line(lines, "    named_type")
    let lines = push_line(lines, "    { pointer_modifier | array_modifier }")
    let lines = push_line(lines, "    [ function_pointer_suffix ] ;")
    let lines = push_line(lines, "")
    let lines = push_line(lines, "named_type =")
    let lines = push_line(lines, "    identifier { \".\" identifier }")
    let lines = push_line(lines, "    [ generic_arguments ] ;")
    let lines = push_line(lines, "")
    let lines = push_line(lines, "generic_arguments =")
    let lines = push_line(lines, "    \"<\" type_expression { \",\" type_expression } \">\" ;")
    let lines = push_line(lines, "")
    let lines = push_line(lines, "type_qualifier = \"const\" | \"volatile\" | \"restrict\" ;")
    let lines = push_line(lines, "")
    let lines = push_line(lines, "pointer_modifier       = \"*\" | \"&\" ;")
    let lines = push_line(lines, "array_modifier         = \"[\" [ expression ] \"]\" ;")
    let lines = push_line(lines, "function_pointer_suffix = \"(\" parameter_list \")\" ;")
    let lines = push_line(lines, "")
    let lines = push_line(lines, "(* ----------------------------------------------------------------------------- *)")
    let lines = push_line(lines, "(* Points d'entrée Vitte (program, service, scenario, ...)                       *)")
    let lines = push_line(lines, "(* ----------------------------------------------------------------------------- *)")
    let lines = push_line(lines, "entry_point_declaration =")
    let lines = push_line(lines, "      [ visibility_modifier ] \"program\"  module_name block")
    let lines = push_line(lines, "    | [ visibility_modifier ] \"service\"  module_name block")
    let lines = push_line(lines, "    | [ visibility_modifier ] \"kernel\"   module_name block")
    let lines = push_line(lines, "    | [ visibility_modifier ] \"driver\"   module_name block")
    let lines = push_line(lines, "    | [ visibility_modifier ] \"tool\"     module_name block")
    let lines = push_line(lines, "    | [ visibility_modifier ] \"scenario\" module_name block")
    let lines = push_line(lines, "    | [ visibility_modifier ] \"pipeline\" module_name block ;")
    let lines = push_line(lines, "")
    let lines = push_line(lines, "(* ----------------------------------------------------------------------------- *)")
    let lines = push_line(lines, "(* Blocs et instructions                                                         *)")
    let lines = push_line(lines, "(* ----------------------------------------------------------------------------- *)")
    let lines = push_line(lines, "block =")
    let lines = push_line(lines, "      \":\" newline")
    let lines = push_line(lines, "          INDENT { statement } DEDENT")
    let lines = push_line(lines, "      \".end\" newline? ;")
    let lines = push_line(lines, "")
    let lines = push_line(lines, "statement =")
    let lines = push_line(lines, "      declaration")
    let lines = push_line(lines, "    | assignment")
    let lines = push_line(lines, "    | expression_statement")
    let lines = push_line(lines, "    | control_flow")
    let lines = push_line(lines, "    | jump_statement")
    let lines = push_line(lines, "    | return_statement ;")
    let lines = push_line(lines, "")
    let lines = push_line(lines, "declaration =")
    let lines = push_line(lines, "      \"let\"   identifier \"=\" expression newline")
    let lines = push_line(lines, "    | \"const\" identifier \"=\" expression newline ;")
    let lines = push_line(lines, "")
    let lines = push_line(lines, "assignment = assignable assignment_operator expression newline ;")
    let lines = push_line(lines, "")
    let lines = push_line(lines, "assignable = target ;")
    let lines = push_line(lines, "")
    let lines = push_line(lines, "assignment_operator =")
    let lines = push_line(lines, "      \"=\"  | \"+=\" | \"-=\" | \"*=\" | \"/=\"")
    let lines = push_line(lines, "    | \"&=\" | \"|=\" | \"^=\" | \"<<=\" | \">>=\" ;")
    let lines = push_line(lines, "")
    let lines = push_line(lines, "expression_statement = expression newline ;")
    let lines = push_line(lines, "")
    let lines = push_line(lines, "control_flow = if_statement | loop_statement | match_statement ;")
    let lines = push_line(lines, "")
    let lines = push_line(lines, "if_statement =")
    let lines = push_line(lines, "    \"if\" expression block")
    let lines = push_line(lines, "    { \"elif\" expression block }")
    let lines = push_line(lines, "    [ \"else\" block ] ;")
    let lines = push_line(lines, "")
    let lines = push_line(lines, "loop_statement =")
    let lines = push_line(lines, "      \"while\" expression block")
    let lines = push_line(lines, "    | \"for\" identifier \"in\" expression block ;")
    let lines = push_line(lines, "")
    let lines = push_line(lines, "match_statement = \"match\" expression match_block ;")
    let lines = push_line(lines, "")
    let lines = push_line(lines, "match_block =")
    let lines = push_line(lines, "      \":\" newline")
    let lines = push_line(lines, "          INDENT { match_arm } DEDENT")
    let lines = push_line(lines, "      \".end\" newline? ;")
    let lines = push_line(lines, "")
    let lines = push_line(lines, "match_arm = pattern \"=>\" block ;")
    let lines = push_line(lines, "")
    let lines = push_line(lines, "pattern =")
    let lines = push_line(lines, "      \"_\"")
    let lines = push_line(lines, "    | literal")
    let lines = push_line(lines, "    | identifier")
    let lines = push_line(lines, "    | pattern_tuple")
    let lines = push_line(lines, "    | pattern_list ;")
    let lines = push_line(lines, "")
    let lines = push_line(lines, "pattern_tuple = \"(\" pattern { \",\" pattern } \")\" ;")
    let lines = push_line(lines, "pattern_list  = \"[\" [ pattern { \",\" pattern } ] \"]\" ;")
    let lines = push_line(lines, "")
    let lines = push_line(lines, "jump_statement =")
    let lines = push_line(lines, "      \"break\" newline")
    let lines = push_line(lines, "    | \"continue\" newline ;")
    let lines = push_line(lines, "")
    let lines = push_line(lines, "return_statement = \"return\" [ expression ] newline ;")
    let lines = push_line(lines, "")
    let lines = push_line(lines, "expression =")
    let lines = push_line(lines, "      literal")
    let lines = push_line(lines, "    | target")
    let lines = push_line(lines, "    | call_expression")
    let lines = push_line(lines, "    | unary_expression")
    let lines = push_line(lines, "    | binary_expression")
    let lines = push_line(lines, "    | cast_expression")
    let lines = push_line(lines, "    | sizeof_expression")
    let lines = push_line(lines, "    | alignof_expression")
    let lines = push_line(lines, "    | parenthesized_expression")
    let lines = push_line(lines, "    | list_expression")
    let lines = push_line(lines, "    | map_expression ;")
    let lines = push_line(lines, "")
    let lines = push_line(lines, "target = identifier { target_suffix } ;")
    let lines = push_line(lines, "")
    let lines = push_line(lines, "target_suffix =")
    let lines = push_line(lines, "      \".\" identifier")
    let lines = push_line(lines, "    | \"[\" expression \"]\"")
    let lines = push_line(lines, "    | \"->\" identifier ;")
    let lines = push_line(lines, "")
    let lines = push_line(lines, "call_expression = target \"(\" [ argument_list ] \")\" ;")
    let lines = push_line(lines, "")
    let lines = push_line(lines, "argument_list = expression { \",\" expression } ;")
    let lines = push_line(lines, "")
    let lines = push_line(lines, "unary_expression = unary_operator expression ;")
    let lines = push_line(lines, "")
    let lines = push_line(lines, "unary_operator = \"-\" | \"not\" | \"&\" | \"*\" | \"~\" ;")
    let lines = push_line(lines, "")
    let lines = push_line(lines, "binary_expression = expression binary_operator expression ;")
    let lines = push_line(lines, "")
    let lines = push_line(lines, "binary_operator =")
    let lines = push_line(lines, "      \"+\" | \"-\" | \"*\" | \"/\" | \"%\"")
    let lines = push_line(lines, "    | \"==\" | \"!=\" | \"<\" | \"<=\" | \">\" | \">=\"")
    let lines = push_line(lines, "    | \"and\" | \"or\"")
    let lines = push_line(lines, "    | \"&\" | \"|\" | \"^\" | \"<<\" | \">>\"")
    let lines = push_line(lines, "    | \"|>\" ;   (* Vitte pipeline operator : expr |> f(...) *)")
    let lines = push_line(lines, "")
    let lines = push_line(lines, "cast_expression = \"(\" type_expression \")\" expression ;")
    let lines = push_line(lines, "")
    let lines = push_line(lines, "sizeof_expression   = \"sizeof\"   \"(\" type_expression \")\" ;")
    let lines = push_line(lines, "alignof_expression  = \"alignof\"  \"(\" type_expression \")\" ;")
    let lines = push_line(lines, "")
    let lines = push_line(lines, "parenthesized_expression = \"(\" expression \")\" ;")
    let lines = push_line(lines, "")
    let lines = push_line(lines, "list_expression = \"[\" [ expression { \",\" expression } ] \"]\" ;")
    let lines = push_line(lines, "")
    let lines = push_line(lines, "map_expression = \"{\" [ map_entry { \",\" map_entry } ] \"}\" ;")
    let lines = push_line(lines, "")
    let lines = push_line(lines, "map_entry = expression \":\" expression ;")
    let lines = push_line(lines, "")
    let lines = push_line(lines, "literal = number | string_literal | boolean_literal | \"null\" ;")
    let lines = push_line(lines, "")
    let lines = push_line(lines, "number = integer | float ;")
    let lines = push_line(lines, "")
    let lines = push_line(lines, "integer = digit { digit } ;")
    let lines = push_line(lines, "")
    let lines = push_line(lines, "float = digit { digit } \".\" digit { digit } ;")
    let lines = push_line(lines, "")
    let lines = push_line(lines, "string_literal = '\"' string_characters '\"' ;")
    let lines = push_line(lines, "")
    let lines = push_line(lines, "string_characters = { character } ;")
    let lines = push_line(lines, "")
    let lines = push_line(lines, "boolean_literal = \"true\" | \"false\" ;")
    let lines = push_line(lines, "")
    let lines = push_line(lines, "identifier = ident_head { ident_tail } ;")
    let lines = push_line(lines, "")
    let lines = push_line(lines, "ident_head = letter | '_' ;")
    let lines = push_line(lines, "ident_tail = letter | digit | '_' ;")
    let lines = push_line(lines, "")
    let lines = push_line(lines, "letter    = ? ASCII letter ? ;")
    let lines = push_line(lines, "digit     = ? ASCII digit  ? ;")
    let lines = push_line(lines, "character = ? printable except quote/backslash/newline ? ;")
    let lines = push_line(lines, "")
    let lines = push_line(lines, "newline = ? platform-dependent newline ? ;")
    let lines = push_line(lines, "INDENT  = ? indentation token produced by lexer ? ;")
    let lines = push_line(lines, "DEDENT  = ? dedentation token produced by lexer ? ;")
    let lines = push_line(lines, "")
    let lines = push_line(lines, "comment = \"#\" { ? any character except newline ? } newline ;")
    let lines = push_line(lines, "")
    let lines = push_line(lines, "(* Notes : le lexer génère NEWLINE, INDENT et DEDENT ")
    let lines = push_line(lines, "   à partir de l'indentation significative (style Python). ")
    let lines = push_line(lines, "   Les blocs sont bornés par un deux-points et \".end\". *)")

    let block = mk_block(
        "core_full",
        "Grammaire Vitte noyau (EBNF complet)",
        GrammarKind::GrammarCore,
        "Noyau du langage Vitte, avec pub/trait/impl et blocs .end.",
        lines
    )
    return block
.end

# ----------------------------------------------------------------------------
# Bloc : grammaire syntaxe Phrase (surface)
# ----------------------------------------------------------------------------

fn grammar_block_phrase_full() -> GrammarBlock:
    let lines = Vec<String>::new()
    let lines = push_line(lines, "(* =============================================================================")
    let lines = push_line(lines, "   Vitte Phrase Syntax — Langage de surface au-dessus du noyau Vitte")
    let lines = push_line(lines, "")
    let lines = push_line(lines, "   Objectifs :")
    let lines = push_line(lines, "   - syntaxe ultra simple, lisible, basée sur des \"phrases\" en début de ligne ;")
    let lines = push_line(lines, "   - blocs terminés par \".end\" (aucune accolade), pas de \";\" ;")
    let lines = push_line(lines, "   - mots-clés uniques : mod, use, type, field, fn, scn, prog, set, say, do,")
    let lines = push_line(lines, "     when, else when, else, loop, from, to, step, ret ;")
    let lines = push_line(lines, "   - cette grammaire décrit UNIQUEMENT la syntaxe \"phrase\" de surface.")
    let lines = push_line(lines, "   - le compilateur la désucre ensuite vers la grammaire noyau ci-dessus.")
    let lines = push_line(lines, " ============================================================================= *)")
    let lines = push_line(lines, "")
    let lines = push_line(lines, "phrase_reserved_keyword =")
    let lines = push_line(lines, "      \"mod\" | \"use\" | \"type\" | \"field\" | \"fn\" | \"scn\" | \"prog\"")
    let lines = push_line(lines, "    | \"set\" | \"say\" | \"do\" | \"ret\"")
    let lines = push_line(lines, "    | \"when\" | \"else\" | \"loop\" | \"from\" | \"to\" | \"step\"")
    let lines = push_line(lines, "    | \"end\" ;")
    let lines = push_line(lines, "")
    let lines = push_line(lines, "phrase_program = { phrase_top_level } ;")
    let lines = push_line(lines, "")
    let lines = push_line(lines, "phrase_top_level =")
    let lines = push_line(lines, "      module_line")
    let lines = push_line(lines, "    | use_line")
    let lines = push_line(lines, "    | type_block")
    let lines = push_line(lines, "    | fn_block")
    let lines = push_line(lines, "    | scenario_block")
    let lines = push_line(lines, "    | program_block")
    let lines = push_line(lines, "    | phrase_empty_line")
    let lines = push_line(lines, "    | phrase_comment_line ;")
    let lines = push_line(lines, "")
    let lines = push_line(lines, "phrase_empty_line   = newline ;")
    let lines = push_line(lines, "phrase_comment_line = \"#\" { ? any character except newline ? } newline ;")
    let lines = push_line(lines, "")
    let lines = push_line(lines, "module_line = \"mod\" phrase_module_path newline ;")
    let lines = push_line(lines, "")
    let lines = push_line(lines, "phrase_module_path =")
    let lines = push_line(lines, "      phrase_module_segment")
    let lines = push_line(lines, "    | phrase_module_path \"/\" phrase_module_segment ;")
    let lines = push_line(lines, "")
    let lines = push_line(lines, "phrase_module_segment = identifier { \".\" identifier } ;")
    let lines = push_line(lines, "")
    let lines = push_line(lines, "use_line =")
    let lines = push_line(lines, "      \"use\" phrase_module_path [ \"as\" identifier ] newline ;")
    let lines = push_line(lines, "")
    let lines = push_line(lines, "type_block =")
    let lines = push_line(lines, "      \"type\" identifier newline")
    let lines = push_line(lines, "          INDENT { field_line } DEDENT")
    let lines = push_line(lines, "      \".end\" newline ;")
    let lines = push_line(lines, "")
    let lines = push_line(lines, "field_line =")
    let lines = push_line(lines, "      INDENT \"field\" identifier \":\" phrase_type_name newline ;")
    let lines = push_line(lines, "")
    let lines = push_line(lines, "phrase_type_name = identifier { \".\" identifier } ;")
    let lines = push_line(lines, "")
    let lines = push_line(lines, "fn_block =")
    let lines = push_line(lines, "      \"fn\" identifier phrase_param_list phrase_return_type newline")
    let lines = push_line(lines, "          INDENT { phrase_stmt } DEDENT")
    let lines = push_line(lines, "      \".end\" newline ;")
    let lines = push_line(lines, "")
    let lines = push_line(lines, "phrase_param_list = { phrase_param } ;")
    let lines = push_line(lines, "phrase_param       = identifier \":\" phrase_type_name ;")
    let lines = push_line(lines, "")
    let lines = push_line(lines, "phrase_return_type =")
    let lines = push_line(lines, "      \"->\" phrase_type_name")
    let lines = push_line(lines, "    |                              (* pas de retour explicite = void *) ;")
    let lines = push_line(lines, "")
    let lines = push_line(lines, "scenario_block =")
    let lines = push_line(lines, "      \"scn\" identifier newline")
    let lines = push_line(lines, "          INDENT { phrase_stmt } DEDENT")
    let lines = push_line(lines, "      \".end\" newline ;")
    let lines = push_line(lines, "")
    let lines = push_line(lines, "program_block =")
    let lines = push_line(lines, "      \"prog\" phrase_module_path \".\" identifier newline")
    let lines = push_line(lines, "          INDENT { phrase_stmt } DEDENT")
    let lines = push_line(lines, "      \".end\" newline ;")
    let lines = push_line(lines, "")
    let lines = push_line(lines, "phrase_stmt =")
    let lines = push_line(lines, "      set_line")
    let lines = push_line(lines, "    | say_line")
    let lines = push_line(lines, "    | do_line")
    let lines = push_line(lines, "    | ret_line")
    let lines = push_line(lines, "    | when_block")
    let lines = push_line(lines, "    | loop_block ;")
    let lines = push_line(lines, "")
    let lines = push_line(lines, "set_line =")
    let lines = push_line(lines, "      INDENT \"set\" phrase_assign_target \"=\" phrase_expr newline ;")
    let lines = push_line(lines, "")
    let lines = push_line(lines, "phrase_assign_target =")
    let lines = push_line(lines, "      identifier")
    let lines = push_line(lines, "    | phrase_assign_target \".\" identifier ;")
    let lines = push_line(lines, "")
    let lines = push_line(lines, "say_line =")
    let lines = push_line(lines, "      INDENT \"say\" phrase_string_interpolated newline ;")
    let lines = push_line(lines, "")
    let lines = push_line(lines, "do_line =")
    let lines = push_line(lines, "      INDENT \"do\" identifier { phrase_expr } newline ;")
    let lines = push_line(lines, "")
    let lines = push_line(lines, "ret_line =")
    let lines = push_line(lines, "      INDENT \"ret\" [ phrase_expr ] newline ;")
    let lines = push_line(lines, "")
    let lines = push_line(lines, "when_block =")
    let lines = push_line(lines, "      INDENT \"when\" phrase_expr newline")
    let lines = push_line(lines, "          INDENT { phrase_stmt } DEDENT")
    let lines = push_line(lines, "        { \"else\" \"when\" phrase_expr newline")
    let lines = push_line(lines, "              INDENT { phrase_stmt } DEDENT")
    let lines = push_line(lines, "        }")
    let lines = push_line(lines, "        [ \"else\" newline")
    let lines = push_line(lines, "              INDENT { phrase_stmt } DEDENT")
    let lines = push_line(lines, "        ]")
    let lines = push_line(lines, "      INDENT \".end\" newline ;")
    let lines = push_line(lines, "")
    let lines = push_line(lines, "loop_block =")
    let lines = push_line(lines, "      INDENT \"loop\" identifier \"from\" phrase_expr \"to\" phrase_expr")
    let lines = push_line(lines, "          [ \"step\" phrase_expr ]")
    let lines = push_line(lines, "          newline")
    let lines = push_line(lines, "          INDENT { phrase_stmt } DEDENT")
    let lines = push_line(lines, "      INDENT \".end\" newline ;")
    let lines = push_line(lines, "")
    let lines = push_line(lines, "phrase_expr =")
    let lines = push_line(lines, "      phrase_literal")
    let lines = push_line(lines, "    | phrase_target")
    let lines = push_line(lines, "    | phrase_binary_expr")
    let lines = push_line(lines, "    | phrase_unary_expr")
    let lines = push_line(lines, "    | phrase_paren_expr ;")
    let lines = push_line(lines, "")
    let lines = push_line(lines, "phrase_target =")
    let lines = push_line(lines, "      identifier")
    let lines = push_line(lines, "    | phrase_target \".\" identifier ;")
    let lines = push_line(lines, "")
    let lines = push_line(lines, "phrase_binary_expr =")
    let lines = push_line(lines, "      phrase_expr phrase_binary_op phrase_expr ;")
    let lines = push_line(lines, "")
    let lines = push_line(lines, "phrase_binary_op =")
    let lines = push_line(lines, "      \"+\" | \"-\" | \"*\" | \"/\" | \"%\"")
    let lines = push_line(lines, "    | \"==\" | \"!=\" | \"<\" | \"<=\" | \">\" | \">=\"")
    let lines = push_line(lines, "    | \"and\" | \"or\" ;")
    let lines = push_line(lines, "")
    let lines = push_line(lines, "phrase_unary_expr =")
    let lines = push_line(lines, "      phrase_unary_op phrase_expr ;")
    let lines = push_line(lines, "")
    let lines = push_line(lines, "phrase_unary_op = \"-\" | \"not\" ;")
    let lines = push_line(lines, "")
    let lines = push_line(lines, "phrase_paren_expr = \"(\" phrase_expr \")\" ;")
    let lines = push_line(lines, "")
    let lines = push_line(lines, "phrase_literal =")
    let lines = push_line(lines, "      phrase_number")
    let lines = push_line(lines, "    | phrase_string_literal")
    let lines = push_line(lines, "    | phrase_boolean_literal ;")
    let lines = push_line(lines, "")
    let lines = push_line(lines, "phrase_number          = integer | float ;")
    let lines = push_line(lines, "phrase_boolean_literal = \"true\" | \"false\" ;")
    let lines = push_line(lines, "")
    let lines = push_line(lines, "phrase_string_interpolated = phrase_string_literal ;")
    let lines = push_line(lines, "phrase_string_literal       = string_literal ;")
    let lines = push_line(lines, "")
    let lines = push_line(lines, "(* Les identifiants, integer, float, newline, INDENT, DEDENT sont partagés *)")

    let block = mk_block(
        "phrase_full",
        "Grammaire Vitte Phrase (EBNF complet)",
        GrammarKind::GrammarPhrase,
        "Syntaxe de surface Vitte Phrase, désucrée vers le noyau.",
        lines
    )
    return block
.end

# ----------------------------------------------------------------------------
# Vues publiques
# ----------------------------------------------------------------------------

pub fn grammar_blocks_all() -> Vec<GrammarBlock>:
    let blocks = Vec<GrammarBlock>::new()
    let b_core = grammar_block_core_full()
    let blocks = append_blocks(blocks, [b_core])    # via un Vec temporaire
    let v_phrase = Vec<GrammarBlock>::new()
    let v_phrase2 = push_block(v_phrase, grammar_block_phrase_full())
    let blocks = append_blocks(blocks, v_phrase2)
    return blocks
.end

# Petit helper pour construire un Vec avec un seul block.
fn push_block(Vec<GrammarBlock> v, GrammarBlock b) -> Vec<GrammarBlock>:
    v.push(b)
    return v
.end

pub fn grammar_find_block_by_id(Vec<GrammarBlock> all, String id) -> Option<GrammarBlock>:
    let n = all.len()
    let i = 0usize

    while i < n:
        let b = all[i]
        if b.id == id:
            let some_b: Option<GrammarBlock> = Option<GrammarBlock>::Some(b)
            return some_b
        .end
        i = i + 1usize
    .end

    let none_b: Option<GrammarBlock> = Option<GrammarBlock>::None()
    return none_b
.end

pub fn grammar_core_block() -> GrammarBlock:
    return grammar_block_core_full()
.end

pub fn grammar_phrase_block() -> GrammarBlock:
    return grammar_block_phrase_full()
.end

# ----------------------------------------------------------------------------
# Notes
# ----------------------------------------------------------------------------
# - Ce module ne fait qu'exposer la grammaire officielle de Vitte sous forme
#   textuelle. Le parseur concret (Pest, hand-written, etc.) doit vivre ailleurs.
# - Les outils externes (LSP, docgen, site web, tests) peuvent s'appuyer sur
#   GrammarBlock pour afficher / tester la grammmare sans dupliquer les EBNF.
# - En cas d'évolution de la syntaxe, c'est ce module qui doit être mis à jour
#   pour rester la référence unique du langage.
# ----------------------------------------------------------------------------
