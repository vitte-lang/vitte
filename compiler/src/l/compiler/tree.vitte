module vitte.compiler.tree

import std.collections as coll
import vitte.compiler.span as span
import vitte.compiler.tokens as tok
import vitte.compiler.syntax as syn
import vitte.compiler.symbols as sym
import vitte.compiler.scope as sc
import vitte.compiler.stdlib as stdlib
import vitte.compiler.traits as trt

# =============================================================================
# Vitte compiler – Project / compilation tree (maximal, logique, sans I/O)
# =============================================================================
#
# Objectifs :
#   - Représenter la vision globale d’un projet Vitte côté front-end :
#       * unités sources (fichiers, modules),
#       * résultats de lexing/parsing/scopes/symbols/traits,
#       * dépendances entre unités (graphe d’imports).
#   - Centraliser les structures purement logiques, sans I/O :
#       * pas d’accès disque, pas de logging, pas de backend.
#   - Faciliter les passes ultérieures (résolution, typage, LSP/IDE).
#
# Ce module n’implémente PAS le parsing ni le typage ; il stocke seulement
# les résultats des passes dans un arbre de compilation immuable.
# =============================================================================

# -----------------------------------------------------------------------------
# Identifiants logiques
# -----------------------------------------------------------------------------

typedef u32 UnitId
typedef u32 DepEdgeId

# -----------------------------------------------------------------------------
# Métadonnées d’unités et de dépendances
# -----------------------------------------------------------------------------

pub enum SourceUnitKind:
    SourceUnitKindUser         # fichier user normal
    SourceUnitKindStdlib       # fichier de la std Vitte
    SourceUnitKindGenerated    # code généré (ex: build, macro, etc.)
.end

pub enum SourceUnitStage:
    SourceUnitStageEmpty           # créé, mais aucun traitement encore
    SourceUnitStageLexed           # lexing effectué (LexResult rempli)
    SourceUnitStageParsed          # parsing + SyntaxTree ok
    SourceUnitStageScoped          # scopes construits
    SourceUnitStageSymbolsResolved # symboles résolus
    SourceUnitStageTraitsResolved  # traits / impls résolus
    SourceUnitStageTypeChecked     # typage effectué
.end

pub enum DepKind:
    DepKindImportModule            # import direct d’un module utilisateur
    DepKindStdlibImplicit          # dépendance implicite vers la std
    DepKindGeneratedCode           # lien vers une unité générée
.end

# -----------------------------------------------------------------------------
# Représentation d’une unité source
# -----------------------------------------------------------------------------

pub struct SourceUnit:
    let id: UnitId
    let file_id: span.FileId       # identifiant logique de fichier
    let path: String               # chemin logique (ex: "src/main.vitte")
    let module_path: String        # chemin de module (ex: "core.main")
    let kind: SourceUnitKind
    let is_entry: bool             # true si unité point d’entrée (program/service/...)
    let stage: SourceUnitStage
    let has_errors: bool

    # Résultats des différentes passes, stockés par valeur.
    let lex: tok.LexResult
    let syntax: syn.SyntaxTree
    let scopes: sc.ScopeTree
    let symbols: sym.SymbolTable
    let symbol_spans: sym.SpanSymbolMap
    let traits: trt.TraitCatalog
.end

# -----------------------------------------------------------------------------
# Représentation des dépendances entre unités
# -----------------------------------------------------------------------------

pub struct DepEdge:
    let id: DepEdgeId
    let from_unit: UnitId
    let to_unit: UnitId
    let kind: DepKind
    let module_path: String        # nom du module importé ("core.math/point")
    let span: span.Span            # span de l’instruction d’import
.end

# -----------------------------------------------------------------------------
# Arbre global de projet / compilation
# -----------------------------------------------------------------------------

pub struct ProjectTree:
    let units: Vec<SourceUnit>
    let deps: Vec<DepEdge>
    let stdlib: stdlib.StdlibCatalog
.end

# -----------------------------------------------------------------------------
# Helpers internes : next_id
# -----------------------------------------------------------------------------

fn project_tree_next_unit_id(tree: ProjectTree) -> UnitId:
    let n = tree.units.len()
    return (UnitId) n
.end

fn project_tree_next_dep_id(tree: ProjectTree) -> DepEdgeId:
    let n = tree.deps.len()
    return (DepEdgeId) n
.end

# -----------------------------------------------------------------------------
# Construction de base
# -----------------------------------------------------------------------------

pub fn project_tree_new_with_stdlib(
    catalog: stdlib.StdlibCatalog
) -> ProjectTree:
    let units = Vec<SourceUnit>::new()
    let deps = Vec<DepEdge>::new()

    let tree = ProjectTree {
        units: units,
        deps: deps,
        stdlib: catalog
    }
    return tree
.end

pub fn project_tree_new_default() -> ProjectTree:
    let catalog = stdlib.stdlib_catalog_new_default()
    let tree = project_tree_new_with_stdlib(catalog)
    return tree
.end

# -----------------------------------------------------------------------------
# Création d’une unité vide (squelettique)
# -----------------------------------------------------------------------------

pub fn project_tree_add_empty_unit(
    tree: ProjectTree,
    file_id: span.FileId,
    path: String,
    module_path: String,
    kind: SourceUnitKind,
    is_entry: bool
) -> (ProjectTree, UnitId):
    let units = tree.units
    let deps = tree.deps
    let stdcat = tree.stdlib

    let new_id = project_tree_next_unit_id(tree)

    # Structures vides par défaut
    let lex0 = tok.lex_result_new(file_id)
    let syn0 = syn.syntax_tree_new()
    let scopes0 = sc.scope_tree_new()
    let symbols0 = sym.symbol_table_new()
    let spans0 = sym.span_symbol_map_new()
    let traits0 = trt.trait_catalog_new()

    let unit = SourceUnit {
        id: new_id,
        file_id: file_id,
        path: path,
        module_path: module_path,
        kind: kind,
        is_entry: is_entry,
        stage: SourceUnitStage::SourceUnitStageEmpty,
        has_errors: false,
        lex: lex0,
        syntax: syn0,
        scopes: scopes0,
        symbols: symbols0,
        symbol_spans: spans0,
        traits: traits0
    }

    units.push(unit)

    let tree2 = ProjectTree {
        units: units,
        deps: deps,
        stdlib: stdcat
    }

    let out = (tree2, new_id)
    return out
.end

# -----------------------------------------------------------------------------
# Mise à jour d’une unité (données des passes)
# -----------------------------------------------------------------------------

pub fn project_tree_update_unit_core_data(
    tree: ProjectTree,
    unit_id: UnitId,
    lex: tok.LexResult,
    syntax: syn.SyntaxTree,
    scopes: sc.ScopeTree,
    symbols: sym.SymbolTable,
    symbol_spans: sym.SpanSymbolMap,
    traits: trt.TraitCatalog
) -> ProjectTree:
    let units = tree.units
    let deps = tree.deps
    let stdcat = tree.stdlib

    let new_units = Vec<SourceUnit>::new()
    let n = units.len()
    let i = (usize) 0

    while i < n:
        let u = units[i]
        if u.id == unit_id:
            let u2 = SourceUnit {
                id: u.id,
                file_id: u.file_id,
                path: u.path,
                module_path: u.module_path,
                kind: u.kind,
                is_entry: u.is_entry,
                stage: u.stage,
                has_errors: u.has_errors,
                lex: lex,
                syntax: syntax,
                scopes: scopes,
                symbols: symbols,
                symbol_spans: symbol_spans,
                traits: traits
            }
            new_units.push(u2)
        else:
            new_units.push(u)
        .end
        let i = i + (usize) 1
    .end

    let tree2 = ProjectTree {
        units: new_units,
        deps: deps,
        stdlib: stdcat
    }
    return tree2
.end

pub fn project_tree_update_unit_stage_and_errors(
    tree: ProjectTree,
    unit_id: UnitId,
    stage: SourceUnitStage,
    has_errors: bool
) -> ProjectTree:
    let units = tree.units
    let deps = tree.deps
    let stdcat = tree.stdlib

    let new_units = Vec<SourceUnit>::new()
    let n = units.len()
    let i = (usize) 0

    while i < n:
        let u = units[i]
        if u.id == unit_id:
            let u2 = SourceUnit {
                id: u.id,
                file_id: u.file_id,
                path: u.path,
                module_path: u.module_path,
                kind: u.kind,
                is_entry: u.is_entry,
                stage: stage,
                has_errors: has_errors,
                lex: u.lex,
                syntax: u.syntax,
                scopes: u.scopes,
                symbols: u.symbols,
                symbol_spans: u.symbol_spans,
                traits: u.traits
            }
            new_units.push(u2)
        else:
            new_units.push(u)
        .end
        let i = i + (usize) 1
    .end

    let tree2 = ProjectTree {
        units: new_units,
        deps: deps,
        stdlib: stdcat
    }
    return tree2
.end

# -----------------------------------------------------------------------------
# Gestion des dépendances
# -----------------------------------------------------------------------------

pub fn project_tree_add_dep(
    tree: ProjectTree,
    from_unit: UnitId,
    to_unit: UnitId,
    kind: DepKind,
    module_path: String,
    span_value: span.Span
) -> (ProjectTree, DepEdgeId):
    let units = tree.units
    let deps = tree.deps
    let stdcat = tree.stdlib

    let new_id = project_tree_next_dep_id(tree)

    let edge = DepEdge {
        id: new_id,
        from_unit: from_unit,
        to_unit: to_unit,
        kind: kind,
        module_path: module_path,
        span: span_value
    }

    deps.push(edge)

    let tree2 = ProjectTree {
        units: units,
        deps: deps,
        stdlib: stdcat
    }

    let out = (tree2, new_id)
    return out
.end

# Liste des arêtes sortantes pour une unité.
pub fn project_tree_deps_from(
    tree: ProjectTree,
    from_unit: UnitId
) -> Vec<DepEdgeId>:
    let deps = tree.deps
    let n = deps.len()
    let i = (usize) 0
    let out = Vec<DepEdgeId>::new()

    while i < n:
        let e = deps[i]
        if e.from_unit == from_unit:
            out.push(e.id)
        .end
        let i = i + (usize) 1
    .end

    return out
.end

# Liste des arêtes entrantes pour une unité.
pub fn project_tree_deps_to(
    tree: ProjectTree,
    to_unit: UnitId
) -> Vec<DepEdgeId>:
    let deps = tree.deps
    let n = deps.len()
    let i = (usize) 0
    let out = Vec<DepEdgeId>::new()

    while i < n:
        let e = deps[i]
        if e.to_unit == to_unit:
            out.push(e.id)
        .end
        let i = i + (usize) 1
    .end

    return out
.end

# Ensemble des UnitId directement dépendants d’une unité.
pub fn project_tree_direct_dependencies(
    tree: ProjectTree,
    from_unit: UnitId
) -> Vec<UnitId>:
    let edges = project_tree_deps_from(tree, from_unit)
    let deps_vec = tree.deps

    let out = Vec<UnitId>::new()
    let n = edges.len()
    let i = (usize) 0

    while i < n:
        let edge_id = edges[i]
        let idx = (usize) edge_id
        let e = deps_vec[idx]
        # On ajoute sans déduplication pour rester simple.
        out.push(e.to_unit)
        let i = i + (usize) 1
    .end

    return out
.end

# -----------------------------------------------------------------------------
# Accès / queries sur ProjectTree
# -----------------------------------------------------------------------------

pub fn project_tree_unit_count(tree: ProjectTree) -> u32:
    let n = tree.units.len()
    return (u32) n
.end

pub fn project_tree_dep_count(tree: ProjectTree) -> u32:
    let n = tree.deps.len()
    return (u32) n
.end

pub fn project_tree_get_unit(
    tree: ProjectTree,
    unit_id: UnitId
) -> SourceUnit:
    let units = tree.units
    let idx = (usize) unit_id
    let u = units[idx]
    return u
.end

pub fn project_tree_get_dep(
    tree: ProjectTree,
    dep_id: DepEdgeId
) -> DepEdge:
    let deps = tree.deps
    let idx = (usize) dep_id
    let e = deps[idx]
    return e
.end

pub fn project_tree_get_stdlib(
    tree: ProjectTree
) -> stdlib.StdlibCatalog:
    return tree.stdlib
.end

# Recherche d’unité par FileId.
pub fn project_tree_find_unit_by_file_id(
    tree: ProjectTree,
    file_id: span.FileId
) -> coll.Option<UnitId>:
    let units = tree.units
    let n = units.len()
    let i = (usize) 0

    while i < n:
        let u = units[i]
        if u.file_id == file_id:
            let some_id = coll.option_some<UnitId>(u.id)
            return some_id
        .end
        let i = i + (usize) 1
    .end

    let none_id = coll.option_none<UnitId>()
    return none_id
.end

# Recherche par chemin de module exact.
pub fn project_tree_units_for_module_path(
    tree: ProjectTree,
    module_path: String
) -> Vec<UnitId>:
    let units = tree.units
    let n = units.len()
    let i = (usize) 0
    let out = Vec<UnitId>::new()

    while i < n:
        let u = units[i]
        if u.module_path == module_path:
            out.push(u.id)
        .end
        let i = i + (usize) 1
    .end

    return out
.end

# Liste des unités marquées comme points d’entrée.
pub fn project_tree_entry_units(
    tree: ProjectTree
) -> Vec<UnitId>:
    let units = tree.units
    let n = units.len()
    let i = (usize) 0
    let out = Vec<UnitId>::new()

    while i < n:
        let u = units[i]
        if u.is_entry:
            out.push(u.id)
        .end
        let i = i + (usize) 1
    .end

    return out
.end

# -----------------------------------------------------------------------------
# Helpers de debug : to_string
# -----------------------------------------------------------------------------

pub fn source_unit_kind_to_string(kind: SourceUnitKind) -> String:
    if kind == SourceUnitKind::SourceUnitKindUser:
        return "user"
    .end
    if kind == SourceUnitKind::SourceUnitKindStdlib:
        return "stdlib"
    .end
    if kind == SourceUnitKind::SourceUnitKindGenerated:
        return "generated"
    .end
    return "unknown"
.end

pub fn source_unit_stage_to_string(stage: SourceUnitStage) -> String:
    if stage == SourceUnitStage::SourceUnitStageEmpty:
        return "empty"
    .end
    if stage == SourceUnitStage::SourceUnitStageLexed:
        return "lexed"
    .end
    if stage == SourceUnitStage::SourceUnitStageParsed:
        return "parsed"
    .end
    if stage == SourceUnitStage::SourceUnitStageScoped:
        return "scoped"
    .end
    if stage == SourceUnitStage::SourceUnitStageSymbolsResolved:
        return "symbols"
    .end
    if stage == SourceUnitStage::SourceUnitStageTraitsResolved:
        return "traits"
    .end
    if stage == SourceUnitStage::SourceUnitStageTypeChecked:
        return "typed"
    .end
    return "unknown"
.end

pub fn dep_kind_to_string(kind: DepKind) -> String:
    if kind == DepKind::DepKindImportModule:
        return "import"
    .end
    if kind == DepKind::DepKindStdlibImplicit:
        return "stdlib"
    .end
    if kind == DepKind::DepKindGeneratedCode:
        return "generated"
    .end
    return "unknown"
.end

# -----------------------------------------------------------------------------
# Scénario interne de smoke-test
# -----------------------------------------------------------------------------

scenario tree_smoke_test():
    # 1) Construction d’un ProjectTree avec stdlib par défaut.
    let proj0 = project_tree_new_default()

    # 2) Ajout d’une unité main.
    let file_main = span.file_id_new(0)
    let path_main = "src/main.vitte"
    let module_main = "core.main"

    let (proj1, unit_main) = project_tree_add_empty_unit(
        proj0,
        file_main,
        path_main,
        module_main,
        SourceUnitKind::SourceUnitKindUser,
        true
    )

    let unit_count1 = project_tree_unit_count(proj1)
    let has_one_unit = unit_count1 == (u32) 1

    let found_main_opt = project_tree_find_unit_by_file_id(proj1, file_main)
    let found_main = coll.option_is_some<UnitId>(found_main_opt)

    let entries = project_tree_entry_units(proj1)

    # 3) Ajout d’une unité lib et d’une dépendance main -> lib.
    let file_lib = span.file_id_new(1)
    let path_lib = "src/lib.vitte"
    let module_lib = "core.lib"

    let (proj2, unit_lib) = project_tree_add_empty_unit(
        proj1,
        file_lib,
        path_lib,
        module_lib,
        SourceUnitKind::SourceUnitKindUser,
        false
    )

    let sp_import = span.span_from_len(
        (span.BytePos) 0,
        (span.ByteLen) 20
    )

    let (proj3, dep_id) = project_tree_add_dep(
        proj2,
        unit_main,
        unit_lib,
        DepKind::DepKindImportModule,
        "core.lib",
        sp_import
    )

    let deps_from_main = project_tree_deps_from(proj3, unit_main)
    let deps_to_lib = project_tree_deps_to(proj3, unit_lib)
    let direct_deps_main = project_tree_direct_dependencies(proj3, unit_main)

    # 4) Mise à jour des données de core pour main (lex/syntax/scopes/...).
    let lex_main = tok.lex_result_new(file_main)
    let syn_main = syn.syntax_tree_new()
    let scopes_main = sc.scope_tree_new()
    let symbols_main = sym.symbol_table_new()
    let spans_main = sym.span_symbol_map_new()
    let traits_main = trt.trait_catalog_new()

    let proj4 = project_tree_update_unit_core_data(
        proj3,
        unit_main,
        lex_main,
        syn_main,
        scopes_main,
        symbols_main,
        spans_main,
        traits_main
    )

    let proj5 = project_tree_update_unit_stage_and_errors(
        proj4,
        unit_main,
        SourceUnitStage::SourceUnitStageParsed,
        false
    )

    let unit_main_struct = project_tree_get_unit(proj5, unit_main)
    let kind_str = source_unit_kind_to_string(unit_main_struct.kind)
    let stage_str = source_unit_stage_to_string(unit_main_struct.stage)

    let _ = has_one_unit
    let _ = found_main
    let _ = entries
    let _ = dep_id
    let _ = deps_from_main
    let _ = deps_to_lib
    let _ = direct_deps_main
    let _ = kind_str
    let _ = stage_str
.end
