

module vitte.compiler.ast

# ============================================================================
# Vitte compiler – Modèle d'AST (Abstract Syntax Tree) ultra complet
#
# Objectifs :
#   - fournir une représentation structurée de la grammaire Vitte "cœur" ;
#   - couvrir les modules, manifestes Muffin, types, traits/impl, fonctions,
#     scénarios, points d'entrée, blocs, instructions, expressions, patterns,
#     types et attributs ;
#   - rester suffisamment générique pour servir :
#       * l'analyse sémantique,
#       * la génération d'IR,
#       * les passes de réécriture / formatage,
#       * les outils externes (LSP, indexation...).
#
# Conventions :
#   - les blocs utilisent ":" + indentation + ".end" (syntax Vitte officielle) ;
#   - les relations entre nœuds utilisent des identifiants (`AstNodeId`) ;
#   - les enums sont "tag-only" : pas de payload direct (structure via champs).
# ============================================================================

# ----------------------------------------------------------------------------
# Types de base : positions, identifiants, visibilité
# ----------------------------------------------------------------------------

pub struct Span:
    let file: String
    let start_line: u32
    let start_col: u32
    let end_line: u32
    let end_col: u32
.end

pub typedef u32 AstIndex

pub struct AstNodeId:
    let index: AstIndex
.end

pub enum Visibility:
    Default
    Public
.end

pub enum AttributeTarget:
    AtModule
    AtType
    AtTrait
    AtImpl
    AtFunction
    AtScenario
    AtEntryPoint
    AtStatement
    AtExpression
    AtTypeExpr
.end

# ----------------------------------------------------------------------------
# Identifiants, opérateurs et littéraux
# ----------------------------------------------------------------------------

pub struct Identifier:
    let name: String
    let span: Span
.end

pub enum UnaryOpKind:
    Negate          # -x
    LogicalNot      # not x
    AddressOf       # &x
    Deref           # *x
    BitNot          # ~x
.end

pub enum BinaryOpKind:
    Add
    Sub
    Mul
    Div
    Mod
    Eq
    Ne
    Lt
    Le
    Gt
    Ge
    BoolAnd
    BoolOr
    BitAnd
    BitOr
    BitXor
    Shl
    Shr
    PipeForward     # |>
.end

pub enum LiteralKind:
    Int
    Float
    String
    Bool
    Null
.end

pub struct Literal:
    let kind: LiteralKind
    let text: String          # représentation brute (parseur spécifique)
    let span: Span
.end

# ----------------------------------------------------------------------------
# Expressions de type (type_expression) et génériques
# ----------------------------------------------------------------------------

pub struct TypeExprId:
    let raw: AstIndex
.end

pub enum TypeExprKind:
    Named                  # named_type : Foo, std.io.File, Vec<Int>
    Pointer                # *T
    Reference              # &T
    Array                  # T[n] ou T[]
    FunctionPointer        # fn(T1, T2) -> R
.end

pub struct TypeExpr:
    let id: TypeExprId
    let kind: TypeExprKind
    let span: Span
    let name: AstNodeId             # identifiant qualifié pour Named
    let qualifiers: Vec<String>     # "const", "volatile", "restrict"
    let generic_args: Vec<TypeExprId>
    let element: TypeExprId         # pour pointer/ref/array/fn-ret
    let array_size: Option<AstNodeId> # expression pour la taille (si connue)
    let fn_params: Vec<TypeExprId>  # pour FunctionPointer
.end

pub struct GenericParam:
    let name: Identifier
    let bounds: Vec<TypeExprId>     # liste de types (trait bounds)
.end

pub struct GenericParamList:
    let params: Vec<GenericParam>
.end

# ----------------------------------------------------------------------------
# Attributs (attribute) – décorateurs génériques
# ----------------------------------------------------------------------------

pub struct AttributeArg:
    let expr: AstNodeId             # réutilise les expressions pour la valeur
.end

pub struct Attribute:
    let name: Identifier
    let args: Vec<AttributeArg>
    let target: AttributeTarget
    let span: Span
.end

# ----------------------------------------------------------------------------
# AST global – un module Vitte
# ----------------------------------------------------------------------------

pub struct ModuleAst:
    let name: Identifier
    let items: Vec<AstNodeId>        # top_level_declaration
.end

pub enum ModuleItemKind:
    ModuleDecl
    ImportDecl
    ExportDecl
    MuffinManifest
    TypeDecl
    TraitDecl
    ImplDecl
    FunctionDecl
    ScenarioDecl
    EntryPointDecl
    TopLevelStmt
.end

pub struct ModuleItem:
    let id: AstNodeId
    let kind: ModuleItemKind
    let span: Span
    let data: AstNodeId              # pointe vers un nœud de détail
.end

# ----------------------------------------------------------------------------
# Déclarations de module/import/export
# ----------------------------------------------------------------------------

pub struct ModuleDecl:
    let name: Identifier
    let span: Span
.end

pub struct ImportAlias:
    let name: Identifier
    let span: Span
.end

pub struct ImportDecl:
    let module_path: Vec<Identifier>
    let alias: Option<ImportAlias>
    let span: Span
.end

pub enum ExportKind:
    AllFromModule
    SpecificIdents
.end

pub struct ExportDecl:
    let kind: ExportKind
    let idents: Vec<Identifier>
    let from_module: Option<Vec<Identifier>>
    let span: Span
.end

# ----------------------------------------------------------------------------
# Manifestes Muffin (muffin_manifest)
# ----------------------------------------------------------------------------

pub struct MuffinEntry:
    let key: Identifier
    let value: AstNodeId         # expression (literal, liste, map...)
    let span: Span
.end

pub struct MuffinManifest:
    let path: Literal            # string_literal
    let entries: Vec<MuffinEntry>
    let span: Span
.end

# ----------------------------------------------------------------------------
# Déclarations de types : struct / union / enum / typedef
# ----------------------------------------------------------------------------

pub enum TypeDeclKind:
    Struct
    Union
    Enum
    Typedef
.end

pub struct FieldDecl:
    let name: Identifier
    let ty: TypeExprId
    let default_value: Option<AstNodeId>
    let span: Span
.end

pub struct StructDecl:
    let visibility: Visibility
    let name: Identifier
    let generics: Option<GenericParamList>
    let fields: Vec<FieldDecl>
    let span: Span
.end

pub struct UnionDecl:
    let visibility: Visibility
    let name: Identifier
    let generics: Option<GenericParamList>
    let fields: Vec<FieldDecl>
    let span: Span
.end

pub struct EnumVariant:
    let name: Identifier
    let value_expr: Option<AstNodeId>    # expression de valeur (facultative)
    let span: Span
.end

pub struct EnumDecl:
    let visibility: Visibility
    let name: Identifier
    let generics: Option<GenericParamList>
    let variants: Vec<EnumVariant>
    let span: Span
.end

pub struct TypedefDecl:
    let visibility: Visibility
    let target_type: TypeExprId
    let name: Identifier
    let span: Span
.end

# ----------------------------------------------------------------------------
# Traits et implémentations (trait / impl / where_clause)
# ----------------------------------------------------------------------------

pub struct TraitDecl:
    let visibility: Visibility
    let name: Identifier
    let generics: Option<GenericParamList>
    let super_bounds: Vec<TypeExprId>
    let members: Vec<AstNodeId>        # fonctions, typedefs, déclarations
    let span: Span
.end

pub struct WherePredicate:
    let ty: TypeExprId
    let bounds: Vec<TypeExprId>
    let span: Span
.end

pub struct WhereClause:
    let predicates: Vec<WherePredicate>
    let span: Span
.end

pub struct ImplDecl:
    let generics: Option<GenericParamList>
    let trait_type: Option<TypeExprId>   # None = impl inherent
    let for_type: TypeExprId
    let where_clause: Option<WhereClause>
    let members: Vec<AstNodeId>
    let span: Span
.end

# ----------------------------------------------------------------------------
# Fonctions, scénarios, points d'entrée
# ----------------------------------------------------------------------------

pub struct Parameter:
    let ty: TypeExprId
    let name: Identifier
    let span: Span
.end

pub struct ParameterList:
    let params: Vec<Parameter>
.end

pub enum FunctionKind:
    Regular
    Scenario
    EntryProgram
    EntryService
    EntryKernel
    EntryDriver
    EntryTool
    EntryScenario
    EntryPipeline
.end

pub struct FunctionDecl:
    let visibility: Visibility
    let storage: Option<String>      # "extern" ou "static"
    let is_inline: Bool
    let kind: FunctionKind
    let name: Identifier
    let generics: Option<GenericParamList>
    let params: ParameterList
    let return_type: Option<TypeExprId>
    let where_clause: Option<WhereClause>
    let body: AstNodeId              # BlockId
    let span: Span
.end

# ----------------------------------------------------------------------------
# Blocs et instructions
# ----------------------------------------------------------------------------

pub struct BlockId:
    let raw: AstIndex
.end

pub struct Block:
    let id: BlockId
    let statements: Vec<AstNodeId>
    let span: Span
.end

pub enum StmtKind:
    LetDecl
    ConstDecl
    Assignment
    ExprStmt
    If
    While
    For
    Match
    Break
    Continue
    Return
.end

pub struct Stmt:
    let id: AstNodeId
    let kind: StmtKind
    let span: Span
    let data: AstNodeId          # détail spécifique de l'instruction
.end

pub struct LetDeclStmt:
    let name: Identifier
    let value: AstNodeId
    let span: Span
.end

pub struct ConstDeclStmt:
    let name: Identifier
    let value: AstNodeId
    let span: Span
.end

pub struct AssignmentStmt:
    let target: AstNodeId
    let op: String               # "=" ou "+=" etc. (token brut)
    let value: AstNodeId
    let span: Span
.end

pub struct IfStmt:
    let condition: AstNodeId
    let then_block: BlockId
    let elif_branches: Vec<AstNodeId>   # ElifBranchId
    let else_block: Option<BlockId>
    let span: Span
.end

pub struct ElifBranch:
    let condition: AstNodeId
    let block: BlockId
    let span: Span
.end

pub struct WhileStmt:
    let condition: AstNodeId
    let body: BlockId
    let span: Span
.end

pub struct ForStmt:
    let pattern: AstNodeId       # pattern (identifier simple dans la grammaire actuelle)
    let iterable: AstNodeId
    let body: BlockId
    let span: Span
.end

pub struct MatchStmt:
    let value: AstNodeId
    let arms: Vec<AstNodeId>     # MatchArmId
    let span: Span
.end

pub struct MatchArm:
    let pattern: AstNodeId
    let block: BlockId
    let span: Span
.end

pub struct BreakStmt:
    let span: Span
.end

pub struct ContinueStmt:
    let span: Span
.end

pub struct ReturnStmt:
    let value: Option<AstNodeId>
    let span: Span
.end

# ----------------------------------------------------------------------------
# Expressions
# ----------------------------------------------------------------------------

pub struct ExprId:
    let raw: AstIndex
.end

pub enum ExprKind:
    Literal
    Target
    Call
    Unary
    Binary
    Cast
    SizeOf
    AlignOf
    List
    Map
    Parenthesized
.end

pub struct Expr:
    let id: ExprId
    let kind: ExprKind
    let span: Span
    let data: AstNodeId           # détail spécifique selon kind
.end

pub struct TargetExpr:
    let base: Identifier
    let suffixes: Vec<AstNodeId>  # TargetSuffixId
    let span: Span
.end

pub enum TargetSuffixKind:
    FieldAccess       # .ident
    Index             # [expr]
    PointerField      # ->ident
.end

pub struct TargetSuffix:
    let kind: TargetSuffixKind
    let name: Option<Identifier>  # pour FieldAccess / PointerField
    let index_expr: Option<ExprId>
    let span: Span
.end

pub struct CallExpr:
    let callee: ExprId            # généralement une TargetExpr
    let args: Vec<ExprId>
    let span: Span
.end

pub struct UnaryExpr:
    let op: UnaryOpKind
    let operand: ExprId
    let span: Span
.end

pub struct BinaryExpr:
    let op: BinaryOpKind
    let left: ExprId
    let right: ExprId
    let span: Span
.end

pub struct CastExpr:
    let target_type: TypeExprId
    let value: ExprId
    let span: Span
.end

pub struct SizeOfExpr:
    let ty: TypeExprId
    let span: Span
.end

pub struct AlignOfExpr:
    let ty: TypeExprId
    let span: Span
.end

pub struct ListExpr:
    let elements: Vec<ExprId>
    let span: Span
.end

pub struct MapEntryExpr:
    let key: ExprId
    let value: ExprId
    let span: Span
.end

pub struct MapExpr:
    let entries: Vec<MapEntryExpr>
    let span: Span
.end

pub struct ParenthesizedExpr:
    let inner: ExprId
    let span: Span
.end

# ----------------------------------------------------------------------------
# Patterns (pattern / pattern_tuple / pattern_list)
# ----------------------------------------------------------------------------

pub struct PatternId:
    let raw: AstIndex
.end

pub enum PatternKind:
    Wildcard
    Literal
    Identifier
    Tuple
    List
.end

pub struct Pattern:
    let id: PatternId
    let kind: PatternKind
    let span: Span
    let data: AstNodeId           # détail spécifique
.end

pub struct WildcardPattern:
    let span: Span
.end

pub struct LiteralPattern:
    let literal: Literal
    let span: Span
.end

pub struct IdentifierPattern:
    let name: Identifier
    let span: Span
.end

pub struct TuplePattern:
    let elements: Vec<PatternId>
    let span: Span
.end

pub struct ListPattern:
    let elements: Vec<PatternId>
    let span: Span
.end

# ----------------------------------------------------------------------------
# Top-level : nœud AST générique (facultatif mais pratique)
# ----------------------------------------------------------------------------

pub enum AstNodeKind:
    NodeModule
    NodeModuleItem
    NodeModuleDecl
    NodeImportDecl
    NodeExportDecl
    NodeMuffinManifest
    NodeMuffinEntry
    NodeStructDecl
    NodeUnionDecl
    NodeEnumDecl
    NodeTypedefDecl
    NodeTraitDecl
    NodeImplDecl
    NodeFunctionDecl
    NodeBlock
    NodeStmt
    NodeExpr
    NodePattern
    NodeTypeExpr
    NodeAttribute
.end

pub struct AstNode:
    let id: AstNodeId
    let kind: AstNodeKind
    let span: Span
    let payload: AstNodeId     # référence vers le nœud concret correspondant
.end