module vitte.compiler.llvm

import vitte.compiler.collections as coll
import vitte.compiler.diagnostics as diag
import vitte.compiler.language as lang
import vitte.compiler.hir as hir
import vitte.compiler.linker as link

# ============================================================================
# Vitte compiler – LLVM backend (maximal, déclaratif)
#
# Objectifs de ce module :
#   - Décrire la configuration de cible LLVM (triple, cpu, features, options).
#   - Représenter un module LLVM logique (sans FFI, sans appel direct à libLLVM).
#   - Fournir un builder textuel de IR LLVM (String-based), utilisable pour :
#       * debug / tests golden-files,
#       * backends simples qui émettent du IR pur.
#   - Définir des structures pour mapper HIR -> LLVM (mangling, tables).
#
# Remarque :
#   - Aucun I/O ici, pas d'écriture de fichiers .ll/.bc, pas de libllvm directe.
#   - Un autre module (par ex. vitte.compiler.llvm_emit) pourra consommer
#     les structures définies ici pour écrire sur disque ou parler à libLLVM.
# ============================================================================

# ----------------------------------------------------------------------------
# Cible LLVM : triple, arch, OS, ABI, options
# ----------------------------------------------------------------------------

pub enum LlvmTargetArch:
    LlvmTargetArchX86_64
    LlvmTargetArchAarch64
    LlvmTargetArchArm
    LlvmTargetArchRiscv64
    LlvmTargetArchUnknown
.end

pub enum LlvmTargetOs:
    LlvmTargetOsLinux
    LlvmTargetOsMacOS
    LlvmTargetOsWindows
    LlvmTargetOsUnknown
.end

pub enum LlvmTargetAbi:
    LlvmTargetAbiSystem
    LlvmTargetAbiMusl
    LlvmTargetAbiGnu
    LlvmTargetAbiMsvc
    LlvmTargetAbiUnknown
.end

pub struct LlvmTargetTriple:
    let arch: LlvmTargetArch
    let os: LlvmTargetOs
    let abi: LlvmTargetAbi
    let raw: String            # forme canonique : "x86_64-unknown-linux-gnu" etc.
.end

pub fn llvm_target_triple_to_string(LlvmTargetTriple triple) -> String:
    return triple.raw
.end

pub fn llvm_target_triple_default_native() -> LlvmTargetTriple:
    # Par défaut, un triple générique portable. Les build-scripts peuvent
    # substituer une valeur détectée (via env ou outils externes).
    let t = LlvmTargetTriple(
        arch = LlvmTargetArch::LlvmTargetArchX86_64,
        os = LlvmTargetOs::LlvmTargetOsLinux,
        abi = LlvmTargetAbi::LlvmTargetAbiGnu,
        raw = "x86_64-unknown-linux-gnu"
    )
    return t
.end

# ----------------------------------------------------------------------------
# Options LLVM : opt level, reloc model, code model, emit kind
# ----------------------------------------------------------------------------

pub enum LlvmOptLevel:
    LlvmOptLevelNone
    LlvmOptLevelLess
    LlvmOptLevelDefault
    LlvmOptLevelAggressive
.end

pub enum LlvmRelocModel:
    LlvmRelocModelDefault
    LlvmRelocModelStatic
    LlvmRelocModelPic
    LlvmRelocModelPie
.end

pub enum LlvmCodeModel:
    LlvmCodeModelDefault
    LlvmCodeModelSmall
    LlvmCodeModelKernel
    LlvmCodeModelMedium
    LlvmCodeModelLarge
.end

pub enum LlvmEmitKind:
    LlvmEmitKindIr             # .ll IR textuel
    LlvmEmitKindBitcode        # .bc
    LlvmEmitKindObj            # .o
    LlvmEmitKindAsm            # .s
.end

pub struct LlvmCodegenOptions:
    let opt_level: LlvmOptLevel
    let reloc_model: LlvmRelocModel
    let code_model: LlvmCodeModel
    let emit_kind: LlvmEmitKind
    let emit_debug_info: Bool
    let verify_ir: Bool
    let enable_lto: Bool
    let enable_sanitizers: Bool
.end

pub fn llvm_codegen_options_from_language(lang.LanguageConfig cfg) -> LlvmCodegenOptions:
    let opt = cfg.optimization
    let opt_level = LlvmOptLevel::LlvmOptLevelDefault

    if opt == lang.OptimizationLevel::OptimizationLevelNone:
        let opt_level = LlvmOptLevel::LlvmOptLevelNone
    .end
    if opt == lang.OptimizationLevel::OptimizationLevelDebug:
        let opt_level = LlvmOptLevel::LlvmOptLevelLess
    .end
    if opt == lang.OptimizationLevel::OptimizationLevelRelease:
        let opt_level = LlvmOptLevel::LlvmOptLevelDefault
    .end
    if opt == lang.OptimizationLevel::OptimizationLevelAggressive:
        let opt_level = LlvmOptLevel::LlvmOptLevelAggressive
    .end

    let emit_kind = LlvmEmitKind::LlvmEmitKindObj
    let dbg = lang.language_config_wants_debug_info(cfg)

    let opts = LlvmCodegenOptions(
        opt_level = opt_level,
        reloc_model = LlvmRelocModel::LlvmRelocModelDefault,
        code_model = LlvmCodeModel::LlvmCodeModelDefault,
        emit_kind = emit_kind,
        emit_debug_info = dbg,
        verify_ir = true,
        enable_lto = false,
        enable_sanitizers = false
    )
    return opts
.end

# ----------------------------------------------------------------------------
# Description de cible LLVM complète
# ----------------------------------------------------------------------------

pub struct LlvmTargetConfig:
    let triple: LlvmTargetTriple
    let cpu: String
    let features: String
    let codegen: LlvmCodegenOptions
.end

pub fn llvm_target_config_default(lang.LanguageConfig cfg) -> LlvmTargetConfig:
    let triple = llvm_target_triple_default_native()
    let codegen = llvm_codegen_options_from_language(cfg)
    let t = LlvmTargetConfig(
        triple = triple,
        cpu = "generic",
        features = "",
        codegen = codegen
    )
    return t
.end

# ----------------------------------------------------------------------------
# Représentation logique d'un module LLVM
# ----------------------------------------------------------------------------

pub struct LlvmGlobal:
    let name: String
    let ty: String             # type LLVM, ex: "i32", "%MyStruct*"
    let init: String           # initialiseur IR ou vide
    let is_const: Bool
    let is_exported: Bool
.end

pub struct LlvmParam:
    let name: String
    let ty: String             # type LLVM, ex: "i32", "%MyStruct*"
.end

pub struct LlvmFunction:
    let name: String
    let ret_type: String
    let params: Vec<LlvmParam>
    let body_ir: String        # corps IR complet, incluant les basic blocks
    let is_declaration: Bool
    let is_exported: Bool
.end

pub struct LlvmModule:
    let name: String
    let target: LlvmTargetConfig
    let globals: Vec<LlvmGlobal>
    let functions: Vec<LlvmFunction>
    let raw_ir_preamble: String    # header IR optionnel (target triple, datalayout)
.end

pub fn llvm_module_new(String name, LlvmTargetConfig target) -> LlvmModule:
    let globals: Vec<LlvmGlobal> = Vec<LlvmGlobal>::new()
    let funcs: Vec<LlvmFunction> = Vec<LlvmFunction>::new()
    let pre = """; ModuleID = '" + name + "'\n"""

    let m = LlvmModule(
        name = name,
        target = target,
        globals = globals,
        functions = funcs,
        raw_ir_preamble = pre
    )
    return m
.end

# ----------------------------------------------------------------------------
# Builder IR textuel (String-based)
# ----------------------------------------------------------------------------

pub struct LlvmIrBuilder:
    let lines: Vec<String>
    let indent_level: usize
.end

pub fn llvm_ir_builder_new() -> LlvmIrBuilder:
    let v: Vec<String> = Vec<String>::new()
    let b = LlvmIrBuilder(
        lines = v,
        indent_level = 0usize
    )
    return b
.end

pub fn llvm_ir_builder_with_preamble(String pre) -> LlvmIrBuilder:
    let b = llvm_ir_builder_new()
    let b2 = llvm_ir_builder_push_raw(b, pre)
    return b2
.end

pub fn llvm_ir_builder_indent(LlvmIrBuilder b) -> LlvmIrBuilder:
    let lvl = b.indent_level + 1usize
    let b2 = LlvmIrBuilder(
        lines = b.lines,
        indent_level = lvl
    )
    return b2
.end

pub fn llvm_ir_builder_dedent(LlvmIrBuilder b) -> LlvmIrBuilder:
    let lvl = b.indent_level
    if lvl == 0usize:
        return b
    .end
    let lvl2 = lvl - 1usize
    let b2 = LlvmIrBuilder(
        lines = b.lines,
        indent_level = lvl2
    )
    return b2
.end

pub fn llvm_ir_builder_push_line(LlvmIrBuilder b, String line) -> LlvmIrBuilder:
    let lines = b.lines

    let indent = ""
    let i = 0usize
    while i < b.indent_level:
        let indent = indent + "    "
        i = i + 1usize
    .end

    let full = indent + line
    lines.push(full)

    let b2 = LlvmIrBuilder(
        lines = lines,
        indent_level = b.indent_level
    )
    return b2
.end

pub fn llvm_ir_builder_push_raw(LlvmIrBuilder b, String text) -> LlvmIrBuilder:
    # Ajoute un bloc brut (multi-lignes) sans indentation additionnelle.
    let lines = b.lines
    let current = text.split("\n")
    let n = current.len()
    let i = 0usize

    while i < n:
        let part = current[i]
        lines.push(part)
        i = i + 1usize
    .end

    let b2 = LlvmIrBuilder(
        lines = lines,
        indent_level = b.indent_level
    )
    return b2
.end

pub fn llvm_ir_builder_to_string(LlvmIrBuilder b) -> String:
    let lines = b.lines
    let n = lines.len()
    let out = ""
    let i = 0usize

    while i < n:
        let l = lines[i]
        let out = out + l
        if i + 1usize < n:
            let out = out + "\n"
        .end
        i = i + 1usize
    .end

    return out
.end

# ----------------------------------------------------------------------------
# Ajout de globaux et fonctions à un LlvmModule
# ----------------------------------------------------------------------------

pub fn llvm_module_add_global(LlvmModule m, LlvmGlobal g) -> LlvmModule:
    let gs = m.globals
    gs.push(g)
    let m2 = LlvmModule(
        name = m.name,
        target = m.target,
        globals = gs,
        functions = m.functions,
        raw_ir_preamble = m.raw_ir_preamble
    )
    return m2
.end

pub fn llvm_module_add_function(LlvmModule m, LlvmFunction f) -> LlvmModule:
    let fs = m.functions
    fs.push(f)
    let m2 = LlvmModule(
        name = m.name,
        target = m.target,
        globals = m.globals,
        functions = fs,
        raw_ir_preamble = m.raw_ir_preamble
    )
    return m2
.end

pub fn llvm_module_render_ir(LlvmModule m) -> String:
    let b0 = llvm_ir_builder_with_preamble(m.raw_ir_preamble)

    # target triple simple
    let triple_str = llvm_target_triple_to_string(m.target.triple)
    let b1 = llvm_ir_builder_push_line(b0, "target triple = \"" + triple_str + "\"")

    # globals
    let gs = m.globals
    let gi = 0usize
    let gn = gs.len()
    let b_g = b1

    while gi < gn:
        let g = gs[gi]
        let line = "@" + g.name + " = "
        if g.is_const:
            let line = line + "constant "
        .end
        if not g.is_const:
            let line = line + "global "
        .end
        let line = line + g.ty
        if g.init != "":
            let line = line + " " + g.init
        .end
        let b_g = llvm_ir_builder_push_line(b_g, line)
        gi = gi + 1usize
    .end

    # functions
    let fs = m.functions
    let fi = 0usize
    let fnn = fs.len()
    let b_f = b_g

    while fi < fnn:
        let f = fs[fi]
        let decl_or_def = "define "
        if f.is_declaration:
            let decl_or_def = "declare "
        .end

        let header = decl_or_def + f.ret_type + " @" + f.name + "("

        let ps = f.params
        let pn = ps.len()
        let pj = 0usize
        let first = true
        let sig = header

        while pj < pn:
            let p = ps[pj]
            if first:
                let sig = sig + p.ty + " %" + p.name
                let first = false
            .end
            if not first:
                if pj > 0usize:
                    let sig = sig + ", " + p.ty + " %" + p.name
                .end
            .end
            pj = pj + 1usize
        .end

        let sig = sig + ")"

        if f.is_declaration:
            let b_f = llvm_ir_builder_push_line(b_f, sig)
        .end
        if not f.is_declaration:
            let b_f = llvm_ir_builder_push_line(b_f, sig + " {")
            let b_f = llvm_ir_builder_push_raw(b_f, f.body_ir)
            let b_f = llvm_ir_builder_push_line(b_f, "}")
        .end

        fi = fi + 1usize
    .end

    let ir_text = llvm_ir_builder_to_string(b_f)
    return ir_text
.end

# ----------------------------------------------------------------------------
# Mapping HIR -> LLVM : noms, symboles, table de fonctions
# ----------------------------------------------------------------------------

pub struct LlvmSymbolName:
    let hir_fn_id: hir.HirFnId
    let llvm_name: String
.end

pub struct LlvmSymbolTable:
    let functions: Vec<LlvmSymbolName>
.end

pub fn llvm_symbol_table_new() -> LlvmSymbolTable:
    let v: Vec<LlvmSymbolName> = Vec<LlvmSymbolName>::new()
    let t = LlvmSymbolTable(functions = v)
    return t
.end

pub fn llvm_symbol_table_insert_fn(LlvmSymbolTable t, hir.HirFnId id, String name) -> LlvmSymbolTable:
    let v = t.functions
    let entry = LlvmSymbolName(
        hir_fn_id = id,
        llvm_name = name
    )
    v.push(entry)
    let t2 = LlvmSymbolTable(functions = v)
    return t2
.end

pub fn llvm_symbol_table_lookup_fn(LlvmSymbolTable t, hir.HirFnId id) -> Option<String>:
    let v = t.functions
    let n = v.len()
    let i = 0usize

    while i < n:
        let e = v[i]
        if e.hir_fn_id == id:
            let some = Option<String>::Some(e.llvm_name)
            return some
        .end
        i = i + 1usize
    .end

    let none = Option<String>::None()
    return none
.end

pub fn llvm_mangle_function_name(String module_name, String fn_name) -> String:
    # Mangling simple et stable : "vitte_" + module + "_" + fn
    # Les backends pourront le remplacer par quelque chose de plus évolué.
    let mangled = "vitte_" + module_name + "_" + fn_name
    return mangled
.end

# ----------------------------------------------------------------------------
# Lowering HIR -> LLVM IR (squelette minimal, pour tests / debug)
# ----------------------------------------------------------------------------

pub struct LlvmLoweringOptions:
    let target: LlvmTargetConfig
    let emit_debug_names: Bool
.end

pub fn llvm_lowering_options_from_language(lang.LanguageConfig cfg) -> LlvmLoweringOptions:
    let target = llvm_target_config_default(cfg)
    let emit_debug_names = true
    let o = LlvmLoweringOptions(
        target = target,
        emit_debug_names = emit_debug_names
    )
    return o
.end

pub struct LlvmLoweringResult:
    let ok: Bool
    let module: Option<LlvmModule>
    let diagnostics: diag.DiagnosticsSink
.end

pub fn llvm_lowering_result_ok(LlvmModule m, diag.DiagnosticsSink d) -> LlvmLoweringResult:
    let some_m: Option<LlvmModule> = Option<LlvmModule>::Some(m)
    let r = LlvmLoweringResult(
        ok = true,
        module = some_m,
        diagnostics = d
    )
    return r
.end

pub fn llvm_lowering_result_err(diag.DiagnosticsSink d) -> LlvmLoweringResult:
    let none_m: Option<LlvmModule> = Option<LlvmModule>::None()
    let r = LlvmLoweringResult(
        ok = false,
        module = none_m,
        diagnostics = d
    )
    return r
.end

# Lowering simplifié : chaque fonction HIR publique devient un stub LLVM
# avec un corps vide (ret void) pour permettre à la chaîne de build de
# déjà produire un IR structurel.

pub fn llvm_lower_hir_module_to_llvm(
    hir.HirModule hm,
    LlvmLoweringOptions opts,
    diag.DiagnosticsSink sink_in
) -> LlvmLoweringResult:
    let sink = sink_in

    let name = hm.name
    let m = llvm_module_new(name, opts.target)

    let symtab = llvm_symbol_table_new()

    # Fonctions : on génère des stubs simples "define void @mangled() { ret void }"
    let fns = hm.fns
    let fn_count = fns.len()
    let fi = 0usize
    let m_acc = m
    let sym_acc = symtab

    while fi < fn_count:
        let f = fns[fi]

        # On ne s'occupe que des fonctions publiques pour l'instant.
        if f.visibility != hir.HirVisibility::HirVisibilityPublic:
            fi = fi + 1usize
            continue
        .end

        let llvm_name = llvm_mangle_function_name(hm.name, f.name)

        let params_ir: Vec<LlvmParam> = Vec<LlvmParam>::new()
        # Lowering des types de paramètres ignoré pour l'instant : on va
        # simplement les typer en i32 pour avoir un IR valide minimal.
        let ps = f.params
        let pn = ps.len()
        let pj = 0usize
        let params_acc = params_ir

        while pj < pn:
            let p = ps[pj]
            let lp = LlvmParam(
                name = p.name,
                ty = "i32"    # placeholder
            )
            params_acc.push(lp)
            pj = pj + 1usize
        .end

        # Type de retour : placeholder "void" si inconnu
        let ret_ty = "void"

        let body_builder = llvm_ir_builder_new()
        let body_builder = llvm_ir_builder_push_line(body_builder, "; body stub for " + llvm_name)
        let body_builder = llvm_ir_builder_push_line(body_builder, "  ret void")
        let body_ir = llvm_ir_builder_to_string(body_builder)

        let lf = LlvmFunction(
            name = llvm_name,
            ret_type = ret_ty,
            params = params_acc,
            body_ir = body_ir,
            is_declaration = false,
            is_exported = true
        )

        let m_acc = llvm_module_add_function(m_acc, lf)
        let sym_acc = llvm_symbol_table_insert_fn(sym_acc, f.id, llvm_name)

        fi = fi + 1usize
    .end

    let res = llvm_lowering_result_ok(m_acc, sink)
    return res
.end

# ----------------------------------------------------------------------------
# Intégration avec le linker : construction d'un LinkedArtifact IR
# ----------------------------------------------------------------------------

pub fn llvm_link_single_module_ir(
    link.LinkInputModule input,
    lang.LanguageConfig cfg,
    diag.DiagnosticsSink sink_in
) -> link.LinkResult:
    let opts_lower = llvm_lowering_options_from_language(cfg)

    let hir_opt = input.hir
    if hir_opt.is_none():
        let span = diag.span_unknown()
        let msg = "missing HIR for LLVM emission: " + input.name
        let err = link.link_error_new(
            link.LinkErrorKind::LinkErrorKindMissingHir,
            msg,
            span
        )
        let d = link.link_error_to_diagnostic(err)
        let sink1 = diag.diagnostics_push(sink_in, d)
        return link.link_result_err(sink1)
    .end

    let hm = hir_opt.unwrap()

    let sink = sink_in
    let lower_res = llvm_lower_hir_module_to_llvm(hm, opts_lower, sink)
    if not lower_res.ok:
        return link.link_result_err(lower_res.diagnostics)
    .end

    let m_opt = lower_res.module
    if m_opt.is_none():
        return link.link_result_err(lower_res.diagnostics)
    .end

    let m = m_opt.unwrap()
    let ir_text = llvm_module_render_ir(m)

    # L'artefact logique pointe sur un chemin abstrait (output_path), le
    # backend réel décidera comment écrire ir_text.
    let art = link.LinkedArtifact(
        kind = link.LinkedArtifactKind::LinkedArtifactKindObject,
        path = input.path,
        config = cfg,
        diagnostics = lower_res.diagnostics
    )

    let res = link.link_result_ok(art)
    return res
.end

# ----------------------------------------------------------------------------
# Notes
# ----------------------------------------------------------------------------
# - Ce module propose un socle conséquent pour un backend LLVM textuel, mais
#   reste volontairement "agnostique" de libLLVM / bindings concrets.
# - L'objectif est de permettre :
#       * génération de IR de debug (pour tests, snapshots),
#       * prototypage de backends LLVM sans setup complexe,
#       * branchement avec un éventuel module vitte.compiler.llvm_ffi.
# ============================================================================
