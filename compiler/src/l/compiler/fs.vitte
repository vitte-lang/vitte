

module vitte.compiler.fs

import vitte.compiler.collections as coll
import vitte.compiler.diagnostics as diag
import vitte.runtime.env as env

# ============================================================================
# Vitte compiler – FS & Source Files (ultra ultra complet max)
#
# Objectifs :
#   - Fournir une abstraction légère pour les chemins (FsPath) utilisable par
#     le compilateur (front-end, Muffin, backends).
#   - Centraliser la représentation des erreurs FS (FsError / FsErrorKind).
#   - Définir des résultats typés pour les opérations de lecture/écriture,
#     même si l'implémentation réelle dépendra du runtime / host.
#   - Offrir un cache de fichiers source simple (SourceFileCache) basé sur
#     SmallMap<String, SourceFile>.
#   - Exposer des constructs plus riches : options d'ouverture, listing de
#     répertoires, config de recherche, résultats détaillés.
#
# Remarques :
#   - Les fonctions de lecture/écriture/listing sont volontairement implémentées
#     en mode "stub" (FsErrorUnsupported). Le host (Rust/C, etc.) peut fournir
#     des implémentations natives ou générer du code correspondant.
#   - La manipulation de String reste volontairement minimale pour ne pas
#     présumer d'une std Vitte complète (pas de split/trim/etc.).
# ============================================================================

# ----------------------------------------------------------------------------
# Représentation des chemins
# ----------------------------------------------------------------------------

pub struct FsPath:
    let raw: String
.end

pub fn fs_path_from_string(String s) -> FsPath:
    let p = FsPath(raw = s)
    return p
.end

pub fn fs_path_to_string(FsPath p) -> String:
    return p.raw
.end

pub fn fs_path_join(FsPath base, String segment) -> FsPath:
    # Implémentation naïve : concatène avec "/" sans normalisation.
    let sep = "/"
    if base.raw == "":
        let p = FsPath(raw = segment)
        return p
    .end

    let raw = base.raw + sep + segment
    let p2 = FsPath(raw = raw)
    return p2
.end

pub fn fs_path_append_extension(FsPath base, String ext) -> FsPath:
    # Implémentation naïve : ajoute "." + ext.
    if ext == "":
        return base
    .end

    let dot = "."
    let raw = base.raw + dot + ext
    let p = FsPath(raw = raw)
    return p
.end

pub fn fs_path_is_empty(FsPath p) -> Bool:
    return p.raw == ""
.end

pub fn fs_path_is_absolute(FsPath p) -> Bool:
    # Stub portable : renvoie false par défaut. Une implémentation réelle
    # pourra tester le premier caractère ("/"), gestion Windows, etc.
    return false
.end

pub fn fs_path_is_relative(FsPath p) -> Bool:
    return not fs_path_is_absolute(p)
.end

# ----------------------------------------------------------------------------
# Métadonnées et types de fichier
# ----------------------------------------------------------------------------

pub enum FileType:
    FileTypeRegular
    FileTypeDirectory
    FileTypeSymlink
    FileTypeOther
.end

pub struct FsMetadata:
    let file_type: FileType
    let size_bytes: u64
    let readonly: Bool
    let modified_timestamp_unix: i64
    let created_timestamp_unix: i64
.end

pub fn fs_metadata_default() -> FsMetadata:
    let meta = FsMetadata(
        file_type = FileType::FileTypeOther,
        size_bytes = 0u64,
        readonly = false,
        modified_timestamp_unix = 0i64,
        created_timestamp_unix = 0i64
    )
    return meta
.end

# ----------------------------------------------------------------------------
# Erreurs FS
# ----------------------------------------------------------------------------

pub enum FsErrorKind:
    FsErrorNotFound
    FsErrorPermissionDenied
    FsErrorAlreadyExists
    FsErrorInvalidPath
    FsErrorIo
    FsErrorUnsupported
    FsErrorUnknown
.end

pub struct FsError:
    let kind: FsErrorKind
    let message: String
    let path: String
.end

pub fn fs_error(FsErrorKind kind, String message, FsPath path) -> FsError:
    let p = fs_path_to_string(path)
    let e = FsError(
        kind = kind,
        message = message,
        path = p
    )
    return e
.end

pub fn fs_error_message(FsError err) -> String:
    return err.message
.end

pub fn fs_error_is_not_found(FsError err) -> Bool:
    return err.kind == FsErrorKind::FsErrorNotFound
.end

pub fn fs_error_is_unsupported(FsError err) -> Bool:
    return err.kind == FsErrorKind::FsErrorUnsupported
.end

# ----------------------------------------------------------------------------
# Résultats typés pour les opérations FS
# ----------------------------------------------------------------------------

pub struct FsResultString:
    let ok: Bool
    let data: String
    let error: Option<FsError>
.end

pub struct FsResultBytes:
    let ok: Bool
    let data: Vec<u8>
    let error: Option<FsError>
.end

pub struct FsResultMetadata:
    let ok: Bool
    let data: FsMetadata
    let error: Option<FsError>
.end

pub fn fs_result_string_ok(String data) -> FsResultString:
    let none_e: Option<FsError> = Option<FsError>::None()
    let r = FsResultString(
        ok = true,
        data = data,
        error = none_e
    )
    return r
.end

pub fn fs_result_string_err(FsError err) -> FsResultString:
    let some_e: Option<FsError> = Option<FsError>::Some(err)
    let r = FsResultString(
        ok = false,
        data = "",
        error = some_e
    )
    return r
.end

pub fn fs_result_bytes_ok(Vec<u8> data) -> FsResultBytes:
    let none_e: Option<FsError> = Option<FsError>::None()
    let r = FsResultBytes(
        ok = true,
        data = data,
        error = none_e
    )
    return r
.end

pub fn fs_result_bytes_err(FsError err) -> FsResultBytes:
    let bytes = Vec<u8>::new()
    let some_e: Option<FsError> = Option<FsError>::Some(err)
    let r = FsResultBytes(
        ok = false,
        data = bytes,
        error = some_e
    )
    return r
.end

pub fn fs_result_metadata_ok(FsMetadata data) -> FsResultMetadata:
    let none_e: Option<FsError> = Option<FsError>::None()
    let r = FsResultMetadata(
        ok = true,
        data = data,
        error = none_e
    )
    return r
.end

pub fn fs_result_metadata_err(FsError err) -> FsResultMetadata:
    let meta = fs_metadata_default()
    let some_e: Option<FsError> = Option<FsError>::Some(err)
    let r = FsResultMetadata(
        ok = false,
        data = meta,
        error = some_e
    )
    return r
.end

# ----------------------------------------------------------------------------
# Stubs d'opérations FS (à implémenter côté runtime / host)
# ----------------------------------------------------------------------------

pub fn fs_read_to_string(FsPath path) -> FsResultString:
    let raw = fs_path_to_string(path)
    let host_res = env.read_file_utf8(raw)

    if host_res.ok:
        return fs_result_string_ok(host_res.data)
    .end

    let msg = if host_res.error == "":
        "failed to read '" + raw + "'"
    else:
        host_res.error
    .end
    let err = fs_error(FsErrorKind::FsErrorIo, msg, path)
    return fs_result_string_err(err)
.end

pub fn fs_read_to_bytes(FsPath path) -> FsResultBytes:
    let msg = "fs_read_to_bytes not implemented for path '" + fs_path_to_string(path) + "'"
    let err = fs_error(FsErrorKind::FsErrorUnsupported, msg, path)
    let r = fs_result_bytes_err(err)
    return r
.end

pub fn fs_write_string(FsPath path, String data, Bool overwrite) -> FsResultMetadata:
    let raw = fs_path_to_string(path)
    let host_res = env.write_file_utf8(raw, data, overwrite)

    if host_res.ok:
        let meta = fs_metadata_default()
        let r_ok = fs_result_metadata_ok(meta)
        return r_ok
    .end

    let msg = if host_res.error == "":
        "failed to write '" + raw + "'"
    else:
        host_res.error
    .end
    let err = fs_error(FsErrorKind::FsErrorIo, msg, path)
    return fs_result_metadata_err(err)
.end

pub fn fs_metadata(FsPath path) -> FsResultMetadata:
    let msg = "fs_metadata not implemented for path '" + fs_path_to_string(path) + "'"
    let err = fs_error(FsErrorKind::FsErrorUnsupported, msg, path)
    let r = fs_result_metadata_err(err)
    return r
.end

# ----------------------------------------------------------------------------
# Diagnostics helpers pour FS
# ----------------------------------------------------------------------------

pub fn fs_push_error_diag(FsError err, diag.DiagnosticsSink sink) -> diag.DiagnosticsSink:
    let msg = fs_error_message(err)
    let span = diag.make_dummy_span()
    let d = diag.make_error(msg, span)
    sink.push(d)
    return sink
.end

# ----------------------------------------------------------------------------
# Fichiers source et cache
# ----------------------------------------------------------------------------

pub struct SourceFile:
    let path: FsPath
    let text: String
.end

pub struct SourceFileCache:
    let files: coll.SmallMap<String, SourceFile>
.end

pub fn source_file_new(FsPath path, String text) -> SourceFile:
    let f = SourceFile(path = path, text = text)
    return f
.end

pub fn source_file_from_str(String path_str, String text) -> SourceFile:
    let p = fs_path_from_string(path_str)
    let f = SourceFile(path = p, text = text)
    return f
.end

pub fn source_file_cache_new() -> SourceFileCache:
    let m = coll.small_map_new<String, SourceFile>()
    let c = SourceFileCache(files = m)
    return c
.end

pub fn source_file_cache_insert(SourceFileCache cache, SourceFile file) -> SourceFileCache:
    let key = fs_path_to_string(file.path)
    let m = cache.files
    let m2 = coll.small_map_insert<String, SourceFile>(m, key, file)
    let c2 = SourceFileCache(files = m2)
    return c2
.end

pub fn source_file_cache_get(SourceFileCache cache, FsPath path) -> Option<SourceFile>:
    let key = fs_path_to_string(path)
    let m = cache.files
    let maybe = coll.small_map_get<String, SourceFile>(m, key)
    return maybe
.end

pub fn source_file_cache_contains(SourceFileCache cache, FsPath path) -> Bool:
    let key = fs_path_to_string(path)
    let m = cache.files
    let has = coll.small_map_contains_key<String, SourceFile>(m, key)
    return has
.end

# ----------------------------------------------------------------------------
# Chargement de source avec cache (stub)
# ----------------------------------------------------------------------------

pub struct SourceLoadResult:
    let ok: Bool
    let file: Option<SourceFile>
    let error: Option<FsError>
.end

pub fn source_load_result_ok(SourceFile file) -> SourceLoadResult:
    let some_f: Option<SourceFile> = Option<SourceFile>::Some(file)
    let none_e: Option<FsError> = Option<FsError>::None()
    let r = SourceLoadResult(
        ok = true,
        file = some_f,
        error = none_e
    )
    return r
.end

pub fn source_load_result_err(FsError err) -> SourceLoadResult:
    let none_f: Option<SourceFile> = Option<SourceFile>::None()
    let some_e: Option<FsError> = Option<FsError>::Some(err)
    let r = SourceLoadResult(
        ok = false,
        file = none_f,
        error = some_e
    )
    return r
.end

pub fn source_load_with_cache(SourceFileCache cache, FsPath path) -> (SourceFileCache, SourceLoadResult):
    # 1) Vérifie le cache.
    let maybe_cached = source_file_cache_get(cache, path)
    if maybe_cached.is_some():
        let f = maybe_cached.unwrap()
        let res = source_load_result_ok(f)
        let out = (cache, res)
        return out
    .end

    # 2) Essaie de lire depuis le FS (stub pour l'instant).
    let r = fs_read_to_string(path)
    if not r.ok:
        # Erreur FS : on propage.
        let err_opt = r.error
        if err_opt.is_some():
            let err = err_opt.unwrap()
            let res_err = source_load_result_err(err)
            let out_err = (cache, res_err)
            return out_err
        .end

        # Pas d'erreur détaillée, on synthétise une erreur inconnue.
        let msg = "unknown fs error while reading '" + fs_path_to_string(path) + "'"
        let err2 = fs_error(FsErrorKind::FsErrorUnknown, msg, path)
        let res_err2 = source_load_result_err(err2)
        let out_err2 = (cache, res_err2)
        return out_err2
    .end

    # 3) Construction du SourceFile et mise en cache.
    let text = r.data
    let file = SourceFile(path = path, text = text)

    let cache2 = source_file_cache_insert(cache, file)
    let res_ok = source_load_result_ok(file)
    let out_ok = (cache2, res_ok)
    return out_ok
.end

# ----------------------------------------------------------------------------
# Options d'ouverture de fichiers (abstraction future)
# ----------------------------------------------------------------------------

pub enum FsOpenMode:
    FsOpenRead
    FsOpenWrite
    FsOpenAppend
    FsOpenReadWrite
    FsOpenTruncate
.end

pub struct FsOpenOptions:
    let mode: FsOpenMode
    let create: Bool
    let create_new: Bool
    let truncate: Bool
    let append: Bool
.end

pub fn fs_open_options_default() -> FsOpenOptions:
    let o = FsOpenOptions(
        mode = FsOpenMode::FsOpenRead,
        create = false,
        create_new = false,
        truncate = false,
        append = false
    )
    return o
.end

pub fn fs_open_with_options(FsPath path, FsOpenOptions opts) -> FsResultMetadata:
    let msg = "fs_open_with_options not implemented for path '" + fs_path_to_string(path) + "'"
    let err = fs_error(FsErrorKind::FsErrorUnsupported, msg, path)
    let r = fs_result_metadata_err(err)
    # opts est accepté mais non utilisé pour l'instant.
    return r
.end

# ----------------------------------------------------------------------------
# Listing de répertoire et création récursive (stubs)
# ----------------------------------------------------------------------------

pub struct FsDirEntry:
    let path: FsPath
    let file_type: FileType
.end

pub struct FsResultDirEntries:
    let ok: Bool
    let entries: Vec<FsDirEntry>
    let error: Option<FsError>
.end

pub fn fs_result_dir_entries_ok(Vec<FsDirEntry> entries) -> FsResultDirEntries:
    let none_e: Option<FsError> = Option<FsError>::None()
    let r = FsResultDirEntries(
        ok = true,
        entries = entries,
        error = none_e
    )
    return r
.end

pub fn fs_result_dir_entries_err(FsError err) -> FsResultDirEntries:
    let empty: Vec<FsDirEntry> = Vec<FsDirEntry>::new()
    let some_e: Option<FsError> = Option<FsError>::Some(err)
    let r = FsResultDirEntries(
        ok = false,
        entries = empty,
        error = some_e
    )
    return r
.end

pub fn fs_read_dir(FsPath path) -> FsResultDirEntries:
    let msg = "fs_read_dir not implemented for path '" + fs_path_to_string(path) + "'"
    let err = fs_error(FsErrorKind::FsErrorUnsupported, msg, path)
    let r = fs_result_dir_entries_err(err)
    return r
.end

pub fn fs_create_dir_all(FsPath path) -> FsResultMetadata:
    let msg = "fs_create_dir_all not implemented for path '" + fs_path_to_string(path) + "'"
    let err = fs_error(FsErrorKind::FsErrorUnsupported, msg, path)
    let r = fs_result_metadata_err(err)
    return r
.end

# ----------------------------------------------------------------------------
# Config de recherche de fichiers (search paths)
# ----------------------------------------------------------------------------

pub struct FsSearchPath:
    let root: FsPath
.end

pub struct FsSearchConfig:
    let roots: Vec<FsSearchPath>
    let default_extension: String
.end

pub fn fs_search_config_new() -> FsSearchConfig:
    let roots = Vec<FsSearchPath>::new()
    let cfg = FsSearchConfig(
        roots = roots,
        default_extension = ""
    )
    return cfg
.end

pub fn fs_search_config_add_root(FsSearchConfig cfg, FsPath root) -> FsSearchConfig:
    let r = FsSearchPath(root = root)
    let roots = cfg.roots
    roots.push(r)
    let cfg2 = FsSearchConfig(
        roots = roots,
        default_extension = cfg.default_extension
    )
    return cfg2
.end

pub fn fs_search_config_set_default_extension(FsSearchConfig cfg, String ext) -> FsSearchConfig:
    let roots = cfg.roots
    let cfg2 = FsSearchConfig(
        roots = roots,
        default_extension = ext
    )
    return cfg2
.end

pub struct FsSearchResult:
    let ok: Bool
    let path: Option<FsPath>
    let error: Option<FsError>
.end

pub fn fs_search_result_ok(FsPath path) -> FsSearchResult:
    let some_p: Option<FsPath> = Option<FsPath>::Some(path)
    let none_e: Option<FsError> = Option<FsError>::None()
    let r = FsSearchResult(
        ok = true,
        path = some_p,
        error = none_e
    )
    return r
.end

pub fn fs_search_result_err(FsError err) -> FsSearchResult:
    let none_p: Option<FsPath> = Option<FsPath>::None()
    let some_e: Option<FsError> = Option<FsError>::Some(err)
    let r = FsSearchResult(
        ok = false,
        path = none_p,
        error = some_e
    )
    return r
.end

pub fn fs_search_first_existing(FsSearchConfig cfg, FsPath relative) -> FsSearchResult:
    let roots = cfg.roots
    let n = roots.len()
    let i = 0usize
    let last_err: Option<FsError> = Option<FsError>::None()

    while i < n:
        let sp = roots[i]
        let seg = fs_path_to_string(relative)
        let candidate = fs_path_join(sp.root, seg)
        let meta_res = fs_metadata(candidate)
        if meta_res.ok:
            let r_ok = fs_search_result_ok(candidate)
            return r_ok
        .end

        let e_opt = meta_res.error
        if e_opt.is_some():
            let e = e_opt.unwrap()
            let last_err2: Option<FsError> = Option<FsError>::Some(e)
            # On écrase last_err avec la dernière erreur connue.
            let last_err = last_err2
        .end

        i = i + 1usize
    .end

    # Aucun chemin trouvé. Si l'on a une erreur, on la propage, sinon on crée
    # une erreur générique FsErrorUnknown avec le dernier root (si présent).
    let seg_rel = fs_path_to_string(relative)

    if n == 0usize:
        let dummy = fs_path_from_string(seg_rel)
        let msg = "no search roots configured for '" + seg_rel + "'"
        let err_none_root = fs_error(FsErrorKind::FsErrorUnknown, msg, dummy)
        let r_err = fs_search_result_err(err_none_root)
        return r_err
    .end

    let last_root = roots[n - 1usize]
    let combined = fs_path_join(last_root.root, seg_rel)
    let has_err = last_err.is_some()
    if has_err:
        let e = last_err.unwrap()
        let r_err2 = fs_search_result_err(e)
        return r_err2
    .end

    let msg2 = "file not found in search paths for '" + seg_rel + "'"
    let err2 = fs_error(FsErrorKind::FsErrorNotFound, msg2, combined)
    let r_err3 = fs_search_result_err(err2)
    return r_err3
.end

# ----------------------------------------------------------------------------
# Notes
# ----------------------------------------------------------------------------
# - Ce module isole la sémantique des chemins, erreurs, caches source et
#   recherches de fichiers. Il peut être utilisé par :
#     * la phase de parsing (chargement de fichiers .vitte / .muf),
#     * la résolution de modules / manifestes,
#     * les backends (résolution de chemins de sortie),
#     * les outils (LSP, docgen, pipeline build).
# - Les fonctions FS sont volontairement stubs; elles pourront être remplacées
#   par des implémentations natives lors de la génération de l'exécutable
#   du compilateur (Rust / C) ou par un runtime Vitte plus complet.
# - Les abstractions FsOpenOptions, FsDirEntry, FsSearchConfig et FsSearchResult
#   préparent l'intégration future d'un FS réel, tout en restant compilables
#   immédiatement dans l'écosystème Vitte actuel.
# ----------------------------------------------------------------------------
