module vitte.compiler.repl

import vitte.compiler.diagnostics as diag
import vitte.compiler.language as lang
import vitte.compiler.pipeline as pipe
import vitte.compiler.path as path

# ============================================================================
# Vitte compiler – REPL core (maximal, déclaratif, sans I/O)
#
# Objectifs :
#   - Fournir un noyau de REPL pour Vitte, purement fonctionnel :
#       * gestion d'état (config, historique, compteur de cellules),
#       * parsing des lignes d'entrée (métacommandes :help, :mode, :reset...),
#       * intégration avec la pipeline de compilation (parse / compile),
#       * rendu textuel des diagnostics.
#   - Ne gérer NI le terminal, NI les flux d'entrée/sortie :
#       * le front-end (CLI, TUI, GUI, LSP) fournit les lignes de texte,
#         appelle `repl_eval_line`, et affiche les messages retournés.
#   - Rester aligné avec la syntaxe Vitte (.end, pas d'accolades).
# ============================================================================

# ----------------------------------------------------------------------------
# Modes d'évaluation et config
# ----------------------------------------------------------------------------

pub enum ReplEvalMode:
    ReplEvalModeParse      # s'arrête après le parsing (AST OK / erreurs)
    ReplEvalModeCompile    # lance la pipeline complète (jusqu'à LLVM)
.end

pub struct ReplConfig:
    let prompt: String
    let mode: ReplEvalMode
    let language_config: lang.LanguageConfig
    let default_profile: String
    let workspace_root: String
.end

pub fn repl_default_config() -> ReplConfig:
    let cfg = lang.language_config_core_default()
    let c = ReplConfig(
        prompt = "vitte> ",
        mode = ReplEvalMode::ReplEvalModeCompile,
        language_config = cfg,
        default_profile = "debug",
        workspace_root = "."
    )
    return c
.end

pub fn repl_config_with_mode(ReplConfig cfg, ReplEvalMode mode) -> ReplConfig:
    let c2 = ReplConfig(
        prompt = cfg.prompt,
        mode = mode,
        language_config = cfg.language_config,
        default_profile = cfg.default_profile,
        workspace_root = cfg.workspace_root
    )
    return c2
.end

# ----------------------------------------------------------------------------
# Sorties du REPL
# ----------------------------------------------------------------------------

pub enum ReplOutputKind:
    ReplOutputKindInfo
    ReplOutputKindDiagnostics
    ReplOutputKindError
    ReplOutputKindHelp
.end

pub struct ReplOutputMessage:
    let kind: ReplOutputKind
    let text: String
.end

pub fn repl_output_info(String text) -> ReplOutputMessage:
    let m = ReplOutputMessage(
        kind = ReplOutputKind::ReplOutputKindInfo,
        text = text
    )
    return m
.end

pub fn repl_output_error(String text) -> ReplOutputMessage:
    let m = ReplOutputMessage(
        kind = ReplOutputKind::ReplOutputKindError,
        text = text
    )
    return m
.end

pub fn repl_output_help(String text) -> ReplOutputMessage:
    let m = ReplOutputMessage(
        kind = ReplOutputKind::ReplOutputKindHelp,
        text = text
    )
    return m
.end

pub fn repl_output_diagnostics(String text) -> ReplOutputMessage:
    let m = ReplOutputMessage(
        kind = ReplOutputKind::ReplOutputKindDiagnostics,
        text = text
    )
    return m
.end

# ----------------------------------------------------------------------------
# Historique
# ----------------------------------------------------------------------------

pub struct ReplHistoryEntry:
    let index: u32
    let source_name: String
    let input_text: String
    let outputs: Vec<ReplOutputMessage>
    let ok: Bool
.end

# ----------------------------------------------------------------------------
# Commandes REPL (métacommandes)
# ----------------------------------------------------------------------------

pub enum ReplCommandKind:
    ReplCommandKindLine      # ligne de code à compiler
    ReplCommandKindReset
    ReplCommandKindSetMode
    ReplCommandKindHelp
    ReplCommandKindQuit
.end

pub struct ReplCommand:
    let kind: ReplCommandKind
    let args: Vec<String>
    let raw: String
.end

# ----------------------------------------------------------------------------
# État du REPL
# ----------------------------------------------------------------------------

pub struct ReplState:
    let config: ReplConfig
    let next_cell_id: u32
    let history: Vec<ReplHistoryEntry>
.end

pub fn repl_state_new(ReplConfig cfg) -> ReplState:
    let hist: Vec<ReplHistoryEntry> = Vec<ReplHistoryEntry>::new()
    let st = ReplState(
        config = cfg,
        next_cell_id = 0u32,
        history = hist
    )
    return st
.end

pub fn repl_state_reset(ReplState st) -> ReplState:
    let hist: Vec<ReplHistoryEntry> = Vec<ReplHistoryEntry>::new()
    let st2 = ReplState(
        config = st.config,
        next_cell_id = 0u32,
        history = hist
    )
    return st2
.end

# ----------------------------------------------------------------------------
# Parsing des commandes (syntaxe :help, :mode etc.)
# ----------------------------------------------------------------------------

fn repl_trim_leading_spaces(String s) -> String:
    let bytes = s.as_bytes()
    let n = bytes.len()
    let i = 0usize

    while i < n:
        let b = bytes[i]
        if b != 32u8 and b != 9u8: # ' ' ou '\t'
            break
        .end
        let i = i + 1usize
    .end

    if i == 0usize:
        return s
    .end

    let out = s.slice(i, n)
    return out
.end

fn repl_is_whitespace_only(String s) -> Bool:
    let bytes = s.as_bytes()
    let n = bytes.len()
    let i = 0usize

    while i < n:
        let b = bytes[i]
        if b != 32u8 and b != 9u8 and b != 10u8 and b != 13u8:
            return false
        .end
        let i = i + 1usize
    .end

    return true
.end

fn repl_parse_meta_command(String line) -> ReplCommand:
    # Exemples :
    #   :q, :quit
    #   :help
    #   :mode parse
    #   :mode compile
    #   :reset
    let trimmed = repl_trim_leading_spaces(line)
    let parts = trimmed.split(" ")
    let n = parts.len()

    if n == 0usize:
        let args: Vec<String> = Vec<String>::new()
        let c = ReplCommand(
            kind = ReplCommandKind::ReplCommandKindHelp,
            args = args,
            raw = line
        )
        return c
    .end

    let cmd = parts[0usize]

    # Normalisation basique
    if cmd == ":q" or cmd == ":quit":
        let args_q: Vec<String> = Vec<String>::new()
        let c_q = ReplCommand(
            kind = ReplCommandKind::ReplCommandKindQuit,
            args = args_q,
            raw = line
        )
        return c_q
    .end

    if cmd == ":h" or cmd == ":help":
        let args_h: Vec<String> = Vec<String>::new()
        let c_h = ReplCommand(
            kind = ReplCommandKind::ReplCommandKindHelp,
            args = args_h,
            raw = line
        )
        return c_h
    .end

    if cmd == ":reset":
        let args_r: Vec<String> = Vec<String>::new()
        let c_r = ReplCommand(
            kind = ReplCommandKind::ReplCommandKindReset,
            args = args_r,
            raw = line
        )
        return c_r
    .end

    if cmd == ":mode":
        let args_m: Vec<String> = Vec<String>::new()
        let mode_str = if n >= 2usize:
            parts[1usize]
        else:
            ""
        .end
        args_m.push(mode_str)
        let c_m = ReplCommand(
            kind = ReplCommandKind::ReplCommandKindSetMode,
            args = args_m,
            raw = line
        )
        return c_m
    .end

    # Commande inconnue -> Help + message d'erreur dans le haut niveau.
    let args_u: Vec<String> = Vec<String>::new()
    let c_u = ReplCommand(
        kind = ReplCommandKind::ReplCommandKindHelp,
        args = args_u,
        raw = line
    )
    return c_u
.end

fn repl_parse_line_to_command(String line) -> ReplCommand:
    if line.len() == 0usize:
        let args: Vec<String> = Vec<String>::new()
        let c_empty = ReplCommand(
            kind = ReplCommandKind::ReplCommandKindLine,
            args = args,
            raw = line
        )
        return c_empty
    .end

    let first = line.as_bytes()[0usize]
    if first == 58u8: # ':'
        let c_meta = repl_parse_meta_command(line)
        return c_meta
    .end

    let args_line: Vec<String> = Vec<String>::new()
    let c = ReplCommand(
        kind = ReplCommandKind::ReplCommandKindLine,
        args = args_line,
        raw = line
    )
    return c
.end

# ----------------------------------------------------------------------------
# Rendu des diagnostics
# ----------------------------------------------------------------------------

fn repl_severity_to_string(diag.Severity s) -> String:
    if s == diag.Severity::SeverityError:
        return "error"
    .end
    if s == diag.Severity::SeverityWarning:
        return "warning"
    .end
    if s == diag.Severity::SeverityInfo:
        return "info"
    .end
    if s == diag.Severity::SeverityHint:
        return "hint"
    .end
    return "unknown"
.end

fn repl_format_span(diag.Span span) -> String:
    let file = span.file
    let line = span.start_line
    let col = span.start_col

    let s = file + ":"
    let s = s + line.to_string()
    let s = s + ":"
    let s = s + col.to_string()
    return s
.end

fn repl_format_diagnostic(diag.Diagnostic d) -> String:
    let sev = repl_severity_to_string(d.severity)
    let loc = repl_format_span(d.span)
    let s = loc + " "
    let s = s + sev
    let s = s + " "
    let s = s + d.code
    let s = s + ": "
    let s = s + d.message
    return s
.end

fn repl_render_diagnostics_sink(diag.DiagnosticsSink sink) -> (String, u32, u32):
    let diags = diag.diagnostics_as_vec(sink)
    let n = diags.len()
    let i = 0usize
    let out = ""
    let errors = 0u32
    let warnings = 0u32

    while i < n:
        let d = diags[i]
        let line = repl_format_diagnostic(d)
        let out = out + line + "\n"

        if d.severity == diag.Severity::SeverityError:
            let errors = errors + 1u32
        .end
        if d.severity == diag.Severity::SeverityWarning:
            let warnings = warnings + 1u32
        .end

        let i = i + 1usize
    .end

    let tup = (out, errors, warnings)
    return tup
.end

# ----------------------------------------------------------------------------
# Intégration pipeline : évaluer une “cellule” de source
# ----------------------------------------------------------------------------

fn repl_compute_source_name(ReplState st) -> String:
    let id = st.next_cell_id
    let base = "repl:"
    let s = base + id.to_string()
    let s = s + ".vitte"
    return s
.end

fn repl_eval_source_parse_only(
    ReplState st,
    String source_name,
    String code
) -> (ReplState, Vec<ReplOutputMessage>, Bool):
    let sink = diag.diagnostics_new()
    let pr = pipe.pipeline_parse_only(source_name, code, sink)
    let sink2 = pr.diagnostics

    let tuple = repl_render_diagnostics_sink(sink2)
    let diag_text = tuple.0
    let errors = tuple.1
    let warnings = tuple.2

    let msgs: Vec<ReplOutputMessage> = Vec<ReplOutputMessage>::new()

    if diag_text != "":
        let m_diag = repl_output_diagnostics(diag_text)
        msgs.push(m_diag)
    .end

    if errors == 0u32:
        let info = if warnings == 0u32:
            "ok (parsed)"
        else:
            "ok (parsed, warnings present)"
        .end
        let m_info = repl_output_info(info)
        msgs.push(m_info)
        let ok = true
        let st2 = st
        let out = (st2, msgs, ok)
        return out
    .end

    let err = repl_output_error("parse failed")
    msgs.push(err)
    let ok_false = false
    let st3 = st
    let out_err = (st3, msgs, ok_false)
    return out_err
.end

fn repl_eval_source_compile(
    ReplState st,
    String source_name,
    String code
) -> (ReplState, Vec<ReplOutputMessage>, Bool):
    let sink = diag.diagnostics_new()
    let opts = pipe.pipeline_default_options()
    let res = pipe.pipeline_frontend(source_name, code, opts, sink)

    let sink2 = res.diagnostics
    let tuple = repl_render_diagnostics_sink(sink2)
    let diag_text = tuple.0
    let errors = tuple.1
    let warnings = tuple.2

    let msgs: Vec<ReplOutputMessage> = Vec<ReplOutputMessage>::new()

    if diag_text != "":
        let m_diag = repl_output_diagnostics(diag_text)
        msgs.push(m_diag)
    .end

    if not res.ok or errors > 0u32:
        let err_msg = "compile failed"
        let m_err = repl_output_error(err_msg)
        msgs.push(m_err)
        let ok_false = false
        let st_fail = st
        let out_fail = (st_fail, msgs, ok_false)
        return out_fail
    .end

    let info = if warnings == 0u32:
        "ok (compiled)"
    else:
        "ok (compiled, warnings present)"
    .end
    let m_info = repl_output_info(info)
    msgs.push(m_info)

    let st2 = st
    let ok_true = true
    let out_ok = (st2, msgs, ok_true)
    return out_ok
.end

fn repl_eval_source(ReplState st, String code) -> (ReplState, Vec<ReplOutputMessage>, Bool):
    let source_name = repl_compute_source_name(st)
    let mode = st.config.mode

    if repl_is_whitespace_only(code):
        let msgs: Vec<ReplOutputMessage> = Vec<ReplOutputMessage>::new()
        let info = repl_output_info("empty line")
        msgs.push(info)
        let ok_true = true
        let st_same = st
        let out = (st_same, msgs, ok_true)
        return out
    .end

    if mode == ReplEvalMode::ReplEvalModeParse:
        let res = repl_eval_source_parse_only(st, source_name, code)
        return res
    .end

    # Mode compile
    let res2 = repl_eval_source_compile(st, source_name, code)
    return res2
.end

# ----------------------------------------------------------------------------
# Aide / messages de bannière
# ----------------------------------------------------------------------------

pub fn repl_banner() -> String:
    let s = "Vitte REPL (core)\n"
    let s = s + "Commands:\n"
    let s = s + "  :help           show this help\n"
    let s = s + "  :mode parse     parse only\n"
    let s = s + "  :mode compile   full pipeline\n"
    let s = s + "  :reset          reset state\n"
    let s = s + "  :quit           leave REPL\n"
    return s
.end

pub fn repl_help_text() -> String:
    let s = repl_banner()
    return s
.end

# ----------------------------------------------------------------------------
# Traitement des commandes haut niveau
# ----------------------------------------------------------------------------

fn repl_handle_set_mode(ReplState st, Vec<String> args) -> (ReplState, Vec<ReplOutputMessage>, Bool):
    let msgs: Vec<ReplOutputMessage> = Vec<ReplOutputMessage>::new()

    if args.len() == 0usize:
        let err = repl_output_error("mode name required: parse | compile")
        msgs.push(err)
        let out = (st, msgs, false)
        return out
    .end

    let name = args[0usize]
    let mode = if name == "parse":
        ReplEvalMode::ReplEvalModeParse
    else:
        if name == "compile":
            ReplEvalMode::ReplEvalModeCompile
        else:
            ReplEvalMode::ReplEvalModeCompile
        .end
    .end

    if not (name == "parse" or name == "compile"):
        let err2 = repl_output_error("unknown mode (use: parse | compile)")
        msgs.push(err2)
        let out_err = (st, msgs, false)
        return out_err
    .end

    let cfg2 = repl_config_with_mode(st.config, mode)
    let st2 = ReplState(
        config = cfg2,
        next_cell_id = st.next_cell_id,
        history = st.history
    )

    let info = repl_output_info("mode set to " + name)
    msgs.push(info)
    let out_ok = (st2, msgs, false)
    return out_ok
.end

fn repl_handle_help(ReplState st) -> (ReplState, Vec<ReplOutputMessage>, Bool):
    let msgs: Vec<ReplOutputMessage> = Vec<ReplOutputMessage>::new()
    let text = repl_help_text()
    let m = repl_output_help(text)
    msgs.push(m)
    let out = (st, msgs, false)
    return out
.end

fn repl_handle_reset(ReplState st) -> (ReplState, Vec<ReplOutputMessage>, Bool):
    let st2 = repl_state_reset(st)
    let msgs: Vec<ReplOutputMessage> = Vec<ReplOutputMessage>::new()
    let info = repl_output_info("state reset")
    msgs.push(info)
    let out = (st2, msgs, false)
    return out
.end

fn repl_handle_quit(ReplState st) -> (ReplState, Vec<ReplOutputMessage>, Bool):
    let msgs: Vec<ReplOutputMessage> = Vec<ReplOutputMessage>::new()
    let info = repl_output_info("quit requested")
    msgs.push(info)
    let out = (st, msgs, true)
    return out
.end

fn repl_handle_line(ReplState st, String line) -> (ReplState, Vec<ReplOutputMessage>, Bool):
    let res = repl_eval_source(st, line)
    return res
.end

# ----------------------------------------------------------------------------
# Fonction principale : une ligne entrée -> nouvel état + messages + quit?
# ----------------------------------------------------------------------------

pub struct ReplStepResult:
    let state: ReplState
    let outputs: Vec<ReplOutputMessage>
    let quit: Bool
.end

pub fn repl_eval_line(ReplState st, String line) -> ReplStepResult:
    let cmd = repl_parse_line_to_command(line)

    let st0 = st
    let msgs0: Vec<ReplOutputMessage> = Vec<ReplOutputMessage>::new()
    let quit0 = false

    let tuple = if cmd.kind == ReplCommandKind::ReplCommandKindHelp:
        repl_handle_help(st0)
    else:
        if cmd.kind == ReplCommandKind::ReplCommandKindReset:
            repl_handle_reset(st0)
        else:
            if cmd.kind == ReplCommandKind::ReplCommandKindSetMode:
                repl_handle_set_mode(st0, cmd.args)
            else:
                if cmd.kind == ReplCommandKind::ReplCommandKindQuit:
                    repl_handle_quit(st0)
                else:
                    # Ligne de code (ReplCommandKindLine)
                    repl_handle_line(st0, cmd.raw)
                .end
            .end
        .end
    .end

    let st1 = tuple.0
    let msgs1 = tuple.1
    let quit1 = tuple.2

    # Enregistrer dans l'historique si c'est une ligne de code.
    let st2 = if cmd.kind == ReplCommandKind::ReplCommandKindLine:
        let idx = st1.next_cell_id
        let src_name = repl_compute_source_name(st1)
        let ok = not quit1   # approximation : on pourrait raffiner en fonction des diagnostics.
        let h_entry = ReplHistoryEntry(
            index = idx,
            source_name = src_name,
            input_text = cmd.raw,
            outputs = msgs1,
            ok = ok
        )
        let hist = st1.history
        hist.push(h_entry)
        let st3 = ReplState(
            config = st1.config,
            next_cell_id = idx + 1u32,
            history = hist
        )
        st3
    else:
        st1
    .end

    let result = ReplStepResult(
        state = st2,
        outputs = msgs1,
        quit = quit1
    )
    return result
.end

# ----------------------------------------------------------------------------
# Notes
# ----------------------------------------------------------------------------
# - Ce module ne connaît pas le terminal ni le protocole LSP; il fournit
#   uniquement un moteur de REPL piloté par des lignes de texte.
# - L'évaluation ne fait pas encore d'exécution de code, seulement parse/compile
#   via la pipeline existante; la valeur des expressions pourra être ajoutée
#   quand un runtime d'exécution Vitte sera disponible.
# - La structure ReplState est sérialisable (JSON, bincode, Muffin...) par des
#   couches supérieures si besoin (historiques persistants, notebooks, etc.).
# ============================================================================
