module vitte.compiler.ir

import vitte.compiler.ast as ast

# ============================================================================
# Vitte compiler – IR central (LIR : "L Intermediate Representation")
#
# Objectifs :
#   - définir un IR générique pour le cœur du compilateur Vitte ;
#   - servir de pivot entre :
#       * le builder AST -> IR (mid-level),
#       * les passes d’optimisation,
#       * les backends (LVM, C, etc.) ;
#   - rester volontairement plus simple que LLVM, mais assez expressif pour :
#       * fonctions, blocs de base, SSA légère,
#       * charges/stores, appels, branches, retours, phi, casts.
#
# Remarques :
#   - Ce module ne génère pas d’IR tout seul : il fournit les structures, un
#     mini builder, un vérificateur et un pretty-printer basique.
#   - Les modules ir_builder / ir_opt / codegen_* peuvent s’appuyer sur ce IR.
# ============================================================================

# ----------------------------------------------------------------------------
# Identifiants & types de base
# ----------------------------------------------------------------------------

pub typedef u32 LIndex

pub struct LModuleId:
    let raw: u32
.end

pub struct LFuncId:
    let raw: u32
.end

pub struct LBlockId:
    let raw: u32
.end

pub struct LValueId:
    let raw: u32
.end

pub enum LVisibility:
    LVisPrivate
    LVisInternal
    LVisPublic
.end

pub enum LLinkage:
    LLinkDefault
    LLinkExtern
    LLinkWeak
.end

pub enum LCallingConv:
    LCallDefault
.end

# ----------------------------------------------------------------------------
# Types LIR
# ----------------------------------------------------------------------------

pub enum LTypeKind:
    LTyVoid
    LTyBool
    LTyI8
    LTyI16
    LTyI32
    LTyI64
    LTyF32
    LTyF64
    LTyPtr
    LTyArray
    LTyStruct
    LTyFunction
.end

pub struct LType:
    let kind: LTypeKind
    let name: String               # pour types nommés / alias éventuels
    let elem: Option<LType>        # pour pointeur / tableau
    let array_len: Option<u64>     # pour tableau
    let fields: Vec<LType>         # pour struct
    let params: Vec<LType>         # pour fonction
    let result: Option<LType>      # pour fonction
.end

fn LType.void() -> LType:
    let none_ty: Option<LType> = Option<LType>::None()
    let empty_types = Vec<LType>::new()
    let t = LType(
        kind = LTypeKind::LTyVoid,
        name = "",
        elem = none_ty,
        array_len = Option<u64>::None(),
        fields = empty_types,
        params = empty_types,
        result = none_ty
    )
    return t
.end

fn LType.bool() -> LType:
    let none_ty: Option<LType> = Option<LType>::None()
    let empty_types = Vec<LType>::new()
    let t = LType(
        kind = LTypeKind::LTyBool,
        name = "",
        elem = none_ty,
        array_len = Option<u64>::None(),
        fields = empty_types,
        params = empty_types,
        result = none_ty
    )
    return t
.end

fn LType.i32() -> LType:
    let none_ty: Option<LType> = Option<LType>::None()
    let empty_types = Vec<LType>::new()
    let t = LType(
        kind = LTypeKind::LTyI32,
        name = "",
        elem = none_ty,
        array_len = Option<u64>::None(),
        fields = empty_types,
        params = empty_types,
        result = none_ty
    )
    return t
.end

fn LType.ptr(LType target) -> LType:
    let some_target: Option<LType> = Option<LType>::Some(target)
    let empty_types = Vec<LType>::new()
    let t = LType(
        kind = LTypeKind::LTyPtr,
        name = "",
        elem = some_target,
        array_len = Option<u64>::None(),
        fields = empty_types,
        params = empty_types,
        result = some_target
    )
    return t
.end

fn LType.function(LType result, Vec<LType> params) -> LType:
    let some_res: Option<LType> = Option<LType>::Some(result)
    let none_ty: Option<LType> = Option<LType>::None()
    let empty_types = Vec<LType>::new()
    let t = LType(
        kind = LTypeKind::LTyFunction,
        name = "",
        elem = none_ty,
        array_len = Option<u64>::None(),
        fields = empty_types,
        params = params,
        result = some_res
    )
    return t
.end

# ----------------------------------------------------------------------------
# Valeurs & opérandes
# ----------------------------------------------------------------------------

pub enum LValueKind:
    LValInstr
    LValParam
    LValGlobal
    LValUndef
.end

pub struct LValue:
    let id: LValueId
    let kind: LValueKind
    let ty: LType
    let name: String
.end

pub enum LOperandKind:
    LOpValue
    LOpImmInt
    LOpImmFloat
    LOpImmBool
.end

pub struct LOperand:
    let kind: LOperandKind
    let value: Option<LValueId>
    let imm_int: Option<i64>
    let imm_float: Option<f64>
    let imm_bool: Option<Bool>
.end

fn LOperand.value(LValueId id) -> LOperand:
    let some_v = Option<LValueId>::Some(id)
    let op = LOperand(
        kind = LOperandKind::LOpValue,
        value = some_v,
        imm_int = Option<i64>::None(),
        imm_float = Option<f64>::None(),
        imm_bool = Option<Bool>::None()
    )
    return op
.end

fn LOperand.imm_i64(i64 v) -> LOperand:
    let some_i = Option<i64>::Some(v)
    let op = LOperand(
        kind = LOperandKind::LOpImmInt,
        value = Option<LValueId>::None(),
        imm_int = some_i,
        imm_float = Option<f64>::None(),
        imm_bool = Option<Bool>::None()
    )
    return op
.end

fn LOperand.imm_bool(Bool v) -> LOperand:
    let some_b = Option<Bool>::Some(v)
    let op = LOperand(
        kind = LOperandKind::LOpImmBool,
        value = Option<LValueId>::None(),
        imm_int = Option<i64>::None(),
        imm_float = Option<f64>::None(),
        imm_bool = some_b
    )
    return op
.end

# ----------------------------------------------------------------------------
# Instructions LIR
# ----------------------------------------------------------------------------

pub enum LBinOp:
    LAdd
    LSub
    LMul
    LDiv
    LMod
    LAnd
    LOr
    LXor
    LShl
    LShr
.end

pub enum LCmpOp:
    LEq
    LNe
    LLt
    LLe
    LGt
    LGe
.end

pub enum LCastOp:
    LTrunc
    LZExt
    LSExt
    LBitcast
    LFPToSI
    LSIToFP
.end

pub enum LInstrKind:
    LInstrNop
    LInstrConst
    LInstrBinOp
    LInstrCmp
    LInstrCast
    LInstrLoad
    LInstrStore
    LInstrPhi
    LInstrCall
    LInstrBr
    LInstrCondBr
    LInstrRet
.end

pub struct LPhiIncoming:
    let block: LBlockId
    let value: LValueId
.end

pub struct LInstr:
    let id: LIndex
    let kind: LInstrKind
    let ty: LType
    let result: Option<LValueId>
    let operands: Vec<LOperand>
    let bin_op: Option<LBinOp>
    let cmp_op: Option<LCmpOp>
    let cast_op: Option<LCastOp>
    let phi_incomings: Vec<LPhiIncoming>
    let target_block: Option<LBlockId>        # pour Br / CondBr
    let else_block: Option<LBlockId>          # pour CondBr
    let callee: Option<LValueId>              # pour Call
    let call_args: Vec<LOperand>              # pour Call
    let span: ast.Span
.end

# ----------------------------------------------------------------------------
# Blocs, paramètres, fonctions, globales, module
# ----------------------------------------------------------------------------

pub struct LBlock:
    let id: LBlockId
    let name: String
    let instrs: Vec<LInstr>
.end

pub struct LParam:
    let name: String
    let ty: LType
    let value: LValueId
.end

pub struct LFunction:
    let id: LFuncId
    let name: String
    let visibility: LVisibility
    let linkage: LLinkage
    let calling_conv: LCallingConv
    let params: Vec<LParam>
    let ret_type: LType
    let blocks: Vec<LBlock>
    let entry_block: LBlockId
.end

pub enum LGlobalKind:
    LGlobalVar
    LGlobalConst
.end

pub struct LGlobal:
    let name: String
    let visibility: LVisibility
    let linkage: LLinkage
    let kind: LGlobalKind
    let ty: LType
    let init: Option<LOperand>
.end

pub struct LModule:
    let id: LModuleId
    let name: String
    let globals: Vec<LGlobal>
    let functions: Vec<LFunction>
.end

# ----------------------------------------------------------------------------
# Builder LIR
# ----------------------------------------------------------------------------

pub struct LBuilder:
    let module: LModule
    let next_value: LIndex
    let next_instr: LIndex
.end

pub fn lbuilder_new(String name) -> LBuilder:
    let globals = Vec<LGlobal>::new()
    let funcs = Vec<LFunction>::new()
    let mid = LModuleId(raw = 0u32)
    let m = LModule(
        id = mid,
        name = name,
        globals = globals,
        functions = funcs
    )
    let b = LBuilder(
        module = m,
        next_value = 0u32,
        next_instr = 0u32
    )
    return b
.end

fn LBuilder.fresh_value(LBuilder b) -> (LBuilder, LValueId):
    let next = b.next_value + 1u32
    let id = LValueId(raw = next)
    let nb = LBuilder(
        module = b.module,
        next_value = next,
        next_instr = b.next_instr
    )
    return (nb, id)
.end

fn LBuilder.fresh_instr(LBuilder b) -> (LBuilder, LIndex):
    let next = b.next_instr + 1u32
    let nb = LBuilder(
        module = b.module,
        next_value = b.next_value,
        next_instr = next
    )
    return (nb, next)
.end

pub fn lbuilder_add_function(
    LBuilder b,
    String name,
    LVisibility vis,
    LLinkage link,
    LCallingConv cc,
    LType ret_type,
    Vec<LParam> params
) -> (LBuilder, LFuncId, LBlockId):
    let blocks = Vec<LBlock>::new()
    let entry_id = LBlockId(raw = 0u32)
    let entry_instrs = Vec<LInstr>::new()
    let entry = LBlock(
        id = entry_id,
        name = "entry",
        instrs = entry_instrs
    )
    blocks.push(entry)

    let funcs = b.module.functions
    let fid = LFuncId(raw = funcs.len() as u32)

    let f = LFunction(
        id = fid,
        name = name,
        visibility = vis,
        linkage = link,
        calling_conv = cc,
        params = params,
        ret_type = ret_type,
        blocks = blocks,
        entry_block = entry_id
    )
    funcs.push(f)

    let m2 = LModule(
        id = b.module.id,
        name = b.module.name,
        globals = b.module.globals,
        functions = funcs
    )

    let nb = LBuilder(
        module = m2,
        next_value = b.next_value,
        next_instr = b.next_instr
    )
    return (nb, fid, entry_id)
.end

pub fn lbuilder_append_block(
    LBuilder b,
    LFuncId func_id,
    String name
) -> (LBuilder, LBlockId):
    let m = b.module
    let funcs = m.functions
    let len = funcs.len()
    let i = 0usize
    let updated_funcs = Vec<LFunction>::new()
    let new_block_id = LBlockId(raw = 0u32)

    # On recalcule la liste de fonctions en ajoutant le bloc à la bonne fonction.
    while i < len:
        let f = funcs[i]
        if f.id.raw == func_id.raw:
            let blocks = f.blocks
            let bid = LBlockId(raw = blocks.len() as u32)
            let instrs = Vec<LInstr>::new()
            let blk = LBlock(
                id = bid,
                name = name,
                instrs = instrs
            )
            blocks.push(blk)

            let f2 = LFunction(
                id = f.id,
                name = f.name,
                visibility = f.visibility,
                linkage = f.linkage,
                calling_conv = f.calling_conv,
                params = f.params,
                ret_type = f.ret_type,
                blocks = blocks,
                entry_block = f.entry_block
            )
            updated_funcs.push(f2)
            new_block_id = bid
        .end

        if f.id.raw != func_id.raw:
            updated_funcs.push(f)
        .end

        i = i + 1usize
    .end

    let m2 = LModule(
        id = m.id,
        name = m.name,
        globals = m.globals,
        functions = updated_funcs
    )

    let nb = LBuilder(
        module = m2,
        next_value = b.next_value,
        next_instr = b.next_instr
    )
    return (nb, new_block_id)
.end

pub fn lbuilder_append_instr(
    LBuilder b,
    LFuncId func_id,
    LBlockId block_id,
    LInstr instr
) -> LBuilder:
    let m = b.module
    let funcs = m.functions
    let len = funcs.len()
    let i = 0usize
    let new_funcs = Vec<LFunction>::new()

    while i < len:
        let f = funcs[i]
        if f.id.raw == func_id.raw:
            let blocks = f.blocks
            let blen = blocks.len()
            let j = 0usize
            let new_blocks = Vec<LBlock>::new()

            while j < blen:
                let blk = blocks[j]
                if blk.id.raw == block_id.raw:
                    let instrs = blk.instrs
                    instrs.push(instr)
                    let blk2 = LBlock(
                        id = blk.id,
                        name = blk.name,
                        instrs = instrs
                    )
                    new_blocks.push(blk2)
                .end

                if blk.id.raw != block_id.raw:
                    new_blocks.push(blk)
                .end

                j = j + 1usize
            .end

            let f2 = LFunction(
                id = f.id,
                name = f.name,
                visibility = f.visibility,
                linkage = f.linkage,
                calling_conv = f.calling_conv,
                params = f.params,
                ret_type = f.ret_type,
                blocks = new_blocks,
                entry_block = f.entry_block
            )
            new_funcs.push(f2)
        .end

        if f.id.raw != func_id.raw:
            new_funcs.push(f)
        .end

        i = i + 1usize
    .end

    let m2 = LModule(
        id = m.id,
        name = m.name,
        globals = m.globals,
        functions = new_funcs
    )

    let nb = LBuilder(
        module = m2,
        next_value = b.next_value,
        next_instr = b.next_instr
    )
    return nb
.end

# ----------------------------------------------------------------------------
# Helpers d’instruction haut niveau (exemples)
# ----------------------------------------------------------------------------

pub fn lbuilder_build_binop(
    LBuilder b,
    LFuncId func_id,
    LBlockId block_id,
    LBinOp op,
    LType ty,
    LOperand lhs,
    LOperand rhs,
    ast.Span span
) -> (LBuilder, LValueId):
    let pair = LBuilder.fresh_value(b)
    let b2 = pair.0
    let val_id = pair.1

    let pair2 = LBuilder.fresh_instr(b2)
    let b3 = pair2.0
    let instr_id = pair2.1

    let ops = Vec<LOperand>::new()
    ops.push(lhs)
    ops.push(rhs)

    let some_val: Option<LValueId> = Option<LValueId>::Some(val_id)
    let some_op: Option<LBinOp> = Option<LBinOp>::Some(op)

    let instr = LInstr(
        id = instr_id,
        kind = LInstrKind::LInstrBinOp,
        ty = ty,
        result = some_val,
        operands = ops,
        bin_op = some_op,
        cmp_op = Option<LCmpOp>::None(),
        cast_op = Option<LCastOp>::None(),
        phi_incomings = Vec<LPhiIncoming>::new(),
        target_block = Option<LBlockId>::None(),
        else_block = Option<LBlockId>::None(),
        callee = Option<LValueId>::None(),
        call_args = Vec<LOperand>::new(),
        span = span
    )

    let b4 = lbuilder_append_instr(b3, func_id, block_id, instr)
    return (b4, val_id)
.end

pub fn lbuilder_build_ret_void(
    LBuilder b,
    LFuncId func_id,
    LBlockId block_id,
    ast.Span span
) -> LBuilder:
    let pair = LBuilder.fresh_instr(b)
    let b2 = pair.0
    let instr_id = pair.1

    let instr = LInstr(
        id = instr_id,
        kind = LInstrKind::LInstrRet,
        ty = LType.void(),
        result = Option<LValueId>::None(),
        operands = Vec<LOperand>::new(),
        bin_op = Option<LBinOp>::None(),
        cmp_op = Option<LCmpOp>::None(),
        cast_op = Option<LCastOp>::None(),
        phi_incomings = Vec<LPhiIncoming>::new(),
        target_block = Option<LBlockId>::None(),
        else_block = Option<LBlockId>::None(),
        callee = Option<LValueId>::None(),
        call_args = Vec<LOperand>::new(),
        span = span
    )

    let b3 = lbuilder_append_instr(b2, func_id, block_id, instr)
    return b3
.end

# ----------------------------------------------------------------------------
# Vérification minimale (stubs structurés)
# ----------------------------------------------------------------------------

pub struct LVerifyError:
    let message: String
    let span: ast.Span
.end

pub struct LVerifyResult:
    let ok: Bool
    let errors: Vec<LVerifyError>
.end

pub fn lir_verify_module(LModule module) -> LVerifyResult:
    # TODO : vérifier cohérence blocs/instr/valeurs/types.
    let errors = Vec<LVerifyError>::new()
    let res = LVerifyResult(
        ok = true,
        errors = errors
    )
    return res
.end

# ----------------------------------------------------------------------------
# Notes :
#   - Ce IR est volontairement générique et ne dépend que de ast.Span pour
#     la localisation, ce qui facilite les diagnostics.
#   - Le builder LBuilder fournit un chemin simple pour produire du LIR,
#     mais d’autres modules peuvent manipuler directement LModule/LFunction.
#   - Les passes d’optimisation et les backends peuvent s’appuyer sur
#     LInstrKind / LBinOp / LCmpOp / LCastOp / LOperand / LBlock / LFunction.
# ----------------------------------------------------------------------------
