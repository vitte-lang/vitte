mod cli.args.args

type ArgValue
  s: str
.end

type Flag
  long: str
  short: str
  help: str
  takes_value: bool
.end

type ArgParser
  flags: [Flag]
  positionals: [str]
  values: [str]   # raw argv values (post-parse)
.end

fn parser_new() -> ArgParser
  let p: ArgParser
  set p.flags = []
  set p.positionals = []
  set p.values = []
  ret p
.end

fn parser_flag(p: &mut ArgParser, long: str, short: str, takes_value: bool, help: str) -> void
  let f: Flag
  set f.long = long
  set f.short = short
  set f.takes_value = takes_value
  set f.help = help
  do p.flags.push(f)
.end

fn parse(p: &mut ArgParser, argv: [str]) -> bool
  # minimal parser: flags --x / -x ; positionals collected
  let i: i64 = 0
  loop
    if i >= argv.len
      ret true
    .end
    let a: str = argv[i]
    if a.len >= 2 && a[0] == '-' && a[1] == '-'
      # --long or --long=value
      do p.values.push(a)
    elif a.len >= 2 && a[0] == '-'
      do p.values.push(a)
    else
      do p.positionals.push(a)
    .end
    set i = i + 1
  .end
.end
