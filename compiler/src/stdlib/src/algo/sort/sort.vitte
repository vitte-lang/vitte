mod algo.sort.sort

fn insertion_sort(xs: &mut [i64]) -> void
  let i: i64 = 1
  loop
    if i >= xs.len
      ret
    .end
    let key: i64 = xs[i]
    let j: i64 = i - 1
    loop
      if j < 0
        break
      .end
      if xs[j] <= key
        break
      .end
      set xs[j+1] = xs[j]
      set j = j - 1
    .end
    set xs[j+1] = key
    set i = i + 1
  .end
.end

fn quick_sort(xs: &mut [i64]) -> void
  if xs.len <= 1
    ret
  .end
  do quick_sort_range(xs, 0, xs.len)
.end

fn quick_sort_range(xs: &mut [i64], lo: i64, hi: i64) -> void
  if hi - lo <= 1
    ret
  .end
  let p: i64 = partition(xs, lo, hi)
  do quick_sort_range(xs, lo, p)
  do quick_sort_range(xs, p + 1, hi)
.end

fn partition(xs: &mut [i64], lo: i64, hi: i64) -> i64
  let pivot: i64 = xs[hi - 1]
  let i: i64 = lo
  let j: i64 = lo
  loop
    if j >= hi - 1
      break
    .end
    if xs[j] <= pivot
      let tmp: i64 = xs[i]
      set xs[i] = xs[j]
      set xs[j] = tmp
      set i = i + 1
    .end
    set j = j + 1
  .end
  let tmp2: i64 = xs[i]
  set xs[i] = xs[hi - 1]
  set xs[hi - 1] = tmp2
  ret i
.end
