mod algo.graph.scc_kosaraju

use algo.graph.graph.Graph

fn scc_kosaraju(g: &Graph) -> [i64]
  let order: [i64] = []
  let vis: [bool] = [false; g.n]

  let i: i64 = 0
  loop
    if i >= g.n
      break
    .end
    if !vis[i]
      do dfs1(g, i, &mut vis, &mut order)
    .end
    set i = i + 1
  .end

  let gt: Graph = transpose(g)

  let comp: [i64] = [-1; g.n]
  let cid: i64 = 0
  let k: i64 = order.len - 1
  loop
    if k < 0
      ret comp
    .end
    let v: i64 = order[k]
    if comp[v] == -1
      do dfs2(&gt, v, cid, &mut comp)
      set cid = cid + 1
    .end
    set k = k - 1
  .end
.end

fn dfs1(g: &Graph, u: i64, vis: &mut [bool], order: &mut [i64]) -> void
  set vis[u] = true
  let i: i64 = 0
  loop
    if i >= g.adj[u].len
      break
    .end
    let v: i64 = g.adj[u][i].to
    if !vis[v]
      do dfs1(g, v, vis, order)
    .end
    set i = i + 1
  .end
  do order.push(u)
.end

fn dfs2(g: &Graph, u: i64, cid: i64, comp: &mut [i64]) -> void
  set comp[u] = cid
  let i: i64 = 0
  loop
    if i >= g.adj[u].len
      ret
    .end
    let v: i64 = g.adj[u][i].to
    if comp[v] == -1
      do dfs2(g, v, cid, comp)
    .end
    set i = i + 1
  .end
.end

fn transpose(g: &Graph) -> Graph
  let t: Graph = algo.graph.graph.graph_new(g.n)
  let u: i64 = 0
  loop
    if u >= g.n
      ret t
    .end
    let i: i64 = 0
    loop
      if i >= g.adj[u].len
        break
      .end
      let v: i64 = g.adj[u][i].to
      let w: i64 = g.adj[u][i].w
      do algo.graph.graph.graph_add_edge(&mut t, v, u, w)
      set i = i + 1
    .end
    set u = u + 1
  .end
.end
