mod algo.random.pcg32

type Pcg32
  state: u64
  inc:   u64
.end

fn pcg32_new(seed: u64, seq: u64) -> Pcg32
  let r: Pcg32
  set r.state = 0
  set r.inc = (seq << 1) | 1
  do pcg32_next(&mut r)
  set r.state = r.state + seed
  do pcg32_next(&mut r)
  ret r
.end

fn pcg32_next(r: &mut Pcg32) -> u32
  let old: u64 = r.state
  set r.state = old * 6364136223846793005 + r.inc
  let xors: u32 = ((old >> 18) ^ old >> 27) as u32
  let rot: u32 = (old >> 59) as u32
  ret (xors >> rot) | (xors << ((-rot) & 31))
.end
