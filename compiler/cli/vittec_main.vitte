module vitte.compiler.vittec

import vitte.compiler.cli.args as cli_args
import vitte.compiler.frontend.lexer as lex
import vitte.compiler.frontend.parser as parser
import vitte.compiler.frontend.diagnostics as diag
import vitte.compiler.frontend.ast as ast
import vitte.compiler.util.fs as ufs

# ============================================================================
# vittec – Entrée CLI du compilateur Vitte (full Vitte)
#
# Rôle :
#   - Lire les arguments de la ligne de commande,
#   - Construire une configuration compilateur,
#   - Orchestrer le pipeline frontend (lex → parse),
#   - Appeler ensuite la sema/IR/backend (à brancher plus tard),
#   - Gérer les options de debug (dump-tokens, dump-ast).
# ============================================================================

struct CompilerConfig
    input_path: string
    profile: string
    dump_tokens: bool
    dump_ast: bool
.end

fn default_config() -> CompilerConfig:
    let cfg: CompilerConfig =
        CompilerConfig(
            input_path = "",
            profile = "debug",
            dump_tokens = false,
            dump_ast = false,
        )
    .end
    return cfg
.end

fn print_tokens(tokens: lex.Token[]) -> ():
    let mut i: i32 = 0
    let n: i32 = len(tokens)
    say "[vittec] tokens:"
    while i < n:
        let t = tokens[i]
        say "  " t.span.file ":L" t.span.start_line "C" t.span.start_col " " t.kind " " t.lexeme
        i = i + 1
    .end
.end

fn emit_frontend_report(
    cfg: &CompilerConfig,
    tokens: lex.Token[],
    parsed: Option[ast.Module],
    sink: &diag.DiagSink,
) -> ():
    if cfg.dump_tokens:
        print_tokens(tokens)
    .end

    if cfg.dump_ast and parsed.is_some():
        let module = parsed.unwrap()
        ast.ast_print_debug(&module)
    .end

    if not sink.is_empty():
        diag.diag_print_all(&sink)
    .end
.end

fn print_usage(prog: string) -> ():
    say "Usage: " prog " [OPTIONS] <input.vitte>"
    say ""
    say "Options:"
    say "  --profile <name>     Profile de build (debug, release, dev…)."
    say "  --dump-tokens        Affiche les tokens après lexing."
    say "  --dump-ast           Affiche un résumé de l'AST."
    say "  -h, --help           Affiche cette aide."
    ret ()
.end

fn parse_args(args: string[], cfg: &mut CompilerConfig) -> i32:
    let argc: i32 = len(args)
    if argc <= 1:
        print_usage(args[0])
        return 1
    .end

    let mut i: i32 = 1
    while i < argc:
        let arg: string = args[i]

        if arg == "-h" or arg == "--help":
            print_usage(args[0])
            return 1
        .end

        if arg == "--dump-tokens":
            cfg.dump_tokens = true
            i = i + 1
            continue
        .end

        if arg == "--dump-ast":
            cfg.dump_ast = true
            i = i + 1
            continue
        .end

        if arg == "--profile":
            if i + 1 >= argc:
                say "diag:error:cli:missing-profile: expected value after --profile"
                return 1
            .end
            cfg.profile = args[i + 1]
            i = i + 2
            continue
        .end

        # premier argument non option = input_path
        if cfg.input_path == "":
            cfg.input_path = arg
            i = i + 1
            continue
        .end

        # argument inattendu
        say "diag:error:cli:unexpected-arg:" arg
        return 1
    .end

    if cfg.input_path == "":
        say "diag:error:cli:no-input-path"
        print_usage(args[0])
        return 1
    .end

    return 0
.end

fn run_compiler(cfg: &CompilerConfig) -> i32:
    # Vérifier l'existence de l'entrée
    if not ufs.exists(cfg.input_path):
        say "diag:error:file-not-found:" cfg.input_path
        return 1
    .end

    let text: string = ufs.read_to_string(cfg.input_path)

    let mut sink: diag.DiagSink = diag.diag_sink_new()

    # Lexing
    let tokens = lex.lex(text, cfg.input_path, &mut sink)

    let mut parsed_module: Option[ast.Module] = None
    if not diag.diag_has_errors(&sink):
        let module = parser.parse_module(tokens, cfg.input_path, &mut sink)
        parsed_module = Some(module)
    .end

    emit_frontend_report(cfg, tokens, parsed_module, &sink)

    # TODO:
    #   - sema: scope + symbols + types + typecheck
    #   - IR: construction + optimisations
    #   - backend: bytecode / C / binaire
    #   - écriture des artefacts (cfg.profile, etc.)

    if diag.diag_has_errors(&sink):
        return 1
    .end
    return 0
.end

fn main(args: string[]) -> i32:
    let mut cfg: CompilerConfig = default_config()
    let status: i32 = parse_args(args, &mut cfg)
    if status != 0:
        return status
    .end

    return run_compiler(&cfg)
.end
