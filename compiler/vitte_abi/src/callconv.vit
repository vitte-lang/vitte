

# callconv.vit (Vitte) — MAX
#
# ABI calling-convention classification layer.
#
# This module mirrors the *shape* of rustc's ABI lowering layer:
#   - RegKind/Reg (in callconv/reg.vit)
#   - PassMode + ArgAttributes + ArgAbi + FnAbi
#   - A small, target-driven classifier API (generic over HasDataLayout)
#
# Design constraints:
#   - Keep data structures simple and stable.
#   - Avoid deep dependencies (no IR required).
#   - Provide a “good enough” default classifier that can be overridden per arch.
#
# Blocks are terminated with `.end` only.

use crate.Align
use crate.HasDataLayout
use crate.Size
use crate.extern_abi.ExternAbi

use crate.callconv.reg.Reg
use crate.callconv.reg.RegKind

#------------------------------------------------------------------------------
# ArgAttributes
#------------------------------------------------------------------------------

# Lightweight “attributes bag” used during ABI lowering.
# This is intentionally flat (booleans + small enums) to simplify codegen.

enum IntExtension
  None
  Zext
  Sext
.end

type ArgAttributes
  inreg bool
  noalias bool
  nocapture bool
  nonnull bool
  readonly bool
  writeonly bool
  sret bool
  byval bool
  noundef bool
  ext IntExtension
.end

fn ArgAttributes.none() -> ArgAttributes
  ret ArgAttributes(
    inreg: false,
    noalias: false,
    nocapture: false,
    nonnull: false,
    readonly: false,
    writeonly: false,
    sret: false,
    byval: false,
    noundef: false,
    ext: IntExtension::None
  )
.end

fn ArgAttributes.with_sret(self) -> ArgAttributes
  let a = self
  set a.sret = true
  ret a
.end

fn ArgAttributes.with_byval(self) -> ArgAttributes
  let a = self
  set a.byval = true
  ret a
.end

fn ArgAttributes.with_noalias(self) -> ArgAttributes
  let a = self
  set a.noalias = true
  ret a
.end

fn ArgAttributes.with_inreg(self) -> ArgAttributes
  let a = self
  set a.inreg = true
  ret a
.end

fn ArgAttributes.with_zext(self) -> ArgAttributes
  let a = self
  set a.ext = IntExtension::Zext
  ret a
.end

fn ArgAttributes.with_sext(self) -> ArgAttributes
  let a = self
  set a.ext = IntExtension::Sext
  ret a
.end

#------------------------------------------------------------------------------
# PassMode
#------------------------------------------------------------------------------

# How a value is passed/returned at the ABI boundary.
#
# - Ignore: no value (ZST / unused)
# - Direct: passed in a single register
# - Pair: passed in two registers
# - Indirect: passed via memory (pointer)
# - Coerce: coerced into a specific register shape

# Indirect options (common subset of rustc's Indirect).

type IndirectOptions
  align Align
  attrs ArgAttributes
.end

fn IndirectOptions.of(align: Align, attrs: ArgAttributes) -> IndirectOptions
  ret IndirectOptions(align: align, attrs: attrs)
.end

# Coercion target: keep it minimal (one reg, optional second reg).

type CoerceTarget
  a Reg
  b Reg
  has_b bool
.end

fn CoerceTarget.single(a: Reg) -> CoerceTarget
  ret CoerceTarget(a: a, b: a, has_b: false)
.end

fn CoerceTarget.pair(a: Reg, b: Reg) -> CoerceTarget
  ret CoerceTarget(a: a, b: b, has_b: true)
.end

enum PassMode
  Ignore
  Direct(Reg)
  Pair(Reg, Reg)
  Indirect(IndirectOptions)
  Coerce(CoerceTarget)
.end

fn PassMode.is_ignore(self) -> bool
  match self
    Ignore =>
      ret true
    .end
    _ =>
      ret false
    .end
  .end
.end

#------------------------------------------------------------------------------
# ArgAbi
#------------------------------------------------------------------------------

type ArgAbi
  mode PassMode
  attrs ArgAttributes
.end

fn ArgAbi.ignore() -> ArgAbi
  ret ArgAbi(mode: PassMode::Ignore, attrs: ArgAttributes.none())
.end

fn ArgAbi.direct(reg: Reg) -> ArgAbi
  ret ArgAbi(mode: PassMode::Direct(reg), attrs: ArgAttributes.none())
.end

fn ArgAbi.pair(a: Reg, b: Reg) -> ArgAbi
  ret ArgAbi(mode: PassMode::Pair(a, b), attrs: ArgAttributes.none())
.end

fn ArgAbi.indirect(opts: IndirectOptions) -> ArgAbi
  ret ArgAbi(mode: PassMode::Indirect(opts), attrs: opts.attrs)
.end

fn ArgAbi.coerce(ct: CoerceTarget) -> ArgAbi
  ret ArgAbi(mode: PassMode::Coerce(ct), attrs: ArgAttributes.none())
.end

fn ArgAbi.with_attrs(self, attrs: ArgAttributes) -> ArgAbi
  let a = self
  set a.attrs = attrs
  ret a
.end

fn ArgAbi.is_indirect(self) -> bool
  match self.mode
    Indirect(_) =>
      ret true
    .end
    _ =>
      ret false
    .end
  .end
.end

fn ArgAbi.is_direct(self) -> bool
  match self.mode
    Direct(_) =>
      ret true
    .end
    _ =>
      ret false
    .end
  .end
.end

#------------------------------------------------------------------------------
# FnAbi
#------------------------------------------------------------------------------

# FnAbi stores per-argument + return ABI classification.
#
# `args` is an indexable, growable list in Vitte (same shape used by
# ExternAbi::ALL_VARIANTS tests: `.len()` + indexing). If your runtime uses a
# different container, adapt FnAbi construction accordingly.

type FnAbi
  abi ExternAbi
  args [ArgAbi]
  ret ArgAbi
  variadic bool
.end

fn FnAbi.new(abi: ExternAbi) -> FnAbi
  ret FnAbi(abi: abi, args: [], ret: ArgAbi.ignore(), variadic: false)
.end

fn FnAbi.with_variadic(self, v: bool) -> FnAbi
  let f = self
  set f.variadic = v
  ret f
.end

fn FnAbi.push_arg(self, a: ArgAbi) -> FnAbi
  let f = self
  f.args.push(a)
  ret f
.end

fn FnAbi.set_ret(self, r: ArgAbi) -> FnAbi
  let f = self
  set f.ret = r
  ret f
.end

fn FnAbi.arg_count(self) -> u32
  ret self.args.len()
.end

#------------------------------------------------------------------------------
# ABI type abstraction
#------------------------------------------------------------------------------

# We keep the classifier generic over a minimal “ABI type” interface.
# The real compiler can implement this for its layout/type system.

trait AbiType
  fn size(self) -> Size
  fn align<C: HasDataLayout>(self, cx: &C) -> Align
  fn is_scalar_int(self) -> bool
  fn is_scalar_float(self) -> bool
  fn is_vector(self) -> bool
  fn is_aggregate(self) -> bool
.end

#------------------------------------------------------------------------------
# Default classifier
#------------------------------------------------------------------------------

# Default rules (portable baseline):
#   - scalar int: direct integer reg rounded up (1/8/16/32/64/128)
#   - scalar float: direct float reg exact (16/32/64/128)
#   - vector: direct vector reg rounded up (64/128/256/512)
#   - aggregate or big: indirect byval with alignment
#
# Arch-specific rules can wrap/override these.

fn classify_scalar_int<C: HasDataLayout, T: AbiType>(cx: &C, ty: T) -> ArgAbi
  let bits = ty.size().bits()

  # rustc-ish: integer scalars are carried in integer regs.
  let reg = Reg.int_round_up(bits)
  ret ArgAbi.direct(reg)
.end

fn classify_scalar_float<C: HasDataLayout, T: AbiType>(cx: &C, ty: T) -> ArgAbi
  let bits = ty.size().bits()
  let reg = Reg.float_exact(bits)
  ret ArgAbi.direct(reg)
.end

fn classify_vector<C: HasDataLayout, T: AbiType>(cx: &C, ty: T) -> ArgAbi
  let bits = ty.size().bits()
  let reg = Reg.vec_round_up(bits)
  ret ArgAbi.direct(reg)
.end

fn classify_indirect<C: HasDataLayout, T: AbiType>(cx: &C, ty: T, is_ret: bool) -> ArgAbi
  let a = ty.align(cx)
  let attrs = ArgAttributes.none()

  if is_ret
    let attrs2 = attrs.with_sret().with_noalias().with_noundef()
    ret ArgAbi.indirect(IndirectOptions.of(a, attrs2))
  else
    let attrs2 = attrs.with_byval().with_noundef()
    ret ArgAbi.indirect(IndirectOptions.of(a, attrs2))
  .end
.end

fn classify_arg<C: HasDataLayout, T: AbiType>(cx: &C, ty: T, is_ret: bool) -> ArgAbi
  # aggregate => indirect
  if ty.is_aggregate()
    ret classify_indirect(cx, ty, is_ret)
  .end

  if ty.is_scalar_float()
    ret classify_scalar_float(cx, ty)
  .end

  if ty.is_vector()
    ret classify_vector(cx, ty)
  .end

  if ty.is_scalar_int()
    ret classify_scalar_int(cx, ty)
  .end

  # fallback: indirect
  ret classify_indirect(cx, ty, is_ret)
.end

#------------------------------------------------------------------------------
# Fn signature abstraction + classifier entrypoints
#------------------------------------------------------------------------------

trait FnSig
  fn ret_ty(self) -> any
  fn arg_count(self) -> u32
  fn arg_ty(self, i: u32) -> any
  fn is_variadic(self) -> bool
.end

# For the default implementation we need a way to turn `any` into an AbiType.
# The compiler can implement `AbiTyProvider` for its type representation.

trait AbiTyProvider
  fn as_abi_type(self, t: any) -> AbiType
.end

# Classify a full function signature into FnAbi.
fn compute_fn_abi<C: HasDataLayout, S: FnSig, P: AbiTyProvider>(cx: &C, sig: S, provider: P, abi: ExternAbi) -> FnAbi
  let f = FnAbi.new(abi).with_variadic(sig.is_variadic())

  # return
  let rt_any = sig.ret_ty()
  let rt = provider.as_abi_type(rt_any)
  let ret_abi = classify_arg(cx, rt, true)
  let f2 = f.set_ret(ret_abi)

  # args
  let i = 0
  let cur = f2
  loop while i < sig.arg_count()
    let at_any = sig.arg_ty(i)
    let at = provider.as_abi_type(at_any)
    let a_abi = classify_arg(cx, at, false)

    set cur = cur.push_arg(a_abi)
    set i = i + 1
  .end

  ret cur
.end

#------------------------------------------------------------------------------
# Debug helpers
#------------------------------------------------------------------------------

fn passmode_to_string(m: PassMode) -> string
  match m
    Ignore =>
      ret "Ignore"
    .end

    Direct(r) =>
      ret "Direct(" + r.to_string() + ")"
    .end

    Pair(a, b) =>
      ret "Pair(" + a.to_string() + "," + b.to_string() + ")"
    .end

    Indirect(_) =>
      ret "Indirect"
    .end

    Coerce(ct) =>
      if ct.has_b
        ret "Coerce(" + ct.a.to_string() + "," + ct.b.to_string() + ")"
      else
        ret "Coerce(" + ct.a.to_string() + ")"
      .end
    .end
  .end
.end

#------------------------------------------------------------------------------
# Smoke scenarios
#------------------------------------------------------------------------------

scenario callconv_smoke_reg
  # Ensure imported Reg + constructors are reachable.
  let a = Reg.i32()
  let b = Reg.f64()

  if a.to_string() != "i32"
    panic("callconv_smoke_reg: expected i32")
  .end

  if b.to_string() != "f64"
    panic("callconv_smoke_reg: expected f64")
  .end
.end

scenario callconv_smoke_passmode
  let m = PassMode::Direct(Reg.i64())
  let s = passmode_to_string(m)

  if s != "Direct(i64)"
    panic("callconv_smoke_passmode broken: " + s)
  .end
.end
