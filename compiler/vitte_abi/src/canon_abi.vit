

# canon_abi.vit (Vitte) — MAX
#
# Canonical ABI selection + routing.
#
# Goals:
#   - Single stable entrypoint for the compiler to obtain a `FnAbi`.
#   - Centralized target triple parsing + OS/arch/env classification.
#   - Deterministic routing for ExternAbi (Rust/C/System/cdecl/…)
#   - Policy tags that can later be swapped to real per-arch classifiers.
#   - No braces; blocks terminate with `.end`.

use crate.extern_abi.ExternAbi
use crate.callconv
use crate.callconv.FnAbi
use crate.callconv.FnSig
use crate.callconv.AbiTyProvider
use crate.HasDataLayout

#------------------------------------------------------------------------------
# Target triple model
#------------------------------------------------------------------------------

enum Arch
  X86_64
  Aarch64
  Riscv64
  Wasm32
  Wasm64
  Unknown
.end

enum Os
  Linux
  Windows
  Macos
  Wasi
  Unknown
.end

type TargetTriple
  arch Arch
  os Os
  vendor string
  env string
  raw string
.end

fn TargetTriple.unknown() -> TargetTriple
  ret TargetTriple(arch: Arch::Unknown, os: Os::Unknown, vendor: "", env: "", raw: "")
.end

fn Arch.to_string(self) -> string
  if self == Arch::X86_64
    ret "x86_64"
  elif self == Arch::Aarch64
    ret "aarch64"
  elif self == Arch::Riscv64
    ret "riscv64"
  elif self == Arch::Wasm32
    ret "wasm32"
  elif self == Arch::Wasm64
    ret "wasm64"
  else
    ret "unknown"
  .end
.end

fn Os.to_string(self) -> string
  if self == Os::Linux
    ret "linux"
  elif self == Os::Windows
    ret "windows"
  elif self == Os::Macos
    ret "darwin"
  elif self == Os::Wasi
    ret "wasi"
  else
    ret "unknown"
  .end
.end

fn arch_from_str(s: string) -> Arch
  if s == "x86_64"
    ret Arch::X86_64
  elif s == "aarch64"
    ret Arch::Aarch64
  elif s == "riscv64"
    ret Arch::Riscv64
  elif s == "wasm32"
    ret Arch::Wasm32
  elif s == "wasm64"
    ret Arch::Wasm64
  else
    ret Arch::Unknown
  .end
.end

fn os_from_str(s: string) -> Os
  if s == "linux"
    ret Os::Linux
  elif s == "windows"
    ret Os::Windows
  elif s == "darwin" || s == "macos" || s == "ios"
    ret Os::Macos
  elif s == "wasi"
    ret Os::Wasi
  else
    ret Os::Unknown
  .end
.end

fn TargetTriple.is_msvc(self) -> bool
  ret self.os == Os::Windows && self.env == "msvc"
.end

fn TargetTriple.is_gnu_windows(self) -> bool
  ret self.os == Os::Windows && (self.env == "gnu" || self.env == "mingw" || self.env == "gnullvm")
.end

fn TargetTriple.is_unix(self) -> bool
  ret self.os == Os::Linux || self.os == Os::Macos || self.os == Os::Wasi
.end

fn TargetTriple.to_string(self) -> string
  # Deterministic re-serialization (best-effort, not a perfect inverse of raw).
  let s = self.arch.to_string()

  if self.vendor != ""
    set s = s + "-" + self.vendor
  .end

  if self.os != Os::Unknown
    set s = s + "-" + self.os.to_string()
  .end

  if self.env != ""
    set s = s + "-" + self.env
  .end

  ret s
.end

fn TargetTriple.parse(triple: string) -> TargetTriple
  # Typical triples:
  #   arch-vendor-os-env
  #   arch-vendor-os
  #   wasm32-wasi
  # Some triples have more than 4 segments; we fold segments 3.. into env.

  let parts = triple.split("-")
  if parts.len() == 0
    ret TargetTriple.unknown()
  .end

  let arch = arch_from_str(parts[0])

  let vendor = ""
  let os = Os::Unknown
  let env = ""

  if parts.len() >= 2
    set vendor = parts[1]
  .end

  if parts.len() >= 3
    set os = os_from_str(parts[2])
  else
    # special case: wasm32-wasi or similar (2 parts)
    if parts.len() == 2
      set os = os_from_str(parts[1])
      set vendor = ""
    .end
  .end

  if parts.len() >= 4
    # env = join(parts[3..], "-")
    let i = 3
    let e = ""
    loop while i < parts.len()
      if e == ""
        set e = parts[i]
      else
        set e = e + "-" + parts[i]
      .end
      set i = i + 1
    .end
    set env = e
  .end

  ret TargetTriple(arch: arch, os: os, vendor: vendor, env: env, raw: triple)
.end

#------------------------------------------------------------------------------
# Canonical ABI policy
#------------------------------------------------------------------------------

type CanonAbiPolicy
  tag string
.end

fn CanonAbiPolicy.default() -> CanonAbiPolicy
  ret CanonAbiPolicy(tag: "default")
.end

fn CanonAbiPolicy.sysv_x86_64() -> CanonAbiPolicy
  ret CanonAbiPolicy(tag: "x86_64-sysv")
.end

fn CanonAbiPolicy.win64_msvc() -> CanonAbiPolicy
  ret CanonAbiPolicy(tag: "x86_64-win64-msvc")
.end

fn CanonAbiPolicy.aapcs64() -> CanonAbiPolicy
  ret CanonAbiPolicy(tag: "aarch64-aapcs64")
.end

fn CanonAbiPolicy.wasm() -> CanonAbiPolicy
  ret CanonAbiPolicy(tag: "wasm")
.end

fn select_policy(t: TargetTriple) -> CanonAbiPolicy
  if t.arch == Arch::X86_64 && t.is_msvc()
    ret CanonAbiPolicy.win64_msvc()
  .end

  if t.arch == Arch::X86_64
    ret CanonAbiPolicy.sysv_x86_64()
  .end

  if t.arch == Arch::Aarch64
    ret CanonAbiPolicy.aapcs64()
  .end

  if t.arch == Arch::Wasm32 || t.arch == Arch::Wasm64
    ret CanonAbiPolicy.wasm()
  .end

  ret CanonAbiPolicy.default()
.end

#------------------------------------------------------------------------------
# ExternAbi canonicalization
#------------------------------------------------------------------------------

fn abi_str_eq(abi: ExternAbi, s: string) -> bool
  # canonical compare is done on the ABI name string.
  ret abi.as_str() == s
.end

fn canonicalize_extern_abi(abi: ExternAbi, target: TargetTriple) -> ExternAbi
  # Policy:
  #   - Rust stays Rust
  #   - System => platform default C-ABI
  #   - cdecl => kept as-is (even on unix)
  #
  # Note: ExternAbi is an enum; we avoid matching on variants to keep this file
  # stable across future changes and use `as_str()`.

  if abi_str_eq(abi, "System") || abi_str_eq(abi, "system")
    # System follows platform.
    if target.os == Os::Windows
      # On Windows, System matches the platform C ABI.
      # We keep it as "System" to let later layers decide Win64 vs stdcall.
      ret abi
    else
      # On unix-like targets, System is effectively C.
      # If your ExternAbi has distinct C variants ("C"/"cdecl"), prefer "C".
      let r = ExternAbi::from_str("C")
      match r
        Ok(a) =>
          ret a
        .end
        Err(_) =>
          ret abi
        .end
      .end
    .end
  .end

  ret abi
.end

#------------------------------------------------------------------------------
# Policy routing hooks
#------------------------------------------------------------------------------

# NOTE: Today we route to the portable default classifier.
# These wrappers exist so later you can drop in real per-arch classifiers without
# changing call sites.

fn compute_fn_abi_default<C: HasDataLayout, S: FnSig, P: AbiTyProvider>(cx: &C, sig: S, provider: P, abi: ExternAbi) -> FnAbi
  ret callconv::compute_fn_abi(cx, sig, provider, abi)
.end

fn compute_fn_abi_sysv_x86_64<C: HasDataLayout, S: FnSig, P: AbiTyProvider>(cx: &C, sig: S, provider: P, abi: ExternAbi) -> FnAbi
  # TODO: SysV classifier (SSE classes, aggregates, etc.)
  ret callconv::compute_fn_abi(cx, sig, provider, abi)
.end

fn compute_fn_abi_win64_msvc<C: HasDataLayout, S: FnSig, P: AbiTyProvider>(cx: &C, sig: S, provider: P, abi: ExternAbi) -> FnAbi
  # TODO: Win64 MSVC classifier (shadow space, sret placement rules, etc.)
  ret callconv::compute_fn_abi(cx, sig, provider, abi)
.end

fn compute_fn_abi_aapcs64<C: HasDataLayout, S: FnSig, P: AbiTyProvider>(cx: &C, sig: S, provider: P, abi: ExternAbi) -> FnAbi
  # TODO: AAPCS64 classifier (HFA/HVA rules)
  ret callconv::compute_fn_abi(cx, sig, provider, abi)
.end

fn compute_fn_abi_wasm<C: HasDataLayout, S: FnSig, P: AbiTyProvider>(cx: &C, sig: S, provider: P, abi: ExternAbi) -> FnAbi
  # WASM ABI is close to the portable default for now.
  ret callconv::compute_fn_abi(cx, sig, provider, abi)
.end

# Canonical post-pass (stable hooks).
fn postpass_fnabi(f: FnAbi, sig: FnSig) -> FnAbi
  # Ensure `variadic` bit is deterministic.
  if sig.is_variadic() && !f.variadic
    ret f.with_variadic(true)
  .end

  ret f
.end

#------------------------------------------------------------------------------
# Canonical compute entrypoint
#------------------------------------------------------------------------------

fn compute_canon_fn_abi<C: HasDataLayout, S: FnSig, P: AbiTyProvider>(cx: &C, sig: S, provider: P, abi: ExternAbi, target: TargetTriple) -> FnAbi
  let pol = select_policy(target)
  let abi2 = canonicalize_extern_abi(abi, target)

  let f = FnAbi.new(abi2)
  # above line ensures FnAbi type is referenced; actual compute below.

  # Route based on policy tag.
  if pol.tag == "x86_64-sysv"
    let r = compute_fn_abi_sysv_x86_64(cx, sig, provider, abi2)
    ret postpass_fnabi(r, sig)
  .end

  if pol.tag == "x86_64-win64-msvc"
    let r = compute_fn_abi_win64_msvc(cx, sig, provider, abi2)
    ret postpass_fnabi(r, sig)
  .end

  if pol.tag == "aarch64-aapcs64"
    let r = compute_fn_abi_aapcs64(cx, sig, provider, abi2)
    ret postpass_fnabi(r, sig)
  .end

  if pol.tag == "wasm"
    let r = compute_fn_abi_wasm(cx, sig, provider, abi2)
    ret postpass_fnabi(r, sig)
  .end

  let r = compute_fn_abi_default(cx, sig, provider, abi2)
  ret postpass_fnabi(r, sig)
.end

#------------------------------------------------------------------------------
# Fingerprint (stable debug string)
#------------------------------------------------------------------------------

fn bool01(v: bool) -> string
  if v
    ret "1"
  else
    ret "0"
  .end
.end

fn fnabi_fingerprint(f: FnAbi, target: TargetTriple) -> string
  # Format:
  #   target=<triple> abi=<ExternAbi> var=<0/1> ret=<PassMode> args=[<PassMode>,...]

  let s = "target=" + target.raw
  let s2 = s + " abi=" + f.abi.as_str()
  let s3 = s2 + " var=" + bool01(f.variadic)

  let ret_pm = callconv::passmode_to_string(f.ret.mode)
  let s4 = s3 + " ret=" + ret_pm

  let cur = s4 + " args=["

  let i = 0
  loop while i < f.args.len()
    let pm = callconv::passmode_to_string(f.args[i].mode)

    if i == 0
      set cur = cur + pm
    else
      set cur = cur + "," + pm
    .end

    set i = i + 1
  .end

  ret cur + "]"
.end

#------------------------------------------------------------------------------
# Smoke scenarios
#------------------------------------------------------------------------------

scenario canon_abi_triple_parse_smoke
  let t1 = TargetTriple.parse("x86_64-unknown-linux-gnu")
  if t1.arch != Arch::X86_64 || t1.os != Os::Linux || t1.env != "gnu"
    panic("triple parse failed for linux")
  .end

  let t2 = TargetTriple.parse("x86_64-pc-windows-msvc")
  if t2.arch != Arch::X86_64 || t2.os != Os::Windows || !t2.is_msvc()
    panic("triple parse failed for msvc")
  .end

  let t3 = TargetTriple.parse("wasm32-wasi")
  if t3.arch != Arch::Wasm32 || t3.os != Os::Wasi
    panic("triple parse failed for wasi")
  .end

  let t4 = TargetTriple.parse("x86_64-unknown-linux-gnu.2.40")
  # env folding should still keep something non-empty.
  if t4.arch != Arch::X86_64
    panic("triple parse failed for folded env")
  .end
.end

scenario canon_abi_policy_smoke
  let a = select_policy(TargetTriple.parse("x86_64-unknown-linux-gnu"))
  if a.tag != "x86_64-sysv"
    panic("policy linux expected sysv")
  .end

  let b = select_policy(TargetTriple.parse("x86_64-pc-windows-msvc"))
  if b.tag != "x86_64-win64-msvc"
    panic("policy msvc expected win64")
  .end

  let c = select_policy(TargetTriple.parse("aarch64-apple-darwin"))
  if c.tag != "aarch64-aapcs64"
    panic("policy aarch64 expected aapcs64")
  .end

  let d = select_policy(TargetTriple.parse("wasm32-wasi"))
  if d.tag != "wasm"
    panic("policy wasm expected wasm")
  .end
.end

scenario canon_abi_system_to_c_smoke
  let t = TargetTriple.parse("x86_64-unknown-linux-gnu")
  let r = ExternAbi::from_str("System")
  match r
    Ok(sys) =>
      let c = canonicalize_extern_abi(sys, t)
      # Should become C if available.
      if c.as_str() == "System" || c.as_str() == "system"
        panic("System did not canonicalize on unix")
      .end
    .end
    Err(_) =>
      # If ABI parsing isn't available yet, skip.
      ret
    .end
  .end
.end