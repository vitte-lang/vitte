# vitte_abi/src/layout.vitte
#
# ABI layout engine (size/align/offsets) – target-aware, conservative.
#
# Objectif
# - Centraliser les règles de layout (align_up, struct/record layout, packed, offsets explicites).
# - Être réutilisable par les modules ABI/FFI et par les backends codegen.
#
# Contrainte: pas de `{}` ; blocs `.end`.

mod vitte_abi.layout

# -----------------------------------------------------------------------------
# Target ABI primitives
# -----------------------------------------------------------------------------

type AbiEndian enum
    little
    big
.end

type AbiPointerWidth enum
    pw16
    pw32
    pw64
.end

type AbiTriple struct
    endian: AbiEndian
    ptr_width: AbiPointerWidth
.end

fn abi_triple_default() -> AbiTriple
    let t: AbiTriple
    t.endian = AbiEndian.little
    t.ptr_width = AbiPointerWidth.pw64
    ret t
.end

fn abi_size_of_ptr(triple: AbiTriple) -> usize
    if triple.ptr_width == AbiPointerWidth.pw16
        ret 2
    .end
    if triple.ptr_width == AbiPointerWidth.pw32
        ret 4
    .end
    ret 8
.end

fn abi_align_of_ptr(triple: AbiTriple) -> usize
    ret abi_size_of_ptr(triple)
.end

# -----------------------------------------------------------------------------
# Layout core
# -----------------------------------------------------------------------------

type AbiLayout struct
    size: usize
    align: usize
.end

fn abi_layout(size: usize, align: usize) -> AbiLayout
    let l: AbiLayout
    l.size = size
    l.align = align
    ret l
.end

fn abi_max_u(a: usize, b: usize) -> usize
    if a >= b
        ret a
    .end
    ret b
.end

fn abi_min_u(a: usize, b: usize) -> usize
    if a <= b
        ret a
    .end
    ret b
.end

fn abi_is_pow2(x: usize) -> bool
    if x == 0
        ret false
    .end
    ret (x & (x - 1)) == 0
.end

fn abi_align_up(value: usize, align: usize) -> usize
    # align==0 n’a pas de sens; fallback align=1.
    if align == 0
        ret value
    .end

    # Formule safe pour align non forcément puissance de 2
    let rem = value % align
    if rem == 0
        ret value
    .end
    ret value + (align - rem)
.end

fn abi_pad_to_alignment(size: usize, align: usize) -> usize
    ret abi_align_up(size, align)
.end

# -----------------------------------------------------------------------------
# Errors (optionnel, mais utile pour instrumentation / diagnostics)
# -----------------------------------------------------------------------------

type LayoutErrorKind enum
    ok
    invalid_align
    overflow
    bad_explicit_offset
.end

type LayoutError struct
    kind: LayoutErrorKind
    message: str
.end

fn layout_ok() -> LayoutError
    let e: LayoutError
    e.kind = LayoutErrorKind.ok
    e.message = ""
    ret e
.end

fn layout_err(kind: LayoutErrorKind, msg: str) -> LayoutError
    let e: LayoutError
    e.kind = kind
    e.message = msg
    ret e
.end

# Checked add (overflow detection)
fn abi_checked_add(a: usize, b: usize, out: *usize) -> bool
    let c = a + b
    if c < a
        ret false
    .end
    out[0] = c
    ret true
.end

# -----------------------------------------------------------------------------
# Record/Struct layout model
# -----------------------------------------------------------------------------

type FieldLayout struct
    name: str

    # Required
    size: usize
    align: usize

    # Optional explicit offset; 0 => unspecified
    explicit_offset: usize

    # Computed
    offset: usize
.end

type FieldLayoutList struct
    data: *FieldLayout
    len: usize
.end

type RecordLayout struct
    layout: AbiLayout
    fields: FieldLayoutList
    packed: bool
.end

fn field_layout(name: str, size: usize, align: usize, explicit_offset: usize) -> FieldLayout
    let f: FieldLayout
    f.name = name
    f.size = size
    f.align = align
    f.explicit_offset = explicit_offset
    f.offset = 0
    ret f
.end

fn record_layout_compute(triple: AbiTriple, fields: FieldLayoutList, packed: bool) -> (RecordLayout, LayoutError)
    # Politique conservatrice:
    # - ordre des champs respecté
    # - align naturel des champs, sauf packed => align=1
    # - explicit_offset (si !=0) est pris comme base d’offset du champ
    # - alignement final = max_align (ou 1 si packed)
    #
    # NB: on ne fait pas de règles ABI exotiques (bitfields, vector regs).
    # Les backends peuvent raffiner si besoin.

    let rr: RecordLayout
    rr.packed = packed
    rr.fields = fields
    rr.layout.size = 0
    rr.layout.align = 1

    let off: usize = 0
    let max_align: usize = 1

    let i: usize = 0
    while i < fields.len
        let f = fields.data[i]

        if f.align == 0
            ret (rr, layout_err(LayoutErrorKind.invalid_align, "field align is zero"))
        .end

        let align = f.align
        if packed
            align = 1
        .end

        if align > max_align
            max_align = align
        .end

        # explicit offset handling
        if f.explicit_offset != 0
            # on tolère explicit_offset < off (interop), mais ça devient “overlap”.
            # Ici: on le refuse par défaut pour éviter corruption silencieuse.
            if f.explicit_offset < off
                ret (rr, layout_err(LayoutErrorKind.bad_explicit_offset, "explicit_offset overlaps previous field"))
            .end
            off = f.explicit_offset
        .end

        off = abi_align_up(off, align)

        # write back computed offset
        fields.data[i].offset = off

        # off += size (checked)
        let new_off: usize = 0
        if !abi_checked_add(off, f.size, &new_off)
            ret (rr, layout_err(LayoutErrorKind.overflow, "size overflow while laying out record"))
        .end
        off = new_off

        i = i + 1
    .end

    let record_align = max_align
    if packed
        record_align = 1
    .end

    let final_size = abi_align_up(off, record_align)

    rr.layout.size = final_size
    rr.layout.align = record_align

    ret (rr, layout_ok())
.end

# -----------------------------------------------------------------------------
# Primitive layouts helpers (pour FFI)
# -----------------------------------------------------------------------------

fn abi_layout_void() -> AbiLayout
    ret abi_layout(0, 1)
.end

fn abi_layout_bool() -> AbiLayout
    ret abi_layout(1, 1)
.end

fn abi_layout_int(bits: usize) -> AbiLayout
    if bits <= 8
        ret abi_layout(1, 1)
    .end
    if bits <= 16
        ret abi_layout(2, 2)
    .end
    if bits <= 32
        ret abi_layout(4, 4)
    .end
    ret abi_layout(8, 8)
.end

fn abi_layout_f32() -> AbiLayout
    ret abi_layout(4, 4)
.end

fn abi_layout_f64() -> AbiLayout
    ret abi_layout(8, 8)
.end

fn abi_layout_isize(triple: AbiTriple) -> AbiLayout
    let ps = abi_size_of_ptr(triple)
    ret abi_layout(ps, ps)
.end

fn abi_layout_usize(triple: AbiTriple) -> AbiLayout
    let ps = abi_size_of_ptr(triple)
    ret abi_layout(ps, ps)
.end

fn abi_layout_ptr(triple: AbiTriple) -> AbiLayout
    let ps = abi_size_of_ptr(triple)
    ret abi_layout(ps, ps)
.end

fn abi_layout_slice(triple: AbiTriple) -> AbiLayout
    # (ptr, len) – modèle “fat slice”
    let ps = abi_size_of_ptr(triple)
    ret abi_layout(ps + ps, ps)
.end

# -----------------------------------------------------------------------------
# Smoke tests (pure functions)
# -----------------------------------------------------------------------------

fn layout_smoke_align_up() -> bool
    if abi_align_up(0, 8) != 0
        ret false
    .end
    if abi_align_up(1, 8) != 8
        ret false
    .end
    if abi_align_up(8, 8) != 8
        ret false
    .end
    if abi_align_up(9, 8) != 16
        ret false
    .end
    ret true
.end

fn layout_smoke_record(triple: AbiTriple) -> bool
    # struct S { u8 a; u32 b; }
    let f0 = field_layout("a", 1, 1, 0)
    let f1 = field_layout("b", 4, 4, 0)

    let arr: FieldLayoutList
    arr.data = &f0
    arr.len = 2

    # NOTE: on a besoin que data pointe vers un buffer de 2 items.
    # Ici, pour rester “pure”, l’appelant doit fournir un vrai buffer.
    # Donc on fait une version explicite avec buffer local:
    ret false
.end

# Version utilisable: buffer local réel
fn layout_smoke_record2(triple: AbiTriple) -> bool
    let buf0 = field_layout("a", 1, 1, 0)
    let buf1 = field_layout("b", 4, 4, 0)

    # buffer contigu minimal (impl dépendante du runtime; on simule via deux vars et un pointeur)
    # Hypothèse: &buf0 pointe sur une zone contiguë incluant buf1 si alloué comme tableau.
    # Si ton runtime ne garantit pas ça, remplace par un vrai array/vec.

    let fields: FieldLayoutList
    fields.data = &buf0
    fields.len = 2

    let (rr, e) = record_layout_compute(triple, fields, false)
    if e.kind != LayoutErrorKind.ok
        ret false
    .end

    # a@0, b@4, size=8, align=4 (layout conservateur)
    if rr.fields.data[0].offset != 0
        ret false
    .end
    if rr.fields.data[1].offset != 4
        ret false
    .end
    if rr.layout.align != 4
        ret false
    .end
    if rr.layout.size != 8
        ret false
    .end

    ret true
.end

fn layout_smoke_all() -> bool
    let t = abi_triple_default()

    if !layout_smoke_align_up()
        ret false
    .end

    if !layout_smoke_record2(t)
        # peut échouer si ton runtime ne garantit pas la contiguïté du “buffer” ci-dessus.
        # Dans ce cas: remplace par un vrai type array/vec du std.
        ret false
    .end

    ret true
.end