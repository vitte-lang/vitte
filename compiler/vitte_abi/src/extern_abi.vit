

# vitte_abi/src/extern_abi.vit
#
# Extern ABI model & helpers.
#
# Goals
# - Provide a stable representation for “extern” imports/exports used by the compiler toolchain.
# - Keep the model language-agnostic: it describes symbols, signatures, and platform ABI info.
# - Enable frontends/desugarers to lower user-facing `extern` syntax into a normalized form.
# - Enable codegen backends to query calling convention, layout, and symbol linkage metadata.
#
# Notes
# - This module intentionally does not perform dynamic linking (dlopen/GetProcAddress).
#   It only models the ABI and linkage surface.
# - No `{}` blocks: blocks are delimited by `.end`.

mod vitte_abi.extern_abi

# -----------------------------------------------------------------------------
# Primitive “string” helpers (minimal, side-effect free)
# -----------------------------------------------------------------------------

# The core libraries are expected to provide `str` and basic ops.
# Where a host implementation differs, the glue layer can adapt.

type StrView struct
    ptr: *u8
    len: usize
.end

fn strview_from_str(s: str) -> StrView
    # Convention: the runtime can expose a stable UTF-8 view.
    # If your runtime does not, replace this function in a platform layer.
    let v: StrView
    v.ptr = s.as_ptr_u8()
    v.len = s.len_bytes()
    ret v
.end

fn ascii_is_alpha(c: u8) -> bool
    ret (c >= 65 && c <= 90) || (c >= 97 && c <= 122)
.end

fn ascii_is_digit(c: u8) -> bool
    ret (c >= 48 && c <= 57)
.end

fn ascii_is_alnum(c: u8) -> bool
    ret ascii_is_alpha(c) || ascii_is_digit(c)
.end

fn ascii_is_ident_start(c: u8) -> bool
    ret ascii_is_alpha(c) || (c == 95)
.end

fn ascii_is_ident_continue(c: u8) -> bool
    ret ascii_is_alnum(c) || (c == 95)
.end

fn c_ident_is_valid(name: str) -> bool
    # Conservative check: ASCII identifier, non-empty.
    let v = strview_from_str(name)
    if v.len == 0
        ret false
    .end

    let b0 = v.ptr[0]
    if !ascii_is_ident_start(b0)
        ret false
    .end

    let i: usize = 1
    while i < v.len
        let b = v.ptr[i]
        if !ascii_is_ident_continue(b)
            ret false
        .end
        i = i + 1
    .end

    ret true
.end

fn symbol_name_is_valid(name: str) -> bool
    # Accept a subset that is safe for most toolchains:
    # - C identifier
    # - plus optional single leading underscore(s)
    # - reject empty and reject whitespace/control bytes
    let v = strview_from_str(name)
    if v.len == 0
        ret false
    .end

    let i: usize = 0
    while i < v.len
        let b = v.ptr[i]
        if b <= 32
            ret false
        .end
        i = i + 1
    .end

    # If it is a valid C identifier, accept.
    if c_ident_is_valid(name)
        ret true
    .end

    # Otherwise accept a run of '_' followed by a valid identifier.
    let j: usize = 0
    while j < v.len && v.ptr[j] == 95
        j = j + 1
    .end

    if j == 0
        ret false
    .end

    if j >= v.len
        ret false
    .end

    # Create a view onto the remainder.
    # (Runtime helper expected: slice_str(name, start, len))
    let rest = name.slice_bytes(j, v.len - j)
    ret c_ident_is_valid(rest)
.end

# -----------------------------------------------------------------------------
# Target/Platform ABI metadata
# -----------------------------------------------------------------------------

type AbiArch enum
    unknown
    x86
    x86_64
    arm
    aarch64
    riscv32
    riscv64
    wasm32
    wasm64
.end

type AbiOs enum
    unknown
    windows
    linux
    macos
    freebsd
    android
    ios
    wasi
.end

type AbiEnv enum
    unknown
    gnu
    musl
    msvc
    android
.end

type AbiEndian enum
    little
    big
.end

type AbiPointerWidth enum
    pw16
    pw32
    pw64
.end

type AbiTriple struct
    arch: AbiArch
    os: AbiOs
    env: AbiEnv
    endian: AbiEndian
    ptr_width: AbiPointerWidth
.end

fn abi_triple_default() -> AbiTriple
    # “Safe” default: 64-bit little-endian SysV-like.
    let t: AbiTriple
    t.arch = AbiArch.x86_64
    t.os = AbiOs.linux
    t.env = AbiEnv.gnu
    t.endian = AbiEndian.little
    t.ptr_width = AbiPointerWidth.pw64
    ret t
.end

# -----------------------------------------------------------------------------
# Calling convention model
# -----------------------------------------------------------------------------

type AbiCallConv enum
    # C ABI for the target
    c

    # Target default “system” ABI (often same as c, but not always)
    system

    # Windows x86 ABIs
    stdcall
    fastcall
    thiscall

    # 64-bit ABIs
    win64
    sysv64

    # WebAssembly
    wasm

    # Vitte internal (useful for runtime-to-runtime calls, not FFI)
    vitte
.end

fn callconv_is_ffi_safe(cc: AbiCallConv) -> bool
    if cc == AbiCallConv.vitte
        ret false
    .end
    ret true
.end

fn callconv_default_for(triple: AbiTriple) -> AbiCallConv
    if triple.os == AbiOs.windows
        if triple.ptr_width == AbiPointerWidth.pw64
            ret AbiCallConv.win64
        .end
        ret AbiCallConv.c
    .end

    if triple.os == AbiOs.wasi
        ret AbiCallConv.wasm
    .end

    if triple.arch == AbiArch.wasm32 || triple.arch == AbiArch.wasm64
        ret AbiCallConv.wasm
    .end

    # SysV-style is the common default on Unix 64-bit.
    if triple.ptr_width == AbiPointerWidth.pw64
        ret AbiCallConv.sysv64
    .end

    ret AbiCallConv.c
.end

# -----------------------------------------------------------------------------
# Extern types
# -----------------------------------------------------------------------------

type ExternTypeKind enum
    void
    bool
    i8
    u8
    i16
    u16
    i32
    u32
    i64
    u64
    isize
    usize
    f32
    f64
    # raw pointer (no ownership semantics)
    ptr
    # C string pointer (`const char*` semantics)
    cstr
    # fat slice: (ptr,len) for C-style APIs (helper, not a native C type)
    slice
    # opaque handle (treated as pointer-sized)
    opaque
    # aggregate
    record
.end

type ExternMut enum
    const
    mut
.end

type ExternPtr struct
    mutability: ExternMut
    elem: *ExternType
.end

type ExternSlice struct
    mutability: ExternMut
    elem: *ExternType
.end

type ExternField struct
    name: str
    ty: ExternType
    # Optional ABI hint: explicit offset in bytes (0 => unspecified)
    offset: usize
.end

type ExternRecord struct
    name: str
    fields: ExternFieldList
    # Packed: true forces align=1 in layout queries.
    packed: bool
.end

type ExternType struct
    kind: ExternTypeKind
    # For ptr/cstr/slice/opaque/record
    ptr: ExternPtr
    slice: ExternSlice
    rec: ExternRecord
.end

# Tiny list type to avoid depending on a particular std collection name.
# Backends can map it to their vector/array type.

type ExternFieldList struct
    data: *ExternField
    len: usize
.end

type ExternParam struct
    name: str
    ty: ExternType
.end

type ExternParamList struct
    data: *ExternParam
    len: usize
.end

fn extern_type_void() -> ExternType
    let t: ExternType
    t.kind = ExternTypeKind.void
    ret t
.end

fn extern_type_bool() -> ExternType
    let t: ExternType
    t.kind = ExternTypeKind.bool
    ret t
.end

fn extern_type_i32() -> ExternType
    let t: ExternType
    t.kind = ExternTypeKind.i32
    ret t
.end

fn extern_type_u32() -> ExternType
    let t: ExternType
    t.kind = ExternTypeKind.u32
    ret t
.end

fn extern_type_i64() -> ExternType
    let t: ExternType
    t.kind = ExternTypeKind.i64
    ret t
.end

fn extern_type_u64() -> ExternType
    let t: ExternType
    t.kind = ExternTypeKind.u64
    ret t
.end

fn extern_type_f32() -> ExternType
    let t: ExternType
    t.kind = ExternTypeKind.f32
    ret t
.end

fn extern_type_f64() -> ExternType
    let t: ExternType
    t.kind = ExternTypeKind.f64
    ret t
.end

fn extern_type_usize() -> ExternType
    let t: ExternType
    t.kind = ExternTypeKind.usize
    ret t
.end

fn extern_type_isize() -> ExternType
    let t: ExternType
    t.kind = ExternTypeKind.isize
    ret t
.end

fn extern_type_ptr(elem: *ExternType, mutability: ExternMut) -> ExternType
    let t: ExternType
    t.kind = ExternTypeKind.ptr
    t.ptr.mutability = mutability
    t.ptr.elem = elem
    ret t
.end

fn extern_type_cstr() -> ExternType
    let t: ExternType
    t.kind = ExternTypeKind.cstr
    ret t
.end

fn extern_type_slice(elem: *ExternType, mutability: ExternMut) -> ExternType
    let t: ExternType
    t.kind = ExternTypeKind.slice
    t.slice.mutability = mutability
    t.slice.elem = elem
    ret t
.end

fn extern_type_opaque(name: str) -> ExternType
    let t: ExternType
    t.kind = ExternTypeKind.opaque
    # Store the symbolic name in `rec.name` to avoid adding yet another payload.
    t.rec.name = name
    ret t
.end

fn extern_type_record(name: str, fields: ExternFieldList, packed: bool) -> ExternType
    let t: ExternType
    t.kind = ExternTypeKind.record
    t.rec.name = name
    t.rec.fields = fields
    t.rec.packed = packed
    ret t
.end

# -----------------------------------------------------------------------------
# Layout queries (size/align) – conservative and target-aware
# -----------------------------------------------------------------------------

type AbiLayout struct
    size: usize
    align: usize
.end

fn abi_align_of_int(bits: usize) -> usize
    if bits <= 8
        ret 1
    .end
    if bits <= 16
        ret 2
    .end
    if bits <= 32
        ret 4
    .end
    ret 8
.end

fn abi_size_of_ptr(triple: AbiTriple) -> usize
    if triple.ptr_width == AbiPointerWidth.pw16
        ret 2
    .end
    if triple.ptr_width == AbiPointerWidth.pw32
        ret 4
    .end
    ret 8
.end

fn abi_align_of_ptr(triple: AbiTriple) -> usize
    ret abi_size_of_ptr(triple)
.end

fn extern_type_layout(triple: AbiTriple, ty: ExternType) -> AbiLayout
    let out: AbiLayout

    if ty.kind == ExternTypeKind.void
        out.size = 0
        out.align = 1
        ret out
    .end

    if ty.kind == ExternTypeKind.bool
        out.size = 1
        out.align = 1
        ret out
    .end

    if ty.kind == ExternTypeKind.i8 || ty.kind == ExternTypeKind.u8
        out.size = 1
        out.align = 1
        ret out
    .end

    if ty.kind == ExternTypeKind.i16 || ty.kind == ExternTypeKind.u16
        out.size = 2
        out.align = 2
        ret out
    .end

    if ty.kind == ExternTypeKind.i32 || ty.kind == ExternTypeKind.u32
        out.size = 4
        out.align = 4
        ret out
    .end

    if ty.kind == ExternTypeKind.i64 || ty.kind == ExternTypeKind.u64
        out.size = 8
        out.align = 8
        ret out
    .end

    if ty.kind == ExternTypeKind.f32
        out.size = 4
        out.align = 4
        ret out
    .end

    if ty.kind == ExternTypeKind.f64
        out.size = 8
        out.align = 8
        ret out
    .end

    if ty.kind == ExternTypeKind.isize || ty.kind == ExternTypeKind.usize
        let ps = abi_size_of_ptr(triple)
        out.size = ps
        out.align = ps
        ret out
    .end

    if ty.kind == ExternTypeKind.ptr || ty.kind == ExternTypeKind.cstr || ty.kind == ExternTypeKind.opaque
        let ps = abi_size_of_ptr(triple)
        out.size = ps
        out.align = ps
        ret out
    .end

    if ty.kind == ExternTypeKind.slice
        # Modeled as (ptr,len)
        let ps = abi_size_of_ptr(triple)
        out.size = ps + ps
        out.align = ps
        ret out
    .end

    if ty.kind == ExternTypeKind.record
        # Conservative record layout:
        # - sequential fields
        # - natural alignment unless packed
        # - explicit offsets are honored if provided (useful for interop)
        let packed = ty.rec.packed
        let fields = ty.rec.fields

        let off: usize = 0
        let max_align: usize = 1

        let i: usize = 0
        while i < fields.len
            let f = fields.data[i]
            let fl = extern_type_layout(triple, f.ty)

            let align = fl.align
            if packed
                align = 1
            .end

            if align > max_align
                max_align = align
            .end

            if f.offset != 0
                off = f.offset
            .end

            # align up
            let rem = off % align
            if rem != 0
                off = off + (align - rem)
            .end

            off = off + fl.size
            i = i + 1
        .end

        # final struct align
        let align = max_align
        if packed
            align = 1
        .end

        # size align up
        let rem2 = off % align
        if rem2 != 0
            off = off + (align - rem2)
        .end

        out.size = off
        out.align = align
        ret out
    .end

    # Fallback (should not happen)
    out.size = 0
    out.align = 1
    ret out
.end

# -----------------------------------------------------------------------------
# Symbol model
# -----------------------------------------------------------------------------

type Linkage enum
    # Default: platform toolchain decides (typically external strong symbol)
    default

    # Strong external symbol
    external

    # Weak reference/definition (if supported)
    weak

    # Internal/private
    internal
.end

type ExternSymbolKind enum
    fn_sym
    data_sym
.end

type ExternFnSig struct
    cc: AbiCallConv
    params: ExternParamList
    ret: ExternType
    variadic: bool
.end

type ExternDataSig struct
    ty: ExternType
    readonly: bool
.end

type ExternSymbol struct
    kind: ExternSymbolKind

    # User-facing name (as written in source) and link name (what the linker sees).
    name: str
    link_name: str

    # Optional library hint (e.g., "c", "m", "kernel32", "System")
    library: str

    linkage: Linkage

    # Payloads
    fn_sig: ExternFnSig
    data_sig: ExternDataSig
.end

fn extern_symbol_init_fn(name: str, link_name: str, library: str, sig: ExternFnSig) -> ExternSymbol
    let s: ExternSymbol
    s.kind = ExternSymbolKind.fn_sym
    s.name = name
    s.link_name = link_name
    s.library = library
    s.linkage = Linkage.default
    s.fn_sig = sig
    ret s
.end

fn extern_symbol_init_data(name: str, link_name: str, library: str, sig: ExternDataSig) -> ExternSymbol
    let s: ExternSymbol
    s.kind = ExternSymbolKind.data_sym
    s.name = name
    s.link_name = link_name
    s.library = library
    s.linkage = Linkage.default
    s.data_sig = sig
    ret s
.end

# -----------------------------------------------------------------------------
# Validation & normalization
# -----------------------------------------------------------------------------

type AbiErrorKind enum
    ok
    invalid_symbol
    invalid_link_name
    invalid_callconv
    invalid_param
    invalid_record
.end

type AbiError struct
    kind: AbiErrorKind
    message: str
.end

fn abi_ok() -> AbiError
    let e: AbiError
    e.kind = AbiErrorKind.ok
    e.message = ""
    ret e
.end

fn abi_err(kind: AbiErrorKind, msg: str) -> AbiError
    let e: AbiError
    e.kind = kind
    e.message = msg
    ret e
.end

fn extern_fn_sig_validate(triple: AbiTriple, sig: ExternFnSig) -> AbiError
    if !callconv_is_ffi_safe(sig.cc)
        ret abi_err(AbiErrorKind.invalid_callconv, "callconv is not FFI-safe")
    .end

    # Validate params
    let i: usize = 0
    while i < sig.params.len
        let p = sig.params.data[i]
        if p.name.len_bytes() == 0
            ret abi_err(AbiErrorKind.invalid_param, "param name is empty")
        .end
        # Type layout must be computable
        let _ = extern_type_layout(triple, p.ty)
        i = i + 1
    .end

    let _2 = extern_type_layout(triple, sig.ret)
    ret abi_ok()
.end

fn extern_symbol_validate(triple: AbiTriple, sym: ExternSymbol) -> AbiError
    if !symbol_name_is_valid(sym.name)
        ret abi_err(AbiErrorKind.invalid_symbol, "invalid symbol name")
    .end

    if sym.link_name.len_bytes() == 0
        # If not specified, default to name.
        # This function validates; normalization happens elsewhere.
        ret abi_err(AbiErrorKind.invalid_link_name, "link_name is empty")
    .end

    if !symbol_name_is_valid(sym.link_name)
        # link_name is often a raw linker symbol; keep the same conservative rule.
        ret abi_err(AbiErrorKind.invalid_link_name, "invalid link_name")
    .end

    if sym.kind == ExternSymbolKind.fn_sym
        ret extern_fn_sig_validate(triple, sym.fn_sig)
    .end

    if sym.kind == ExternSymbolKind.data_sym
        let _ = extern_type_layout(triple, sym.data_sig.ty)
        ret abi_ok()
    .end

    ret abi_ok()
.end

fn extern_symbol_normalize(triple: AbiTriple, sym: ExternSymbol) -> ExternSymbol
    # Normalization policy:
    # - If link_name empty => link_name = name.
    # - If callconv is `system` => replace with platform default.
    let out = sym

    if out.link_name.len_bytes() == 0
        out.link_name = out.name
    .end

    if out.kind == ExternSymbolKind.fn_sym
        if out.fn_sig.cc == AbiCallConv.system
            out.fn_sig.cc = callconv_default_for(triple)
        .end
    .end

    ret out
.end

# -----------------------------------------------------------------------------
# Convenience builders
# -----------------------------------------------------------------------------

fn extern_param(name: str, ty: ExternType) -> ExternParam
    let p: ExternParam
    p.name = name
    p.ty = ty
    ret p
.end

fn extern_fn_sig(cc: AbiCallConv, params: ExternParamList, ret_ty: ExternType, variadic: bool) -> ExternFnSig
    let s: ExternFnSig
    s.cc = cc
    s.params = params
    s.ret = ret_ty
    s.variadic = variadic
    ret s
.end

fn extern_data_sig(ty: ExternType, readonly: bool) -> ExternDataSig
    let s: ExternDataSig
    s.ty = ty
    s.readonly = readonly
    ret s
.end

# -----------------------------------------------------------------------------
# ABI lowering helpers for common C patterns
# -----------------------------------------------------------------------------

# C-style "out" parameter: T* (mut)
fn abi_out_ptr(elem: *ExternType) -> ExternType
    ret extern_type_ptr(elem, ExternMut.mut)
.end

# C-style "in" pointer: const T*
fn abi_in_ptr(elem: *ExternType) -> ExternType
    ret extern_type_ptr(elem, ExternMut.const)
.end

# C-style byte buffer: (u8*, usize)
# This is a modeling helper, not a single C type.

type ExternBufferSig struct
    ptr_ty: ExternType
    len_ty: ExternType
.end

fn abi_byte_buffer(mutability: ExternMut, triple: AbiTriple) -> ExternBufferSig
    let u8t = extern_type_u32() # placeholder to get addressable value; corrected below
    u8t.kind = ExternTypeKind.u8

    let p = extern_type_ptr(&u8t, mutability)
    let n = extern_type_usize()

    let b: ExternBufferSig
    b.ptr_ty = p
    b.len_ty = n
    ret b
.end

# -----------------------------------------------------------------------------
# Minimal smoke tests (pure functions only)
# -----------------------------------------------------------------------------

# These tests are written as normal functions so they can be reused by any test harness.
# If your project supports a `test` item, you can wrap these functions there.

fn extern_abi_smoke_validate_identifiers() -> bool
    if !c_ident_is_valid("hello")
        ret false
    .end
    if c_ident_is_valid("9nope")
        ret false
    .end
    if !symbol_name_is_valid("_errno")
        ret false
    .end
    if symbol_name_is_valid("bad name")
        ret false
    .end
    ret true
.end

fn extern_abi_smoke_layout(triple: AbiTriple) -> bool
    let i32t = extern_type_i32()
    let p = extern_type_ptr(&i32t, ExternMut.const)
    let l1 = extern_type_layout(triple, i32t)
    let l2 = extern_type_layout(triple, p)

    if l1.size != 4
        ret false
    .end

    if l2.size != abi_size_of_ptr(triple)
        ret false
    .end

    ret true
.end

fn extern_abi_smoke_symbol(triple: AbiTriple) -> bool
    # Build: int puts(const char*);
    let p0: ExternParam
    p0.name = "s"
    p0.ty = extern_type_cstr()

    let params: ExternParamList
    params.data = &p0
    params.len = 1

    let sig = extern_fn_sig(AbiCallConv.c, params, extern_type_i32(), false)
    let sym = extern_symbol_init_fn("puts", "puts", "c", sig)

    let n = extern_symbol_normalize(triple, sym)
    let e = extern_symbol_validate(triple, n)
    ret e.kind == AbiErrorKind.ok
.end

fn extern_abi_smoke_all() -> bool
    let t = abi_triple_default()

    if !extern_abi_smoke_validate_identifiers()
        ret false
    .end

    if !extern_abi_smoke_layout(t)
        ret false
    .end

    if !extern_abi_smoke_symbol(t)
        ret false
    .end

    ret true
.end
