# tests.vit (Vitte)
#
# Port of the Rust unit tests for ExternAbi parsing.
#
# Conventions:
# - Use `scenario` blocks as lightweight tests.
# - Use core `match` to avoid relying on Result helper methods.

use super.*

#------------------------------------------------------------------------------
# Minimal asserts (local, to avoid depending on a specific test harness API)
#------------------------------------------------------------------------------

fn assert_true(cond: bool, msg: string)
  if !cond
    panic(msg)
  .end
.end

fn assert_eq_str(got: string, want: string)
  if got != want
    panic("assert_eq_str failed: got='" + got + "' want='" + want + "'")
  .end
.end

#------------------------------------------------------------------------------
# Scenarios
#------------------------------------------------------------------------------

scenario lookup_Rust
  let r = ExternAbi::from_str("Rust")

  match r
    Ok(abi) =>
      assert_eq_str(abi.as_str(), "Rust")
    .end

    Err(_) =>
      panic("lookup_Rust: expected Ok")
    .end
  .end
.end

scenario lookup_cdecl
  let r = ExternAbi::from_str("cdecl")

  match r
    Ok(abi) =>
      assert_eq_str(abi.as_str(), "cdecl")
    .end

    Err(_) =>
      panic("lookup_cdecl: expected Ok")
    .end
  .end
.end

scenario lookup_baz
  let r = ExternAbi::from_str("baz")

  match r
    Ok(_) =>
      panic("lookup_baz: expected Err(Unknown)")
    .end

    Err(e) =>
      # Expect Unknown
      assert_true(e == AbiFromStrErr::Unknown, "lookup_baz: expected AbiFromStrErr::Unknown")
    .end
  .end
.end

scenario guarantee_lexicographic_ordering
  let abis = ExternAbi::ALL_VARIANTS

  # Verify `abis` is already sorted (lexicographic ordering).
  # This avoids depending on Vec/sort APIs.
  let i = 1
  loop while i < abis.len()
    let prev = abis[i - 1]
    let cur = abis[i]

    # assumes ExternAbi implements ordering (as in Rust Ord)
    if prev > cur
      panic("ALL_VARIANTS not sorted")
    .end

    set i = i + 1
  .end
.end