module vitte.compiler.sema.typecheck

import std.collections as coll
import vitte.compiler.frontend.ast as ast
import vitte.compiler.frontend.diagnostics as diag

# Typage minimal : vérifie uniquement l'existence d'un corps pour les fonctions
# non externes et signale un avertissement si absent.

pub fn run_typecheck(mods: &mut coll.Vec[ast.Module], bag: &mut diag.DiagnosticBag) -> Result[Unit, Unit]
  let i = 0usize
  while i < mods.len()
    let mut m = mods[i]
    check_module(&mut m, bag)
    infer_module_types(&mut m)
    mods[i] = m
    i = i + 1usize
  end
  if bag.has_error()
    return Err(())
  end
  return Ok(())
.end

fn check_module(m: &mut ast.Module, bag: &mut diag.DiagnosticBag) -> Unit
  let i = 0usize
  while i < m.items.len()
    let item = m.items[i]
    if item.kind == ast.ModuleItemKind.FnDecl and item.fn_decl.is_some()
      let f = item.fn_decl.unwrap()
      if f.body.is_none()
        bag.add_warning(
          "Fonction sans corps (traitée comme extern)",
          f.span,
          "W3001",
        )
      end
    end
    i = i + 1usize
  end
.end

fn infer_module_types(m: &mut ast.Module) -> Unit
  let i = 0usize
  while i < m.items.len()
    let item = m.items[i]
    if item.kind == ast.ModuleItemKind.FnDecl and item.fn_decl.is_some()
      let f = item.fn_decl.unwrap()
      infer_function_types(m, f)
    end
    i = i + 1usize
  end
.end

fn unknown_type(span: diag.Span) -> ast.TypeExpr
  return ast.TypeExpr(kind = ast.TypeExprKind.Infer, span = span)
.end

fn infer_function_types(m: &mut ast.Module, f: ast.FnDecl) -> Unit
  let env = coll.HashMap[String, ast.TypeExpr].new()
  let i = 0usize
  while i < f.params.len()
    let p = f.params[i]
    let pty = if p.ty.is_some() then p.ty.unwrap() else unknown_type(p.span) end
    env.insert(p.name.name, pty)
    m.set_symbol_type(p.name.name, pty)
    i = i + 1usize
  end

  if f.return_type.is_some()
    m.set_return_type(f.name.name, f.return_type.unwrap())
  end

  if f.body.is_none()
    return
  end

  let body_id = f.body.unwrap()
  infer_block_types(m, body_id, env)
.end

fn infer_block_types(m: &mut ast.Module, bid: ast.BlockId, env: coll.HashMap[String, ast.TypeExpr]) -> coll.HashMap[String, ast.TypeExpr]
  let blk = m.get_block(bid)
  let i = 0usize
  let cur_env = env
  while i < blk.stmts.len()
    let sid = blk.stmts[i]
    let stmt = m.get_stmt(sid)
    let next_env = infer_stmt_types(m, stmt, cur_env)
    cur_env = next_env
    i = i + 1usize
  end
  return cur_env
.end

fn infer_stmt_types(m: &mut ast.Module, s: ast.Stmt, env: coll.HashMap[String, ast.TypeExpr]) -> coll.HashMap[String, ast.TypeExpr]
  match s.kind
    ast.StmtKind.Expr(expr = eid) ->
      let _ = infer_expr_type(m, eid, env)
      return env
    ast.StmtKind.Return(value = val) ->
      if val.is_some()
        let _ = infer_expr_type(m, val.unwrap(), env)
      end
      return env
    ast.StmtKind.Let(name = id, mutable = _, ty = annot, value = val) ->
      let ety =
        if annot.is_some()
          annot.unwrap()
        elif val.is_some()
          infer_expr_type(m, val.unwrap(), env)
        else
          unknown_type(s.span)
        end
      let new_env = env
      new_env.insert(id.name, ety)
      m.set_symbol_type(id.name, ety)
      return new_env
    ast.StmtKind.If(cond = c, then_block = t, else_block = eopt) ->
      let _ = infer_expr_type(m, c, env)
      let _ = infer_block_types(m, t, env)
      if eopt.is_some()
        let _ = infer_block_types(m, eopt.unwrap(), env)
      end
      return env
    ast.StmtKind.While(cond = c, body = b) ->
      let _ = infer_expr_type(m, c, env)
      let _ = infer_block_types(m, b, env)
      return env
    _ ->
      return env
  end
.end

fn infer_expr_type(m: &mut ast.Module, eid: ast.ExprId, env: coll.HashMap[String, ast.TypeExpr]) -> ast.TypeExpr
  if m.get_expr_type(eid).is_some()
    return m.get_expr_type(eid).unwrap()
  end

  let expr = m.get_expr(eid)
  let ty =
    match expr.kind
      ast.ExprKind.IntLiteral(value = _) ->
        ast.TypeExpr.from_name("i64", expr.span)
      ast.ExprKind.BoolLiteral(value = _) ->
        ast.TypeExpr.from_name("bool", expr.span)
      ast.ExprKind.StringLiteral(value = _) ->
        ast.TypeExpr.from_name("str", expr.span)
      ast.ExprKind.TupleLiteral(items = it) ->
        let tys = coll.Vec[ast.TypeExpr].new()
        let i = 0usize
        while i < it.len()
          let t = infer_expr_type(m, it[i], env)
          tys.push(t)
          i = i + 1usize
        end
        ast.TypeExpr(kind = ast.TypeExprKind.Tuple(items = tys), span = expr.span)
      ast.ExprKind.Name(ident = id) ->
        if env.contains_key(id.name)
          env[id.name]
        else
          unknown_type(expr.span)
        end
      ast.ExprKind.PathName(path = p) ->
        if p.len() == 1 and env.contains_key(p[0].name)
          env[p[0].name]
        else
          unknown_type(expr.span)
        end
      ast.ExprKind.Unary(op = op, operand = opnd) ->
        let oty = infer_expr_type(m, opnd, env)
        match op
          ast.UnaryOp.Neg -> ast.TypeExpr.from_name("i64", expr.span)
          ast.UnaryOp.Not -> ast.TypeExpr.from_name("bool", expr.span)
        end
      ast.ExprKind.Binary(op = op, lhs = l, rhs = r) ->
        let lty = infer_expr_type(m, l, env)
        let rty = infer_expr_type(m, r, env)
        match op
          ast.BinaryOp.Add -> lty
          ast.BinaryOp.Sub -> lty
          ast.BinaryOp.Mul -> lty
          ast.BinaryOp.Div -> lty
          ast.BinaryOp.Assign -> lty
          ast.BinaryOp.Eq -> ast.TypeExpr.from_name("bool", expr.span)
          ast.BinaryOp.Ne -> ast.TypeExpr.from_name("bool", expr.span)
          ast.BinaryOp.Lt -> ast.TypeExpr.from_name("bool", expr.span)
          ast.BinaryOp.Le -> ast.TypeExpr.from_name("bool", expr.span)
          ast.BinaryOp.Gt -> ast.TypeExpr.from_name("bool", expr.span)
          ast.BinaryOp.Ge -> ast.TypeExpr.from_name("bool", expr.span)
        end
      ast.ExprKind.Call(callee = _, args = args) ->
        let i = 0usize
        while i < args.len()
          let _ = infer_expr_type(m, args[i], env)
          i = i + 1usize
        end
        unknown_type(expr.span)
      ast.ExprKind.BlockExpr(block = b) ->
        let _ = infer_block_types(m, b, env)
        ast.TypeExpr(kind = ast.TypeExprKind.Unit, span = expr.span)
      ast.ExprKind.IfExpr(cond = c, then_block = t, else_block = eopt) ->
        let _ = infer_expr_type(m, c, env)
        let _ = infer_block_types(m, t, env)
        if eopt.is_some()
          let _ = infer_block_types(m, eopt.unwrap(), env)
        end
        ast.TypeExpr(kind = ast.TypeExprKind.Unit, span = expr.span)
      _ ->
        unknown_type(expr.span)
    end

  m.set_expr_type(eid, ty)
  return ty
.end
