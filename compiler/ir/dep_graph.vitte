module vitte.bootstrap.middle.bt_dep_graph

import std.collections as coll
import vitte.bootstrap.host.bt_env as env
import vitte.bootstrap.host.bt_fs as fs
import vitte.bootstrap.host.bt_platform as pl
import vitte.bootstrap.host.bt_io as io
import vitte.bootstrap.core.bt_toolchain as tc
import vitte.bootstrap.front.bt_span as span
import vitte.bootstrap.front.bt_resolve as res
import vitte.bootstrap.front.bt_symbol as sy

# ============================================================================
# Vitte bootstrap middle – Modèle logique du graphe de dépendances
# (maximal, déclaratif, sans I/O)
#
# Objectifs :
#   - Modéliser, de manière purement déclarative :
#       * les noeuds de dépendance (modules, fichiers, targets, outils, artefacts),
#       * les arêtes (import, build, link, runtime, toolchain),
#       * les couches/layers (topologiques, phases de compilation),
#       * les composants fortement connectés (cycles),
#       * les plans de build (unités, ordre d’évaluation),
#       * les résumés/métriques d’un graphe de dépendances.
#   - Servir de contrat entre :
#       * les passes front/middle (resolve, symbol, IR),
#       * l’orchestrateur de build / CI,
#       * la toolchain (`bt_toolchain`) et les plateformes (`bt_platform`),
#       * les outils (visualisation de graphes, lints de dépendance).
#   - Ne contenir :
#       * aucune fonction,
#       * aucune logique de graph algorithm (DFS, topo-sort, SCC),
#       * aucune I/O ni formatage.
# ============================================================================

# ---------------------------------------------------------------------------
# Identifiants internes
# ---------------------------------------------------------------------------

struct DepNodeId
    raw: u32
.end

struct DepEdgeId
    raw: u32
.end

struct DepLayerId
    raw: u32
.end

struct DepSccId
    raw: u32
.end

struct DepCycleId
    raw: u32
.end

struct DepBuildUnitId
    raw: u32
.end

struct DepGraphId
    raw: u32
.end

# ---------------------------------------------------------------------------
# Kinds / catégories de noeuds et d’arêtes
# ---------------------------------------------------------------------------

enum DepNodeKind
    DepNodeModule            # module logique Vitte
    DepNodeFile              # fichier source
    DepNodePackage           # paquet / crate / unité logique
    DepNodeTarget            # cible de build (PlTargetSpec)
    DepNodeRuntime           # runtime (PlRuntimeSpec)
    DepNodeTool              # outil (compiler, runner, etc.)
    DepNodeStdlib            # bibliothèque standard Vitte
    DepNodeThirdPartyLib     # lib externe
    DepNodeBuildArtifact     # artefact de build (binaire, lib, archive)
    DepNodeTest              # test suite / test binary
    DepNodeExample           # exemple / sample
    DepNodeWorkspace         # workspace / repo
    DepNodeConfig            # config (manifest muffin, etc.)
    DepNodeCache             # cache (target/, .cache/, etc.)
    DepNodeOther
.end

enum DepEdgeKind
    DepEdgeImport            # import / use / include
    DepEdgeReexport          # re-export, pub use
    DepEdgeBuildDependsOn    # dépendance de build (compile-time)
    DepEdgeLink              # dépendance de linking
    DepEdgeRuntimeDependsOn  # dépendance runtime
    DepEdgeToolchainUses     # l’outil/ou target utilise un composant toolchain
    DepEdgeGenerates         # un noeud génère un autre (source → artefact)
    DepEdgeReadsFrom         # lit depuis (logs, cache, config)
    DepEdgeWritesTo          # écrit vers (artefacts, cache)
    DepEdgeTestDependsOn     # test dépend d’un binaire/lib
    DepEdgeOther
.end

enum DepDirection
    DepForward
    DepReverse
    DepBidirectional
.end

enum DepStrength
    DepStrong
    DepWeak
    DepOptional
.end

enum DepNodeStatus
    DepNodeUnknown
    DepNodePresent
    DepNodeMissing
    DepNodeSynthetic
    DepNodeError
.end

enum DepLayerKind
    DepLayerFrontEnd         # lex/parse/resolve/symbol
    DepLayerMiddleEnd        # IR, analyses, optimisations
    DepLayerBackEnd          # codegen, linking
    DepLayerRuntime          # environnements runtime
    DepLayerHostTooling      # outils host (CI, scripts)
    DepLayerWorkspace        # vue globale workspace
    DepLayerOther
.end

enum DepCycleSeverity
    DepCycleInfo
    DepCycleWarning
    DepCycleError
.end

# ---------------------------------------------------------------------------
# Origine / rattachements d’un noeud
# ---------------------------------------------------------------------------

struct DepNodeOrigin
    # Chemin/logique de base
    workspace_id: env.BtEnvWorkspaceId
    workspace_root: fs.FsPath

    # Fichier / source associé (si applicable)
    file_path: String
    file_id: span.BfFileId

    # Identifiants de résolution/typage (si applicable)
    resolve_file_id: res.ResFileId
    module_name: String

    # Cible / runtime / toolchain associés (optionnels)
    target_id: pl.PlTargetId
    runtime_id: pl.PlRuntimeId
    tool_id: env.BtEnvToolId

    # Span primaire (origine principale)
    primary_span_id: span.BfSpanId

    extra: coll.HashMap<String, String>
.end

# ---------------------------------------------------------------------------
# Noeuds de dépendance
# ---------------------------------------------------------------------------

struct DepNode
    id: DepNodeId
    kind: DepNodeKind

    # Nom logique et display
    name: String                     # ident interne stable
    display_name: String             # ce qui est affiché à l’utilisateur
    description: String

    # Rattachements
    origin: DepNodeOrigin

    # Statut
    status: DepNodeStatus
    is_entry_point: bool             # main/program/service/driver/etc.
    is_public_api: bool              # fait partie de l’API exposée

    # Layers / topologie
    layer_id: DepLayerId
    scc_id: DepSccId                 # composant fortement connecté
    topo_index: u32                  # indice topologique si acyclique

    # Degrés (pour stats rapides)
    indegree: u32
    outdegree: u32

    # Tags/métadonnées libres
    tags: coll.Vec<String>
    extra: coll.HashMap<String, String>
.end

# ---------------------------------------------------------------------------
# Arêtes de dépendance
# ---------------------------------------------------------------------------

struct DepEdgeOrigin
    # Texte / path ayant introduit cette dépendance (import, manifest, script)
    file_path: String
    span_id: span.BfSpanId

    # Optionnel : identifiant de symbole/type qui a porté cette relation
    symbol_id: res.ResSymbolId

    # Informations additionnelles (nom de section, clé dans manifest, etc.)
    source_kind: String
    notes: String

    extra: coll.HashMap<String, String>
.end

struct DepEdge
    id: DepEdgeId
    kind: DepEdgeKind

    from_node: DepNodeId
    to_node: DepNodeId

    direction: DepDirection
    strength: DepStrength

    # True si arête de retour dans un ordre topologique (back-edge)
    is_back_edge: bool

    # True si traverse des layers logiques différents
    is_cross_layer: bool

    # Pondération / coût abstrait (compose ou non selon les passes)
    weight: u32

    label: String
    origin: DepEdgeOrigin

    tags: coll.Vec<String>
    extra: coll.HashMap<String, String>
.end

# ---------------------------------------------------------------------------
# Layers / couches logiques
# ---------------------------------------------------------------------------

struct DepLayer
    id: DepLayerId
    kind: DepLayerKind

    name: String
    description: String

    # Noeuds présents dans cette couche
    node_ids: coll.Vec<DepNodeId>

    # Indice logique (0 = plus bas, N = plus haut)
    index: u32

    extra: coll.HashMap<String, String>
.end

# ---------------------------------------------------------------------------
# Composants fortement connectés (SCC) et cycles
# ---------------------------------------------------------------------------

struct DepScc
    id: DepSccId

    # Noeuds de ce SCC
    node_ids: coll.Vec<DepNodeId>

    # Arêtes internes à ce SCC
    edge_ids: coll.Vec<DepEdgeId>

    # True si ce SCC contient un cycle non trivial
    has_cycle: bool

    # Labels / commentaires
    label: String
    description: String

    extra: coll.HashMap<String, String>
.end

struct DepCycle
    id: DepCycleId

    severity: DepCycleSeverity

    # Noeuds/arêtes impliqués
    node_ids: coll.Vec<DepNodeId>
    edge_ids: coll.Vec<DepEdgeId>

    # Chemin représentatif (séquence de noeuds formant un cycle)
    representative_path: coll.Vec<DepNodeId>

    description: String
    notes: String

    extra: coll.HashMap<String, String>
.end

# ---------------------------------------------------------------------------
# Unités de build et plan de compilation
# ---------------------------------------------------------------------------

enum DepBuildUnitKind
    BuildUnitLibrary
    BuildUnitBinary
    BuildUnitTest
    BuildUnitExample
    BuildUnitTool
    BuildUnitOther
.end

struct DepBuildUnit
    id: DepBuildUnitId
    kind: DepBuildUnitKind

    name: String                    # ex: "vittec-bootstrap", "core-lib"
    description: String

    # Cible / runtime / profil de build
    target_id: pl.PlTargetId
    runtime_id: pl.PlRuntimeId
    build_profile_id: pl.PlBuildProfileId

    # Workspace / profil d’environnement
    workspace_id: env.BtEnvWorkspaceId
    env_profile_id: env.BtEnvProfileId

    # Toolchain et components utilisés
    toolchain_profile_id: String
    toolchain_component_ids: coll.Vec<String>

    # Noeud racine de cette unité (package/target principal)
    root_node_id: DepNodeId

    # Noeuds et arêtes inclus dans cette unité
    included_node_ids: coll.Vec<DepNodeId>
    direct_dependency_node_ids: coll.Vec<DepNodeId>
    transitive_dependency_node_ids: coll.Vec<DepNodeId>

    # Artefacts produits (noeuds DepNodeBuildArtifact)
    artifact_node_ids: coll.Vec<DepNodeId>

    # Ordre de compilation local (topo ordre restreint aux noeuds inclus)
    local_topo_order: coll.Vec<DepNodeId>

    # Statistiques
    total_nodes: u32
    total_edges: u32

    extra: coll.HashMap<String, String>
.end

struct DepBuildPlan
    # Graphe global auquel ce plan se réfère
    graph_id: DepGraphId

    # Unités de build ordonnées (ordre global suggéré)
    units: coll.Vec<DepBuildUnitId>

    # Adjacence unité → unités dont elle dépend
    unit_dependencies: coll.HashMap<DepBuildUnitId, coll.Vec<DepBuildUnitId>>

    # Profil / pipeline d’exécution (optionnel, lié à IoPipelineSpec)
    pipeline_names: coll.Vec<String>

    extra: coll.HashMap<String, String>
.end

# ---------------------------------------------------------------------------
# Résumés et métriques
# ---------------------------------------------------------------------------

struct DepGraphSummary
    graph_id: DepGraphId

    total_nodes: u32
    total_edges: u32

    total_layers: u32
    total_sccs: u32
    total_cycles: u32

    # Degrés moyens/max
    average_indegree: f64
    average_outdegree: f64
    max_indegree: u32
    max_outdegree: u32

    # Noeuds "feuilles" et "racines"
    leaf_nodes_count: u32
    root_nodes_count: u32

    # Compteurs par type de noeud (clé = DepNodeKind sous forme texte)
    count_by_node_kind: coll.HashMap<String, u32>

    # Compteurs par type d’arête
    count_by_edge_kind: coll.HashMap<String, u32>

    # Cycles
    cycles_info: coll.HashMap<String, u32>    # ex: "error" -> n, "warning" -> n

    extra: coll.HashMap<String, String>
.end

# ---------------------------------------------------------------------------
# Indexation du graphe
# ---------------------------------------------------------------------------

struct DepGraphIndex
    # Index : nom → id (via raw)
    node_index_by_name: coll.HashMap<String, u32>

    # Index par kind (clé stringifiée)
    node_ids_by_kind: coll.HashMap<String, coll.Vec<DepNodeId>>

    # Index arêtes par noeud
    outgoing_edge_ids_by_node_raw: coll.HashMap<u32, coll.Vec<DepEdgeId>>
    incoming_edge_ids_by_node_raw: coll.HashMap<u32, coll.Vec<DepEdgeId>>

    # Mapping SCC / layers
    node_ids_by_scc: coll.HashMap<u32, coll.Vec<DepNodeId>>
    node_ids_by_layer: coll.HashMap<u32, coll.Vec<DepNodeId>>

    extra: coll.HashMap<String, String>
.end

# ---------------------------------------------------------------------------
# Métadonnées & graphe racine
# ---------------------------------------------------------------------------

struct DepGraphMetadata
    id: DepGraphId

    project_name: String             # ex: "vitte-core-bootstrap"
    edition: String                  # ex: "2025"
    profile: String                  # ex: "bootstrap"

    created_at: String               # ISO 8601
    updated_at: String

    # Contextes / tags
    tags: coll.Vec<String>
    description: String

    extra: coll.HashMap<String, String>
.end

struct DepGraph
    meta: DepGraphMetadata

    # Noeuds et arêtes
    nodes: coll.Vec<DepNode>
    edges: coll.Vec<DepEdge>

    # Layers, SCC et cycles
    layers: coll.Vec<DepLayer>
    sccs: coll.Vec<DepScc>
    cycles: coll.Vec<DepCycle>

    # Unités de build et plan global
    build_units: coll.Vec<DepBuildUnit>
    build_plan: DepBuildPlan

    # Résumé & indexation
    summary: DepGraphSummary
    index: DepGraphIndex

    extra: coll.HashMap<String, String>
.end
