module vitte.compiler.ir.ir

import std.collections as coll
import vitte.compiler.frontend.diagnostics as diag

# =============================================================================
# Vitte compiler – IR runtime (squelette projet)
#
# Objectifs :
#   - Fournir une représentation intermédiaire simple :
#       * Program : plusieurs modules IR,
#       * Module  : plusieurs fonctions,
#       * Function: liste d'instructions linéaire (pas encore de blocs/SSA).
#   - Servir de contrat entre :
#       * le frontend (AST),
#       * les passes d'optimisation,
#       * le backend (C, VM, bytecode...).
# =============================================================================

# -----------------------------------------------------------------------------
# Instructions IR (ultra simples pour commencer)
# -----------------------------------------------------------------------------

enum IrInstrKind
  Nop
  RetVoid
  RetValue
  Call
  # TODO :
  #   - BinOp, Load/Store, Branch, etc.
.end

struct IrValue
  name: String
.end

fn IrValue.temp(name: String) -> IrValue
  return IrValue(name = name)
.end

struct IrInstr
  kind: IrInstrKind
  span: diag.Span
  target: IrValue?        # résultat, ex: t0 = ...
  callee: String          # pour Call
  args: coll.Vec[IrValue] # pour Call
.end

fn IrInstr.nop(span: diag.Span) -> IrInstr
  return IrInstr(
    kind = IrInstrKind.Nop,
    span = span,
    target = None,
    callee = "",
    args = coll.Vec[IrValue].new(),
  )
.end

fn IrInstr.ret_void(span: diag.Span) -> IrInstr
  return IrInstr(
    kind = IrInstrKind.RetVoid,
    span = span,
    target = None,
    callee = "",
    args = coll.Vec[IrValue].new(),
  )
.end

# -----------------------------------------------------------------------------
# Function / Module / Program
# -----------------------------------------------------------------------------

struct Function
  name: String
  span: diag.Span
  instrs: coll.Vec[IrInstr]
.end

fn Function.new(name: String, span: diag.Span) -> Function
  return Function(
    name = name,
    span = span,
    instrs = coll.Vec[IrInstr].new(),
  )
.end

fn Function.add_instr(self: &mut Function, instr: IrInstr) -> Unit
  self.instrs.push(instr)
.end

struct Module
  name: String
  functions: coll.Vec[Function]
.end

fn Module.new(name: String) -> Module
  return Module(
    name = name,
    functions = coll.Vec[Function].new(),
  )
.end

fn Module.add_function(self: &mut Module, func: Function) -> Unit
  self.functions.push(func)
.end

struct Program
  modules: coll.Vec[Module]
.end

fn Program.empty() -> Program
  return Program(
    modules = coll.Vec[Module].new(),
  )
.end

fn Program.add_module(self: &mut Program, m: Module) -> Unit
  self.modules.push(m)
.end

fn Program.is_empty(self: Program) -> Bool
  return self.modules.len() == 0
.end