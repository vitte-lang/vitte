module vitte.compiler.ir.ir

import std.collections as coll
import std.string as str
import vitte.compiler.frontend.diagnostics as diag

# =============================================================================
# SSA IR de base pour Vitte
#   - Bloc orienté SSA : chaque instruction produit au plus une valeur.
#   - Terminator obligatoire par bloc.
#   - Invariants vérifiés via validate_program.
# =============================================================================

pub struct ValueId
  raw: u32
.end

pub struct BlockId
  raw: u32
.end

pub struct InstrId
  raw: u32
.end

pub enum TypeKind
  Unit
  Bool
  I64
  Str
  Tuple
  Unknown
.end

pub struct Type
  kind: TypeKind
  name: String
  items: coll.Vec[Type]
.end

fn empty_items() -> coll.Vec[Type]
  return coll.Vec[Type].new()
.end

fn Type.unit() -> Type
  return Type(kind = TypeKind.Unit, name = "", items = empty_items())
.end

fn Type.bool() -> Type
  return Type(kind = TypeKind.Bool, name = "", items = empty_items())
.end

fn Type.i64() -> Type
  return Type(kind = TypeKind.I64, name = "", items = empty_items())
.end

fn Type.str() -> Type
  return Type(kind = TypeKind.Str, name = "", items = empty_items())
.end

fn Type.tuple(items: coll.Vec[Type]) -> Type
  let tname = tuple_type_name(items)
  return Type(kind = TypeKind.Tuple, name = tname, items = items)
.end

fn Type.unknown() -> Type
  return Type(kind = TypeKind.Unknown, name = "", items = empty_items())
.end

fn tuple_type_name(items: coll.Vec[Type]) -> String
  let out = "("
  let i = 0usize
  while i < items.len()
    out = out + type_name(items[i])
    if i + 1usize < items.len()
      out = out + ", "
    end
    i = i + 1usize
  end
  return out + ")"
.end

pub fn type_name(t: Type) -> String
  match t.kind
    TypeKind.Unit -> return "unit"
    TypeKind.Bool -> return "bool"
    TypeKind.I64 -> return "i64"
    TypeKind.Str -> return "str"
    TypeKind.Tuple ->
      if t.name != ""
        return t.name
      end
      return tuple_type_name(t.items)
    TypeKind.Unknown ->
      if t.name != ""
        return t.name
      end
      return "unknown"
  end
.end

fn types_equal(a: Type, b: Type) -> Bool
  if a.kind == TypeKind.Tuple and b.kind == TypeKind.Tuple
    if a.items.len() != b.items.len()
      return false
    end
    let i = 0usize
    while i < a.items.len()
      if not types_equal(a.items[i], b.items[i])
        return false
      end
      i = i + 1usize
    end
  end
  return a.kind == b.kind and a.name == b.name
.end

pub enum BinOp
  Add
  Sub
  Mul
  Div
  Eq
  Ne
  Lt
  Le
  Gt
  Ge
.end

pub enum UnOp
  Neg
  Not
.end

pub enum Terminator
  Return
    value: ValueId?
  Jump
    target: BlockId
  CondJump
    cond: ValueId
    then_tgt: BlockId
    else_tgt: BlockId
.end

pub enum InstrKind
  ConstInt
    value: String
  ConstBool
    value: Bool
  ConstString
    value: String
  Param
    index: u32
  Phi
    incomings: coll.Vec[(BlockId, ValueId)]
  BinOp
    op: BinOp
    lhs: ValueId
    rhs: ValueId
  UnOp
    op: UnOp
    operand: ValueId
  Call
    callee: String
    args: coll.Vec[ValueId]
  MakeTuple
    items: coll.Vec[ValueId]
.end

pub struct Instr
  id: InstrId
  kind: InstrKind
  ty: Type
  span: diag.Span
  result: ValueId
.end

pub struct Block
  id: BlockId
  name: String
  instrs: coll.Vec[Instr]
  terminator: Terminator?
.end

pub struct Param
  name: String
  ty: Type
  value: ValueId
  span: diag.Span
.end

pub struct Function
  name: String
  params: coll.Vec[Param]
  ret_type: Type
  blocks: coll.Vec[Block]
  entry: BlockId
  span: diag.Span
.end

pub struct Module
  name: String
  functions: coll.Vec[Function]
.end

pub struct Program
  modules: coll.Vec[Module]
.end

fn Program.empty() -> Program
  return Program(modules = coll.Vec[Module].new())
.end

# -----------------------------------------------------------------------------
# Validation basique des invariants SSA
# -----------------------------------------------------------------------------

pub struct ValidationError
  message: String
  span: diag.Span
.end

pub fn validate_program(prog: Program) -> coll.Vec[ValidationError]
  let errors = coll.Vec[ValidationError].new()
  let mlen = prog.modules.len()
  let mi = 0usize
  while mi < mlen
    let m = prog.modules[mi]
    let flen = m.functions.len()
    let fi = 0usize
    while fi < flen
      let f = m.functions[fi]
      validate_function(f, &mut errors)
      fi = fi + 1usize
    end
    mi = mi + 1usize
  end
  return errors
.end

fn validate_function(f: Function, out: &mut coll.Vec[ValidationError]) -> Unit
  let seen_blocks = coll.HashSet[u32].new()
  let block_ids = coll.HashSet[u32].new()
  let blen = f.blocks.len()
  let bi = 0usize
  while bi < blen
    let b = f.blocks[bi]
    if seen_blocks.contains(b.id.raw)
      out.push(ValidationError(
        message = "Duplicate block id " + b.name,
        span = f.span,
      ))
    else
      seen_blocks.insert(b.id.raw)
      block_ids.insert(b.id.raw)
    end

    validate_block(b, out)
    bi = bi + 1usize
  end

  let bi2 = 0usize
  while bi2 < blen
    let b = f.blocks[bi2]
    validate_block_with_targets(b, block_ids, out)
    match b.terminator
      Some(t) -> validate_terminator(t, b, block_ids, out)
      None -> pass
    end
    bi2 = bi2 + 1usize
  end

  validate_reachability(f, out)
  validate_types(f, out)
.end

fn validate_block(b: Block, out: &mut coll.Vec[ValidationError]) -> Unit
  let term_missing = b.terminator.is_none()
  if term_missing
    out.push(ValidationError(
      message = "Terminator manquant pour le bloc " + b.name,
      span = diag.Span.dummy("<ir>"),
    ))
  end

  let seen_instrs = coll.HashSet[u32].new()
  let ilen = b.instrs.len()
  let ii = 0usize
  while ii < ilen
    let instr = b.instrs[ii]
    if seen_instrs.contains(instr.id.raw)
      out.push(ValidationError(
        message = "Duplicate instruction id dans " + b.name,
        span = instr.span,
      ))
    else
      seen_instrs.insert(instr.id.raw)
    end
    ii = ii + 1usize
  end
.end

fn validate_block_with_targets(b: Block, block_ids: coll.HashSet[u32], out: &mut coll.Vec[ValidationError]) -> Unit
  let ilen = b.instrs.len()
  let ii = 0usize
  while ii < ilen
    let instr = b.instrs[ii]
    match instr.kind
      InstrKind.Phi(incomings = incs) ->
        if incs.len() == 0
          out.push(ValidationError(
            message = "Phi sans incoming dans " + b.name,
            span = instr.span,
          ))
        end
        let k = 0usize
        while k < incs.len()
          let pair = incs[k]
          if not block_ids.contains(pair.0.raw)
            out.push(ValidationError(
              message = "Phi référence un bloc inconnu",
              span = instr.span,
            ))
          end
          k = k + 1usize
        end
      _ ->
        pass
    end
    ii = ii + 1usize
  end
.end

fn validate_reachability(f: Function, out: &mut coll.Vec[ValidationError]) -> Unit
  let visited = coll.HashSet[u32].new()
  let stack = coll.Vec[BlockId].new()
  stack.push(f.entry)

  let blocks = f.blocks
  let cursor = 0usize
  while cursor < stack.len()
    let bid = stack[cursor]
    cursor = cursor + 1usize
    if visited.contains(bid.raw)
      continue
    end
    visited.insert(bid.raw)
    let blk = find_block(blocks, bid)
    match blk.terminator
      Some(Terminator.Jump(target = t)) ->
        stack.push(t)
      Some(Terminator.CondJump(cond = _, then_tgt = tt, else_tgt = et)) ->
        stack.push(tt)
        stack.push(et)
      _ ->
        pass
    end
  end

  let i = 0usize
  while i < blocks.len()
    let b = blocks[i]
    if not visited.contains(b.id.raw)
      out.push(ValidationError(
        message = "Bloc inatteignable: " + b.name,
        span = f.span,
      ))
    end
    i = i + 1usize
  end
.end

fn collect_value_types(f: Function) -> coll.HashMap[u32, Type]
  let table = coll.HashMap[u32, Type].new()
  let pi = 0usize
  while pi < f.params.len()
    let p = f.params[pi]
    table.insert(p.value.raw, p.ty)
    pi = pi + 1usize
  end

  let bi = 0usize
  while bi < f.blocks.len()
    let b = f.blocks[bi]
    let ii = 0usize
    while ii < b.instrs.len()
      let inst = b.instrs[ii]
      table.insert(inst.result.raw, inst.ty)
      ii = ii + 1usize
    end
    bi = bi + 1usize
  end
  return table
.end

fn type_for_value(table: coll.HashMap[u32, Type], vid: ValueId) -> Type
  if table.contains_key(vid.raw)
    return table[vid.raw]
  end
  return Type.unknown()
.end

pub fn binop_name(op: BinOp) -> String
  match op
    BinOp.Add -> return "add"
    BinOp.Sub -> return "sub"
    BinOp.Mul -> return "mul"
    BinOp.Div -> return "div"
    BinOp.Eq  -> return "eq"
    BinOp.Ne  -> return "ne"
    BinOp.Lt  -> return "lt"
    BinOp.Le  -> return "le"
    BinOp.Gt  -> return "gt"
    BinOp.Ge  -> return "ge"
  end
.end

pub fn unop_name(op: UnOp) -> String
  match op
    UnOp.Neg -> return "neg"
    UnOp.Not -> return "not"
  end
.end

fn validate_binop_types(inst: Instr, op: BinOp, lhs: ValueId, rhs: ValueId, types: coll.HashMap[u32, Type], out: &mut coll.Vec[ValidationError]) -> Unit
  let lhs_ty = type_for_value(types, lhs)
  let rhs_ty = type_for_value(types, rhs)
  let res_ty = inst.ty

  let operands_match =
    if lhs_ty.kind == TypeKind.Unknown or rhs_ty.kind == TypeKind.Unknown
      true
    else
      types_equal(lhs_ty, rhs_ty)
    end

  match op
    BinOp.Add ->
      if lhs_ty.kind != TypeKind.I64 or rhs_ty.kind != TypeKind.I64
        out.push(ValidationError(
          message = "Opérandes non i64 pour " + binop_name(op) + " (" + type_name(lhs_ty) + ", " + type_name(rhs_ty) + ")",
          span = inst.span,
        ))
      end
      if res_ty.kind != TypeKind.I64
        out.push(ValidationError(
          message = "Type de résultat inattendu pour " + binop_name(op) + ": " + type_name(res_ty),
          span = inst.span,
        ))
      end
    BinOp.Sub ->
      if lhs_ty.kind != TypeKind.I64 or rhs_ty.kind != TypeKind.I64
        out.push(ValidationError(
          message = "Opérandes non i64 pour " + binop_name(op) + " (" + type_name(lhs_ty) + ", " + type_name(rhs_ty) + ")",
          span = inst.span,
        ))
      end
      if res_ty.kind != TypeKind.I64
        out.push(ValidationError(
          message = "Type de résultat inattendu pour " + binop_name(op) + ": " + type_name(res_ty),
          span = inst.span,
        ))
      end
    BinOp.Mul ->
      if lhs_ty.kind != TypeKind.I64 or rhs_ty.kind != TypeKind.I64
        out.push(ValidationError(
          message = "Opérandes non i64 pour " + binop_name(op) + " (" + type_name(lhs_ty) + ", " + type_name(rhs_ty) + ")",
          span = inst.span,
        ))
      end
      if res_ty.kind != TypeKind.I64
        out.push(ValidationError(
          message = "Type de résultat inattendu pour " + binop_name(op) + ": " + type_name(res_ty),
          span = inst.span,
        ))
      end
    BinOp.Div ->
      if lhs_ty.kind != TypeKind.I64 or rhs_ty.kind != TypeKind.I64
        out.push(ValidationError(
          message = "Opérandes non i64 pour " + binop_name(op) + " (" + type_name(lhs_ty) + ", " + type_name(rhs_ty) + ")",
          span = inst.span,
        ))
      end
      if res_ty.kind != TypeKind.I64
        out.push(ValidationError(
          message = "Type de résultat inattendu pour " + binop_name(op) + ": " + type_name(res_ty),
          span = inst.span,
        ))
      end
    BinOp.Eq ->
      if not operands_match
        out.push(ValidationError(
          message = "Types incompatibles pour comparaison: " + type_name(lhs_ty) + " vs " + type_name(rhs_ty),
          span = inst.span,
        ))
      end
      if res_ty.kind != TypeKind.Bool
        out.push(ValidationError(
          message = "Résultat de comparaison devrait être bool et non " + type_name(res_ty),
          span = inst.span,
        ))
      end
    BinOp.Ne ->
      if not operands_match
        out.push(ValidationError(
          message = "Types incompatibles pour comparaison: " + type_name(lhs_ty) + " vs " + type_name(rhs_ty),
          span = inst.span,
        ))
      end
      if res_ty.kind != TypeKind.Bool
        out.push(ValidationError(
          message = "Résultat de comparaison devrait être bool et non " + type_name(res_ty),
          span = inst.span,
        ))
      end
    BinOp.Lt ->
      if lhs_ty.kind != TypeKind.I64 or rhs_ty.kind != TypeKind.I64
        out.push(ValidationError(
          message = "Comparaison ordinale attend des i64, obtenu (" + type_name(lhs_ty) + ", " + type_name(rhs_ty) + ")",
          span = inst.span,
        ))
      end
      if res_ty.kind != TypeKind.Bool
        out.push(ValidationError(
          message = "Résultat de comparaison ordinale devrait être bool et non " + type_name(res_ty),
          span = inst.span,
        ))
      end
    BinOp.Le ->
      if lhs_ty.kind != TypeKind.I64 or rhs_ty.kind != TypeKind.I64
        out.push(ValidationError(
          message = "Comparaison ordinale attend des i64, obtenu (" + type_name(lhs_ty) + ", " + type_name(rhs_ty) + ")",
          span = inst.span,
        ))
      end
      if res_ty.kind != TypeKind.Bool
        out.push(ValidationError(
          message = "Résultat de comparaison ordinale devrait être bool et non " + type_name(res_ty),
          span = inst.span,
        ))
      end
    BinOp.Gt ->
      if lhs_ty.kind != TypeKind.I64 or rhs_ty.kind != TypeKind.I64
        out.push(ValidationError(
          message = "Comparaison ordinale attend des i64, obtenu (" + type_name(lhs_ty) + ", " + type_name(rhs_ty) + ")",
          span = inst.span,
        ))
      end
      if res_ty.kind != TypeKind.Bool
        out.push(ValidationError(
          message = "Résultat de comparaison ordinale devrait être bool et non " + type_name(res_ty),
          span = inst.span,
        ))
      end
    BinOp.Ge ->
      if lhs_ty.kind != TypeKind.I64 or rhs_ty.kind != TypeKind.I64
        out.push(ValidationError(
          message = "Comparaison ordinale attend des i64, obtenu (" + type_name(lhs_ty) + ", " + type_name(rhs_ty) + ")",
          span = inst.span,
        ))
      end
      if res_ty.kind != TypeKind.Bool
        out.push(ValidationError(
          message = "Résultat de comparaison ordinale devrait être bool et non " + type_name(res_ty),
          span = inst.span,
        ))
      end
  end
.end

fn validate_unop_types(inst: Instr, op: UnOp, operand: ValueId, types: coll.HashMap[u32, Type], out: &mut coll.Vec[ValidationError]) -> Unit
  let op_ty = type_for_value(types, operand)
  match op
    UnOp.Neg ->
      if op_ty.kind != TypeKind.I64
        out.push(ValidationError(
          message = "Opérande non i64 pour " + unop_name(op) + ": " + type_name(op_ty),
          span = inst.span,
        ))
      end
      if inst.ty.kind != TypeKind.I64
        out.push(ValidationError(
          message = "Type de résultat inattendu pour " + unop_name(op) + ": " + type_name(inst.ty),
          span = inst.span,
        ))
      end
    UnOp.Not ->
      if op_ty.kind != TypeKind.Bool
        out.push(ValidationError(
          message = "Opérande non bool pour " + unop_name(op) + ": " + type_name(op_ty),
          span = inst.span,
        ))
      end
      if inst.ty.kind != TypeKind.Bool
        out.push(ValidationError(
          message = "Type de résultat inattendu pour " + unop_name(op) + ": " + type_name(inst.ty),
          span = inst.span,
        ))
      end
  end
.end

fn validate_tuple_types(inst: Instr, items: coll.Vec[ValueId], types: coll.HashMap[u32, Type], out: &mut coll.Vec[ValidationError]) -> Unit
  if inst.ty.kind != TypeKind.Tuple
    return
  end
  if inst.ty.items.len() != items.len()
    out.push(ValidationError(
      message = "Tuple attendu avec " + str.from_int(inst.ty.items.len() as Int) + " éléments, obtenu " + str.from_int(items.len() as Int),
      span = inst.span,
    ))
    return
  end
  let i = 0usize
  while i < items.len()
    let item_ty = type_for_value(types, items[i])
    let expected = inst.ty.items[i]
    if expected.kind != TypeKind.Unknown and item_ty.kind != TypeKind.Unknown and not types_equal(expected, item_ty)
      out.push(ValidationError(
        message = "Type d’élément de tuple inattendu: " + type_name(item_ty) + " au lieu de " + type_name(expected),
        span = inst.span,
      ))
    end
    i = i + 1usize
  end
.end

fn validate_phi_types(inst: Instr, incomings: coll.Vec[(BlockId, ValueId)], types: coll.HashMap[u32, Type], out: &mut coll.Vec[ValidationError]) -> Unit
  if incomings.len() == 0
    return
  end

  let expected = type_for_value(types, incomings[0].1)

  let i = 0usize
  while i < incomings.len()
    let inc = incomings[i]
    let ty = type_for_value(types, inc.1)
    if expected.kind != TypeKind.Unknown and ty.kind != TypeKind.Unknown and not types_equal(expected, ty)
      out.push(ValidationError(
        message = "Phi avec types incohérents: " + type_name(expected) + " vs " + type_name(ty),
        span = inst.span,
      ))
    end
    i = i + 1usize
  end

  if expected.kind != TypeKind.Unknown and inst.ty.kind != TypeKind.Unknown and not types_equal(expected, inst.ty)
    out.push(ValidationError(
      message = "Type de sortie du phi " + type_name(inst.ty) + " ne correspond pas aux entrées " + type_name(expected),
      span = inst.span,
    ))
  end
.end

fn validate_types(f: Function, out: &mut coll.Vec[ValidationError]) -> Unit
  let types = collect_value_types(f)
  let bi = 0usize
  while bi < f.blocks.len()
    let b = f.blocks[bi]
    let ii = 0usize
    while ii < b.instrs.len()
      let inst = b.instrs[ii]
      match inst.kind
        InstrKind.BinOp(op = op, lhs = lhs, rhs = rhs) ->
          validate_binop_types(inst, op, lhs, rhs, types, out)
        InstrKind.Phi(incomings = incs) ->
          validate_phi_types(inst, incs, types, out)
        InstrKind.UnOp(op = op, operand = opd) ->
          validate_unop_types(inst, op, opd, types, out)
        InstrKind.ConstString(value = _) ->
          if inst.ty.kind != TypeKind.Str
            out.push(ValidationError(
              message = "Const string doit avoir le type str et non " + type_name(inst.ty),
              span = inst.span,
            ))
          end
        InstrKind.MakeTuple(items = items) ->
          validate_tuple_types(inst, items, types, out)
        _ ->
          pass
      end
      ii = ii + 1usize
    end
    bi = bi + 1usize
  end
.end

fn find_block(blocks: coll.Vec[Block], id: BlockId) -> Block
  let i = 0usize
  while i < blocks.len()
    if blocks[i].id.raw == id.raw
      return blocks[i]
    end
    i = i + 1usize
  end
  return blocks[0]
.end

fn validate_terminator(t: Terminator, blk: Block, block_ids: coll.HashSet[u32], out: &mut coll.Vec[ValidationError]) -> Unit
  match t
    Terminator.Jump(target = tgt) ->
      if not block_ids.contains(tgt.raw)
        out.push(ValidationError(
          message = "Jump cible inconnue depuis " + blk.name,
          span = diag.Span.dummy("<ir>"),
        ))
      end
    Terminator.CondJump(cond = _, then_tgt = tt, else_tgt = et) ->
      if not block_ids.contains(tt.raw) or not block_ids.contains(et.raw)
        out.push(ValidationError(
          message = "CondJump cible inconnue depuis " + blk.name,
          span = diag.Span.dummy("<ir>"),
        ))
      end
    Terminator.Return(value = _) ->
      pass
  end
.end
