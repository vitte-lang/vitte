module vitte.compiler.ir.builder

import std.collections as coll
import std.string as str
import vitte.compiler.frontend.ast as ast
import vitte.compiler.frontend.diagnostics as diag
import vitte.compiler.ir as ir

# -----------------------------------------------------------------------------
# Résultat de construction
# -----------------------------------------------------------------------------

pub struct BuildResult
  program: ir.Program
  diagnostics: coll.Vec[diag.Diagnostic]
.end

pub fn build_program(modules: coll.Vec[ast.Module]) -> BuildResult
  let diags = coll.Vec[diag.Diagnostic].new()
  let irmods = coll.Vec[ir.Module].new()
  let midx = 0usize
  while midx < modules.len()
    let m = modules[midx]
    let irm = build_module(m, &mut diags)
    irmods.push(irm)
    midx = midx + 1usize
  end
  let prog = ir.Program(modules = irmods)
  return BuildResult(program = prog, diagnostics = diags)
.end

fn build_module(m: ast.Module, diags: &mut coll.Vec[diag.Diagnostic]) -> ir.Module
  let funcs = coll.Vec[ir.Function].new()
  let i = 0usize
  while i < m.items.len()
    let item = m.items[i]
    if item.kind == ast.ModuleItemKind.FnDecl and item.fn_decl.is_some()
      let fdecl = item.fn_decl.unwrap()
      let f = build_function(m, fdecl, diags)
      funcs.push(f)
    end
    i = i + 1usize
  end
  return ir.Module(name = m.file, functions = funcs)
.end

struct FuncCtx
  func: ir.Function
  next_block: u32
  next_instr: u32
  next_value: u32
  cur_block: ir.BlockId
  env: coll.HashMap[String, ir.ValueId]
  vars: coll.Vec[String]
  value_types: coll.HashMap[u32, ir.Type]
.end

fn remember_value_type(table: coll.HashMap[u32, ir.Type], vid: ir.ValueId, ty: ir.Type) -> coll.HashMap[u32, ir.Type]
  let map = table
  map.insert(vid.raw, ty)
  return map
.end

fn value_type_or_unknown(table: coll.HashMap[u32, ir.Type], vid: ir.ValueId) -> ir.Type
  if table.contains_key(vid.raw)
    return table[vid.raw]
  end
  return ir.Type.unknown()
.end

fn resolve_symbol_type(m: ast.Module, name: String, annot: Option[ast.TypeExpr]) -> ir.Type
  if annot.is_some()
    return map_type(m, annot)
  end
  if m.get_symbol_type(name).is_some()
    return map_type(m, m.get_symbol_type(name))
  end
  return ir.Type.unknown()
.end

fn resolve_return_type(m: ast.Module, f: ast.FnDecl) -> ir.Type
  if f.return_type.is_some()
    return map_type(m, f.return_type)
  end
  if m.get_return_type(f.name.name).is_some()
    return map_type(m, m.get_return_type(f.name.name))
  end
  return ir.Type.unknown()
.end

fn type_from_expr_info(m: ast.Module, eid: ast.ExprId) -> ir.Type
  if m.get_expr_type(eid).is_some()
    return map_type(m, m.get_expr_type(eid))
  end
  return ir.Type.unknown()
.end

fn build_function(m: ast.Module, fdecl: ast.FnDecl, diags: &mut coll.Vec[diag.Diagnostic]) -> ir.Function
  let params = coll.Vec[ir.Param].new()
  let pi = 0usize
  let env = coll.HashMap[String, ir.ValueId].new()
  let vars = coll.Vec[String].new()
  let types = coll.HashMap[u32, ir.Type].new()
  while pi < fdecl.params.len()
    let p = fdecl.params[pi]
    let vid = ir.ValueId(raw = pi as u32)
    let pty = resolve_symbol_type(m, p.name.name, p.ty)
    params.push(ir.Param(
      name = p.name.name,
      ty = pty,
      value = vid,
      span = p.span,
    ))
    env.insert(p.name.name, vid)
    vars.push(p.name.name)
    types.insert(vid.raw, pty)
    pi = pi + 1usize
  end

  let entry_id = ir.BlockId(raw = 0u32)
  let entry = ir.Block(
    id = entry_id,
    name = "entry",
    instrs = coll.Vec[ir.Instr].new(),
    terminator = None,
  )

  let blocks = coll.Vec[ir.Block].new()
  blocks.push(entry)

  let func = ir.Function(
    name = fdecl.name.name,
    params = params,
    ret_type = resolve_return_type(m, fdecl),
    blocks = blocks,
    entry = entry_id,
    span = fdecl.span,
  )

  let ctx = FuncCtx(
    func = func,
    next_block = 1u32,
    next_instr = 0u32,
    next_value = fdecl.params.len() as u32,
    cur_block = entry_id,
    env = env,
    vars = vars,
    value_types = types,
  )

  let ctx2 = build_body(m, ctx, fdecl.body, diags)
  let f2 = ctx2.func
  return f2
.end

fn build_body(m: ast.Module, ctx: FuncCtx, body: Option[ast.BlockId], diags: &mut coll.Vec[diag.Diagnostic]) -> FuncCtx
  if body.is_none()
    return ctx
  end
  let blk_id = body.unwrap()
  let blk = m.get_block(blk_id)
  return lower_block(m, ctx, blk, diags)
.end

fn lower_block(m: ast.Module, ctx: FuncCtx, blk: ast.Block, diags: &mut coll.Vec[diag.Diagnostic]) -> FuncCtx
  let i = 0usize
  let stmts = blk.stmts
  let cur = ctx
  let out = lower_stmt_loop(m, cur, stmts, i, diags)
  return ensure_terminator(out, blk.span)
.end

fn clone_env(env: coll.HashMap[String, ir.ValueId], vars: coll.Vec[String]) -> coll.HashMap[String, ir.ValueId]
  let new_env = coll.HashMap[String, ir.ValueId].new()
  let i = 0usize
  while i < vars.len()
    let name = vars[i]
    if env.contains_key(name)
      let v = env[name]
      new_env.insert(name, v)
    end
    i = i + 1usize
  end
  return new_env
.end

fn clone_vars(vars: coll.Vec[String]) -> coll.Vec[String]
  let out = coll.Vec[String].new()
  let i = 0usize
  while i < vars.len()
    out.push(vars[i])
    i = i + 1usize
  end
  return out
.end

fn lower_stmt_loop(m: ast.Module, ctx: FuncCtx, stmts: coll.Vec[ast.StmtId], idx: usize, diags: &mut coll.Vec[diag.Diagnostic]) -> FuncCtx
  let i = idx
  let cur = ctx
  let len = stmts.len()
  let out = loop_inner(m, cur, stmts, i, len, diags)
  return out
.end

fn insert_binding(ctx: FuncCtx, name: String, val: ir.ValueId) -> FuncCtx
  let env2 = ctx.env
  env2.insert(name, val)
  let vars2 = ctx.vars
  if not contains_var(vars2, name)
    vars2.push(name)
  end
  return FuncCtx(
    func = ctx.func,
    next_block = ctx.next_block,
    next_instr = ctx.next_instr,
    next_value = ctx.next_value,
    cur_block = ctx.cur_block,
    env = env2,
    vars = vars2,
    value_types = ctx.value_types,
  )
.end

fn contains_var(vars: coll.Vec[String], name: String) -> Bool
  let i = 0usize
  while i < vars.len()
    if vars[i] == name
      return true
    end
    i = i + 1usize
  end
  return false
.end

fn loop_inner(m: ast.Module, ctx: FuncCtx, stmts: coll.Vec[ast.StmtId], start: usize, len: usize, diags: &mut coll.Vec[diag.Diagnostic]) -> FuncCtx
  let i = start
  let cur = ctx
  while i < len
    let sid = stmts[i]
    let stmt = m.get_stmt(sid)
    let next = lower_stmt(m, cur, stmt, diags)
    if block_finished(next)
      return next
    end
    cur = next
    i = i + 1usize
  end
  return cur
.end

fn block_finished(ctx: FuncCtx) -> Bool
  let b = current_block_mut(ctx.func, ctx.cur_block)
  return b.terminator.is_some()
.end

fn lower_stmt(m: ast.Module, ctx: FuncCtx, stmt: ast.Stmt, diags: &mut coll.Vec[diag.Diagnostic]) -> FuncCtx
  match stmt.kind
    ast.StmtKind.Return(value = val_opt) ->
      let pair =
        if val_opt.is_some()
          lower_expr(ctx, m, val_opt.unwrap(), diags)
        else
          (ctx, None)
        end
      let ctx2 = pair.0
      let vopt = pair.1
      let term = ir.Terminator.Return(value = vopt)
      return set_terminator(ctx2, term)
    ast.StmtKind.Expr(expr = eid) ->
      let pair = lower_expr(ctx, m, eid, diags)
      return pair.0
    ast.StmtKind.Let(name = ident, mutable = _, ty = annot, value = val_opt) ->
      let pair =
        if val_opt.is_some()
          lower_expr(ctx, m, val_opt.unwrap(), diags)
        else
          fresh_unit(ctx, stmt.span)
        end
      let ctx2 = pair.0
      let val = pair.1.unwrap()
      let ctx3 = insert_binding(ctx2, ident.name, val)
      let declared_ty = resolve_symbol_type(m, ident.name, annot)
      let inferred_ty = value_type_or_unknown(ctx2.value_types, val)
      let final_ty = if declared_ty.kind != ir.TypeKind.Unknown then declared_ty else inferred_ty end
      let updated_types = remember_value_type(ctx3.value_types, val, final_ty)
      return FuncCtx(
        func = ctx3.func,
        next_block = ctx3.next_block,
        next_instr = ctx3.next_instr,
        next_value = ctx3.next_value,
        cur_block = ctx3.cur_block,
        env = ctx3.env,
        vars = ctx3.vars,
        value_types = updated_types,
      )
    ast.StmtKind.If(cond = cexpr, then_block = tblk, else_block = eblk) ->
      return lower_if(ctx, m, cexpr, tblk, eblk, stmt.span, diags)
    ast.StmtKind.While(cond = cexpr, body = bblk) ->
      return lower_while(ctx, m, cexpr, bblk, stmt.span, diags)
    _ ->
      # Fallback : NOP
      return ctx
  end
.end

fn lower_if(ctx: FuncCtx, m: ast.Module, cond_expr: ast.ExprId, then_block: ast.BlockId, else_block: Option[ast.BlockId], span: diag.Span, diags: &mut coll.Vec[diag.Diagnostic]) -> FuncCtx
  let pair = lower_expr(ctx, m, cond_expr, diags)
  let ctx1 = pair.0
  let cond_val = pair.1.unwrap()

  let then_id = fresh_block_id(ctx1)
  let else_id = fresh_block_id(then_id.0)
  let join_id = fresh_block_id(else_id.0)

  let base_env = clone_env(ctx1.env, ctx1.vars)
  let base_vars = clone_vars(ctx1.vars)

  let ctx_after_blocks = join_id.0
  let then_ctx = with_block_env(ctx_after_blocks, then_id.1, clone_env(base_env, base_vars), clone_vars(base_vars))
  let lowered_then = lower_block(m, then_ctx, m.get_block(then_block), diags)
  let after_then = ensure_jump(lowered_then, join_id.1)

  let ctx_for_else = after_then
  let else_start = with_block_env(ctx_for_else, else_id.1, clone_env(base_env, base_vars), clone_vars(base_vars))
  let lowered_else =
    if else_block.is_some()
      lower_block(m, else_start, m.get_block(else_block.unwrap()), diags)
    else
      else_start
    end
  let after_else = ensure_jump(lowered_else, join_id.1)

  let term = ir.Terminator.CondJump(
    cond = cond_val,
    then_tgt = then_id.1,
    else_tgt = else_id.1,
  )
  let ctx_with_term = set_terminator(ctx1, term)

  let join_ctx = FuncCtx(
    func = after_else.func,
    next_block = after_else.next_block,
    next_instr = after_else.next_instr,
    next_value = after_else.next_value,
    cur_block = join_id.1,
    env = coll.HashMap[String, ir.ValueId].new(),
    vars = base_vars,
    value_types = after_else.value_types,
  )

  let merged = merge_envs(join_ctx, after_then.env, after_else.env, then_id.1, else_id.1)
  return merged
.end

fn lower_while(ctx: FuncCtx, m: ast.Module, cond_expr: ast.ExprId, body_block: ast.BlockId, span: diag.Span, diags: &mut coll.Vec[diag.Diagnostic]) -> FuncCtx
  let head_id = fresh_block_id(ctx)
  let body_id = fresh_block_id(head_id.0)
  let exit_id = fresh_block_id(body_id.0)

  let pre_block = ctx.cur_block
  let ctx0 = set_terminator(ctx, ir.Terminator.Jump(target = head_id.1))

  let base_vars = clone_vars(ctx.vars)
  let base_env = clone_env(ctx.env, base_vars)

  let head_start = with_block_env(ctx0, head_id.1, clone_env(base_env, base_vars), clone_vars(base_vars))

  let phi_records = coll.Vec[(ir.ValueId, String)].new()
  let phi_env = coll.HashMap[String, ir.ValueId].new()
  let i = 0usize
  let current_ctx = head_start
  while i < base_vars.len()
    let name = base_vars[i]
    if base_env.contains_key(name)
      let incoming_pre = base_env[name]
      let incomings = coll.Vec[(ir.BlockId, ir.ValueId)].new()
      incomings.push((pre_block, incoming_pre))
      incomings.push((body_id.1, incoming_pre))
      let pair = emit_phi(current_ctx, incomings, ir.Type.unknown(), span)
      let ctx_phi = pair.0
      let vphi = pair.1.unwrap()
      phi_env.insert(name, vphi)
      phi_records.push((vphi, name))
      current_ctx = ctx_phi
    end
    i = i + 1usize
  end

  let head_ctx = FuncCtx(
    func = current_ctx.func,
    next_block = current_ctx.next_block,
    next_instr = current_ctx.next_instr,
    next_value = current_ctx.next_value,
    cur_block = head_id.1,
    env = phi_env,
    vars = current_ctx.vars,
  )

  let pair = lower_expr(head_ctx, m, cond_expr, diags)
  let cond_ctx = pair.0
  let cond_val = pair.1.unwrap()
  let head_term = ir.Terminator.CondJump(
    cond = cond_val,
    then_tgt = body_id.1,
    else_tgt = exit_id.1,
  )
  let cond_done = set_terminator(cond_ctx, head_term)

  let body_ctx = with_block_env(cond_done, body_id.1, clone_env(head_ctx.env, head_ctx.vars), head_ctx.vars)
  let lowered_body = lower_block(m, body_ctx, m.get_block(body_block), diags)
  let body_back = ensure_jump(lowered_body, head_id.1)

  let patched_func = patch_loop_phis(body_back.func, head_id.1, phi_records, body_back.env, body_id.1)

  let out_ctx = FuncCtx(
    func = patched_func,
    next_block = body_back.next_block,
    next_instr = body_back.next_instr,
    next_value = body_back.next_value,
    cur_block = exit_id.1,
    env = head_ctx.env,
    vars = head_ctx.vars,
    value_types = body_back.value_types,
  )
  return out_ctx
.end

fn merge_envs(ctx: FuncCtx, then_env: coll.HashMap[String, ir.ValueId], else_env: coll.HashMap[String, ir.ValueId], then_bid: ir.BlockId, else_bid: ir.BlockId) -> FuncCtx
  let env_out = coll.HashMap[String, ir.ValueId].new()
  let vars_out = ctx.vars
  let current_ctx = ctx
  let i = 0usize
  while i < vars_out.len()
    let name = vars_out[i]
    let has_then = then_env.contains_key(name)
    let has_else = else_env.contains_key(name)
    if has_then and has_else
      let vt = then_env[name]
      let ve = else_env[name]
      if vt.raw == ve.raw
        env_out.insert(name, vt)
      else
        let incomings = coll.Vec[(ir.BlockId, ir.ValueId)].new()
        incomings.push((then_bid, vt))
        incomings.push((else_bid, ve))
        let pair = emit_phi(current_ctx, incomings, ir.Type.unknown(), diag.Span.dummy("<phi>"))
        let ctx_phi = pair.0
        let val_phi = pair.1.unwrap()
        env_out.insert(name, val_phi)
        current_ctx = ctx_phi
      end
    elif has_then
      env_out.insert(name, then_env[name])
    elif has_else
      env_out.insert(name, else_env[name])
    end
    i = i + 1usize
  end
  return FuncCtx(
    func = current_ctx.func,
    next_block = current_ctx.next_block,
    next_instr = current_ctx.next_instr,
    next_value = current_ctx.next_value,
    cur_block = ctx.cur_block,
    env = env_out,
    vars = vars_out,
    value_types = current_ctx.value_types,
  )
.end

fn ensure_jump(ctx: FuncCtx, target: ir.BlockId) -> FuncCtx
  if block_finished(ctx)
    return ctx
  end
  return set_terminator(ctx, ir.Terminator.Jump(target = target))
.end

fn ensure_terminator(ctx: FuncCtx, span: diag.Span) -> FuncCtx
  if block_finished(ctx)
    return ctx
  end
  return set_terminator(ctx, ir.Terminator.Return(value = None))
.end

fn lower_expr(ctx: FuncCtx, m: ast.Module, eid: ast.ExprId, diags: &mut coll.Vec[diag.Diagnostic]) -> (FuncCtx, Option[ir.ValueId])
  let expr = m.get_expr(eid)
  match expr.kind
    ast.ExprKind.IntLiteral(value = v) ->
      return emit_instr(ctx, ir.InstrKind.ConstInt(value = v), ir.Type.i64(), expr.span)
    ast.ExprKind.BoolLiteral(value = b) ->
      return emit_instr(ctx, ir.InstrKind.ConstBool(value = b), ir.Type.bool(), expr.span)
    ast.ExprKind.StringLiteral(value = s) ->
      let ty = type_from_expr_info(m, eid)
      let inferred = if ty.kind == ir.TypeKind.Unknown then ir.Type.str() else ty end
      return emit_instr(ctx, ir.InstrKind.ConstString(value = s), inferred, expr.span)
    ast.ExprKind.TupleLiteral(items = items) ->
      let vals = coll.Vec[ir.ValueId].new()
      let i = 0usize
      let cur_ctx = ctx
      while i < items.len()
        let pair = lower_expr(cur_ctx, m, items[i], diags)
        cur_ctx = pair.0
        let v = pair.1.unwrap()
        vals.push(v)
        i = i + 1usize
      end
      let ty_info = type_from_expr_info(m, eid)
      let tuple_ty =
        if ty_info.kind != ir.TypeKind.Unknown
          ty_info
        else
          let mapped = coll.Vec[ir.Type].new()
          let j = 0usize
          while j < vals.len()
            mapped.push(value_type_or_unknown(cur_ctx.value_types, vals[j]))
            j = j + 1usize
          end
          ir.Type.tuple(mapped)
        end
      return emit_instr(cur_ctx, ir.InstrKind.MakeTuple(items = vals), tuple_ty, expr.span)
    ast.ExprKind.Name(ident = id) ->
      if ctx.env.contains_key(id.name)
        let val = ctx.env[id.name]
        return (ctx, Some(val))
      end
      if m.get_symbol_type(id.name).is_some()
        # Unknown SSA value, mais type connu : erreur de nom non résolu.
        pass
      end
      let diag = diag.Diagnostic(
        message = "Nom non résolu: " + id.name,
        span = id.span,
        severity = diag.Severity.Error,
        code = diag.code_for_message("E0000"),
        labels = coll.Vec[diag.DiagnosticLabel].new(),
      )
      diags.push(diag)
      return (ctx, None)
    ast.ExprKind.PathName(path = p) ->
      if p.len() == 1 and ctx.env.contains_key(p[0].name)
        let val = ctx.env[p[0].name]
        return (ctx, Some(val))
      end
      let diag = diag.Diagnostic(
        message = "Nom non résolu: " + (if p.len() > 0 then p[0].name else "<empty>"),
        span = expr.span,
        severity = diag.Severity.Error,
        code = diag.code_for_message("E0000"),
        labels = coll.Vec[diag.DiagnosticLabel].new(),
      )
      diags.push(diag)
      return (ctx, None)
    ast.ExprKind.Unary(op = op, operand = operand) ->
      let pair = lower_expr(ctx, m, operand, diags)
      let ctx_op = pair.0
      let vop = pair.1.unwrap()
      let uop = map_unop(op)
      let opd_ty = value_type_or_unknown(ctx_op.value_types, vop)
      let inferred = type_from_expr_info(m, eid)
      let res_ty =
        if inferred.kind != ir.TypeKind.Unknown
          inferred
        else
          unop_result_type(uop, opd_ty)
        end
      return emit_instr(ctx_op, ir.InstrKind.UnOp(op = uop, operand = vop), res_ty, expr.span)
    ast.ExprKind.Binary(op = op, lhs = l, rhs = r) ->
      let pair_l = lower_expr(ctx, m, l, diags)
      let ctx_l = pair_l.0
      let lhs = pair_l.1.unwrap()
      let pair_r = lower_expr(ctx_l, m, r, diags)
      let ctx_r = pair_r.0
      let rhs = pair_r.1.unwrap()
      let bop = map_binop(op)
      let lhs_ty = value_type_or_unknown(ctx_l.value_types, lhs)
      let rhs_ty = value_type_or_unknown(ctx_r.value_types, rhs)
      let merged_ty = merge_types(lhs_ty, rhs_ty)
      let annotated = type_from_expr_info(m, eid)
      let res_ty =
        if annotated.kind != ir.TypeKind.Unknown
          annotated
        else
          binop_result_type(bop, merged_ty, merged_ty)
        end
      return emit_instr(ctx_r, ir.InstrKind.BinOp(op = bop, lhs = lhs, rhs = rhs), res_ty, expr.span)
    ast.ExprKind.Call(callee = c, args = args) ->
      let arg_vals = coll.Vec[ir.ValueId].new()
      let i = 0usize
      let cur_ctx = ctx
      while i < args.len()
        let pair = lower_expr(cur_ctx, m, args[i], diags)
        cur_ctx = pair.0
        arg_vals.push(pair.1.unwrap())
        i = i + 1usize
      end
      let callee_expr = m.get_expr(c)
      let callee_name =
        match callee_expr.kind
          ast.ExprKind.PathName(path = p) ->
            if p.len() > 0 then p[0].name else "<anon>"
          ast.ExprKind.Name(ident = id) ->
            id.name
          _ ->
            "<anon>"
        end
      let annotated = type_from_expr_info(m, eid)
      let call_ty = if annotated.kind == ir.TypeKind.Unknown then ir.Type.unknown() else annotated end
      return emit_instr(cur_ctx, ir.InstrKind.Call(callee = callee_name, args = arg_vals), call_ty, expr.span)
    ast.ExprKind.IfExpr(cond = c, then_block = tb, else_block = eb) ->
      # On réutilise le lowering des statements if pour l'effet, retourne unit.
      let dummy_stmt = ast.Stmt(
        kind = ast.StmtKind.If(cond = c, then_block = tb, else_block = eb),
        span = expr.span,
      )
      let ctx_after = lower_stmt(m, ctx, dummy_stmt, diags)
      return fresh_unit(ctx_after, expr.span)
    _ ->
      return fresh_unit(ctx, expr.span)
  end
.end

fn map_binop(op: ast.BinaryOp) -> ir.BinOp
  match op
    ast.BinaryOp.Add -> return ir.BinOp.Add
    ast.BinaryOp.Sub -> return ir.BinOp.Sub
    ast.BinaryOp.Mul -> return ir.BinOp.Mul
    ast.BinaryOp.Div -> return ir.BinOp.Div
    ast.BinaryOp.Eq  -> return ir.BinOp.Eq
    ast.BinaryOp.Ne  -> return ir.BinOp.Ne
    ast.BinaryOp.Lt  -> return ir.BinOp.Lt
    ast.BinaryOp.Le  -> return ir.BinOp.Le
    ast.BinaryOp.Gt  -> return ir.BinOp.Gt
    ast.BinaryOp.Ge  -> return ir.BinOp.Ge
    _ -> return ir.BinOp.Add
  end
.end

fn map_unop(op: ast.UnaryOp) -> ir.UnOp
  match op
    ast.UnaryOp.Neg -> return ir.UnOp.Neg
    ast.UnaryOp.Not -> return ir.UnOp.Not
  end
.end

fn same_type(a: ir.Type, b: ir.Type) -> Bool
  return a.kind == b.kind and a.name == b.name
.end

fn merge_types(a: ir.Type, b: ir.Type) -> ir.Type
  if a.kind == ir.TypeKind.Unknown
    return b
  end
  if b.kind == ir.TypeKind.Unknown
    return a
  end
  if same_type(a, b)
    return a
  end
  return ir.Type.unknown()
.end

fn infer_phi_type(ctx: FuncCtx, incomings: coll.Vec[(ir.BlockId, ir.ValueId)]) -> ir.Type
  let acc = ir.Type.unknown()
  let i = 0usize
  while i < incomings.len()
    let inc = incomings[i]
    let ty = value_type_or_unknown(ctx.value_types, inc.1)
    acc = merge_types(acc, ty)
    i = i + 1usize
  end
  return acc
.end

fn binop_result_type(op: ir.BinOp, lhs: ir.Type, rhs: ir.Type) -> ir.Type
  match op
    ir.BinOp.Add -> return lhs
    ir.BinOp.Sub -> return lhs
    ir.BinOp.Mul -> return lhs
    ir.BinOp.Div -> return lhs
    ir.BinOp.Eq  -> return ir.Type.bool()
    ir.BinOp.Ne  -> return ir.Type.bool()
    ir.BinOp.Lt  -> return ir.Type.bool()
    ir.BinOp.Le  -> return ir.Type.bool()
    ir.BinOp.Gt  -> return ir.Type.bool()
    ir.BinOp.Ge  -> return ir.Type.bool()
  end
.end

fn unop_result_type(op: ir.UnOp, operand: ir.Type) -> ir.Type
  match op
    ir.UnOp.Neg -> return operand
    ir.UnOp.Not -> return ir.Type.bool()
  end
.end

fn fresh_unit(ctx: FuncCtx, span: diag.Span) -> (FuncCtx, Option[ir.ValueId])
  return emit_instr(ctx, ir.InstrKind.ConstInt(value = "0"), ir.Type.unit(), span)
.end

fn map_type(m: ast.Module, t: Option[ast.TypeExpr]) -> ir.Type
  if t.is_none()
    return ir.Type.unknown()
  end
  let texpr = t.unwrap()
  match texpr.kind
    ast.TypeExprKind.Unit ->
      return ir.Type.unit()
    ast.TypeExprKind.Tuple(items = items) ->
      let mapped = coll.Vec[ir.Type].new()
      let i = 0usize
      while i < items.len()
        mapped.push(map_type(m, Some(items[i])))
        i = i + 1usize
      end
      return ir.Type.tuple(mapped)
    ast.TypeExprKind.Named(path = p) ->
      if p.len() == 0
        return ir.Type.unknown()
      end
      let name = p[0].name
      if name == "i64"
        return ir.Type.i64()
      elif name == "bool"
        return ir.Type.bool()
      elif name == "unit"
        return ir.Type.unit()
      elif name == "str"
        return ir.Type.str()
      end
      return ir.Type(kind = ir.TypeKind.Unknown, name = name, items = coll.Vec[ir.Type].new())
    _ ->
      return ir.Type.unknown()
  end
.end

fn emit_instr(ctx: FuncCtx, kind: ir.InstrKind, ty: ir.Type, span: diag.Span) -> (FuncCtx, Option[ir.ValueId])
  let vid = ir.ValueId(raw = ctx.next_value)
  let iid = ir.InstrId(raw = ctx.next_instr)
  let instr = ir.Instr(
    id = iid,
    kind = kind,
    ty = ty,
    span = span,
    result = vid,
  )
  let func = ctx.func
  let blk = current_block_mut(func, ctx.cur_block)
  blk.instrs.push(instr)
  let func2 = update_block(func, blk)
  let types = remember_value_type(ctx.value_types, vid, ty)
  let next_ctx = FuncCtx(
    func = func2,
    next_block = ctx.next_block,
    next_instr = ctx.next_instr + 1u32,
    next_value = ctx.next_value + 1u32,
    cur_block = ctx.cur_block,
    env = ctx.env,
    vars = ctx.vars,
    value_types = types,
  )
  return (next_ctx, Some(vid))
.end

fn emit_phi(ctx: FuncCtx, incomings: coll.Vec[(ir.BlockId, ir.ValueId)], ty: ir.Type, span: diag.Span) -> (FuncCtx, Option[ir.ValueId])
  let kind = ir.InstrKind.Phi(incomings = incomings)
  let phi_ty =
    if ty.kind == ir.TypeKind.Unknown
      infer_phi_type(ctx, incomings)
    else
      ty
    end
  return emit_instr(ctx, kind, phi_ty, span)
.end

fn set_terminator(ctx: FuncCtx, term: ir.Terminator) -> FuncCtx
  let func = ctx.func
  let blk = current_block_mut(func, ctx.cur_block)
  blk.terminator =
    if blk.terminator.is_some()
      blk.terminator
    else
      Some(term)
    end
  let func2 = update_block(func, blk)
  return FuncCtx(
    func = func2,
    next_block = ctx.next_block,
    next_instr = ctx.next_instr,
    next_value = ctx.next_value,
    cur_block = ctx.cur_block,
    env = ctx.env,
    vars = ctx.vars,
    value_types = ctx.value_types,
  )
.end

fn fresh_block_id(ctx: FuncCtx) -> (FuncCtx, ir.BlockId)
  let id = ir.BlockId(raw = ctx.next_block)
  let blk = ir.Block(
    id = id,
    name = "bb" + str.from_int(id.raw as Int),
    instrs = coll.Vec[ir.Instr].new(),
    terminator = None,
  )
  let func = ctx.func
  func.blocks.push(blk)
  let next_ctx = FuncCtx(
    func = func,
    next_block = ctx.next_block + 1u32,
    next_instr = ctx.next_instr,
    next_value = ctx.next_value,
    cur_block = ctx.cur_block,
    env = ctx.env,
    vars = ctx.vars,
    value_types = ctx.value_types,
  )
  return (next_ctx, id)
.end

fn with_block(ctx: FuncCtx, bid: ir.BlockId) -> FuncCtx
  return FuncCtx(
    func = ctx.func,
    next_block = ctx.next_block,
    next_instr = ctx.next_instr,
    next_value = ctx.next_value,
    cur_block = bid,
    env = ctx.env,
    vars = ctx.vars,
    value_types = ctx.value_types,
  )
.end

fn with_block_env(ctx: FuncCtx, bid: ir.BlockId, env: coll.HashMap[String, ir.ValueId], vars: coll.Vec[String]) -> FuncCtx
  return FuncCtx(
    func = ctx.func,
    next_block = ctx.next_block,
    next_instr = ctx.next_instr,
    next_value = ctx.next_value,
    cur_block = bid,
    env = env,
    vars = vars,
    value_types = ctx.value_types,
  )
.end

fn patch_loop_phis(func: ir.Function, head: ir.BlockId, records: coll.Vec[(ir.ValueId, String)], body_env: coll.HashMap[String, ir.ValueId], body_bid: ir.BlockId) -> ir.Function
  let blocks = func.blocks
  let i = 0usize
  while i < blocks.len()
    let blk = blocks[i]
    if blk.id.raw == head.raw
      let instrs = blk.instrs
      let j = 0usize
      while j < instrs.len()
        let inst = instrs[j]
        match inst.kind
          ir.InstrKind.Phi(incomings = inc) ->
            let mut_incomings = inc
            let k = 0usize
            while k < records.len()
              let rec = records[k]
              if rec.0.raw == inst.result.raw
                if body_env.contains_key(rec.1) and mut_incomings.len() >= 2
                  mut_incomings[1] = (body_bid, body_env[rec.1])
                end
              end
              k = k + 1usize
            end
            let new_inst = ir.Instr(
              id = inst.id,
              kind = ir.InstrKind.Phi(incomings = mut_incomings),
              ty = inst.ty,
              span = inst.span,
              result = inst.result,
            )
            instrs[j] = new_inst
          _ ->
            pass
        end
        j = j + 1usize
      end
      let new_blk = ir.Block(
        id = blk.id,
        name = blk.name,
        instrs = instrs,
        terminator = blk.terminator,
      )
      blocks[i] = new_blk
    end
    i = i + 1usize
  end
  let out_func = ir.Function(
    name = func.name,
    params = func.params,
    ret_type = func.ret_type,
    blocks = blocks,
    entry = func.entry,
    span = func.span,
  )
  return out_func
.end

fn current_block_mut(func: ir.Function, id: ir.BlockId) -> ir.Block
  let i = 0usize
  while i < func.blocks.len()
    let b = func.blocks[i]
    if b.id.raw == id.raw
      return b
    end
    i = i + 1usize
  end
  return func.blocks[0]
.end

fn update_block(func: ir.Function, blk: ir.Block) -> ir.Function
  let i = 0usize
  while i < func.blocks.len()
    if func.blocks[i].id.raw == blk.id.raw
      func.blocks[i] = blk
      return func
    end
    i = i + 1usize
  end
  return func
.end
