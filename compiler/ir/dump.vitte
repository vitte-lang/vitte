module vitte.compiler.ir.dump

import std.collections as coll
import std.string as str
import vitte.compiler.ir.ir as ir

fn join_with(parts: coll.Vec[String], sep: String) -> String
  let out = ""
  let i = 0usize
  while i < parts.len()
    out = out + parts[i]
    if i + 1usize < parts.len()
      out = out + sep
    end
    i = i + 1usize
  end
  return out
.end

fn fmt_type(t: ir.Type) -> String
  return ir.type_name(t)
.end

fn fmt_value(v: ir.ValueId) -> String
  return "%" + str.from_int(v.raw as Int)
.end

fn fmt_block_id(b: ir.BlockId) -> String
  return "bb" + str.from_int(b.raw as Int)
.end

fn fmt_binop(op: ir.BinOp) -> String
  return ir.binop_name(op)
.end

fn fmt_incomings(incs: coll.Vec[(ir.BlockId, ir.ValueId)]) -> String
  let parts = coll.Vec[String].new()
  let i = 0usize
  while i < incs.len()
    let inc = incs[i]
    parts.push(fmt_block_id(inc.0) + ":" + fmt_value(inc.1))
    i = i + 1usize
  end
  return join_with(parts, ", ")
.end

fn fmt_instr(inst: ir.Instr) -> String
  match inst.kind
    ir.InstrKind.ConstInt(value = v) ->
      return fmt_value(inst.result) + " = const " + v + " : " + fmt_type(inst.ty)
    ir.InstrKind.ConstBool(value = b) ->
      let lit = if b then "true" else "false"
      return fmt_value(inst.result) + " = const " + lit + " : " + fmt_type(inst.ty)
    ir.InstrKind.ConstString(value = v) ->
      return fmt_value(inst.result) + " = const \"" + v + "\" : " + fmt_type(inst.ty)
    ir.InstrKind.Param(index = idx) ->
      return fmt_value(inst.result) + " = param " + str.from_int(idx as Int) + " : " + fmt_type(inst.ty)
    ir.InstrKind.Phi(incomings = incs) ->
      return fmt_value(inst.result) + " = phi [" + fmt_incomings(incs) + "] : " + fmt_type(inst.ty)
    ir.InstrKind.BinOp(op = op, lhs = lhs, rhs = rhs) ->
      return fmt_value(inst.result) + " = " + fmt_binop(op) + " " + fmt_value(lhs) + ", " + fmt_value(rhs) + " : " + fmt_type(inst.ty)
    ir.InstrKind.UnOp(op = op, operand = opd) ->
      return fmt_value(inst.result) + " = " + ir.unop_name(op) + " " + fmt_value(opd) + " : " + fmt_type(inst.ty)
    ir.InstrKind.Call(callee = callee, args = args) ->
      let arg_strings = coll.Vec[String].new()
      let i = 0usize
      while i < args.len()
        arg_strings.push(fmt_value(args[i]))
        i = i + 1usize
      end
      return fmt_value(inst.result) + " = call " + callee + "(" + join_with(arg_strings, ", ") + ") : " + fmt_type(inst.ty)
    ir.InstrKind.MakeTuple(items = items) ->
      let parts = coll.Vec[String].new()
      let i = 0usize
      while i < items.len()
        parts.push(fmt_value(items[i]))
        i = i + 1usize
      end
      return fmt_value(inst.result) + " = tuple (" + join_with(parts, ", ") + ") : " + fmt_type(inst.ty)
  end
.end

fn fmt_terminator(t: ir.Terminator) -> String
  match t
    ir.Terminator.Return(value = vopt) ->
      if vopt.is_some()
        return "ret " + fmt_value(vopt.unwrap())
      end
      return "ret"
    ir.Terminator.Jump(target = tgt) ->
      return "jmp " + fmt_block_id(tgt)
    ir.Terminator.CondJump(cond = c, then_tgt = tt, else_tgt = et) ->
      return "br " + fmt_value(c) + ", " + fmt_block_id(tt) + ", " + fmt_block_id(et)
  end
.end

fn fmt_params(params: coll.Vec[ir.Param]) -> String
  let parts = coll.Vec[String].new()
  let i = 0usize
  while i < params.len()
    let p = params[i]
    parts.push(fmt_value(p.value) + ": " + fmt_type(p.ty))
    i = i + 1usize
  end
  return join_with(parts, ", ")
.end

fn fmt_block(block: ir.Block) -> String
  let lines = coll.Vec[String].new()
  lines.push("  block " + fmt_block_id(block.id) + " (" + block.name + "):")
  let i = 0usize
  while i < block.instrs.len()
    lines.push("    " + fmt_instr(block.instrs[i]))
    i = i + 1usize
  end
  match block.terminator
    Some(term) ->
      lines.push("    " + fmt_terminator(term))
    None ->
      lines.push("    <no terminator>")
  end
  return join_with(lines, "\n")
.end

fn fmt_function(f: ir.Function) -> String
  let head = "fn " + f.name + "(" + fmt_params(f.params) + ") -> " + fmt_type(f.ret_type)
  let lines = coll.Vec[String].new()
  lines.push(head)
  let i = 0usize
  while i < f.blocks.len()
    lines.push(fmt_block(f.blocks[i]))
    i = i + 1usize
  end
  return join_with(lines, "\n")
.end

fn fmt_module(m: ir.Module) -> String
  let lines = coll.Vec[String].new()
  lines.push("module " + m.name)
  let i = 0usize
  while i < m.functions.len()
    lines.push(fmt_function(m.functions[i]))
    i = i + 1usize
  end
  return join_with(lines, "\n\n")
.end

pub fn format_program(p: ir.Program) -> String
  let lines = coll.Vec[String].new()
  let i = 0usize
  while i < p.modules.len()
    lines.push(fmt_module(p.modules[i]))
    i = i + 1usize
  end
  return join_with(lines, "\n\n") + "\n"
.end
