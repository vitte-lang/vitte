module vitte.bootstrap.middle.bt_ir_builder

import vitte.bootstrap.front.bt_ast as ast
import vitte.bootstrap.front.bt_diagnostics as diag

# ============================================================================
# Vitte compiler – IR Builder (AST -> Mid-level IR)
#
# Objectifs :
#   - définir un IR intermédiaire (MidIR) indépendant de l'AST ;
#   - fournir un builder structuré :
#       * build_ir_module(ModuleAst) -> IrBuildResult
#       * IR orienté blocs/valeurs (style 3-adresses, non encore SSA strict) ;
#   - servir de base pour :
#       * optimisations,
#       * backends (LVM, C, etc.),
#       * outils d'analyse statique.
#
# Remarques :
#   - beaucoup de fonctions sont des stubs TODO : la structure globale est
#     prête, mais la sémantique détaillée reste à implémenter ;
#   - toutes les constructions respectent la syntaxe Vitte
#     (blocs ":" + INDENT/DEDENT + ".end").
# ============================================================================

# ----------------------------------------------------------------------------
# Types de base IR
# ----------------------------------------------------------------------------

pub typedef u32 IrIndex

pub struct IrModuleId:
    let raw: u32
.end

pub struct IrFuncId:
    let raw: u32
.end

pub struct IrBlockId:
    let raw: u32
.end

pub struct IrValueId:
    let raw: u32
.end

pub enum IrTypeKind:
    IrUnit
    IrI32
    IrI64
    IrF32
    IrF64
    IrBool
    IrPtr
    IrUnknown
.end

pub struct IrType:
    let kind: IrTypeKind
    let name: String          # pour types nommés / alias, sinon vide
.end

fn IrType.unit() -> IrType:
    let t = IrType(kind = IrTypeKind::IrUnit, name = "")
    return t
.end

fn IrType.i32() -> IrType:
    let t = IrType(kind = IrTypeKind::IrI32, name = "")
    return t
.end

fn IrType.bool() -> IrType:
    let t = IrType(kind = IrTypeKind::IrBool, name = "")
    return t
.end

fn IrType.unknown() -> IrType:
    let t = IrType(kind = IrTypeKind::IrUnknown, name = "")
    return t
.end

# ----------------------------------------------------------------------------
# Instructions IR
# ----------------------------------------------------------------------------

pub enum IrBinOp:
    IrAdd
    IrSub
    IrMul
    IrDiv
    IrMod
    IrAnd
    IrOr
    IrXor
    IrShl
    IrShr
.end

pub enum IrCmpOp:
    IrEq
    IrNe
    IrLt
    IrLe
    IrGt
    IrGe
.end

pub enum IrInstrKind:
    IrNop
    IrConstInt
    IrConstFloat
    IrConstBool
    IrParam
    IrUnary
    IrBinary
    IrCall
    IrLoad
    IrStore
    IrPhi
    IrBranch
    IrCondBranch
    IrReturn
.end

pub struct IrInstr:
    let id: IrIndex
    let kind: IrInstrKind
    let ty: IrType
    let value: IrValueId           # résultat (si applicable)
    let operands: Vec<IrValueId>   # liste d'opérandes
    let extra: String              # info symbolique (nom de fonction, etc.)
    let span: ast.Span
.end

pub struct IrBlock:
    let id: IrBlockId
    let name: String
    let instrs: Vec<IrInstr>
.end

pub struct IrParam:
    let name: String
    let ty: IrType
    let value: IrValueId
.end

pub struct IrFunction:
    let id: IrFuncId
    let name: String
    let params: Vec<IrParam>
    let ret_type: IrType
    let blocks: Vec<IrBlock>
    let entry_block: IrBlockId
.end

pub struct IrModule:
    let id: IrModuleId
    let name: String
    let functions: Vec<IrFunction>
.end

# ----------------------------------------------------------------------------
# Options & erreurs du builder
# ----------------------------------------------------------------------------

pub struct IrBuilderOptions:
    let optimize: Bool             # placeholder pour passes futures
    let ssa_form: Bool             # si true, viser une forme SSA (TODO)
.end

pub fn ir_builder_default_options() -> IrBuilderOptions:
    let opts = IrBuilderOptions(
        optimize = false,
        ssa_form = false
    )
    return opts
.end

pub enum IrBuilderErrorKind:
    IrUnsupported
    IrInternal
    IrTypeMismatch
.end

pub struct IrBuilderError:
    let kind: IrBuilderErrorKind
    let message: String
    let span: ast.Span
.end

pub struct IrBuildResult:
    let module: Option<IrModule>
    let diagnostics: diag.DiagnosticsSink
.end

# ----------------------------------------------------------------------------
# Contexte de construction IR
# ----------------------------------------------------------------------------

pub struct IrFuncEnv:
    let func: IrFunction
    let current_block: IrBlockId
    let next_value: IrIndex
    let next_instr: IrIndex
.end

fn IrFuncEnv.new(IrFuncId id, String name, IrType ret_type, Vec<IrParam> params, IrBlockId entry_block, IrBlock entry) -> IrFuncEnv:
    let blocks = Vec<IrBlock>::new()
    blocks.push(entry)

    let func = IrFunction(
        id = id,
        name = name,
        params = params,
        ret_type = ret_type,
        blocks = blocks,
        entry_block = entry_block
    )

    let env = IrFuncEnv(
        func = func,
        current_block = entry_block,
        next_value = 0u32,
        next_instr = 0u32
    )
    return env
.end

fn IrFuncEnv.fresh_value(IrFuncEnv env) -> (IrFuncEnv, IrValueId):
    let idx = env.next_value + 1u32
    let value = IrValueId(raw = idx)

    let updated = IrFuncEnv(
        func = env.func,
        current_block = env.current_block,
        next_value = idx,
        next_instr = env.next_instr
    )
    return (updated, value)
.end

fn IrFuncEnv.append_instr(IrFuncEnv env, IrInstr instr) -> IrFuncEnv:
    let blocks = env.func.blocks
    let blk_id = env.current_block

    let len = blocks.len()
    let i = 0usize
    while i < len:
        let blk = blocks[i]
        if blk.id.raw == blk_id.raw:
            blk.instrs.push(instr)
            blocks[i] = blk
        .end
        i = i + 1usize
    .end

    let func = IrFunction(
        id = env.func.id,
        name = env.func.name,
        params = env.func.params,
        ret_type = env.func.ret_type,
        blocks = blocks,
        entry_block = env.func.entry_block
    )

    let next_instr = env.next_instr + 1u32
    let updated = IrFuncEnv(
        func = func,
        current_block = env.current_block,
        next_value = env.next_value,
        next_instr = next_instr
    )
    return updated
.end

pub struct IrBuilderContext:
    let opts: IrBuilderOptions
    let diagnostics: diag.DiagnosticsSink
    let module_ast: ast.ModuleAst
    let ir_module: IrModule
.end

fn IrBuilderContext.new(IrBuilderOptions opts, diag.DiagnosticsSink sink, ast.ModuleAst module_ast) -> IrBuilderContext:
    let functions = Vec<IrFunction>::new()
    let module_id = IrModuleId(raw = 0u32)
    let irm = IrModule(
        id = module_id,
        name = module_ast.name.name,
        functions = functions
    )
    let ctx = IrBuilderContext(
        opts = opts,
        diagnostics = sink,
        module_ast = module_ast,
        ir_module = irm
    )
    return ctx
.end

fn IrBuilderContext.report_error(IrBuilderContext ctx, IrBuilderErrorKind kind, String message, ast.Span span) -> IrBuilderContext:
    # On wrappe dans un diagnostic sémantique générique.
    let text = "[IR] " + message
    let diag_err = diag.make_semantic_error(text, span)
    ctx.diagnostics.push(diag_err)
    return ctx
.end

# ----------------------------------------------------------------------------
# API principale
# ----------------------------------------------------------------------------

pub fn build_ir_module(IrBuilderOptions opts, diag.DiagnosticsSink sink, ast.ModuleAst module_ast) -> IrBuildResult:
    let ctx0 = IrBuilderContext.new(opts, sink, module_ast)
    let ctx1 = build_ir_for_module(ctx0)

    let has_errors = ctx1.diagnostics.has_errors()
    if has_errors:
        let none_mod: Option<IrModule> = Option<IrModule>::None()
        let result_err = IrBuildResult(
            module = none_mod,
            diagnostics = ctx1.diagnostics
        )
        return result_err
    .end

    let some_mod: Option<IrModule> = Option<IrModule>::Some(ctx1.ir_module)
    let result_ok = IrBuildResult(
        module = some_mod,
        diagnostics = ctx1.diagnostics
    )
    return result_ok
.end

fn build_ir_for_module(IrBuilderContext ctx) -> IrBuilderContext:
    let items = ctx.module_ast.items
    let len = items.len()
    let i = 0usize
    let current_ctx = ctx

    let out_ctx = build_ir_for_module_loop(current_ctx, items, len)
    return out_ctx
.end

fn build_ir_for_module_loop(IrBuilderContext ctx, Vec<ast.AstNodeId> items, usize len) -> IrBuilderContext:
    let i = 0usize
    let current = ctx

    let final_ctx = build_ir_for_module_loop_inner(current, items, len, i)
    return final_ctx
.end

fn build_ir_for_module_loop_inner(IrBuilderContext ctx, Vec<ast.AstNodeId> items, usize len, usize start) -> IrBuilderContext:
    let i = start
    let current_ctx = ctx

    let result_ctx = build_ir_for_module_iter(current_ctx, items, len, i)
    return result_ctx
.end

fn build_ir_for_module_iter(IrBuilderContext ctx, Vec<ast.AstNodeId> items, usize len, usize start) -> IrBuilderContext:
    let i = start
    let current_ctx = ctx

    while i < len:
        let item_id = items[i]
        let next_ctx = build_ir_for_item(current_ctx, item_id)
        i = i + 1usize
        current_ctx = next_ctx
    .end

    return current_ctx
.end

fn build_ir_for_item(IrBuilderContext ctx, ast.AstNodeId item_id) -> IrBuilderContext:
    let node = ast.lookup_node(ctx.module_ast, item_id)

    if node.kind == ast.AstNodeKind::NodeFunctionDecl:
        let fdecl = ast.lookup_function(ctx.module_ast, node.payload)
        let ctx2 = build_ir_for_function(ctx, fdecl)
        return ctx2
    .end

    # TODO : struct/enum/trait/impl/manifestes Muffin si nécessaire.
    return ctx
.end

# ----------------------------------------------------------------------------
# Construction IR par fonction
# ----------------------------------------------------------------------------

fn build_ir_for_function(IrBuilderContext ctx, ast.FunctionDecl fdecl) -> IrBuilderContext:
    let func_index = ctx.ir_module.functions.len() as u32
    let func_id = IrFuncId(raw = func_index)

    let ret_ty = map_type_to_ir(fdecl.return_type)
    let params = build_ir_params_from_ast(fdecl)

    # Création du bloc d'entrée.
    let entry_block_id = IrBlockId(raw = 0u32)
    let entry_instrs = Vec<IrInstr>::new()
    let entry_block = IrBlock(
        id = entry_block_id,
        name = "entry",
        instrs = entry_instrs
    )

    let env0 = IrFuncEnv.new(
        func_id,
        fdecl.name.name,
        ret_ty,
        params,
        entry_block_id,
        entry_block
    )

    # TODO : générer réellement le corps à partir de fdecl.body.
    let env1 = build_ir_for_block(env0, fdecl.body)

    let func = env1.func

    let funcs = ctx.ir_module.functions
    funcs.push(func)

    let irm = IrModule(
        id = ctx.ir_module.id,
        name = ctx.ir_module.name,
        functions = funcs
    )

    let updated_ctx = IrBuilderContext(
        opts = ctx.opts,
        diagnostics = ctx.diagnostics,
        module_ast = ctx.module_ast,
        ir_module = irm
    )
    return updated_ctx
.end

fn build_ir_params_from_ast(ast.FunctionDecl fdecl) -> Vec<IrParam>:
    let params = Vec<IrParam>::new()
    let ast_params = fdecl.params.params
    let len = ast_params.len()
    let i = 0usize

    let updated_params = build_ir_params_loop(params, ast_params, len, i)
    return updated_params
.end

fn build_ir_params_loop(Vec<IrParam> params, Vec<ast.Parameter> ast_params, usize len, usize start) -> Vec<IrParam>:
    let i = start
    let out = params

    let result = build_ir_params_iter(out, ast_params, len, i)
    return result
.end

fn build_ir_params_iter(Vec<IrParam> params, Vec<ast.Parameter> ast_params, usize len, usize start) -> Vec<IrParam>:
    let out = params
    let i = start

    let result = build_ir_params_iter_inner(out, ast_params, len, i)
    return result
.end

fn build_ir_params_iter_inner(Vec<IrParam> params, Vec<ast.Parameter> ast_params, usize len, usize start) -> Vec<IrParam>:
    let out = params
    let i = start

    while i < len:
        let p = ast_params[i]
        let ty = map_type_to_ir(Some(p.ty))

        # Dans un vrai builder, chaque param obtiendrait un IrValueId dédié.
        let value = IrValueId(raw = i as u32)

        let param = IrParam(
            name = p.name.name,
            ty = ty,
            value = value
        )
        out.push(param)

        i = i + 1usize
    .end

    return out
.end

fn map_type_to_ir(Option<ast.TypeExprId> maybe_ty) -> IrType:
    let has_ty = maybe_ty.is_some()
    if not has_ty:
        return IrType.unit()
    .end

    let _ = maybe_ty.unwrap()
    # TODO : implémenter le mapping réel en consultant les TypeExpr.
    return IrType.unknown()
.end

fn build_ir_for_block(IrFuncEnv env, ast.BlockId block_id) -> IrFuncEnv:
    # TODO : récupérer le bloc AST et itérer sur ses statements.
    let block = ast.lookup_block(block_id)
    let stmts = block.statements
    let len = stmts.len()
    let i = 0usize
    let current_env = env

    let out_env = build_ir_for_block_iter(current_env, stmts, len, i)
    return out_env
.end

fn build_ir_for_block_iter(IrFuncEnv env, Vec<ast.AstNodeId> stmts, usize len, usize start) -> IrFuncEnv:
    let i = start
    let current_env = env

    while i < len:
        let stmt_id = stmts[i]
        let next_env = build_ir_for_stmt(current_env, stmt_id)
        i = i + 1usize
        current_env = next_env
    .end

    return current_env
.end

fn build_ir_for_stmt(IrFuncEnv env, ast.AstNodeId stmt_id) -> IrFuncEnv:
    let stmt = ast.lookup_stmt(stmt_id)

    # TODO : dispatch complet selon stmt.kind (LetDecl, Return, etc.).
    # Pour l'instant, on insère une instruction IR NOP avec un commentaire implicite.

    let pair = IrFuncEnv.fresh_value(env)
    let env2 = pair.0
    let value = pair.1

    let dummy_span = stmt.span

    let instr = IrInstr(
        id = env2.next_instr,
        kind = IrInstrKind::IrNop,
        ty = IrType.unit(),
        value = value,
        operands = Vec<IrValueId>::new(),
        extra = "unimplemented stmt -> NOP",
        span = dummy_span
    )

    let env3 = IrFuncEnv.append_instr(env2, instr)
    return env3
.end

fn build_ir_for_expr(IrFuncEnv env, ast.ExprId expr_id) -> (IrFuncEnv, IrValueId):
    # TODO : implémenter la traduction des expressions.
    let pair = IrFuncEnv.fresh_value(env)
    let env2 = pair.0
    let value = pair.1

    # Pour l'instant, on génère aussi un NOP symbolique.
    let span = ast.lookup_expr_span(expr_id)

    let instr = IrInstr(
        id = env2.next_instr,
        kind = IrInstrKind::IrNop,
        ty = IrType.unknown(),
        value = value,
        operands = Vec<IrValueId>::new(),
        extra = "unimplemented expr -> NOP",
        span = span
    )

    let env3 = IrFuncEnv.append_instr(env2, instr)
    return (env3, value)
.end

# ----------------------------------------------------------------------------
# Notes :
#   - Les helpers ast.lookup_* (node, function, block, stmt, expr_span, etc.)
#     sont supposés fournis par le module vitte.compiler.ast.
#   - Ce builder définit la structure IR et des chemins de code prêts à être
#     remplis progressivement (types, instructions réelles, contrôle, SSA...).
#   - build_ir_module(...) peut déjà être utilisé dans une pipeline pour
#     vérifier l’enchaînement AST -> IR + diagnostics.
# ----------------------------------------------------------------------------
