

# ast_traits.vit
# -----------------------------------------------------------------------------
# AST Traits & Extensions for Vitte
#
# Purpose
# -------
# Centralize lightweight “traits” (interfaces) and extension methods used across
# compiler passes (expand, validate, lower) without pulling heavy dependencies.
#
# This file is meant to provide:
#  - core traits (HasSpan, HasAttrs, HasName, HasNodeId)
#  - robust identifier validation helpers
#  - Item/TypeExpr/Attribute extension helpers (is_*, as_*, getters)
#  - visitor + walk utilities (immutable + mutable)
#
# Notes
# -----
# The exact AST shapes may evolve. Keep this module as the *compat layer*:
#  - Prefer small wrappers + best-effort defaults.
#  - Avoid panics; return Option and let callers diagnose.
#  - Keep behavior deterministic.
# -----------------------------------------------------------------------------

use vitte/ast
use vitte/ast/diag

# -----------------------------------------------------------------------------
# Core small traits
# -----------------------------------------------------------------------------

# Stable node identifier used by caches and incremental passes.
# Keep it small (u32) unless you need >4B nodes.

type NodeId = u32

trait HasNodeId
  fn node_id(&self) -> NodeId
.end

trait HasSpan
  fn span(&self) -> ast::Span
.end

trait HasAttrs
  fn attrs(&self) -> &Vec[ast::Attribute]
  fn attrs_mut(&mut self) -> &mut Vec[ast::Attribute]
.end

trait HasName
  fn name_ident(&self) -> ast::Ident
.end

# -----------------------------------------------------------------------------
# Identifier helpers
# -----------------------------------------------------------------------------

# Strict but practical identifier validation.
# Rules (current):
#  - non-empty
#  - starts with [_A-Za-z]
#  - continues with [_A-Za-z0-9]
#  - not a keyword (best-effort set)

fn is_ascii_alpha(c: char) -> bool
  ret (c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z')
.end

fn is_ascii_digit(c: char) -> bool
  ret c >= '0' && c <= '9'
.end

fn is_ident_start(c: char) -> bool
  ret c == '_' || is_ascii_alpha(c)
.end

fn is_ident_continue(c: char) -> bool
  ret c == '_' || is_ascii_alpha(c) || is_ascii_digit(c)
.end

fn is_keyword(s: &str) -> bool
  # Keep synchronized with the language grammar.
  if s == "mod" || s == "use" || s == "export"
    ret true
  .end
  if s == "type" || s == "struct" || s == "enum" || s == "union"
    ret true
  .end
  if s == "fn" || s == "scn" || s == "prog" || s == "ret"
    ret true
  .end
  if s == "let" || s == "const" || s == "if" || s == "elif" || s == "else"
    ret true
  .end
  if s == "while" || s == "for" || s == "match" || s == "break" || s == "continue"
    ret true
  .end
  if s == "true" || s == "false" || s == "null"
    ret true
  .end
  if s == "do" || s == "when" || s == "loop" || s == "set" || s == "say"
    ret true
  .end
  ret false
.end

fn is_valid_ident(s: &str) -> bool
  let t = s.trim()
  if t.len() == 0
    ret false
  .end

  if is_keyword(t)
    ret false
  .end

  let c0 = t.char_at(0)
  if !is_ident_start(c0)
    ret false
  .end

  let i = 1
  while i < t.len()
    let c = t.char_at(i)
    if !is_ident_continue(c)
      ret false
    .end
    i = i + 1
  .end

  ret true
.end

fn diag_expect_ident(di: &mut diag::DiagSink, span: ast::Span, s: &str) -> Option[ast::Ident]
  if is_valid_ident(s)
    ret Option::some(ast::Ident(name=s.to_string(), span=span))
  .end
  di.error(span, "invalid identifier: '" + s + "'")
  ret Option::none()
.end

# -----------------------------------------------------------------------------
# Item kind tagging
# -----------------------------------------------------------------------------

enum ItemTag
  Unknown
  Module
  Use
  Export
  Struct
  Enum
  Union
  TypeAlias
  Fn
  Scenario
  Global
.end

fn item_tag(it: &ast::Item) -> ItemTag
  # Best-effort: relies on common `is_*` methods or fields.
  if it.is_struct()
    ret ItemTag::Struct
  .end
  if it.is_enum()
    ret ItemTag::Enum
  .end
  if it.is_union()
    ret ItemTag::Union
  .end
  if it.is_type_alias()
    ret ItemTag::TypeAlias
  .end
  if it.is_fn()
    ret ItemTag::Fn
  .end
  if it.is_scenario()
    ret ItemTag::Scenario
  .end
  ret ItemTag::Unknown
.end

# -----------------------------------------------------------------------------
# Extension traits for common AST nodes
# -----------------------------------------------------------------------------

trait ItemExt
  fn tag(&self) -> ItemTag

  fn is_fn(&self) -> bool
  fn as_fn(&self) -> &ast::ItemFn
  fn as_fn_mut(&mut self) -> &mut ast::ItemFn

  fn is_struct(&self) -> bool
  fn as_struct(&self) -> &ast::ItemStruct

  fn is_enum(&self) -> bool
  fn as_enum(&self) -> &ast::ItemEnum

  fn is_union(&self) -> bool
  fn as_union(&self) -> &ast::ItemUnion

  fn is_type_alias(&self) -> bool
  fn as_type_alias(&self) -> &ast::ItemTypeAlias
.end

# Implementations should adapt to your real AST enums.
# These bodies assume your `ast::Item` exposes helper methods (preferred).

impl ItemExt for ast::Item
  fn tag(&self) -> ItemTag
    ret item_tag(self)
  .end

  fn is_fn(&self) -> bool
    ret self.kind == "fn" || self.is_fn_kind()
  .end

  fn as_fn(&self) -> &ast::ItemFn
    ret self.unwrap_fn()
  .end

  fn as_fn_mut(&mut self) -> &mut ast::ItemFn
    ret self.unwrap_fn_mut()
  .end

  fn is_struct(&self) -> bool
    ret self.kind == "struct" || self.is_struct_kind()
  .end

  fn as_struct(&self) -> &ast::ItemStruct
    ret self.unwrap_struct()
  .end

  fn is_enum(&self) -> bool
    ret self.kind == "enum" || self.is_enum_kind()
  .end

  fn as_enum(&self) -> &ast::ItemEnum
    ret self.unwrap_enum()
  .end

  fn is_union(&self) -> bool
    ret self.kind == "union" || self.is_union_kind()
  .end

  fn as_union(&self) -> &ast::ItemUnion
    ret self.unwrap_union()
  .end

  fn is_type_alias(&self) -> bool
    ret self.kind == "type_alias" || self.is_type_alias_kind()
  .end

  fn as_type_alias(&self) -> &ast::ItemTypeAlias
    ret self.unwrap_type_alias()
  .end
.end

# NOTE: If your AST does not provide `kind/is_*_kind/unwrap_*`, switch to match
# on the enum variants here.

# -----------------------------------------------------------------------------
# TypeExpr helpers
# -----------------------------------------------------------------------------

trait TypeExprExt
  fn is_named(&self) -> bool
  fn as_named(&self) -> ast::TypeName

  fn is_path(&self) -> bool
  fn as_path(&self) -> ast::TypePath

  fn is_primitive(&self, name: &str) -> bool
  fn is_named_str(&self, name: &str) -> bool

  fn has_generics(&self) -> bool
  fn generics_len(&self) -> usize
  fn generic_at(&self, idx: usize) -> ast::TypeExpr
.end

impl TypeExprExt for ast::TypeExpr
  fn is_named(&self) -> bool
    ret self.kind == "named" || self.is_named_kind()
  .end

  fn as_named(&self) -> ast::TypeName
    ret self.unwrap_named()
  .end

  fn is_path(&self) -> bool
    ret self.kind == "path" || self.is_path_kind()
  .end

  fn as_path(&self) -> ast::TypePath
    ret self.unwrap_path()
  .end

  fn is_primitive(&self, name: &str) -> bool
    if self.is_named()
      ret self.as_named().name == name
    .end
    ret false
  .end

  fn is_named_str(&self, name: &str) -> bool
    if self.is_named()
      ret self.as_named().name == name
    .end
    if self.is_path()
      let p = self.as_path()
      if p.segments.len() > 0
        ret p.segments[p.segments.len() - 1].name == name
      .end
    .end
    ret false
  .end

  fn has_generics(&self) -> bool
    ret self.generics.is_some()
  .end

  fn generics_len(&self) -> usize
    if self.generics.is_some()
      ret self.generics.unwrap().args.len()
    .end
    ret 0
  .end

  fn generic_at(&self, idx: usize) -> ast::TypeExpr
    ret self.generics.unwrap().args[idx]
  .end
.end

# -----------------------------------------------------------------------------
# Attribute helpers
# -----------------------------------------------------------------------------

trait AttributeExt
  fn is_named(&self, name: &str) -> bool
  fn args_text_or_empty(&self) -> String
.end

impl AttributeExt for ast::Attribute
  fn is_named(&self, name: &str) -> bool
    ret self.name == name
  .end

  fn args_text_or_empty(&self) -> String
    if self.args_text.is_some()
      ret self.args_text.unwrap()
    .end
    ret ""
  .end
.end

# Convenience: search in an attribute list.
fn attrs_find(attrs: &Vec[ast::Attribute], name: &str) -> Option[ast::Attribute]
  let i = 0
  while i < attrs.len()
    if attrs[i].name == name
      ret Option::some(attrs[i])
    .end
    i = i + 1
  .end
  ret Option::none()
.end

fn attrs_has(attrs: &Vec[ast::Attribute], name: &str) -> bool
  ret attrs_find(attrs, name).is_some()
.end

# -----------------------------------------------------------------------------
# Minimal visitors (immutable)
# -----------------------------------------------------------------------------

trait Visitor
  fn diags(&mut self) -> &mut diag::DiagSink

  # Override points
  fn visit_crate(&mut self, c: &ast::Crate)
  fn visit_module(&mut self, m: &ast::Module)
  fn visit_item(&mut self, it: &ast::Item)
  fn visit_fn(&mut self, f: &ast::ItemFn)
  fn visit_type_expr(&mut self, t: &ast::TypeExpr)
.end

# Default visitor implementations = walk.
fn visitor_walk_crate(v: &mut Visitor, c: &ast::Crate)
  let i = 0
  while i < c.modules.len()
    v.visit_module(&c.modules[i])
    i = i + 1
  .end
.end

fn visitor_walk_module(v: &mut Visitor, m: &ast::Module)
  let i = 0
  while i < m.items.len()
    v.visit_item(&m.items[i])
    i = i + 1
  .end
.end

fn visitor_walk_item(v: &mut Visitor, it: &ast::Item)
  if it.is_fn()
    v.visit_fn(it.as_fn())
    ret
  .end

  if it.is_type_alias()
    let a = it.as_type_alias()
    v.visit_type_expr(&a.to_ty)
    ret
  .end

  if it.is_struct()
    let s = it.as_struct()
    let i = 0
    while i < s.fields.len()
      v.visit_type_expr(&s.fields[i].ty)
      i = i + 1
    .end
    ret
  .end

  if it.is_enum()
    let e = it.as_enum()
    let j = 0
    while j < e.variants.len()
      let v0 = e.variants[j]
      let k = 0
      while k < v0.payload.len()
        v.visit_type_expr(&v0.payload[k])
        k = k + 1
      .end
      j = j + 1
    .end
    ret
  .end

  if it.is_union()
    let u = it.as_union()
    let i2 = 0
    while i2 < u.fields.len()
      v.visit_type_expr(&u.fields[i2].ty)
      i2 = i2 + 1
    .end
    ret
  .end
.end

fn visitor_walk_fn(v: &mut Visitor, f: &ast::ItemFn)
  let i = 0
  while i < f.params.len()
    v.visit_type_expr(&f.params[i].ty)
    i = i + 1
  .end

  if f.ret_ty.is_some()
    v.visit_type_expr(&f.ret_ty.unwrap())
  .end
.end

# -----------------------------------------------------------------------------
# Minimal visitors (mutable)
# -----------------------------------------------------------------------------

trait VisitorMut
  fn diags(&mut self) -> &mut diag::DiagSink

  fn visit_crate_mut(&mut self, c: &mut ast::Crate)
  fn visit_module_mut(&mut self, m: &mut ast::Module)
  fn visit_item_mut(&mut self, it: &mut ast::Item)
  fn visit_fn_mut(&mut self, f: &mut ast::ItemFn)
  fn visit_type_expr_mut(&mut self, t: &mut ast::TypeExpr)
.end

fn visitor_walk_crate_mut(v: &mut VisitorMut, c: &mut ast::Crate)
  let i = 0
  while i < c.modules.len()
    v.visit_module_mut(&mut c.modules[i])
    i = i + 1
  .end
.end

fn visitor_walk_module_mut(v: &mut VisitorMut, m: &mut ast::Module)
  let i = 0
  while i < m.items.len()
    v.visit_item_mut(&mut m.items[i])
    i = i + 1
  .end
.end

fn visitor_walk_item_mut(v: &mut VisitorMut, it: &mut ast::Item)
  if it.is_fn()
    v.visit_fn_mut(it.as_fn_mut())
    ret
  .end

  if it.is_type_alias()
    let a = it.as_type_alias_mut()
    v.visit_type_expr_mut(&mut a.to_ty)
    ret
  .end

  if it.is_struct()
    let s = it.as_struct_mut()
    let i = 0
    while i < s.fields.len()
      v.visit_type_expr_mut(&mut s.fields[i].ty)
      i = i + 1
    .end
    ret
  .end

  if it.is_enum()
    let e = it.as_enum_mut()
    let j = 0
    while j < e.variants.len()
      let k = 0
      while k < e.variants[j].payload.len()
        v.visit_type_expr_mut(&mut e.variants[j].payload[k])
        k = k + 1
      .end
      j = j + 1
    .end
    ret
  .end

  if it.is_union()
    let u = it.as_union_mut()
    let i2 = 0
    while i2 < u.fields.len()
      v.visit_type_expr_mut(&mut u.fields[i2].ty)
      i2 = i2 + 1
    .end
    ret
  .end
.end

fn visitor_walk_fn_mut(v: &mut VisitorMut, f: &mut ast::ItemFn)
  let i = 0
  while i < f.params.len()
    v.visit_type_expr_mut(&mut f.params[i].ty)
    i = i + 1
  .end

  if f.ret_ty.is_some()
    let t = f.ret_ty.unwrap_mut()
    v.visit_type_expr_mut(t)
  .end
.end

# -----------------------------------------------------------------------------
# Diagnostics helpers
# -----------------------------------------------------------------------------

fn diag_unsupported_attr_target(di: &mut diag::DiagSink, a: &ast::Attribute, expected: &str, got: &str)
  di.error(a.span, "attribute '" + a.name + "' expects target " + expected + ", got " + got)
.end

# -----------------------------------------------------------------------------
# Smoke tests (compilation-level)
# -----------------------------------------------------------------------------

fn t_is_valid_ident_smoke()
  ast::assert(is_valid_ident("hello"))
  ast::assert(is_valid_ident("_x1"))
  ast::assert(!is_valid_ident("1x"))
  ast::assert(!is_valid_ident("fn"))
.end

# End of file.