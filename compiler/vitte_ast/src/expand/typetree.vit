

# typetree.vit
# -----------------------------------------------------------------------------
# TypeTree (lightweight type index) for AST expansion / early validation.
#
# Motivation
# ----------
# Several expansion passes (attributes, macros, derives) want *basic* knowledge
# about types without pulling the full name-resolver / type-checker:
#   - detect float-like parameters (autodiff)
#   - validate that an attribute targets a struct/enum/function, etc.
#   - resolve trivial `type Alias = ...` chains
#
# This module builds a *best-effort* type index (TypeTree) from the AST.
# It is intentionally conservative:
#   - does not perform full path resolution across crates
#   - does not compute layouts
#   - avoids panics; emits diagnostics
#   - provides small query helpers for expansion stages
#
# The TypeTree can be rebuilt per module, or per crate.
# -----------------------------------------------------------------------------

use vitte/ast
use vitte/ast/diag

# -----------------------------------------------------------------------------
# Kinds and signatures
# -----------------------------------------------------------------------------

enum TypeKind
  Primitive
  Struct
  Enum
  Union
  Alias
  Opaque
.end

struct FieldSig
  name: ast::Ident
  ty: ast::TypeExpr
.end

struct VariantSig
  name: ast::Ident
  # Tuple-like payload; empty for unit variants.
  payload: Vec[ast::TypeExpr]
.end

enum TypeDetail
  None
  Struct(fields: Vec[FieldSig])
  Enum(variants: Vec[VariantSig])
  Union(fields: Vec[FieldSig])
  Alias(to: ast::TypeExpr)
.end

struct TypeEntry
  name: ast::Ident
  kind: TypeKind
  generics: Vec[ast::Ident]
  detail: TypeDetail
  span: ast::Span
.end

struct TypeTree
  entries: Vec[TypeEntry]
.end

fn typetree_new() -> TypeTree
  ret TypeTree(entries=Vec::new())
.end

fn typetree_len(tt: &TypeTree) -> usize
  ret tt.entries.len()
.end

fn typetree_find(tt: &TypeTree, name: &str) -> Option[TypeEntry]
  let i = 0
  while i < tt.entries.len()
    if tt.entries[i].name.name == name
      ret Option::some(tt.entries[i])
    .end
    i = i + 1
  .end
  ret Option::none()
.end

fn typetree_contains(tt: &TypeTree, name: &str) -> bool
  ret typetree_find(tt, name).is_some()
.end

fn typetree_insert(di: &mut diag::DiagSink, tt: &mut TypeTree, e: TypeEntry)
  if typetree_contains(tt, e.name.name)
    di.error(e.span, "typetree: duplicate type name: '" + e.name.name + "'")
    ret
  .end
  tt.entries.push(e)
.end

# -----------------------------------------------------------------------------
# Builtins
# -----------------------------------------------------------------------------

fn typetree_add_builtin(tt: &mut TypeTree, name: &str)
  let span = ast::Span::dummy()
  let id = ast::Ident(name=name.to_string(), span=span)
  let e = TypeEntry(
    name=id,
    kind=TypeKind::Primitive,
    generics=Vec::new(),
    detail=TypeDetail::None,
    span=span,
  )
  tt.entries.push(e)
.end

fn typetree_add_default_builtins(tt: &mut TypeTree)
  # Numeric primitives
  typetree_add_builtin(tt, "f16")
  typetree_add_builtin(tt, "f32")
  typetree_add_builtin(tt, "f64")
  typetree_add_builtin(tt, "i8")
  typetree_add_builtin(tt, "i16")
  typetree_add_builtin(tt, "i32")
  typetree_add_builtin(tt, "i64")
  typetree_add_builtin(tt, "isize")
  typetree_add_builtin(tt, "u8")
  typetree_add_builtin(tt, "u16")
  typetree_add_builtin(tt, "u32")
  typetree_add_builtin(tt, "u64")
  typetree_add_builtin(tt, "usize")

  # Common containers (treated specially by float-like heuristic)
  typetree_add_builtin(tt, "Vec")
  typetree_add_builtin(tt, "vec")
  typetree_add_builtin(tt, "Slice")
  typetree_add_builtin(tt, "slice")
.end

# -----------------------------------------------------------------------------
# Options
# -----------------------------------------------------------------------------

struct TypeTreeBuildOptions
  include_builtins: bool
  # Placeholder for future resolver integration.
  include_imports: bool
.end

fn typetree_build_options_default() -> TypeTreeBuildOptions
  ret TypeTreeBuildOptions(
    include_builtins=true,
    include_imports=false,
  )
.end

# -----------------------------------------------------------------------------
# Building from AST
# -----------------------------------------------------------------------------

# Extract generic parameters from a type declaration node (best-effort).
fn extract_generics_from_type_decl(td: &ast::TypeDecl) -> Vec[ast::Ident]
  if td.generics.is_some()
    ret td.generics.unwrap().params.clone()
  .end
  ret Vec::new()
.end

fn build_entry_from_type_item(di: &mut diag::DiagSink, it: &ast::Item) -> Option[TypeEntry]
  if it.is_struct()
    let s = it.as_struct()
    let fields = Vec::new()
    let i = 0
    while i < s.fields.len()
      let f = s.fields[i]
      fields.push(FieldSig(name=f.name, ty=f.ty))
      i = i + 1
    .end

    let e = TypeEntry(
      name=s.name,
      kind=TypeKind::Struct,
      generics=extract_generics_from_type_decl(&s.type_decl),
      detail=TypeDetail::Struct(fields=fields),
      span=s.span,
    )
    ret Option::some(e)
  .end

  if it.is_enum()
    let e0 = it.as_enum()
    let vars = Vec::new()
    let j = 0
    while j < e0.variants.len()
      let v = e0.variants[j]
      vars.push(VariantSig(name=v.name, payload=v.payload.clone()))
      j = j + 1
    .end

    let e = TypeEntry(
      name=e0.name,
      kind=TypeKind::Enum,
      generics=extract_generics_from_type_decl(&e0.type_decl),
      detail=TypeDetail::Enum(variants=vars),
      span=e0.span,
    )
    ret Option::some(e)
  .end

  if it.is_union()
    let u = it.as_union()
    let fields = Vec::new()
    let k = 0
    while k < u.fields.len()
      let f = u.fields[k]
      fields.push(FieldSig(name=f.name, ty=f.ty))
      k = k + 1
    .end

    let e = TypeEntry(
      name=u.name,
      kind=TypeKind::Union,
      generics=extract_generics_from_type_decl(&u.type_decl),
      detail=TypeDetail::Union(fields=fields),
      span=u.span,
    )
    ret Option::some(e)
  .end

  if it.is_type_alias()
    let a = it.as_type_alias()
    let e = TypeEntry(
      name=a.name,
      kind=TypeKind::Alias,
      generics=extract_generics_from_type_decl(&a.type_decl),
      detail=TypeDetail::Alias(to=a.to_ty),
      span=a.span,
    )
    ret Option::some(e)
  .end

  # Not a type item.
  ret Option::none()
.end

fn build_typetree_in_module(di: &mut diag::DiagSink, m: &ast::Module, opt: TypeTreeBuildOptions) -> TypeTree
  let tt = typetree_new()
  if opt.include_builtins
    typetree_add_default_builtins(&mut tt)
  .end

  let i = 0
  while i < m.items.len()
    let it = m.items[i]
    let e = build_entry_from_type_item(di, &it)
    if e.is_some()
      typetree_insert(di, &mut tt, e.unwrap())
    .end
    i = i + 1
  .end

  ret tt
.end

fn build_typetree_in_crate(di: &mut diag::DiagSink, c: &ast::Crate, opt: TypeTreeBuildOptions) -> TypeTree
  # Crate index: concatenate all module entries, warn on duplicates.
  let tt = typetree_new()
  if opt.include_builtins
    typetree_add_default_builtins(&mut tt)
  .end

  let mi = 0
  while mi < c.modules.len()
    let m = c.modules[mi]
    let local = build_typetree_in_module(di, &m, TypeTreeBuildOptions(include_builtins=false, include_imports=opt.include_imports))

    let i = 0
    while i < local.entries.len()
      typetree_insert(di, &mut tt, local.entries[i])
      i = i + 1
    .end

    mi = mi + 1
  .end

  ret tt
.end

# -----------------------------------------------------------------------------
# Queries / heuristics
# -----------------------------------------------------------------------------

fn is_primitive_float_name(name: &str) -> bool
  ret name == "f16" || name == "f32" || name == "f64"
.end

fn is_container_float_like(name: &str) -> bool
  # Containers where element type determines float-likeness.
  ret name == "Vec" || name == "vec" || name == "Slice" || name == "slice"
.end

# Try to obtain the head identifier of a type expression, e.g.:
#   f32 -> "f32"
#   Vec[f32] -> "Vec"
#   my::Real -> "Real" (best-effort without resolver)
fn typeexpr_head_name(ty: &ast::TypeExpr) -> Option[String]
  if ty.is_named()
    ret Option::some(ty.as_named().name)
  .end
  if ty.is_path()
    let p = ty.as_path()
    if p.segments.len() > 0
      ret Option::some(p.segments[p.segments.len() - 1].name)
    .end
  .end
  ret Option::none()
.end

# Resolve alias chains up to a depth limit.
fn resolve_alias_shallow(tt: &TypeTree, ty: &ast::TypeExpr, max_depth: usize) -> ast::TypeExpr
  let cur = ty.clone()
  let depth = 0

  while depth < max_depth
    let head = typeexpr_head_name(&cur)
    if head.is_none()
      ret cur
    .end

    let ent = typetree_find(tt, head.unwrap())
    if ent.is_none()
      ret cur
    .end

    let e = ent.unwrap()
    if e.kind != TypeKind::Alias
      ret cur
    .end

    if e.detail.is_alias()
      cur = e.detail.as_alias().to.clone()
      depth = depth + 1
      continue
    .end

    ret cur
  .end

  ret cur
.end

# Heuristic: float-like types are:
#  - primitive f16/f32/f64
#  - Alias -> float-like
#  - Vec[T]/Slice[T] where T is float-like
fn typetree_is_float_like(tt: &TypeTree, ty: &ast::TypeExpr) -> bool
  let r = resolve_alias_shallow(tt, ty, 8)

  let head = typeexpr_head_name(&r)
  if head.is_none()
    ret false
  .end

  let h = head.unwrap()
  if is_primitive_float_name(h)
    ret true
  .end

  if is_container_float_like(h)
    # Try to inspect first generic argument.
    if r.has_generics() && r.generics_len() > 0
      let inner = r.generic_at(0)
      ret typetree_is_float_like(tt, &inner)
    .end
    ret true # container with unknown inner => assume float-like for early passes
  .end

  ret false
.end

# Heuristic: integer-like
fn typetree_is_int_like(tt: &TypeTree, ty: &ast::TypeExpr) -> bool
  let r = resolve_alias_shallow(tt, ty, 8)
  let head = typeexpr_head_name(&r)
  if head.is_none()
    ret false
  .end
  let h = head.unwrap()
  if h == "i8" || h == "i16" || h == "i32" || h == "i64" || h == "isize"
    ret true
  .end
  if h == "u8" || h == "u16" || h == "u32" || h == "u64" || h == "usize"
    ret true
  .end
  ret false
.end

# Validate that a set of identifiers correspond to declared types.
fn typetree_validate_type_idents(di: &mut diag::DiagSink, tt: &TypeTree, ids: &Vec[ast::Ident])
  let i = 0
  while i < ids.len()
    let id = ids[i]
    if !typetree_contains(tt, id.name)
      di.error(id.span, "typetree: unknown type: '" + id.name + "'")
    .end
    i = i + 1
  .end
.end

# -----------------------------------------------------------------------------
# Optional integration helper for expand pipeline
# -----------------------------------------------------------------------------

# Some expand passes may want to build a typetree once and reuse it.
# This helper attaches it to crate metadata if the AST supports it.
fn attach_typetree_to_crate(di: &mut diag::DiagSink, c: &mut ast::Crate)
  let opt = typetree_build_options_default()
  let tt = build_typetree_in_crate(di, c, opt)
  c.metadata.typetree = Option::some(tt)
.end

# -----------------------------------------------------------------------------
# Smoke tests
# -----------------------------------------------------------------------------

fn t_typetree_builtins_present()
  let di = diag::DiagSink::new()
  let m = ast::Module::new(
    name=ast::Ident(name="m", span=ast::Span::dummy()),
    items=Vec::new(),
    span=ast::Span::dummy(),
  )

  let tt = build_typetree_in_module(&mut di, &m, typetree_build_options_default())
  ast::assert(typetree_contains(&tt, "f32"))
  ast::assert(typetree_contains(&tt, "Vec"))
.end

fn t_typetree_alias_resolution_float_like()
  let di = diag::DiagSink::new()

  # type Real = f64
  let a = ast::Item::TypeAlias(ast::ItemTypeAlias::new(
    name=ast::Ident(name="Real", span=ast::Span::dummy()),
    to_ty=ast::TypeExpr::named("f64", ast::Span::dummy()),
    span=ast::Span::dummy(),
  ))

  let m = ast::Module::new(
    name=ast::Ident(name="m", span=ast::Span::dummy()),
    items=Vec::new(),
    span=ast::Span::dummy(),
  )
  m.items.push(a)

  let tt = build_typetree_in_module(&mut di, &mut m, typetree_build_options_default())
  let ty = ast::TypeExpr::named("Real", ast::Span::dummy())
  ast::assert(typetree_is_float_like(&tt, &ty))
.end

# End of file.