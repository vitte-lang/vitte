

# autodiff_attrs.vit
# -----------------------------------------------------------------------------
# AutoDiff attribute handling for the Vitte AST.
#
# Scope
# -----
# This module is responsible for:
#  - parsing `@autodiff(...)`-style attributes (or `#[autodiff(...)]` depending on
#    the surface syntax layer),
#  - validating that they are applied to supported targets (functions),
#  - producing a typed configuration used by later passes,
#  - optionally expanding/generating derivative entrypoints (grad/jac/hess) as
#    extra AST items.
#
# Design constraints
# ------------------
#  - Deterministic: same input -> same generated names and order.
#  - Diagnostics-first: never panic; emit structured diagnostics.
#  - Non-invasive: if expansion is disabled, only attach metadata.
#  - Backends: allow `backend="dual"|"tape"|"llvm"|...` without hard-coding.
#
# Attribute grammar (canonical)
# -----------------------------
# `autodiff` can be present multiple times but MUST resolve to a single effective
# configuration.
#
# Keys:
#   mode      = "forward" | "reverse"           (default: "reverse")
#   out       = "grad" | "jac" | "hess"         (default: "grad")
#   wrt       = (a, b, c)                        (default: all float params)
#   name      = "custom_name"                   (default: <fn>_<out>)
#   keep      = true|false                       (default: true)
#   checks    = true|false                       (default: true)
#   backend   = "dual"|"tape"|"llvm"|...        (default: "")
#   export    = true|false                       (default: false)
#   inline    = true|false                       (default: false)
#
# Examples:
#   @autodiff(mode="reverse", out="grad", wrt(x, y))
#   @autodiff(out="jac", name="f_jac", keep=false)
#
# Notes:
#   - The arg parser here is intentionally simple (key/value + list). It can be
#     swapped later to a token-stream parser.
# -----------------------------------------------------------------------------

# NOTE: imports are intentionally “soft”. Adjust paths to your actual module tree.
# The compiler codebase usually provides: Span, Diag, Attribute, Ident, ItemFn, Item.

use vitte/ast
use vitte/ast/diag
use vitte/ast/tokens

# -----------------------------------------------------------------------------
# Typed configuration
# -----------------------------------------------------------------------------

enum AutoDiffMode
  Forward
  Reverse
.end

enum AutoDiffOut
  Grad
  Jac
  Hess
.end

struct AutoDiffWrt
  # Names of parameters to differentiate w.r.t.
  # Empty => infer default (all float-like params)
  params: Vec[ast::Ident]
.end

struct AutoDiffConfig
  mode: AutoDiffMode
  out: AutoDiffOut
  wrt: AutoDiffWrt

  # Generated function name override.
  name_override: Option[ast::Ident]

  # Keep original/primal function (if expansion generates a new wrapper).
  keep_primal: bool

  # Emit runtime or compile-time checks (shape/type constraints).
  checks: bool

  # Backend hint (stringly-typed; resolved by later stage).
  backend: String

  # Whether generated function should be exported.
  export: bool

  # Whether generated function should be force-inlined.
  inline: bool

  # Attribute span for diagnostics.
  span: ast::Span
.end

fn autodiff_default_config(span: ast::Span) -> AutoDiffConfig
  let cfg = AutoDiffConfig(
    mode=AutoDiffMode::Reverse,
    out=AutoDiffOut::Grad,
    wrt=AutoDiffWrt(params=Vec::new()),
    name_override=Option::none(),
    keep_primal=true,
    checks=true,
    backend="",
    export=false,
    inline=false,
    span=span,
  )
  ret cfg
.end

# -----------------------------------------------------------------------------
# Raw args parser
# -----------------------------------------------------------------------------
# This is a lightweight parser operating on a normalized argument string.
# Expected normalized forms:
#   key=value, key="value", key(true)
#   wrt(a,b,c)
#   flags: keep, export, inline (equivalent to keep=true etc.)
#
# Normalization is done by the attribute extraction layer (tokens->string).
# If your Attribute already stores tokens, replace the `args_text` accessor.

struct ArgKV
  key: String
  value: Option[String]
  list: Vec[String]
  span: ast::Span
.end

struct ParsedArgs
  items: Vec[ArgKV]
.end

fn parsed_args_new() -> ParsedArgs
  ret ParsedArgs(items=Vec::new())
.end

fn parsed_args_push(pa: &mut ParsedArgs, kv: ArgKV)
  pa.items.push(kv)
.end

fn parsed_args_find(pa: &ParsedArgs, key: &str) -> Option[ArgKV]
  let i = 0
  while i < pa.items.len()
    if pa.items[i].key == key
      ret Option::some(pa.items[i])
    .end
    i = i + 1
  .end
  ret Option::none()
.end

fn parsed_args_find_all(pa: &ParsedArgs, key: &str) -> Vec[ArgKV]
  let out = Vec::new()
  let i = 0
  while i < pa.items.len()
    if pa.items[i].key == key
      out.push(pa.items[i])
    .end
    i = i + 1
  .end
  ret out
.end

# Best-effort split respecting quotes.
fn split_top_level_commas(s: &str) -> Vec[String]
  let out = Vec::new()
  let buf = ""
  let i = 0
  let in_str = false

  while i < s.len()
    let ch = s.char_at(i)
    if ch == '"'
      in_str = !in_str
      buf = buf + ch
      i = i + 1
      continue
    .end

    if !in_str && ch == ','
      out.push(buf.trim().to_string())
      buf = ""
      i = i + 1
      continue
    .end

    buf = buf + ch
    i = i + 1
  .end

  if buf.trim().len() > 0
    out.push(buf.trim().to_string())
  .end

  ret out
.end

fn strip_quotes(s: &str) -> String
  let t = s.trim()
  if t.len() >= 2 && t.starts_with("\"") && t.ends_with("\"")
    ret t.slice(1, t.len() - 1).to_string()
  .end
  ret t.to_string()
.end

fn parse_arg_item(text: &str, span: ast::Span) -> Option[ArgKV]
  let t = text.trim()
  if t.len() == 0
    ret Option::none()
  .end

  # key=value
  let eq = t.find('=')
  if eq.is_some()
    let idx = eq.unwrap()
    let key = t.slice(0, idx).trim().to_string()
    let val = t.slice(idx + 1, t.len()).trim().to_string()
    ret Option::some(ArgKV(key=key, value=Option::some(strip_quotes(val)), list=Vec::new(), span=span))
  .end

  # key(a,b,c)
  let lp = t.find('(')
  let rp = t.rfind(')')
  if lp.is_some() && rp.is_some()
    let li = lp.unwrap()
    let ri = rp.unwrap()
    if ri > li
      let key = t.slice(0, li).trim().to_string()
      let inside = t.slice(li + 1, ri).trim().to_string()
      let parts = split_top_level_commas(inside)
      let list = Vec::new()
      let j = 0
      while j < parts.len()
        let p = parts[j].trim()
        if p.len() > 0
          list.push(strip_quotes(p))
        .end
        j = j + 1
      .end
      ret Option::some(ArgKV(key=key, value=Option::none(), list=list, span=span))
    .end
  .end

  # flag => flag=true
  ret Option::some(ArgKV(key=t.to_string(), value=Option::some("true"), list=Vec::new(), span=span))
.end

fn parse_args_text(args_text: &str, span: ast::Span) -> ParsedArgs
  let pa = parsed_args_new()
  let parts = split_top_level_commas(args_text)
  let i = 0
  while i < parts.len()
    let kv = parse_arg_item(parts[i], span)
    if kv.is_some()
      parsed_args_push(&mut pa, kv.unwrap())
    .end
    i = i + 1
  .end
  ret pa
.end

# -----------------------------------------------------------------------------
# Attribute extraction and config building
# -----------------------------------------------------------------------------

fn attr_is_autodiff(a: &ast::Attribute) -> bool
  # Accept both “autodiff” and “vitte::autodiff” names.
  if a.name == "autodiff"
    ret true
  .end
  if a.name == "vitte::autodiff"
    ret true
  .end
  ret false
.end

fn attr_args_text(a: &ast::Attribute) -> String
  # Fallback: return stored text; if token-based, convert via tokens::to_text.
  if a.args_text.is_some()
    ret a.args_text.unwrap()
  .end
  if a.args_tokens.is_some()
    ret tokens::to_text(a.args_tokens.unwrap())
  .end
  ret ""
.end

fn parse_bool(di: &mut diag::DiagSink, span: ast::Span, key: &str, v: &str) -> Option[bool]
  let t = v.trim().to_lower()
  if t == "true" || t == "1" || t == "yes" || t == "on"
    ret Option::some(true)
  .end
  if t == "false" || t == "0" || t == "no" || t == "off"
    ret Option::some(false)
  .end
  di.error(span, "autodiff: invalid boolean for '" + key + "': '" + v + "'")
  ret Option::none()
.end

fn parse_mode(di: &mut diag::DiagSink, span: ast::Span, v: &str) -> Option[AutoDiffMode]
  let t = v.trim().to_lower()
  if t == "forward"
    ret Option::some(AutoDiffMode::Forward)
  .end
  if t == "reverse"
    ret Option::some(AutoDiffMode::Reverse)
  .end
  di.error(span, "autodiff: invalid mode '" + v + "' (expected forward|reverse)")
  ret Option::none()
.end

fn parse_out(di: &mut diag::DiagSink, span: ast::Span, v: &str) -> Option[AutoDiffOut]
  let t = v.trim().to_lower()
  if t == "grad" || t == "gradient"
    ret Option::some(AutoDiffOut::Grad)
  .end
  if t == "jac" || t == "jacobian"
    ret Option::some(AutoDiffOut::Jac)
  .end
  if t == "hess" || t == "hessian"
    ret Option::some(AutoDiffOut::Hess)
  .end
  di.error(span, "autodiff: invalid out '" + v + "' (expected grad|jac|hess)")
  ret Option::none()
.end

fn ident_from_string(di: &mut diag::DiagSink, span: ast::Span, s: &str) -> Option[ast::Ident]
  # Minimal validation: must be a valid identifier.
  if ast::is_valid_ident(s)
    ret Option::some(ast::Ident(name=s.to_string(), span=span))
  .end
  di.error(span, "autodiff: invalid identifier '" + s + "'")
  ret Option::none()
.end

fn build_config_from_attr(di: &mut diag::DiagSink, a: &ast::Attribute) -> AutoDiffConfig
  let span = a.span
  let cfg = autodiff_default_config(span)

  let args = parse_args_text(attr_args_text(a), span)

  # mode
  let m = parsed_args_find(&args, "mode")
  if m.is_some() && m.unwrap().value.is_some()
    let mm = parse_mode(di, m.unwrap().span, m.unwrap().value.unwrap())
    if mm.is_some()
      cfg.mode = mm.unwrap()
    .end
  .end

  # out
  let o = parsed_args_find(&args, "out")
  if o.is_some() && o.unwrap().value.is_some()
    let oo = parse_out(di, o.unwrap().span, o.unwrap().value.unwrap())
    if oo.is_some()
      cfg.out = oo.unwrap()
    .end
  .end

  # backend
  let b = parsed_args_find(&args, "backend")
  if b.is_some() && b.unwrap().value.is_some()
    cfg.backend = b.unwrap().value.unwrap()
  .end

  # name override
  let n = parsed_args_find(&args, "name")
  if n.is_some() && n.unwrap().value.is_some()
    let id = ident_from_string(di, n.unwrap().span, n.unwrap().value.unwrap())
    if id.is_some()
      cfg.name_override = Option::some(id.unwrap())
    .end
  .end

  # keep / checks / export / inline
  let k = parsed_args_find(&args, "keep")
  if k.is_some() && k.unwrap().value.is_some()
    let bb = parse_bool(di, k.unwrap().span, "keep", k.unwrap().value.unwrap())
    if bb.is_some()
      cfg.keep_primal = bb.unwrap()
    .end
  .end

  let c = parsed_args_find(&args, "checks")
  if c.is_some() && c.unwrap().value.is_some()
    let bb = parse_bool(di, c.unwrap().span, "checks", c.unwrap().value.unwrap())
    if bb.is_some()
      cfg.checks = bb.unwrap()
    .end
  .end

  let e = parsed_args_find(&args, "export")
  if e.is_some() && e.unwrap().value.is_some()
    let bb = parse_bool(di, e.unwrap().span, "export", e.unwrap().value.unwrap())
    if bb.is_some()
      cfg.export = bb.unwrap()
    .end
  .end

  let inl = parsed_args_find(&args, "inline")
  if inl.is_some() && inl.unwrap().value.is_some()
    let bb = parse_bool(di, inl.unwrap().span, "inline", inl.unwrap().value.unwrap())
    if bb.is_some()
      cfg.inline = bb.unwrap()
    .end
  .end

  # wrt(a,b,c)
  let wrt_all = parsed_args_find_all(&args, "wrt")
  if wrt_all.len() > 1
    di.error(span, "autodiff: duplicate 'wrt(...)' entries")
  .end
  if wrt_all.len() == 1
    let w = wrt_all[0]
    let params = Vec::new()
    let i = 0
    while i < w.list.len()
      let id = ident_from_string(di, w.span, w.list[i])
      if id.is_some()
        params.push(id.unwrap())
      .end
      i = i + 1
    .end
    cfg.wrt = AutoDiffWrt(params=params)
  .end

  ret cfg
.end

# Merge behavior when multiple autodiff attributes exist.
# Current rule: last one wins, but we emit a warning.
fn merge_configs(di: &mut diag::DiagSink, first: AutoDiffConfig, second: AutoDiffConfig) -> AutoDiffConfig
  di.warn(second.span, "autodiff: multiple autodiff attributes; last one wins")
  ret second
.end

# Public API: extract effective autodiff config from attribute list.
fn extract_autodiff_config(di: &mut diag::DiagSink, attrs: &Vec[ast::Attribute]) -> Option[AutoDiffConfig]
  let found = false
  let cfg = autodiff_default_config(ast::Span::dummy())

  let i = 0
  while i < attrs.len()
    let a = attrs[i]
    if attr_is_autodiff(&a)
      let next = build_config_from_attr(di, &a)
      if !found
        cfg = next
        found = true
      else
        cfg = merge_configs(di, cfg, next)
      .end
    .end
    i = i + 1
  .end

  if found
    ret Option::some(cfg)
  .end
  ret Option::none()
.end

# -----------------------------------------------------------------------------
# Validation
# -----------------------------------------------------------------------------

fn is_float_like_type(ty: &ast::TypeExpr) -> bool
  # Heuristic; refine in type-checker. Here we accept primitive float + vectors.
  if ty.is_primitive("f32") || ty.is_primitive("f64")
    ret true
  .end
  if ty.is_named("Vec") || ty.is_named("vec")
    ret true
  .end
  ret false
.end

fn infer_default_wrt(fn_item: &ast::ItemFn) -> AutoDiffWrt
  let params = Vec::new()
  let i = 0
  while i < fn_item.params.len()
    let p = fn_item.params[i]
    if is_float_like_type(&p.ty)
      params.push(p.name)
    .end
    i = i + 1
  .end
  ret AutoDiffWrt(params=params)
.end

fn validate_wrt(di: &mut diag::DiagSink, cfg: &mut AutoDiffConfig, fn_item: &ast::ItemFn)
  # If wrt is empty, infer.
  if cfg.wrt.params.len() == 0
    cfg.wrt = infer_default_wrt(fn_item)
  .end

  # Validate each name matches a parameter.
  let i = 0
  while i < cfg.wrt.params.len()
    let id = cfg.wrt.params[i]
    if !fn_item.has_param_named(id.name)
      di.error(id.span, "autodiff: wrt parameter not found: '" + id.name + "'")
    .end
    i = i + 1
  .end

  # Validate float-like (best-effort without typing).
  let j = 0
  while j < cfg.wrt.params.len()
    let id = cfg.wrt.params[j]
    let p = fn_item.param_by_name(id.name)
    if p.is_some() && !is_float_like_type(&p.unwrap().ty)
      di.error(id.span, "autodiff: wrt parameter must be float-like: '" + id.name + "'")
    .end
    j = j + 1
  .end
.end

fn validate_target(di: &mut diag::DiagSink, cfg: &mut AutoDiffConfig, fn_item: &ast::ItemFn)
  # Ensure function has at least one float-like parameter.
  validate_wrt(di, cfg, fn_item)

  if cfg.wrt.params.len() == 0
    di.error(cfg.span, "autodiff: no differentiable parameters found")
  .end

  # Output-specific constraints (heuristics).
  if cfg.out == AutoDiffOut::Hess && cfg.wrt.params.len() != 1
    di.error(cfg.span, "autodiff: hess requires exactly one parameter in wrt(...)")
  .end
.end

# -----------------------------------------------------------------------------
# Expansion (optional)
# -----------------------------------------------------------------------------

# Generated name: <fn>_<out> or override.
fn compute_generated_name(cfg: &AutoDiffConfig, fn_name: &ast::Ident) -> ast::Ident
  if cfg.name_override.is_some()
    ret cfg.name_override.unwrap()
  .end

  let suffix = "grad"
  if cfg.out == AutoDiffOut::Jac
    suffix = "jac"
  .end
  if cfg.out == AutoDiffOut::Hess
    suffix = "hess"
  .end

  let name = fn_name.name + "_" + suffix
  ret ast::Ident(name=name, span=cfg.span)
.end

# Attach metadata on the function for later compiler stages.
fn attach_autodiff_metadata(fn_item: &mut ast::ItemFn, cfg: AutoDiffConfig)
  fn_item.metadata.autodiff = Option::some(cfg)
.end

# Expand by generating an extra function item that represents the derivative.
# This is a shallow AST expansion: the body is a placeholder that will be lowered
# to backend IR later.
fn expand_autodiff_fn(di: &mut diag::DiagSink, fn_item: &mut ast::ItemFn, cfg: &AutoDiffConfig) -> Option[ast::Item]
  let gen_name = compute_generated_name(cfg, fn_item.name)

  # Avoid collisions.
  if fn_item.module_scope_contains(gen_name.name)
    di.error(cfg.span, "autodiff: generated name already exists: '" + gen_name.name + "'")
    ret Option::none()
  .end

  # Build signature for derivative function (best-effort):
  #  - grad: returns same shape as wrt param
  #  - jac: returns matrix-like (opaque)
  #  - hess: returns matrix-like
  # Without types, use an opaque `AutoDiffResult` type.
  let ret_ty = ast::TypeExpr::named("AutoDiffResult", cfg.span)

  let der = ast::ItemFn::new(
    name=gen_name,
    params=fn_item.params.clone(),
    ret_ty=ret_ty,
    attrs=Vec::new(),
    body=ast::Block::placeholder(cfg.span, "autodiff-generated"),
    span=cfg.span,
  )

  # Propagate ABI/export/inline attributes if requested.
  if cfg.export
    der.attrs.push(ast::Attribute::flag("export", cfg.span))
  .end
  if cfg.inline
    der.attrs.push(ast::Attribute::flag("inline", cfg.span))
  .end

  # Attach metadata for later lowering.
  der.metadata.autodiff = Option::some(cfg.clone())

  ret Option::some(ast::Item::Fn(der))
.end

# -----------------------------------------------------------------------------
# Pass entrypoint
# -----------------------------------------------------------------------------

struct AutoDiffExpandOptions
  # If true, generate new derivative functions as items.
  generate: bool
.end

fn autodiff_expand_options_default() -> AutoDiffExpandOptions
  ret AutoDiffExpandOptions(generate=true)
.end

# Apply autodiff parsing/validation/expansion to a module.
fn expand_autodiff_in_module(di: &mut diag::DiagSink, m: &mut ast::Module, opt: AutoDiffExpandOptions)
  let new_items = Vec::new()

  let i = 0
  while i < m.items.len()
    let it = &mut m.items[i]

    if it.is_fn()
      let f = it.as_fn_mut()
      let cfg_opt = extract_autodiff_config(di, &f.attrs)
      if cfg_opt.is_some()
        let cfg = cfg_opt.unwrap()

        let mut_cfg = cfg.clone()
        validate_target(di, &mut mut_cfg, f)

        attach_autodiff_metadata(f, mut_cfg.clone())

        if opt.generate
          let gen = expand_autodiff_fn(di, f, &mut_cfg)
          if gen.is_some()
            new_items.push(gen.unwrap())
          .end
        .end
      .end
    .end

    i = i + 1
  .end

  # Append generated items deterministically.
  let j = 0
  while j < new_items.len()
    m.items.push(new_items[j])
    j = j + 1
  .end
.end

# -----------------------------------------------------------------------------
# Tests (smoke)
# -----------------------------------------------------------------------------

# These tests assume a test harness in `vitte/ast/diag` and `vitte/ast`.
# If your harness differs, keep the intent and adapt the constructors.

fn t_autodiff_parse_defaults()
  let di = diag::DiagSink::new()
  let a = ast::Attribute::with_text("autodiff", "", ast::Span::dummy())
  let attrs = Vec::new()
  attrs.push(a)

  let cfg = extract_autodiff_config(&mut di, &attrs)
  ast::assert(cfg.is_some())

  let c = cfg.unwrap()
  ast::assert(c.mode == AutoDiffMode::Reverse)
  ast::assert(c.out == AutoDiffOut::Grad)
.end

fn t_autodiff_parse_wrt()
  let di = diag::DiagSink::new()
  let a = ast::Attribute::with_text("autodiff", "wrt(x, y), out=\"jac\"", ast::Span::dummy())
  let attrs = Vec::new()
  attrs.push(a)

  let cfg = extract_autodiff_config(&mut di, &attrs)
  ast::assert(cfg.is_some())
  let c = cfg.unwrap()
  ast::assert(c.out == AutoDiffOut::Jac)
  ast::assert(c.wrt.params.len() == 2)
.end

fn t_autodiff_expand_generates_item()
  let di = diag::DiagSink::new()

  let f = ast::ItemFn::new(
    name=ast::Ident(name="f", span=ast::Span::dummy()),
    params=Vec::new(),
    ret_ty=ast::TypeExpr::named("f64", ast::Span::dummy()),
    attrs=Vec::new(),
    body=ast::Block::placeholder(ast::Span::dummy(), "body"),
    span=ast::Span::dummy(),
  )

  f.attrs.push(ast::Attribute::with_text("autodiff", "out=\"grad\"", ast::Span::dummy()))

  let m = ast::Module::new(
    name=ast::Ident(name="m", span=ast::Span::dummy()),
    items=Vec::new(),
    span=ast::Span::dummy(),
  )
  m.items.push(ast::Item::Fn(f))

  expand_autodiff_in_module(&mut di, &mut m, autodiff_expand_options_default())

  ast::assert(m.items.len() == 2)
.end

# End of file.