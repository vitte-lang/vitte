

# vitte_ast/src/attr/mod.vit
#
# Attributes model for the Vitte AST.
#
# Goals
# - Represent compiler attributes in a backend-agnostic way.
# - Keep the data model small and portable (no allocations required here).
# - Provide validation + common query helpers for passes (desugar, IR lowering).
#
# Conventions
# - No `{}` blocks; `.end` only.
# - Lists are modeled as (ptr,len) to avoid depending on std collections.

mod vitte_ast.attr

# -----------------------------------------------------------------------------
# Minimal Span (local mirror)
# -----------------------------------------------------------------------------
# NOTE
# - If the project already defines a canonical `Span` elsewhere, you can replace
#   this with an import and type alias when your type system supports it.

type Span struct
    file_id: u32
    lo: usize
    hi: usize
.end

fn span_none() -> Span
    let s: Span
    s.file_id = 0
    s.lo = 0
    s.hi = 0
    ret s
.end

fn span_is_valid(s: Span) -> bool
    ret s.lo <= s.hi
.end

# -----------------------------------------------------------------------------
# Attribute surface
# -----------------------------------------------------------------------------

type AttrStyle enum
    # `#[attr]`
    outer

    # `#![attr]`
    inner
.end

type AttrTarget enum
    # Target categories for analysis/passes.
    file
    module
    item
    field
    param
    stmt
    expr
    ty
.end

# Path string – canonical form is segments joined with `::`.
# Example: "cfg", "doc", "lang::item".

type AttrPath struct
    text: str
.end

fn attr_path(text: str) -> AttrPath
    let p: AttrPath
    p.text = text
    ret p
.end

fn attr_path_is_empty(p: AttrPath) -> bool
    ret p.text == ""
.end

# -----------------------------------------------------------------------------
# Values (meta)
# -----------------------------------------------------------------------------

type AttrValueKind enum
    none
    bool
    int
    string
    path
    tokens
    kv_list
.end

type AttrKv struct
    key: str
    value: AttrValue
.end

type AttrKvList struct
    data: *AttrKv
    len: usize
.end

type AttrValue struct
    kind: AttrValueKind

    b: bool
    i: i64
    s: str
    p: AttrPath
    tok: str

    kvs: AttrKvList
.end

fn attr_value_none() -> AttrValue
    let v: AttrValue
    v.kind = AttrValueKind.none
    v.b = false
    v.i = 0
    v.s = ""
    v.p = attr_path("")
    v.tok = ""
    v.kvs.data = 0
    v.kvs.len = 0
    ret v
.end

fn attr_value_bool(x: bool) -> AttrValue
    let v = attr_value_none()
    v.kind = AttrValueKind.bool
    v.b = x
    ret v
.end

fn attr_value_int(x: i64) -> AttrValue
    let v = attr_value_none()
    v.kind = AttrValueKind.int
    v.i = x
    ret v
.end

fn attr_value_string(x: str) -> AttrValue
    let v = attr_value_none()
    v.kind = AttrValueKind.string
    v.s = x
    ret v
.end

fn attr_value_path(x: AttrPath) -> AttrValue
    let v = attr_value_none()
    v.kind = AttrValueKind.path
    v.p = x
    ret v
.end

fn attr_value_tokens(x: str) -> AttrValue
    let v = attr_value_none()
    v.kind = AttrValueKind.tokens
    v.tok = x
    ret v
.end

fn attr_value_kv_list(kvs: AttrKvList) -> AttrValue
    let v = attr_value_none()
    v.kind = AttrValueKind.kv_list
    v.kvs = kvs
    ret v
.end

fn attr_kv(key: str, value: AttrValue) -> AttrKv
    let kv: AttrKv
    kv.key = key
    kv.value = value
    ret kv
.end

# -----------------------------------------------------------------------------
# Meta item model
# -----------------------------------------------------------------------------
# Rust-like meta items:
# - word:     #[inline]
# - name-val: #[doc = "..."]
# - list:     #[cfg(feature = "x", any(...))]


type MetaItemKind enum
    word
    name_value
    list
.end

type MetaItem struct
    path: AttrPath
    kind: MetaItemKind

    # kind=word: value.kind=none
    # kind=name_value: value is scalar (bool/int/string/path/tokens)
    # kind=list: value.kind=kv_list, kvs are entries inside (...)
    value: AttrValue
.end

fn meta_word(path: AttrPath) -> MetaItem
    let m: MetaItem
    m.path = path
    m.kind = MetaItemKind.word
    m.value = attr_value_none()
    ret m
.end

fn meta_name_value(path: AttrPath, value: AttrValue) -> MetaItem
    let m: MetaItem
    m.path = path
    m.kind = MetaItemKind.name_value
    m.value = value
    ret m
.end

fn meta_list(path: AttrPath, kvs: AttrKvList) -> MetaItem
    let m: MetaItem
    m.path = path
    m.kind = MetaItemKind.list
    m.value = attr_value_kv_list(kvs)
    ret m
.end

# -----------------------------------------------------------------------------
# Attr object
# -----------------------------------------------------------------------------

type Attr struct
    style: AttrStyle
    target: AttrTarget

    # The syntactic path of the attribute.
    path: AttrPath

    # Parsed meta representation (optional).
    meta: MetaItem

    # Raw payload tokens, if the parser kept them.
    raw_tokens: str

    span: Span
.end

fn attr_init(style: AttrStyle, target: AttrTarget, path: AttrPath, meta: MetaItem, raw_tokens: str, span: Span) -> Attr
    let a: Attr
    a.style = style
    a.target = target
    a.path = path
    a.meta = meta
    a.raw_tokens = raw_tokens
    a.span = span
    ret a
.end

fn attr_word(style: AttrStyle, target: AttrTarget, name: str, span: Span) -> Attr
    let p = attr_path(name)
    let m = meta_word(p)
    ret attr_init(style, target, p, m, "", span)
.end

fn attr_name_value(style: AttrStyle, target: AttrTarget, name: str, value: AttrValue, span: Span) -> Attr
    let p = attr_path(name)
    let m = meta_name_value(p, value)
    ret attr_init(style, target, p, m, "", span)
.end

fn attr_list(style: AttrStyle, target: AttrTarget, name: str, kvs: AttrKvList, span: Span) -> Attr
    let p = attr_path(name)
    let m = meta_list(p, kvs)
    ret attr_init(style, target, p, m, "", span)
.end

# -----------------------------------------------------------------------------
# Lists + queries
# -----------------------------------------------------------------------------

type AttrList struct
    data: *Attr
    len: usize
.end

fn attr_list_empty() -> AttrList
    let l: AttrList
    l.data = 0
    l.len = 0
    ret l
.end

fn attr_list_has(list: AttrList, name: str) -> bool
    if list.data == 0
        ret false
    .end

    let i: usize = 0
    while i < list.len
        if list.data[i].path.text == name
            ret true
        .end
        i = i + 1
    .end

    ret false
.end

fn attr_list_find_first(list: AttrList, name: str) -> *Attr
    if list.data == 0
        ret 0
    .end

    let i: usize = 0
    while i < list.len
        if list.data[i].path.text == name
            ret &list.data[i]
        .end
        i = i + 1
    .end

    ret 0
.end

fn attr_list_count(list: AttrList, name: str) -> usize
    if list.data == 0
        ret 0
    .end

    let c: usize = 0
    let i: usize = 0
    while i < list.len
        if list.data[i].path.text == name
            c = c + 1
        .end
        i = i + 1
    .end

    ret c
.end

# Extract `#[doc = "..."]` strings.
# Returns number of collected docs written to `out_docs`.

type DocList struct
    data: *str
    cap: usize
    len: usize
.end

fn doc_list_init(data: *str, cap: usize) -> DocList
    let d: DocList
    d.data = data
    d.cap = cap
    d.len = 0
    ret d
.end

fn attr_list_collect_docs(list: AttrList, out_docs: *str, out_cap: usize) -> usize
    if out_docs == 0 || out_cap == 0
        ret 0
    .end

    let out = doc_list_init(out_docs, out_cap)

    if list.data == 0
        ret 0
    .end

    let i: usize = 0
    while i < list.len
        let a = list.data[i]
        if a.path.text == "doc" && a.meta.kind == MetaItemKind.name_value
            if a.meta.value.kind == AttrValueKind.string
                if out.len < out.cap
                    out.data[out.len] = a.meta.value.s
                    out.len = out.len + 1
                .end
            .end
        .end
        i = i + 1
    .end

    ret out.len
.end

# -----------------------------------------------------------------------------
# Validation
# -----------------------------------------------------------------------------

# Basic identifier rules for attribute segments.
# - first: [A-Za-z_]
# - rest:  [A-Za-z0-9_]

fn _is_alpha(c: u8) -> bool
    ret (c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z')
.end

fn _is_digit(c: u8) -> bool
    ret (c >= '0' && c <= '9')
.end

fn _is_ident_start(c: u8) -> bool
    ret _is_alpha(c) || c == '_'
.end

fn _is_ident_continue(c: u8) -> bool
    ret _is_alpha(c) || _is_digit(c) || c == '_'
.end

fn attr_ident_is_valid(s: str) -> bool
    if s == ""
        ret false
    .end

    let b0: u8 = s[0]
    if !_is_ident_start(b0)
        ret false
    .end

    let i: usize = 1
    while i < s.len
        if !_is_ident_continue(s[i])
            ret false
        .end
        i = i + 1
    .end

    ret true
.end

# Path syntax:
# - segments separated by "::"
# - each segment must be a valid ident

fn attr_path_is_valid(p: AttrPath) -> bool
    if p.text == ""
        ret false
    .end

    # Scan segments.
    let i: usize = 0
    let seg_start: usize = 0

    while i < p.text.len
        # Detect separator "::"
        if p.text[i] == ':'
            if (i + 1) >= p.text.len
                ret false
            .end
            if p.text[i + 1] != ':'
                ret false
            .end

            # Validate segment [seg_start, i)
            if i == seg_start
                ret false
            .end

            let seg = p.text.slice(seg_start, i)
            if !attr_ident_is_valid(seg)
                ret false
            .end

            # Move past separator
            i = i + 2
            seg_start = i
            continue
        .end

        i = i + 1
    .end

    # Validate final segment
    if seg_start >= p.text.len
        ret false
    .end

    let last = p.text.slice(seg_start, p.text.len)
    ret attr_ident_is_valid(last)
.end

type AttrErrorKind enum
    ok
    invalid_path
    invalid_meta
    duplicate_disallowed
    invalid_span
.end

type AttrError struct
    kind: AttrErrorKind
    message: str
.end

fn attr_ok() -> AttrError
    let e: AttrError
    e.kind = AttrErrorKind.ok
    e.message = ""
    ret e
.end

fn attr_err(kind: AttrErrorKind, msg: str) -> AttrError
    let e: AttrError
    e.kind = kind
    e.message = msg
    ret e
.end

fn attr_meta_is_valid(m: MetaItem) -> bool
    if !attr_path_is_valid(m.path)
        ret false
    .end

    if m.kind == MetaItemKind.word
        ret m.value.kind == AttrValueKind.none
    .end

    if m.kind == MetaItemKind.name_value
        # Scalars only.
        ret m.value.kind == AttrValueKind.bool
            || m.value.kind == AttrValueKind.int
            || m.value.kind == AttrValueKind.string
            || m.value.kind == AttrValueKind.path
            || m.value.kind == AttrValueKind.tokens
    .end

    # list
    if m.value.kind != AttrValueKind.kv_list
        ret false
    .end

    # Validate each kv key (empty keys disallowed) – values can be nested.
    let kvs = m.value.kvs
    if kvs.data == 0 && kvs.len != 0
        ret false
    .end

    let i: usize = 0
    while i < kvs.len
        let kv = kvs.data[i]
        if kv.key == ""
            ret false
        .end
        # If key looks like an ident, enforce the ident rule.
        # Otherwise, allow string-like keys for interop.
        if attr_ident_is_valid(kv.key)
            # ok
        .end
        # Recurse shallowly only (do not force deep validation here).
        i = i + 1
    .end

    ret true
.end

fn attr_is_valid(a: Attr) -> AttrError
    if !span_is_valid(a.span)
        ret attr_err(AttrErrorKind.invalid_span, "invalid span")
    .end

    if !attr_path_is_valid(a.path)
        ret attr_err(AttrErrorKind.invalid_path, "invalid attr path")
    .end

    if !attr_meta_is_valid(a.meta)
        ret attr_err(AttrErrorKind.invalid_meta, "invalid attr meta")
    .end

    ret attr_ok()
.end

# Duplicate policy helper:
# - Some attributes are intended to be unique per target.
# - This function enforces a conservative allowlist.
# - Returns true if duplicates are allowed for `name`.

fn attr_allows_duplicates(name: str) -> bool
    # Common duplicates allowed:
    # - doc: multiple lines
    # - cfg: multiple conditions
    if name == "doc"
        ret true
    .end
    if name == "cfg"
        ret true
    .end

    ret false
.end

fn attr_list_validate(list: AttrList) -> AttrError
    if list.data == 0 && list.len != 0
        ret attr_err(AttrErrorKind.invalid_meta, "attr list pointer is null")
    .end

    let i: usize = 0
    while i < list.len
        let a = list.data[i]
        let e = attr_is_valid(a)
        if e.kind != AttrErrorKind.ok
            ret e
        .end

        # Duplicate check (O(n^2), but lists are small; keeps this module std-free).
        if !attr_allows_duplicates(a.path.text)
            let j: usize = i + 1
            while j < list.len
                if list.data[j].path.text == a.path.text
                    ret attr_err(AttrErrorKind.duplicate_disallowed, "duplicate attribute")
                .end
                j = j + 1
            .end
        .end

        i = i + 1
    .end

    ret attr_ok()
.end

# -----------------------------------------------------------------------------
# Canonical helpers (well-known attributes)
# -----------------------------------------------------------------------------

fn attr_is_doc(a: Attr) -> bool
    ret a.path.text == "doc"
.end

fn attr_is_cfg(a: Attr) -> bool
    ret a.path.text == "cfg"
.end

fn attr_is_inline(a: Attr) -> bool
    ret a.path.text == "inline"
.end

fn attr_doc_string(a: Attr) -> str
    if a.path.text != "doc"
        ret ""
    .end

    if a.meta.kind != MetaItemKind.name_value
        ret ""
    .end

    if a.meta.value.kind != AttrValueKind.string
        ret ""
    .end

    ret a.meta.value.s
.end

# -----------------------------------------------------------------------------
# Pure smoke tests
# -----------------------------------------------------------------------------

type _AttrBuf4 struct
    a0: Attr
    a1: Attr
    a2: Attr
    a3: Attr
.end

type _StrBuf8 struct
    s0: str
    s1: str
    s2: str
    s3: str
    s4: str
    s5: str
    s6: str
    s7: str
.end

fn attr_smoke_ident_and_path() -> bool
    if !attr_ident_is_valid("cfg")
        ret false
    .end
    if !attr_ident_is_valid("_x1")
        ret false
    .end
    if attr_ident_is_valid("9bad")
        ret false
    .end
    if attr_ident_is_valid("bad-name")
        ret false
    .end

    if !attr_path_is_valid(attr_path("doc"))
        ret false
    .end
    if !attr_path_is_valid(attr_path("lang::item"))
        ret false
    .end
    if attr_path_is_valid(attr_path("lang::"))
        ret false
    .end
    if attr_path_is_valid(attr_path("::lang"))
        ret false
    .end

    ret true
.end

fn attr_smoke_docs_collect() -> bool
    let sp = span_none()

    let a0 = attr_name_value(AttrStyle.outer, AttrTarget.item, "doc", attr_value_string("line1"), sp)
    let a1 = attr_name_value(AttrStyle.outer, AttrTarget.item, "doc", attr_value_string("line2"), sp)
    let a2 = attr_word(AttrStyle.outer, AttrTarget.item, "inline", sp)

    let buf: _AttrBuf4
    buf.a0 = a0
    buf.a1 = a1
    buf.a2 = a2
    buf.a3 = a2

    let list: AttrList
    list.data = &buf.a0
    list.len = 3

    let out: _StrBuf8
    let n = attr_list_collect_docs(list, &out.s0, 8)

    if n != 2
        ret false
    .end
    if out.s0 != "line1"
        ret false
    .end
    if out.s1 != "line2"
        ret false
    .end

    ret true
.end

fn attr_smoke_duplicate_policy() -> bool
    let sp = span_none()

    let a0 = attr_word(AttrStyle.outer, AttrTarget.item, "inline", sp)
    let a1 = attr_word(AttrStyle.outer, AttrTarget.item, "inline", sp)

    let buf: _AttrBuf4
    buf.a0 = a0
    buf.a1 = a1
    buf.a2 = a0
    buf.a3 = a0

    let list: AttrList
    list.data = &buf.a0
    list.len = 2

    let e = attr_list_validate(list)
    ret e.kind == AttrErrorKind.duplicate_disallowed
.end

fn attr_smoke_all() -> bool
    if !attr_smoke_ident_and_path()
        ret false
    .end

    if !attr_smoke_docs_collect()
        ret false
    .end

    if !attr_smoke_duplicate_policy()
        ret false
    .end

    ret true
.end
