module vitte.compiler.frontend.parser

import std.collections as coll

import vitte.compiler.frontend.lexer as lex
import vitte.compiler.frontend.diagnostics as diag
import vitte.compiler.frontend.ast as ast

# =============================================================================
# Vitte compiler – Parser runtime (version avec AST rempli)
#
# Objectifs :
#   - parse_module(tokens, file, diags) -> ast.Module complet,
#   - Parser qui:
#       * parcourt les tokens,
#       * dispatch les déclarations toplevel,
#       * construit des ast.ModuleItem (ModuleDecl, ImportDecl, StructDecl, FnDecl),
#       * accumule diagnostics.
# =============================================================================

# -----------------------------------------------------------------------------
# État du parser
# -----------------------------------------------------------------------------

struct Parser
  tokens: coll.Vec[lex.Token]
  index: Int
  file: String
  diags: &mut diag.DiagnosticBag
.end

fn Parser.new(tokens: coll.Vec[lex.Token], file: String, diags: &mut diag.DiagnosticBag) -> Parser
  return Parser(
    tokens = tokens,
    index = 0,
    file = file,
    diags = diags,
  )
.end

# -----------------------------------------------------------------------------
# API publique
# -----------------------------------------------------------------------------

fn parse_module(
  tokens: coll.Vec[lex.Token],
  file: String,
  diags: &mut diag.DiagnosticBag,
) -> ast.Module
  let parser = Parser.new(tokens, file, diags)
  return parser.parse_module()
.end

# Alias pratique pour compat CLI (parse_file == parse_module)
fn parse_file(
  tokens: coll.Vec[lex.Token],
  file: String,
  diags: &mut diag.DiagnosticBag,
) -> ast.Module
  return parse_module(tokens, file, diags)
.end

# -----------------------------------------------------------------------------
# Helpers de navigation
# -----------------------------------------------------------------------------

fn Parser.is_eof(self: Parser) -> Bool
  return self.index >= self.tokens.len()
.end

fn Parser.sentinel(self: Parser) -> lex.Token
  let dummy_span = diag.Span.dummy(self.file)
  return lex.Token(
    kind = lex.TokenKind.Eof,
    lexeme = "",
    span = dummy_span,
  )
.end

fn Parser.current(self: Parser) -> lex.Token
  if self.tokens.len() == 0
    return self.sentinel()
  end

  if self.is_eof()
    # Hypothèse : le lexer ajoute toujours un token Eof final, sinon sentinel.
    if self.tokens.len() > 0
      return self.tokens[self.tokens.len() - 1]
    end
    return self.sentinel()
  end
  return self.tokens[self.index]
.end

fn Parser.peek_kind(self: Parser) -> lex.TokenKind
  let tok = self.current()
  return tok.kind
.end

fn Parser.peek_next_kind(self: Parser) -> lex.TokenKind
  let next_index = self.index + 1
  if next_index >= self.tokens.len()
    return lex.TokenKind.Eof
  end
  return self.tokens[next_index].kind
.end

fn Parser.peek_is_dot_end(self: Parser) -> Bool
  let tok = self.current()

  if tok.lexeme == ".end" or tok.kind == lex.TokenKind.KwEnd or tok.lexeme == "end"
    return true
  end

  if tok.kind == lex.TokenKind.Dot
    let next_kind = self.peek_next_kind()
    if next_kind == lex.TokenKind.KwEnd
      return true
    end
  end

  return false
.end

fn Parser.advance(self: &mut Parser) -> lex.Token
  let tok = self.current()
  if not self.is_eof()
    self.index = self.index + 1
  end
  return tok
.end

fn Parser.match_kind(self: &mut Parser, kind: lex.TokenKind) -> Bool
  if self.peek_kind() == kind
    self.advance()
    return true
  end
  return false
.end

fn Parser.expect_kind(self: &mut Parser, kind: lex.TokenKind, code: String, msg: String) -> lex.Token
  let tok = self.current()
  if tok.kind == kind
    self.advance()
    return tok
  end

  # Diagnostic simple : "token attendu"
  let span = tok.span
  self.diags.add_error(msg, span, code)

  # On retourne quand même le token courant pour éviter de casser le flux.
  self.advance()
  return tok
.end

fn Parser.expect_symbol(self: &mut Parser, symbol: String, code: String, msg: String) -> lex.Token
  let tok = self.current()
  if tok.lexeme == symbol
    self.advance()
    return tok
  end

  self.diags.add_error(
    msg,
    tok.span,
    code,
  )

  self.advance()
  return tok
.end

# -----------------------------------------------------------------------------
# Helpers noms/chemins et fin de bloc
# -----------------------------------------------------------------------------

fn Parser.parse_ident_path(self: &mut Parser, err_code: String, err_msg: String) -> (coll.Vec[ast.Ident], diag.Span)
  let idents = coll.Vec[ast.Ident].new()

  if self.peek_kind() != lex.TokenKind.Ident
    let tok = self.current()
    self.diags.add_error(err_msg, tok.span, err_code)
    return (idents, tok.span)
  end

  let first_tok = self.advance()
  let first_ident = ast.Ident(
    name = first_tok.lexeme,
    span = first_tok.span,
  )
  idents.push(first_ident)

  let mut out_span = first_tok.span

  while not self.is_eof() and (self.peek_kind() == lex.TokenKind.Dot or self.peek_kind() == lex.TokenKind.ColonColon)
    let sep_tok = self.advance()

    if self.peek_kind() != lex.TokenKind.Ident
      self.diags.add_error(
        "Identifiant attendu après un séparateur de chemin",
        sep_tok.span,
        "E0901",
      )
      break
    end

    let seg_tok = self.advance()
    let ident = ast.Ident(
      name = seg_tok.lexeme,
      span = seg_tok.span,
    )
    idents.push(ident)
    out_span = diag.Span.merge(out_span, seg_tok.span)
  end

  return (idents, out_span)
.end

fn Parser.path_to_string(idents: coll.Vec[ast.Ident]) -> String
  let mut out = ""
  let mut first = true

  for ident in idents
    if not first
      out = out + "."
    else
      first = false
    end
    out = out + ident.name
  end

  return out
.end

fn Parser.is_block_end(self: Parser) -> Bool
  let tok = self.current()

  if tok.kind == lex.TokenKind.Eof
    return true
  end

  if tok.lexeme == ".end" or tok.kind == lex.TokenKind.KwEnd or tok.lexeme == "end"
    return true
  end

  if tok.kind == lex.TokenKind.RBrace
    return true
  end

  if tok.kind == lex.TokenKind.Dot
    let next_index = self.index + 1
    if next_index < self.tokens.len()
      let next = self.tokens[next_index]
      if next.kind == lex.TokenKind.KwEnd or next.lexeme == "end"
        return true
      end
    end
  end

  return false
.end

fn Parser.consume_block_end(self: &mut Parser) -> diag.Span
  let tok = self.current()

  if tok.lexeme == ".end"
    self.advance()
    return tok.span
  end

  if tok.kind == lex.TokenKind.Dot
    let dot_span = tok.span
    self.advance()

    if self.peek_kind() == lex.TokenKind.KwEnd or self.current().lexeme == "end"
      let end_tok = self.current()
      self.advance()
      return diag.Span.merge(dot_span, end_tok.span)
    end

    return dot_span
  end

  if tok.kind == lex.TokenKind.RBrace
    self.advance()
    return tok.span
  end

  self.advance()
  return tok.span
.end

# -----------------------------------------------------------------------------
# Parsing haut niveau – module
# -----------------------------------------------------------------------------

fn Parser.parse_module(self: &mut Parser) -> ast.Module
  # On construit le module AST et on le remplit au fur et à mesure.
  let module = ast.Module.new(self.file)

  # Pour pouvoir muter module dans la boucle, on crée une variable mutable.
  let mut_mod = module

  while not self.is_eof()
    let kind = self.peek_kind()

    if kind == lex.TokenKind.Eof
      break
    end

    # Sauter les lignes vides
    if kind == lex.TokenKind.Newline
      self.advance()
      continue
    end

    self.parse_toplevel_item(&mut mut_mod)
  end

  return mut_mod
.end

# -----------------------------------------------------------------------------
# Parsing des items de haut niveau
# -----------------------------------------------------------------------------

fn Parser.parse_toplevel_item(self: &mut Parser, module: &mut ast.Module) -> Unit
  # Dispatch des déclarations de haut niveau selon le token courant.
  let kind = self.peek_kind()

  if kind == lex.TokenKind.KwLet
    self.parse_let_stmt(module)
    return
  end

  if kind == lex.TokenKind.KwModule
    self.parse_module_decl(module)
    return
  end

  if kind == lex.TokenKind.KwImport
    self.parse_import_decl(module)
    return
  end

  if kind == lex.TokenKind.KwStruct
    self.parse_struct_decl(module)
    return
  end

  if kind == lex.TokenKind.KwFn
    self.parse_fn_decl(module)
    return
  end

  # Token inattendu au toplevel : on signale une erreur puis on se resynchronise.
  let tok = self.current()
  let span = tok.span
  self.diags.add_error(
    "Déclaration de haut niveau inattendue",
    span,
    "E1000",
  )

  self.synchronize()
.end

fn Parser.synchronize(self: &mut Parser) -> Unit
  # Avancer jusqu'à un point de synchronisation raisonnable après une erreur :
  #   - newline,
  #   - EOF.
  # Plus tard, on pourra ajouter d'autres points (module, struct, fn, etc.).

  while not self.is_eof()
    let kind = self.peek_kind()

    if kind == lex.TokenKind.Newline or kind == lex.TokenKind.Eof
      # On consomme éventuellement le newline, mais on laisse EOF au parser.
      if kind == lex.TokenKind.Newline
        self.advance()
      end
      return
    end

    self.advance()
  end
.end

# -----------------------------------------------------------------------------
# Déclarations de module / import / struct / fn → construisent des ModuleItem
# -----------------------------------------------------------------------------

# -----------------------------------------------------------------------------
# Helpers pour les fonctions : types, paramètres, corps
# -----------------------------------------------------------------------------

fn Parser.parse_type_expr(self: &mut Parser) -> ast.TypeExpr
  # Pour le moment, on supporte uniquement les types nommés simples : Ident
  if self.peek_kind() == lex.TokenKind.Ident
    let (idents, span) = self.parse_ident_path(
      "E1035",
      "Nom de type attendu",
    )
    return ast.TypeExpr.named_from_path(idents, span)
  end

  let tok = self.current()
  self.diags.add_error(
    "Type attendu",
    tok.span,
    "E1034",
  )

  # Type de repli : ident vide, span = token courant
  let dummy_ident = ast.Ident(
    name = "",
    span = tok.span,
  )
  return ast.TypeExpr.named_from_ident(dummy_ident)
.end

fn Parser.parse_fn_param(self: &mut Parser) -> ast.FnParam
  # <ident> (':' TypeExpr)?
  let mut name = ""
  let mut name_span = self.current().span

  if self.peek_kind() == lex.TokenKind.Ident
    let t = self.advance()
    name = t.lexeme
    name_span = t.span
  else
    let tok = self.current()
    self.diags.add_error(
      "Nom de paramètre attendu",
      tok.span,
      "E1036",
    )
  end

  let ident = ast.Ident(
    name = name,
    span = name_span,
  )

  # Paramètre typé : ':' TypeExpr
  let tok = self.current()
  if tok.lexeme == ":"
    # Consommer le ':'
    self.expect_symbol(
      ":",
      "E1037",
      "':' attendu après le nom du paramètre",
    )

    let ty = self.parse_type_expr()
    let span = diag.Span.merge(name_span, ty.span)

    let param = ast.FnParam.new(
      ident,
      Some(ty),
      None,
      span,
    )
    return param
  end

  # Paramètre sans type
  let param = ast.FnParam.new(
    ident,
    None,
    None,
    name_span,
  )
  return param
.end

fn Parser.parse_fn_param_list(self: &mut Parser) -> coll.Vec[ast.FnParam]
  let params = coll.Vec[ast.FnParam].new()

  # '('
  self.expect_symbol(
    "(",
    "E1032",
    "Parenthèse ouvrante '(' attendue après le nom de la fonction",
  )

  # Cas : aucun paramètre
  let tok = self.current()
  if tok.lexeme == ")"
    self.advance()
    return params
  end

  while not self.is_eof()
    let param = self.parse_fn_param()
    params.push(param)

    let sep = self.current()

    if sep.lexeme == ","
      self.advance()
      let after = self.current()
      if after.lexeme == ")"
        self.advance()
        break
      end
      continue
    end

    if sep.lexeme == ")"
      self.advance()
      break
    end

    # Autre chose : erreur douce, on sort de la liste.
    self.diags.add_error(
      "',' ou ')' attendu après un paramètre de fonction",
      sep.span,
      "E1033",
    )
    break
  end

  return params
.end

fn Parser.parse_expr(self: &mut Parser, module: &mut ast.Module) -> ast.ExprId
  return self.parse_binary_expr(module, 0)
.end

fn Parser.parse_primary_expr(self: &mut Parser, module: &mut ast.Module) -> ast.ExprId
  let tok = self.current()

  if tok.kind == lex.TokenKind.FloatLiteral
    self.advance()
    let expr = ast.Expr(
      kind = ast.ExprKind.FloatLiteral(
        value = tok.lexeme,
      ),
      span = tok.span,
    )
    return module.add_expr(expr)
  end

  if tok.kind == lex.TokenKind.CharLiteral
    self.advance()
    let expr = ast.Expr(
      kind = ast.ExprKind.CharLiteral(
        value = tok.lexeme,
      ),
      span = tok.span,
    )
    return module.add_expr(expr)
  end

  if tok.kind == lex.TokenKind.StringLiteral
    self.advance()
    let expr = ast.Expr(
      kind = ast.ExprKind.StringLiteral(
        value = tok.lexeme,
      ),
      span = tok.span,
    )
    return module.add_expr(expr)
  end

  if tok.kind == lex.TokenKind.KwTrue
    self.advance()
    let expr = ast.Expr(
      kind = ast.ExprKind.BoolLiteral(
        value = true,
      ),
      span = tok.span,
    )
    return module.add_expr(expr)
  end

  if tok.kind == lex.TokenKind.KwFalse
    self.advance()
    let expr = ast.Expr(
      kind = ast.ExprKind.BoolLiteral(
        value = false,
      ),
      span = tok.span,
    )
    return module.add_expr(expr)
  end

  if tok.kind == lex.TokenKind.IntLiteral
    self.advance()
    let expr = ast.Expr(
      kind = ast.ExprKind.IntLiteral(
        value = tok.lexeme,
      ),
      span = tok.span,
    )
    return module.add_expr(expr)
  end

  if tok.kind == lex.TokenKind.Ident
    let (idents, span) = self.parse_ident_path(
      "E2004",
      "Identifiant attendu dans une expression",
    )

    # Struct literal si suivi de '{'
    if self.peek_kind() == lex.TokenKind.LBrace
      self.advance()
      let (fields, end_span) = self.parse_struct_literal_fields(module)
      let final_span = diag.Span.merge(span, end_span)
      let expr = ast.Expr(
        kind = ast.ExprKind.StructLiteral(
          type_path = idents,
          fields = fields,
        ),
        span = final_span,
      )
      return module.add_expr(expr)
    end

    # Sinon, simple nom/chemin
    let expr = ast.Expr(
      kind = ast.ExprKind.PathName(
        path = idents,
      ),
      span = span,
    )
    return module.add_expr(expr)
  end

  if tok.kind == lex.TokenKind.LParen
    self.advance()
    let inner_id = self.parse_expr(module)
    self.expect_symbol(
      ")",
      "E2002",
      "Parenthèse fermante ')' attendue",
    )

    let inner = module.get_expr(inner_id)
    let span = diag.Span.merge(tok.span, inner.span)
    let mut_expr = ast.Expr(
      kind = inner.kind,
      span = span,
    )
    return module.add_expr(mut_expr)
  end

  if tok.kind == lex.TokenKind.LBrace
    let lbrace = self.advance()
    let block_id = self.parse_block_braced(module, lbrace.span)
    let block = module.get_block(block_id)
    let expr = ast.Expr(
      kind = ast.ExprKind.BlockExpr(
        block = block_id,
      ),
      span = block.span,
    )
    return module.add_expr(expr)
  end

  self.diags.add_error(
    "Expression attendue",
    tok.span,
    "E2000",
  )

  let dummy_ident = ast.Ident(
    name = "",
    span = tok.span,
  )
  let expr = ast.Expr(
    kind = ast.ExprKind.Name(
      ident = dummy_ident,
    ),
    span = tok.span,
  )
  self.advance()
  return module.add_expr(expr)
.end

fn Parser.parse_struct_literal_fields(self: &mut Parser, module: &mut ast.Module) -> (coll.Vec[ast.StructField], diag.Span)
  let fields = coll.Vec[ast.StructField].new()
  let mut end_span = self.current().span

  while not self.is_eof()
    if self.peek_kind() == lex.TokenKind.RBrace
      let brace = self.advance()
      end_span = brace.span
      break
    end

    if self.peek_is_dot_end()
      let bad = self.current()
      self.diags.add_error(
        "Un littéral de struct se ferme avec '}' (et non '.end')",
        bad.span,
        "E2009",
      )
      let consumed = self.consume_block_end()
      end_span = consumed
      break
    end

    if self.peek_kind() == lex.TokenKind.Newline
      self.advance()
      continue
    end

    # Nom du champ
    if self.peek_kind() != lex.TokenKind.Ident
      let tok = self.current()
      self.diags.add_error(
        "Nom de champ attendu dans un littéral de struct",
        tok.span,
        "E2005",
      )
      self.advance()
      continue
    end

    let name_tok = self.advance()
    let name_ident = ast.Ident(name = name_tok.lexeme, span = name_tok.span)

    self.expect_symbol(
      "=",
      "E2006",
      "'=' attendu après le nom du champ",
    )

    let value_id = self.parse_expr(module)
    let value_expr = module.get_expr(value_id)
    let field_span = diag.Span.merge(name_tok.span, value_expr.span)

    let field = ast.StructField(
      name = name_ident,
      value = value_id,
      span = field_span,
    )
    fields.push(field)
    end_span = field_span

    if self.peek_kind() == lex.TokenKind.Comma
      self.advance()
      continue
    end

    if self.peek_kind() == lex.TokenKind.RBrace
      let brace = self.advance()
      end_span = diag.Span.merge(end_span, brace.span)
      break
    end

    # Séparateur manquant : diagnostic et tentative de récupération
    let sep = self.current()
    self.diags.add_error(
      "',' ou '}' attendu après un champ de struct",
      sep.span,
      "E2007",
    )
    # Récupération : avancer jusqu'à un séparateur raisonnable
    while not self.is_eof()
      let k = self.peek_kind()
      if k == lex.TokenKind.Comma or k == lex.TokenKind.RBrace or self.peek_is_dot_end() or k == lex.TokenKind.Newline
        break
      end
      self.advance()
    end

    if self.peek_kind() == lex.TokenKind.Comma
      self.advance()
      continue
    end

    if self.peek_kind() == lex.TokenKind.RBrace
      let brace = self.advance()
      end_span = diag.Span.merge(end_span, brace.span)
      break
    end

    if self.peek_is_dot_end()
      let bad_span = self.consume_block_end()
      self.diags.add_error(
        "Un littéral de struct se ferme avec '}' (et non '.end')",
        bad_span,
        "E2009",
      )
      end_span = bad_span
      break
    end

    if self.peek_kind() == lex.TokenKind.Newline
      self.advance()
    end
  end

  return (fields, end_span)
.end

fn Parser.parse_call_expr(self: &mut Parser, module: &mut ast.Module) -> ast.ExprId
  let mut callee_id = self.parse_primary_expr(module)

  while not self.is_eof() and self.peek_kind() == lex.TokenKind.LParen
    let lparen = self.advance()
    let args = coll.Vec[ast.ExprId].new()

    if self.peek_kind() == lex.TokenKind.RParen
      self.advance()
    else
      while not self.is_eof()
        let arg_id = self.parse_expr(module)
        args.push(arg_id)

        if self.peek_kind() == lex.TokenKind.Comma
          self.advance()
          continue
        end

        if self.peek_kind() == lex.TokenKind.RParen
          self.advance()
          break
        end

        let sep = self.current()
        self.diags.add_error(
          "',' ou ')' attendu dans la liste d'arguments",
          sep.span,
          "E2003",
        )
        break
      end
    end

    let callee_expr = module.get_expr(callee_id)
    let span =
      if args.len() == 0
        diag.Span.merge(callee_expr.span, lparen.span)
      else
        let last_arg = module.get_expr(args[args.len() - 1])
        diag.Span.merge(callee_expr.span, last_arg.span)
      end

    let call_expr = ast.Expr(
      kind = ast.ExprKind.Call(
        callee = callee_id,
        args = args,
      ),
      span = span,
    )
    callee_id = module.add_expr(call_expr)
  end

  return callee_id
.end

fn Parser.binary_precedence(self: Parser, op: ast.BinaryOp) -> Int
  if op == ast.BinaryOp.Assign
    return 1
  end

  if op == ast.BinaryOp.Mul or op == ast.BinaryOp.Div
    return 20
  end

  if op == ast.BinaryOp.Add or op == ast.BinaryOp.Sub
    return 10
  end

  if op == ast.BinaryOp.Eq or op == ast.BinaryOp.Ne
    return 4
  end

  if op == ast.BinaryOp.Lt or op == ast.BinaryOp.Le or op == ast.BinaryOp.Gt or op == ast.BinaryOp.Ge
    return 5
  end

  return -1
.end

struct BinaryOpLookahead
  found: Bool
  op: ast.BinaryOp
.end

fn Parser.current_binary_op(self: Parser) -> BinaryOpLookahead
  let tok = self.current()

  if tok.kind == lex.TokenKind.Plus
    return BinaryOpLookahead(found = true, op = ast.BinaryOp.Add)
  end
  if tok.kind == lex.TokenKind.Minus
    return BinaryOpLookahead(found = true, op = ast.BinaryOp.Sub)
  end
  if tok.kind == lex.TokenKind.Star
    return BinaryOpLookahead(found = true, op = ast.BinaryOp.Mul)
  end
  if tok.kind == lex.TokenKind.Slash
    return BinaryOpLookahead(found = true, op = ast.BinaryOp.Div)
  end
  if tok.kind == lex.TokenKind.EqualEqual
    return BinaryOpLookahead(found = true, op = ast.BinaryOp.Eq)
  end
  if tok.kind == lex.TokenKind.BangEqual
    return BinaryOpLookahead(found = true, op = ast.BinaryOp.Ne)
  end
  if tok.kind == lex.TokenKind.Less
    return BinaryOpLookahead(found = true, op = ast.BinaryOp.Lt)
  end
  if tok.kind == lex.TokenKind.LessEqual
    return BinaryOpLookahead(found = true, op = ast.BinaryOp.Le)
  end
  if tok.kind == lex.TokenKind.Greater
    return BinaryOpLookahead(found = true, op = ast.BinaryOp.Gt)
  end
  if tok.kind == lex.TokenKind.GreaterEqual
    return BinaryOpLookahead(found = true, op = ast.BinaryOp.Ge)
  end
  if tok.kind == lex.TokenKind.Equal
    return BinaryOpLookahead(found = true, op = ast.BinaryOp.Assign)
  end

  return BinaryOpLookahead(found = false, op = ast.BinaryOp.Add)
.end

fn Parser.parse_binary_expr(self: &mut Parser, module: &mut ast.Module, min_prec: Int) -> ast.ExprId
  let mut lhs = self.parse_call_expr(module)

  while not self.is_eof()
    let look = self.current_binary_op()
    if not look.found
      break
    end

    let op = look.op
    let prec = self.binary_precedence(op)
    if prec < min_prec
      break
    end

    self.advance()
    let next_prec = if op == ast.BinaryOp.Assign then prec else prec + 1 end
    let rhs = self.parse_binary_expr(module, next_prec)

    let lhs_expr = module.get_expr(lhs)
    let rhs_expr = module.get_expr(rhs)
    let span = diag.Span.merge(lhs_expr.span, rhs_expr.span)

    let bin_expr = ast.Expr(
      kind = ast.ExprKind.Binary(
        op = op,
        lhs = lhs,
        rhs = rhs,
      ),
      span = span,
    )
    lhs = module.add_expr(bin_expr)
  end

  return lhs
.end

fn Parser.parse_stmt(self: &mut Parser, module: &mut ast.Module) -> ast.StmtId
  let tok = self.current()

  # ---------------------------------------------------------------------------
  # let ...
  # ---------------------------------------------------------------------------
  if tok.kind == lex.TokenKind.KwLet
    return self.parse_let_stmt(module)
  end

  # ---------------------------------------------------------------------------
  # while ...
  # ---------------------------------------------------------------------------
  if tok.kind == lex.TokenKind.KwWhile
    let kw = self.advance()
    let cond_id = self.parse_expr(module)
    let body_id = self.parse_block(module)
    let body = module.get_block(body_id)
    let span = diag.Span.merge(kw.span, body.span)

    let stmt = ast.Stmt(
      kind = ast.StmtKind.While(
        cond = cond_id,
        body = body_id,
      ),
      span = span,
    )
    return module.add_stmt(stmt)
  end

  # ---------------------------------------------------------------------------
  # if ... else ...
  # ---------------------------------------------------------------------------
  if tok.kind == lex.TokenKind.KwIf
    let kw = self.advance()
    let cond_id = self.parse_expr(module)
    let then_block_id = self.parse_block(module)
    let then_block = module.get_block(then_block_id)

    let mut has_else = false
    let mut else_block_id = 0
    if self.peek_kind() == lex.TokenKind.KwElse
      self.advance()
      else_block_id = self.parse_block(module)
      has_else = true
    end

    let end_span =
      if has_else
        let blk = module.get_block(else_block_id)
        blk.span
      else
        then_block.span
      end

    let stmt_span = diag.Span.merge(kw.span, end_span)

    let stmt = ast.Stmt(
      kind = ast.StmtKind.If(
        cond = cond_id,
        then_block = then_block_id,
        else_block = if has_else then Some(else_block_id) else None end,
      ),
      span = stmt_span,
    )
    return module.add_stmt(stmt)
  end

  # ---------------------------------------------------------------------------
  # match ...
  # ---------------------------------------------------------------------------
  if tok.kind == lex.TokenKind.KwMatch
    return self.parse_match_stmt(module)
  end

  # ---------------------------------------------------------------------------
  # return ...
  # ---------------------------------------------------------------------------
  if tok.lexeme == "return"
    let kw = self.advance()

    # return nu sur la ligne
    if self.peek_kind() == lex.TokenKind.Newline or self.peek_kind() == lex.TokenKind.Eof or self.current().lexeme == ".end"
      let stmt = ast.Stmt(
        kind = ast.StmtKind.Return(
          value = None,
        ),
        span = kw.span,
      )
      let id = module.add_stmt(stmt)
      return id
    end

    # return avec une expression
    let expr_id = self.parse_expr(module)
    let expr = module.get_expr(expr_id)
    let stmt_span = diag.Span.merge(kw.span, expr.span)

    let stmt = ast.Stmt(
      kind = ast.StmtKind.Return(
        value = Some(expr_id),
      ),
      span = stmt_span,
    )
    let id = module.add_stmt(stmt)

    # Consommer jusqu'à fin de ligne (mais pas le '.end')
    while not self.is_eof()
      let k = self.peek_kind()
      if k == lex.TokenKind.Newline or k == lex.TokenKind.Eof
        if k == lex.TokenKind.Newline
          self.advance()
        end
        break
      end
      if self.is_block_end()
        break
      end
      self.advance()
    end

    return id
  end

  # ---------------------------------------------------------------------------
  # Statement = expression simple
  # ---------------------------------------------------------------------------
  let expr_id = self.parse_expr(module)
  let expr = module.get_expr(expr_id)
  let stmt_span = expr.span

  let stmt = ast.Stmt(
    kind = ast.StmtKind.Expr(
      expr = expr_id,
    ),
    span = stmt_span,
  )
  let id = module.add_stmt(stmt)

  # Consommer jusqu'à fin de ligne (mais pas le '.end')
  while not self.is_eof()
    let k = self.peek_kind()
    if k == lex.TokenKind.Newline or k == lex.TokenKind.Eof
      if k == lex.TokenKind.Newline
        self.advance()
      end
      break
    end
    if self.is_block_end()
      break
    end
    self.advance()
  end

  return id
.end

fn Parser.parse_block(self: &mut Parser, module: &mut ast.Module) -> ast.BlockId
  if self.peek_kind() == lex.TokenKind.LBrace
    let lbrace = self.advance()
    return self.parse_block_impl(
      module,
      true,    # allow_rbrace
      false,   # allow_dot_end
      "Bloc '{ ... }' non terminé",
      "E1301",
      Some(lbrace.span),
    )
  end

  return self.parse_block_impl(
    module,
    false,   # allow_rbrace
    true,    # allow_dot_end
    "Bloc non terminé ('.end' manquant)",
    "E1300",
    None,
  )
.end

fn Parser.parse_block_braced(self: &mut Parser, module: &mut ast.Module, open_span: diag.Span) -> ast.BlockId
  return self.parse_block_impl(
    module,
    true,    # allow_rbrace
    false,   # allow_dot_end
    "Bloc '{ ... }' non terminé",
    "E1301",
    Some(open_span),
  )
.end

fn Parser.parse_block_impl(
  self: &mut Parser,
  module: &mut ast.Module,
  allow_rbrace: Bool,
  allow_dot_end: Bool,
  missing_msg: String,
  missing_code: String,
  start_span_override: Option[diag.Span],
) -> ast.BlockId
  let start_tok = self.current()
  let start_span =
    if start_span_override.is_some()
      start_span_override.unwrap()
    else
      start_tok.span
    end

  let stmt_ids = coll.Vec[ast.StmtId].new()

  while true
    let tok = self.current()

    # Fermeture explicite par '}'
    if tok.kind == lex.TokenKind.RBrace
      if allow_rbrace
        let end_span = tok.span
        self.advance()
        let span = diag.Span.merge(start_span, end_span)
        let block = ast.Block(
          stmts = stmt_ids,
          span = span,
        )
        let id = module.add_block(block)
        return id
      else
        let mut d = diag.Diagnostic.error(
          missing_msg,
          tok.span,
          missing_code,
        )
        d.add_secondary_label(
          "Bloc ouvert ici",
          start_span,
        )
        self.diags.add(d)
        let span = diag.Span.merge(start_span, tok.span)
        let block = ast.Block(
          stmts = stmt_ids,
          span = span,
        )
        let id = module.add_block(block)
        self.advance()
        return id
      end
    end

    # Fermeture explicite par '.end'
    if self.peek_is_dot_end()
      let end_span = self.consume_block_end()
      if not allow_dot_end
        let mut d = diag.Diagnostic.error(
          "Utiliser '}' pour fermer ce bloc",
          end_span,
          "E1302",
        )
        d.add_secondary_label(
          "Bloc ouvert ici",
          start_span,
        )
        self.diags.add(d)
      end

      let span = diag.Span.merge(start_span, end_span)
      let block = ast.Block(
        stmts = stmt_ids,
        span = span,
      )
      let id = module.add_block(block)
      return id
    end

    # EOF inattendu
    if tok.kind == lex.TokenKind.Eof
      let mut d = diag.Diagnostic.error(
        missing_msg,
        tok.span,
        missing_code,
      )
      d.add_secondary_label(
        "Bloc ouvert ici",
        start_span,
      )
      self.diags.add(d)
      let span = diag.Span.merge(start_span, tok.span)
      let block = ast.Block(
        stmts = stmt_ids,
        span = span,
      )
      let id = module.add_block(block)
      return id
    end

    # Sauter les lignes vides
    if tok.kind == lex.TokenKind.Newline
      self.advance()
      continue
    end

    # Sinon, on parse un statement
    let stmt_id = self.parse_stmt(module)
    stmt_ids.push(stmt_id)
  end

  # Pas de '.end' : on ferme sur le dernier token (EOF typiquement).
  let last = self.current()
  let span = diag.Span.merge(start_span, last.span)
  let block = ast.Block(
    stmts = stmt_ids,
    span = span,
  )
  let id = module.add_block(block)
  return id
.end

fn Parser.parse_module_decl(self: &mut Parser, module: &mut ast.Module) -> Unit
  # module <Ident> ...
  let kw_tok = self.expect_kind(
    lex.TokenKind.KwModule,
    "E1001",
    "Mot-clé 'module' attendu",
  )
  let kw_span = kw_tok.span

  let (idents, name_span) = self.parse_ident_path(
    "E1002",
    "Nom de module attendu après 'module'",
  )
  let name = self.path_to_string(idents)

  let decl_span = diag.Span.merge(kw_span, name_span)
  let item = ast.ModuleItem.new(
    ast.ModuleItemKind.ModuleDecl,
    name,
    decl_span,
  )
  module.add_item(item)

  # Consommer le reste de la ligne (paramètres futurs, attributs, etc.)
  while not self.is_eof()
    let kind = self.peek_kind()
    if kind == lex.TokenKind.Newline or kind == lex.TokenKind.Eof
      if kind == lex.TokenKind.Newline
        self.advance()
      end
      break
    end
    self.advance()
  end
.end

fn Parser.parse_import_decl(self: &mut Parser, module: &mut ast.Module) -> Unit
  # import <Ident> ...
  let kw_tok = self.expect_kind(
    lex.TokenKind.KwImport,
    "E1010",
    "Mot-clé 'import' attendu",
  )
  let kw_span = kw_tok.span

  let (idents, name_span) = self.parse_ident_path(
    "E1011",
    "Nom de module attendu après 'import'",
  )
  let name = self.path_to_string(idents)

  let decl_span = diag.Span.merge(kw_span, name_span)
  let item = ast.ModuleItem.new(
    ast.ModuleItemKind.ImportDecl,
    name,
    decl_span,
  )
  module.add_item(item)

  while not self.is_eof()
    let kind = self.peek_kind()
    if kind == lex.TokenKind.Newline or kind == lex.TokenKind.Eof
      if kind == lex.TokenKind.Newline
        self.advance()
      end
      break
    end
    self.advance()
  end
.end

fn Parser.parse_struct_decl(self: &mut Parser, module: &mut ast.Module) -> Unit
  # struct <Ident> ...
  let kw_tok = self.expect_kind(
    lex.TokenKind.KwStruct,
    "E1020",
    "Mot-clé 'struct' attendu",
  )
  let kw_span = kw_tok.span

  let mut name = ""
  let mut name_span = kw_span

  if self.peek_kind() == lex.TokenKind.Ident
    let t = self.advance()
    name = t.lexeme
    name_span = t.span
  else
    let tok = self.current()
    let span = tok.span
    self.diags.add_error(
      "Nom de struct attendu après 'struct'",
      span,
      "E1021",
    )
  end

  let decl_span = diag.Span.merge(kw_span, name_span)
  let item = ast.ModuleItem.new(
    ast.ModuleItemKind.StructDecl,
    name,
    decl_span,
  )
  module.add_item(item)

  # TODO: plus tard, parser les champs jusqu'à 'end'.
  # Pour l'instant, on avance jusqu'à la fin de ligne.
  while not self.is_eof()
    let kind = self.peek_kind()
    if kind == lex.TokenKind.Newline or kind == lex.TokenKind.Eof
      if kind == lex.TokenKind.Newline
        self.advance()
      end
      break
    end
    self.advance()
  end
.end

fn Parser.parse_fn_decl(self: &mut Parser, module: &mut ast.Module) -> Unit
  # fn <Ident>(...) [-> Type] .end
  let kw_tok = self.expect_kind(
    lex.TokenKind.KwFn,
    "E1030",
    "Mot-clé 'fn' attendu",
  )
  let kw_span = kw_tok.span

  let mut name = ""
  let mut name_span = kw_span

  if self.peek_kind() == lex.TokenKind.Ident
    let t = self.advance()
    name = t.lexeme
    name_span = t.span
  else
    let tok = self.current()
    let span = tok.span
    self.diags.add_error(
      "Nom de fonction attendu après 'fn'",
      span,
      "E1031",
    )
  end

  let ident = ast.Ident(
    name = name,
    span = name_span,
  )

  # Paramètres : fn name (param, ...) ...
  let params = self.parse_fn_param_list()

  # Type de retour optionnel : '-> Type'
  let tok_after_params = self.current()
  if tok_after_params.lexeme == "->"
    self.expect_symbol(
      "->",
      "E1038",
      "Symbole '->' attendu avant le type de retour",
    )

    let ret_ty = self.parse_type_expr()

    # Corps de fonction jusqu'à '.end'
    let body_id = self.parse_block(module)
    let block = module.get_block(body_id)
    let decl_span = diag.Span.merge(kw_span, block.span)

    let decl = ast.FnDecl.new(
      ident,
      ast.Visibility.Private,
      ast.FnKind.Normal,
      params,
      Some(ret_ty),
      Some(body_id),
      decl_span,
    )

    let item = ast.ModuleItem.from_fn(decl)
    module.add_item(item)
    return
  end

  # Pas de type de retour explicite
  let body_id = self.parse_block(module)
  let block = module.get_block(body_id)
  let decl_span = diag.Span.merge(kw_span, block.span)

  let decl = ast.FnDecl.new(
    ident,
    ast.Visibility.Private,
    ast.FnKind.Normal,
    params,
    None,
    Some(body_id),
    decl_span,
  )

  let item = ast.ModuleItem.from_fn(decl)
  module.add_item(item)
.end

# -----------------------------------------------------------------------------
# Déclarations / statements supplémentaires
# -----------------------------------------------------------------------------

fn Parser.parse_let_stmt(self: &mut Parser, module: &mut ast.Module) -> ast.StmtId
  let kw = self.expect_kind(
    lex.TokenKind.KwLet,
    "E1100",
    "Mot-clé 'let' attendu",
  )

  let mut is_mut = false
  if self.peek_kind() == lex.TokenKind.KwMut
    self.advance()
    is_mut = true
  end

  let mut name = ""
  let mut name_span = kw.span
  if self.peek_kind() == lex.TokenKind.Ident
    let t = self.advance()
    name = t.lexeme
    name_span = t.span
  else
    let tok = self.current()
    self.diags.add_error(
      "Identifiant attendu après 'let'",
      tok.span,
      "E1101",
    )
  end

  let ident = ast.Ident(
    name = name,
    span = name_span,
  )

  # Type optionnel
  let mut ty = None
  if self.current().lexeme == ":"
    self.expect_symbol(":", "E1102", "':' attendu après le nom dans une déclaration let")
    let parsed_ty = self.parse_type_expr()
    ty = Some(parsed_ty)
  end

  # Initialisation optionnelle
  let mut value_id = None
  if self.current().lexeme == "="
    self.advance()
    let expr_id = self.parse_expr(module)
    value_id = Some(expr_id)
  end

  let mut end_span = name_span
  if ty.is_some()
    let t = ty.unwrap()
    end_span = diag.Span.merge(end_span, t.span)
  end
  if value_id.is_some()
    let expr = module.get_expr(value_id.unwrap())
    end_span = diag.Span.merge(end_span, expr.span)
  end

  let stmt = ast.Stmt(
    kind = ast.StmtKind.Let(
      name = ident,
      mutable = is_mut,
      ty = ty,
      value = value_id,
    ),
    span = diag.Span.merge(kw.span, end_span),
  )
  let id = module.add_stmt(stmt)

  # Consommer jusqu'à la fin de ligne ou de bloc
  while not self.is_eof()
    let k = self.peek_kind()
    if k == lex.TokenKind.Newline or k == lex.TokenKind.Eof or self.is_block_end()
      if k == lex.TokenKind.Newline
        self.advance()
      end
      break
    end
    self.advance()
  end

  return id
.end

fn Parser.parse_match_stmt(self: &mut Parser, module: &mut ast.Module) -> ast.StmtId
  let kw = self.expect_kind(
    lex.TokenKind.KwMatch,
    "E1200",
    "Mot-clé 'match' attendu",
  )

  let scrutinee_id = self.parse_expr(module)
  let arms = coll.Vec[ast.MatchArm].new()

  while not self.is_eof()
    # Fin de match
    if self.is_block_end()
      let end_span = self.consume_block_end()
      let scrutinee = module.get_expr(scrutinee_id)
      let span = diag.Span.merge(kw.span, diag.Span.merge(scrutinee.span, end_span))
      let stmt = ast.Stmt(
        kind = ast.StmtKind.Match(
          scrutinee = scrutinee_id,
          arms = arms,
        ),
        span = span,
      )
      return module.add_stmt(stmt)
    end

    # Sauter les newlines
    if self.peek_kind() == lex.TokenKind.Newline
      self.advance()
      continue
    end

    let pattern = self.parse_match_pattern()
    let mut guard_expr: Option[ast.ExprId] = None
    let mut guard_expr_id: ast.ExprId = 0
    let mut has_guard = false

    if self.current().kind == lex.TokenKind.KwIf
      self.advance()
      let guard_id = self.parse_expr(module)
      guard_expr = Some(guard_id)
      guard_expr_id = guard_id
      has_guard = true
    end

    if self.current().kind == lex.TokenKind.FatArrow or self.current().lexeme == "=>"
      self.advance()
    else
      self.diags.add_error(
        "Symbole '=>' attendu dans un bras de match",
        self.current().span,
        "E1201",
      )
    end

    # Corps du bras : bloc classique .end ou fin de match/bras suivant
    let body_id = self.parse_block(module)
    let body = module.get_block(body_id)

    let mut arm_span = diag.Span.merge(pattern.span, body.span)
    if has_guard
      let guard = module.get_expr(guard_expr_id)
      arm_span = diag.Span.merge(pattern.span, diag.Span.merge(guard.span, body.span))
    end

    let arm = ast.MatchArm(
      pattern = pattern,
      guard = guard_expr,
      body = body_id,
    )
    arms.push(arm)
  end

  # Si on sort de la boucle : match non terminé, on construit quand même
  let scrutinee = module.get_expr(scrutinee_id)
  let stmt_span = diag.Span.merge(kw.span, scrutinee.span)
  let stmt = ast.Stmt(
    kind = ast.StmtKind.Match(
      scrutinee = scrutinee_id,
      arms = arms,
    ),
    span = stmt_span,
  )
  return module.add_stmt(stmt)
.end

fn Parser.parse_match_pattern(self: &mut Parser) -> ast.MatchPattern
  let tok = self.current()

  if tok.lexeme == "_"
    self.advance()
    return ast.MatchPattern(
      kind = ast.MatchPatternKind.Wildcard,
      span = tok.span,
    )
  end

  if tok.kind == lex.TokenKind.LParen
    return self.parse_tuple_pattern()
  end

  if tok.kind == lex.TokenKind.IntLiteral
    self.advance()
    return ast.MatchPattern(
      kind = ast.MatchPatternKind.Int(
        value = tok.lexeme,
      ),
      span = tok.span,
    )
  end

  if tok.kind == lex.TokenKind.FloatLiteral
    self.advance()
    return ast.MatchPattern(
      kind = ast.MatchPatternKind.Float(
        value = tok.lexeme,
      ),
      span = tok.span,
    )
  end

  if tok.kind == lex.TokenKind.CharLiteral
    self.advance()
    return ast.MatchPattern(
      kind = ast.MatchPatternKind.Char(
        value = tok.lexeme,
      ),
      span = tok.span,
    )
  end

  if tok.kind == lex.TokenKind.StringLiteral
    self.advance()
    return ast.MatchPattern(
      kind = ast.MatchPatternKind.String(
        value = tok.lexeme,
      ),
      span = tok.span,
    )
  end

  if tok.kind == lex.TokenKind.KwTrue
    self.advance()
    return ast.MatchPattern(
      kind = ast.MatchPatternKind.Bool(value = true),
      span = tok.span,
    )
  end

  if tok.kind == lex.TokenKind.KwFalse
    self.advance()
    return ast.MatchPattern(
      kind = ast.MatchPatternKind.Bool(value = false),
      span = tok.span,
    )
  end

  if tok.kind == lex.TokenKind.Ident
    let (idents, span) = self.parse_ident_path(
      "E1202",
      "Identifiant attendu dans un pattern de match",
    )

    if self.peek_kind() == lex.TokenKind.LBrace
      self.advance()
      let (fields, end_span) = self.parse_struct_pattern_fields()
      let pat_span = diag.Span.merge(span, end_span)
      return ast.MatchPattern(
        kind = ast.MatchPatternKind.Struct(
          type_path = idents,
          fields = fields,
        ),
        span = pat_span,
      )
    end

    return ast.MatchPattern(
      kind = ast.MatchPatternKind.Path(path = idents),
      span = span,
    )
  end

  self.diags.add_error(
    "Pattern de match invalide",
    tok.span,
    "E1203",
  )

  self.advance()
  return ast.MatchPattern(
    kind = ast.MatchPatternKind.Wildcard,
    span = tok.span,
  )
.end

fn Parser.parse_tuple_pattern(self: &mut Parser) -> ast.MatchPattern
  let lparen = self.expect_kind(
    lex.TokenKind.LParen,
    "E1204",
    "Parenthèse ouvrante '(' attendue dans un pattern de tuple",
  )

  # Cas unit '()'
  if self.peek_kind() == lex.TokenKind.RParen
    let rparen = self.advance()
    let span = diag.Span.merge(lparen.span, rparen.span)
    return ast.MatchPattern(
      kind = ast.MatchPatternKind.Tuple(items = coll.Vec[ast.MatchPattern].new()),
      span = span,
    )
  end

  let items = coll.Vec[ast.MatchPattern].new()
  let mut last_span = lparen.span
  let mut saw_comma = false

  while not self.is_eof()
    let pat = self.parse_match_pattern()
    last_span = pat.span
    items.push(pat)

    if self.peek_kind() == lex.TokenKind.Comma
      self.advance()
      saw_comma = true
      continue
    end

    if self.peek_kind() == lex.TokenKind.RParen
      let rparen = self.advance()
      last_span = diag.Span.merge(last_span, rparen.span)
      break
    end

    let sep = self.current()
    self.diags.add_error(
      "',' ou ')' attendu dans un pattern de tuple",
      sep.span,
      "E1205",
    )
    break
  end

  # Single element without comma = pattern parenthésé
  if items.len() == 1 and not saw_comma
    let span = diag.Span.merge(lparen.span, last_span)
    let single = items[0]
    return ast.MatchPattern(
      kind = single.kind,
      span = span,
    )
  end

  let span = diag.Span.merge(lparen.span, last_span)
  return ast.MatchPattern(
    kind = ast.MatchPatternKind.Tuple(items = items),
    span = span,
  )
.end

fn Parser.parse_struct_pattern_fields(self: &mut Parser) -> (coll.Vec[ast.StructPatternField], diag.Span)
  let fields = coll.Vec[ast.StructPatternField].new()
  let mut end_span = self.current().span

  while not self.is_eof()
    if self.peek_kind() == lex.TokenKind.RBrace
      let brace = self.advance()
      end_span = brace.span
      break
    end

    if self.peek_is_dot_end()
      let bad = self.current()
      self.diags.add_error(
        "Utiliser '}' pour fermer un pattern de struct (pas '.end')",
        bad.span,
        "E1206",
      )
      let consumed = self.consume_block_end()
      end_span = consumed
      break
    end

    if self.peek_kind() == lex.TokenKind.Newline
      self.advance()
      continue
    end

    if self.peek_kind() != lex.TokenKind.Ident
      let tok = self.current()
      self.diags.add_error(
        "Nom de champ attendu dans un pattern de struct",
        tok.span,
        "E1207",
      )
      self.advance()
      continue
    end

    let name_tok = self.advance()
    let name_ident = ast.Ident(name = name_tok.lexeme, span = name_tok.span)

    let mut field_pattern: ast.MatchPattern
    if self.peek_kind() == lex.TokenKind.Equal
      self.advance()
      field_pattern = self.parse_match_pattern()
    else
      # Destructuration courte : foo { x } == foo { x = x }
      let path = coll.Vec[ast.Ident].new()
      path.push(name_ident)
      field_pattern = ast.MatchPattern(
        kind = ast.MatchPatternKind.Path(path = path),
        span = name_tok.span,
      )
    end

    let field_span = diag.Span.merge(name_tok.span, field_pattern.span)
    let field = ast.StructPatternField(
      name = name_ident,
      pattern = field_pattern,
      span = field_span,
    )
    fields.push(field)
    end_span = field_span

    if self.peek_kind() == lex.TokenKind.Comma
      self.advance()
      continue
    end

    if self.peek_kind() == lex.TokenKind.RBrace
      let brace = self.advance()
      end_span = diag.Span.merge(end_span, brace.span)
      break
    end

    let sep = self.current()
    self.diags.add_error(
      "',' ou '}' attendu après un champ de pattern struct",
      sep.span,
      "E1208",
    )
    while not self.is_eof()
      let k = self.peek_kind()
      if k == lex.TokenKind.Comma or k == lex.TokenKind.RBrace or self.peek_is_dot_end() or k == lex.TokenKind.Newline
        break
      end
      self.advance()
    end

    if self.peek_kind() == lex.TokenKind.Comma
      self.advance()
      continue
    end

    if self.peek_kind() == lex.TokenKind.RBrace
      let brace = self.advance()
      end_span = diag.Span.merge(end_span, brace.span)
      break
    end

    if self.peek_is_dot_end()
      let bad_span = self.consume_block_end()
      self.diags.add_error(
        "Utiliser '}' pour fermer un pattern de struct (pas '.end')",
        bad_span,
        "E1206",
      )
      end_span = bad_span
      break
    end

    if self.peek_kind() == lex.TokenKind.Newline
      self.advance()
    end
  end

  return (fields, end_span)
.end
