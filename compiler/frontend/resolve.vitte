module vitte.bootstrap.front.bt_resolve

import std.collections as coll
import vitte.bootstrap.front.bt_ast as ast
import vitte.bootstrap.front.bt_diagnostics as diag

# ============================================================================
# Vitte bootstrap front-end – Modèle logique de la résolution de noms
# (maximal, déclaratif, sans I/O)
#
# Objectifs :
#   - Définir une représentation purement déclarative de :
#       * la hiérarchie de scopes (root, module, bloc, fonction, type, etc.),
#       * les symboles (déclarations) et leurs namespace,
#       * la résolution des chemins (paths) et des identifiants,
#       * les imports (use, glob, re-export) et les conflits de noms,
#       * les bindings AST -> symboles, et les erreurs de résolution.
#   - Servir de contrat entre :
#       * le parser / AST (`bt_ast.vitte`),
#       * les passes suivantes (typage, IR),
#       * les outils (IDE, lints, visualisation, tests).
#   - Ne contenir :
#       * aucune fonction,
#       * aucune logique de résolution,
#       * aucune I/O ni formatage.
# ============================================================================

# ---------------------------------------------------------------------------
# Identifiants de base
# ---------------------------------------------------------------------------

struct ResSymbolId
    raw: u32
.end

struct ResScopeId
    raw: u32
.end

struct ResImportId
    raw: u32
.end

struct ResPathId
    raw: u32
.end

struct ResFileId
    raw: u32
.end

# ---------------------------------------------------------------------------
# Namespaces, genres de symboles, visibilité
# ---------------------------------------------------------------------------

enum ResNamespace
    NsType          # types (struct, enum, alias, union, generic type params)
    NsValue         # valeurs (fn, const, static, locals, params)
    NsModule        # modules, packages
    NsMacro         # macros éventuelles
    NsLabel         # labels de boucles
    NsBuiltin       # symboles builtins
    NsUnknown
.end

enum ResSymbolKind
    SymModule
    SymPackage
    SymStruct
    SymEnum
    SymUnion
    SymTypeAlias
    SymFn
    SymConst
    SymStatic
    SymField
    SymEnumVariant
    SymParam
    SymLocal
    SymTypeParam
    SymLifetimeParam
    SymProgram
    SymService
    SymKernel
    SymDriver
    SymTool
    SymScenario
    SymPipeline
    SymLabel
    SymBuiltin
    SymOther
.end

enum ResScopeKind
    ScopeRoot
    ScopeFile
    ScopeModule
    ScopeBlock
    ScopeFn
    ScopeType
    ScopeImpl
    ScopeGenericParams
    ScopeBuiltin
    ScopeOther
.end

# ---------------------------------------------------------------------------
# Invariants de portée (module vs bloc)
# ---------------------------------------------------------------------------

struct ResScopeRule
    scope_kind: ResScopeKind

    # Déclarations autorisées dans ce scope
    allowed_namespaces: coll.Vec<ResNamespace>
    allowed_symbol_kinds: coll.Vec<ResSymbolKind>
    allow_imports: bool                   # use / import uniquement au module
    allow_type_items: bool                # struct / enum / alias / union
    allow_value_items: bool               # fn / const / static / program / services
    allow_module_items: bool              # module et sous-modules
    allow_locals: bool                    # let / let mut / params
    allow_labels: bool

    # Résolution et shadowing
    lookup_chain: coll.Vec<ResScopeKind>  # ordre de remontée (bloc -> fn -> module -> root)
    shadowing_allowed: bool               # bindings locaux peuvent masquer un identifiant parent
    stops_at_module_boundary: bool        # un bloc ne fuit pas son module pour les locals

    notes: String
    extra: coll.HashMap<String, String>
.end

struct ResScopeRules
    # Règle standard pour un scope de module (fichier)
    module_scope: ResScopeRule

    # Règle standard pour un scope de bloc (fn body / block / loop / if / match arm)
    block_scope: ResScopeRule

    # Options communes héritées par la résolution
    implicit_prelude_visible_in_modules: bool
    blocks_inherit_imports_from_module: bool

    notes: String
    extra: coll.HashMap<String, String>
.end

# ---------------------------------------------------------------------------
# Scopes
# ---------------------------------------------------------------------------

struct ResScope
    id: ResScopeId
    kind: ResScopeKind

    # Id du scope parent (raw=0 si racine spéciale)
    parent: ResScopeId

    # Identifiant (pour modules/fichiers/impl), sinon vide
    name: String

    # Span approximatif couvrant ce scope (délimitation logique)
    span: ast.AstSpan

    # Références AST principales (optionnelles)
    ast_node: ast.AstNodeId
    file_id: ResFileId

    # Liste des symboles déclarés directement dans ce scope
    declared_symbols: coll.Vec<ResSymbolId>

    # Sous-scopes immédiats
    child_scopes: coll.Vec<ResScopeId>

    # Données libres
    notes: String
    extra: coll.HashMap<String, String>
.end

# ---------------------------------------------------------------------------
# Symboles résolus
# ---------------------------------------------------------------------------

struct ResSymbol
    id: ResSymbolId
    name: String
    kind: ResSymbolKind
    namespace: ResNamespace

    # Scope de définition
    defining_scope: ResScopeId

    # Visibilité, reprise de l’AST
    visibility: ast.AstVisibility

    # Référence AST de la déclaration
    ast_id: ast.AstNodeId
    span: ast.AstSpan

    # Informations sur l’origine
    is_extern: bool            # déclaré extern
    is_builtin: bool           # symbole builtin injecté
    is_imported: bool          # vient d’un import
    is_reexported: bool        # re-exporté (pub use ...)
    import_id: ResImportId     # ref vers l’import qui l’expose (si applicable)

    # Typage statique (facultatif au niveau résolution)
    declared_type: ast.AstTypeRef

    # Données annexes
    attributes: coll.Vec<ast.AstAttribute>
    tags: coll.Vec<String>
    extra: coll.HashMap<String, String>
.end

# ---------------------------------------------------------------------------
# Imports (use, glob, re-export)
# ---------------------------------------------------------------------------

enum ResImportKind
    ImportSingle        # use foo::bar;
    ImportGlob          # use foo::*;
    ImportGroup         # use foo::{bar, baz};
    ImportSelf          # use foo::self;
    ImportPrelude       # import implicite (prélu de base)
    ImportOther
.end

enum ResImportStatus
    ImportPending
    ImportResolved
    ImportFailed
    ImportPartial
.end

struct ResImport
    id: ResImportId
    kind: ResImportKind
    status: ResImportStatus

    # Scope dans lequel apparaît l’import
    scope: ResScopeId

    # Références AST
    use_tree_id: ast.AstNodeId     # typiquement AstUseTree.id
    item_id: ast.AstNodeId         # item parent (AstItem pour Use)
    span: ast.AstSpan

    # Path et alias tels que vus dans l’AST
    path: ast.AstPath
    alias: ast.AstIdent

    # Symboles cibles après résolution (0..n)
    target_symbols: coll.Vec<ResSymbolId>

    # Diagnostics associés à cet import
    diagnostics: coll.Vec<diag.DiagId>

    # Données libres
    notes: String
    extra: coll.HashMap<String, String>
.end

# ---------------------------------------------------------------------------
# Résolution des chemins (paths)
# ---------------------------------------------------------------------------

enum ResPathResolutionKind
    PathResolved
    PathUnresolved
    PathError
    PathAmbiguous
    PathBuiltin
    PathExternal
.end

struct ResPathResolution
    id: ResPathId
    kind: ResPathResolutionKind

    # AST
    ast_path_id: ast.AstNodeId      # id du noeud AstPath/élément contenant le path
    span: ast.AstSpan

    # Scope de départ pour la résolution
    start_scope: ResScopeId

    # Symboles cibles (un ou plusieurs si ambigu)
    resolved_symbols: coll.Vec<ResSymbolId>

    # Import via lequel est résolu ce path (si applicable)
    via_import: ResImportId

    # Diagnostics associés
    diagnostics: coll.Vec<diag.DiagId>

    # Notes libres
    notes: String
    extra: coll.HashMap<String, String>
.end

# ---------------------------------------------------------------------------
# Conflits de noms / erreurs de résolution
# ---------------------------------------------------------------------------

enum ResNameConflictKind
    DuplicateDefinition
    NameClashDifferentKinds
    LocalVsImport
    ImportVsImport
    GlobAmbiguity
    PreludeShadowed
    OtherConflict
.end

struct ResNameConflict
    kind: ResNameConflictKind

    # Nom en conflit
    name: String

    # Scope concerné
    scope: ResScopeId

    # Symboles impliqués
    symbols: coll.Vec<ResSymbolId>

    # Import(s) en cause (optionnel)
    imports: coll.Vec<ResImportId>

    # Diagnostic principal
    diag_id: diag.DiagId

    notes: String
.end

enum ResUnresolvedKind
    UnresolvedName
    UnresolvedPath
    UnresolvedImport
    UnresolvedType
    UnresolvedModule
    UnresolvedLabel
    OtherUnresolved
.end

struct ResUnresolved
    kind: ResUnresolvedKind

    # Nom ou path textuel (si disponible)
    name: String

    # AST associé
    ast_id: ast.AstNodeId
    span: ast.AstSpan

    # Scope de recherche
    scope: ResScopeId

    # Diagnostic lié
    diag_id: diag.DiagId

    notes: String
.end

# ---------------------------------------------------------------------------
# Binding AST -> symboles
# ---------------------------------------------------------------------------

enum ResNodeBindingKind
    BindItem              # déclaration d’item (struct, fn, etc.)
    BindExpr              # référence de valeur
    BindType              # référence de type
    BindPattern           # pattern introduisant des bindings
    BindPath              # chemin (type ou valeur)
    BindLabel             # label
    BindModule            # module ou paquet
    BindOther
.end

struct ResNodeBinding
    kind: ResNodeBindingKind

    # AST
    ast_id: ast.AstNodeId
    span: ast.AstSpan

    # Scope dans lequel se situe le nœud
    scope: ResScopeId

    # Symboles associés à ce nœud
    primary_symbol: ResSymbolId         # symbole principal (id.raw=0 si aucun)
    secondary_symbols: coll.Vec<ResSymbolId>

    # Résolution de path liée (si applicable)
    path_id: ResPathId

    # Diagnostics associés à ce binding précis
    diagnostics: coll.Vec<diag.DiagId>

    notes: String
.end

# Index de bindings par AST node
struct ResBindingIndex
    # ast_id.raw -> index dans une table de ResNodeBinding
    binding_by_ast_id: coll.HashMap<u32, u32>

    # path_id.raw -> index dans une table de ResPathResolution
    path_by_ast_id: coll.HashMap<u32, u32>

    notes: String
.end

# ---------------------------------------------------------------------------
# Fichier résolu et indexation par file/module
# ---------------------------------------------------------------------------

struct ResFileMetadata
    file_id: ResFileId
    file_path: String
    module_name: String
    edition: String          # ex: "2025"
    profile: String          # ex: "core-bootstrap"
    is_root: bool
    notes: String
.end

struct ResFile
    meta: ResFileMetadata

    # AST correspondant
    ast: ast.BtAst

    # Scope racine attaché à ce fichier/module
    root_scope: ResScopeId

    # Scopes et symboles connus pour ce fichier
    scopes: coll.Vec<ResScope>
    symbols: coll.Vec<ResSymbol>

    # Règles de portée appliquées (module vs bloc)
    scope_rules: ResScopeRules

    # Imports
    imports: coll.Vec<ResImport>

    # Résolution de paths et bindings
    path_resolutions: coll.Vec<ResPathResolution>
    node_bindings: coll.Vec<ResNodeBinding>
    binding_index: ResBindingIndex

    # Conflits et entités non résolues
    conflicts: coll.Vec<ResNameConflict>
    unresolved: coll.Vec<ResUnresolved>

    # Diagnostics agrégés de résolution (per-file)
    diagnostics: diag.BtDiagnostics

    # Données libres
    extra: coll.HashMap<String, String>
.end

# ---------------------------------------------------------------------------
# Résumé et statistiques de résolution (par fichier)
# ---------------------------------------------------------------------------

struct ResFileSummary
    total_scopes: u32
    total_symbols: u32
    total_imports: u32
    total_paths: u32

    total_conflicts: u32
    total_unresolved: u32

    has_errors: bool
    has_unresolved: bool
.end

struct BtResolveUnit
    file: ResFile
    summary: ResFileSummary

    # Compteurs par namespace
    count_types: u32
    count_values: u32
    count_modules: u32
    count_macros: u32
    count_builtins: u32

    # Map optionnelle name -> symbol ids pour ce fichier
    symbol_ids_by_name: coll.HashMap<String, coll.Vec<ResSymbolId>>

    # Données libres
    extra: coll.HashMap<String, String>
.end

# ---------------------------------------------------------------------------
# Résolution pour un ensemble d’unités (bundle)
# ---------------------------------------------------------------------------

struct BtResolveBundleSummary
    units_total: u32
    units_with_errors: u32
    units_with_unresolved: u32

    total_scopes: u32
    total_symbols: u32
    total_imports: u32
    total_paths: u32
    total_conflicts: u32
    total_unresolved: u32

    has_errors: bool
    has_unresolved: bool
.end

struct BtResolveIndex
    # Index global pour navigation/résolution cross-file
    unit_index_by_file_path: coll.HashMap<String, u32>
    symbol_ids_by_qualified_name: coll.HashMap<String, coll.Vec<ResSymbolId>>
    module_scope_by_name: coll.HashMap<String, ResScopeId>

    notes: String
.end

struct BtResolveBundle
    units: coll.Vec<BtResolveUnit>
    summary: BtResolveBundleSummary
    index: BtResolveIndex

    # Données libres pour tooling/CI/IDE
    extra: coll.HashMap<String, String>
.end
