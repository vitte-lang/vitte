module vitte.compiler.frontend.lexer

import std.collections as coll
import std.string as str

import vitte.compiler.frontend.diagnostics as diag

# =============================================================================
# Vitte compiler – Lexer runtime (squelette projet complet)
#
# Objectifs :
#   - Fournir :
#       * un type TokenKind pour tous les tokens logiques,
#       * un type Token (kind + lexeme + span),
#       * un état de lexer (Lexer) avec helpers,
#       * une fonction publique lex(source, file, diags) -> Vec[Token].
#   - Servir de contrat stable pour :
#       * le parser,
#       * le driver,
#       * les tests (goldens, snapshots).
#
# Remarques :
#   - Ce fichier définit l'architecture du lexer runtime pour le compilateur.
#   - Aucun I/O ici : le texte source est déjà fourni en String.
#   - La logique de lexing (identifiants, nombres, opérateurs, etc.)
#     peut être enrichie progressivement sans changer les signatures.
# =============================================================================

# -----------------------------------------------------------------------------
# TokenKind – catégories de tokens
# -----------------------------------------------------------------------------

enum TokenKind
  # Fin de fichier ------------------------------------------------------------
  Eof

  # Identifiants et littéraux -------------------------------------------------
  Ident
  IntLiteral
  FloatLiteral
  CharLiteral
  StringLiteral

  # Mots-clés principaux (à compléter si besoin) -----------------------------
  KwModule
  KwImport
  KwExport
  KwStruct
  KwEnum
  KwUnion
  KwType
  KwFn
  KwProgram
  KwScenario
  KwPipeline
  KwEnd
  KwLet
  KwMut
  KwIf
  KwElse
  KwWhile
  KwMatch
  KwTrue
  KwFalse

  # Punctuations et opérateurs simples ---------------------------------------
  LParen         # (
  RParen         # )
  LBrace         # {
  RBrace         # }
  LBracket       # [
  RBracket       # ]
  Comma          # ,
  Colon          # :
  ColonColon     # ::
  Dot            # .
  Equal          # =
  Plus           # +
  Minus          # -
  Star           # *
  Slash          # /
  Percent        # %
  Arrow          # ->
  FatArrow       # =>
  EqualEqual     # ==
  BangEqual      # !=
  Bang           # !
  Less           # <
  LessEqual      # <=
  Greater        # >
  GreaterEqual   # >=
  AmpAmp         # &&
  PipePipe       # ||

  # Indentation / structure ---------------------------------------------------
  Newline
  Indent
  Dedent

  # Divers --------------------------------------------------------------------
  Unknown
.end

# -----------------------------------------------------------------------------
# Token – produit par le lexer
# -----------------------------------------------------------------------------

struct Token
  kind: TokenKind
  lexeme: String
  span: diag.Span
.end

fn Token.new(kind: TokenKind, lexeme: String, span: diag.Span) -> Token
  return Token(
    kind = kind,
    lexeme = lexeme,
    span = span,
  )
.end

# -----------------------------------------------------------------------------
# État du lexer
# -----------------------------------------------------------------------------

struct Lexer
  source: String
  file: String
  index: Int
  line: Int
  col: Int
  tokens: coll.Vec[Token]
  diags: &mut diag.DiagnosticBag
.end

fn Lexer.new(source: String, file: String, diags: &mut diag.DiagnosticBag) -> Lexer
  return Lexer(
    source = source,
    file = file,
    index = 0,
    line = 1,
    col = 1,
    tokens = coll.Vec[Token].new(),
    diags = diags,
  )
.end

# -----------------------------------------------------------------------------
# API publique
# -----------------------------------------------------------------------------

fn lex(source: String, file: String, diags: &mut diag.DiagnosticBag) -> coll.Vec[Token]
  let lexer = Lexer.new(source, file, diags)
  return lexer.run()
.end

# -----------------------------------------------------------------------------
# Implémentation – boucle principale
# -----------------------------------------------------------------------------

fn Lexer.run(self: &mut Lexer) -> coll.Vec[Token]
  while not self.is_eof()
    self.lex_one_token()
  end

  # Ajouter un token EOF final avec un span factice
  let eof_span = diag.Span(
    file = self.file,
    start_line = self.line,
    start_col = self.col,
    end_line = self.line,
    end_col = self.col,
  )
  let eof = Token.new(TokenKind.Eof, "", eof_span)
  self.tokens.push(eof)

  return self.tokens
.end

fn Lexer.is_eof(self: Lexer) -> Bool
  return self.index >= self.source.len()
.end

# -----------------------------------------------------------------------------
# Helpers de navigation dans le texte source
# -----------------------------------------------------------------------------

fn Lexer.peek_char(self: Lexer) -> Char
  if self.is_eof()
    return '\0'
  end
  return self.source[self.index]
.end

fn Lexer.peek_next_char(self: Lexer) -> Char
  let next_index = self.index + 1
  if next_index >= self.source.len()
    return '\0'
  end
  return self.source[next_index]
.end

fn Lexer.advance(self: &mut Lexer) -> Char
  if self.is_eof()
    return '\0'
  end

  let c = self.source[self.index]
  self.index = self.index + 1

  if c == '\n'
    self.line = self.line + 1
    self.col = 1
  else
    self.col = self.col + 1
  end

  return c
.end

fn Lexer.make_span_single(self: Lexer) -> diag.Span
  # Span élémentaire au point courant (utile pour les tokens 1-char).
  return diag.Span(
    file = self.file,
    start_line = self.line,
    start_col = self.col,
    end_line = self.line,
    end_col = self.col,
  )
.end

fn Lexer.push_token(self: &mut Lexer, kind: TokenKind, lexeme: String, span: diag.Span) -> Unit
  let tok = Token.new(kind, lexeme, span)
  self.tokens.push(tok)
.end

fn Lexer.push_simple_token(self: &mut Lexer, kind: TokenKind, c: Char) -> Unit
  let span = self.make_span_single()
  let s = str.from_char(c)
  self.push_token(kind, s, span)
.end

# -----------------------------------------------------------------------------
# Lexing de base – version minimale à enrichir
# -----------------------------------------------------------------------------

fn Lexer.lex_one_token(self: &mut Lexer) -> Unit
  # NOTE :
  #   Implémentation plus complète :
  #   - saute les espaces simples,
  #   - matérialise les newlines,
  #   - détecte identifiants / mots-clés,
  #   - détecte nombres simples,
  #   - détecte chaînes basiques,
  #   - sinon, délègue aux opérateurs / ponctuation.

  let c = self.peek_char()

  if c == '\0'
    # Rien à faire, EOF sera ajouté dans run().
    return
  end

  # Espaces simples (hors newline) : on avance sans token.
  if c == ' ' or c == '\t' or c == '\r'
    self.advance()
    return
  end

  # Newline -> token Newline
  if c == '\n'
    let span = self.make_span_single()
    self.advance()
    self.push_token(TokenKind.Newline, "\n", span)
    self.handle_indent_after_newline()
    return
  end

  # Identifiants / mots-clés
  if is_ident_start(c)
    self.lex_ident_or_keyword()
    return
  end

  # Nombres
  if is_digit(c)
    self.lex_number()
    return
  end

  # Caractères
  if c == '\''
    self.lex_char_literal()
    return
  end

  # Chaînes
  if c == '"'
    self.lex_string()
    return
  end

  # Opérateurs / ponctuations
  self.lex_operator_or_punct()
.end

# -----------------------------------------------------------------------------
# Hooks futurs – squelette pour lex ident / nombre / string
# -----------------------------------------------------------------------------

fn Lexer.lex_ident_or_keyword(self: &mut Lexer) -> Unit
  let start_line = self.line
  let start_col = self.col

  let buf = ""
  while true
    let c = self.peek_char()
    if not is_ident_continue(c)
      break
    end
    let ch = self.advance()
    buf = buf + str.from_char(ch)
  end

  let span = diag.Span(
    file = self.file,
    start_line = start_line,
    start_col = start_col,
    end_line = self.line,
    end_col = self.col,
  )

  # Classification en mots-clés ou Ident
  let kind =
    if buf == "module" then TokenKind.KwModule
    else if buf == "import" then TokenKind.KwImport
    else if buf == "export" then TokenKind.KwExport
    else if buf == "struct" then TokenKind.KwStruct
    else if buf == "enum" then TokenKind.KwEnum
    else if buf == "union" then TokenKind.KwUnion
    else if buf == "type" then TokenKind.KwType
    else if buf == "fn" then TokenKind.KwFn
    else if buf == "program" then TokenKind.KwProgram
    else if buf == "scenario" then TokenKind.KwScenario
    else if buf == "pipeline" then TokenKind.KwPipeline
    else if buf == "end" then TokenKind.KwEnd
    else if buf == "let" then TokenKind.KwLet
    else if buf == "mut" then TokenKind.KwMut
    else if buf == "if" then TokenKind.KwIf
    else if buf == "else" then TokenKind.KwElse
    else if buf == "while" then TokenKind.KwWhile
    else if buf == "match" then TokenKind.KwMatch
    else if buf == "true" then TokenKind.KwTrue
    else if buf == "false" then TokenKind.KwFalse
    else TokenKind.Ident
    end

  self.push_token(kind, buf, span)
.end

fn Lexer.lex_number(self: &mut Lexer) -> Unit
  let start_line = self.line
  let start_col = self.col

  let buf = ""
  let seen_dot = false

  while true
    let c = self.peek_char()
    if is_digit(c)
      let ch = self.advance()
      buf = buf + str.from_char(ch)
      continue
    end

    if c == '.' and not seen_dot
      # Premier '.' : on le considère comme flottant
      let ch = self.advance()
      buf = buf + str.from_char(ch)
      seen_dot = true
      continue
    end

    break
  end

  let span = diag.Span(
    file = self.file,
    start_line = start_line,
    start_col = start_col,
    end_line = self.line,
    end_col = self.col,
  )

  let kind =
    if seen_dot then TokenKind.FloatLiteral else TokenKind.IntLiteral end

  self.push_token(kind, buf, span)
.end

fn Lexer.lex_char_literal(self: &mut Lexer) -> Unit
  let start_line = self.line
  let start_col = self.col

  # Consommer la quote ouvrante
  let _ = self.advance()

  let buf = ""
  let terminated = false

  if self.is_eof()
    let span = self.make_span_single()
    self.diags.add_error(
      "Littéral de caractère non terminé",
      span,
      diag.code_for_message("Littéral de caractère non terminé"),
    )
    self.push_token(TokenKind.CharLiteral, buf, span)
    return
  end

  let c = self.peek_char()

  # Support d'une forme minimale : un caractère ou une séquence d'échappement simple.
  if c == '\\'
    let first = self.advance()
    buf = buf + str.from_char(first)
    if not self.is_eof()
      let escaped = self.advance()
      buf = buf + str.from_char(escaped)
    end
  else if c == '\n' or c == '\0'
    let span = self.make_span_single()
    self.diags.add_error(
      "Littéral de caractère non terminé",
      span,
      diag.code_for_message("Littéral de caractère non terminé"),
    )
    self.push_token(TokenKind.CharLiteral, buf, span)
    return
  else
    let ch = self.advance()
    buf = buf + str.from_char(ch)
  end

  if self.peek_char() == '\''
    self.advance()
    terminated = true
  end

  let span = diag.Span(
    file = self.file,
    start_line = start_line,
    start_col = start_col,
    end_line = self.line,
    end_col = self.col,
  )

  if not terminated
    self.diags.add_error(
      "Littéral de caractère non terminé",
      span,
      diag.code_for_message("Littéral de caractère non terminé"),
    )
  end

  self.push_token(TokenKind.CharLiteral, buf, span)
.end

fn Lexer.lex_string(self: &mut Lexer) -> Unit
  let start_line = self.line
  let start_col = self.col

  # Consommer le guillemet ouvrant
  let quote = self.advance()

  let buf = ""
  let terminated = false

  while not self.is_eof()
    let c = self.peek_char()

    if c == '"'
      # Fin de chaîne
      self.advance()
      terminated = true
      break
    end

    if c == '\n'
      # Fin de ligne avant la fermeture : erreur
      break
    end

    let ch = self.advance()
    buf = buf + str.from_char(ch)
  end

  let span = diag.Span(
    file = self.file,
    start_line = start_line,
    start_col = start_col,
    end_line = self.line,
    end_col = self.col,
  )

  if not terminated
    self.diags.add_error(
      "Littéral de chaîne non terminé",
      span,
      diag.code_for_message("Littéral de chaîne non terminé"),
    )
  end

  self.push_token(TokenKind.StringLiteral, buf, span)
.end

fn Lexer.lex_operator_or_punct(self: &mut Lexer) -> Unit
  let span = self.make_span_single()
  let c = self.advance()
  let next = self.peek_char()

  # 2-caractères d'abord
  if c == '-' and next == '>'
    self.advance()
    self.push_token(TokenKind.Arrow, "->", span)
    return
  end

  if c == '=' and next == '>'
    self.advance()
    self.push_token(TokenKind.FatArrow, "=>", span)
    return
  end

  if c == '=' and next == '='
    self.advance()
    self.push_token(TokenKind.EqualEqual, "==", span)
    return
  end

  if c == '!' and next == '='
    self.advance()
    self.push_token(TokenKind.BangEqual, "!=", span)
    return
  end

  if c == '!' and next != '='
    self.push_token(TokenKind.Bang, "!", span)
    return
  end

  if c == '<' and next == '='
    self.advance()
    self.push_token(TokenKind.LessEqual, "<=", span)
    return
  end

  if c == '>' and next == '='
    self.advance()
    self.push_token(TokenKind.GreaterEqual, ">=", span)
    return
  end

  if c == '&' and next == '&'
    self.advance()
    self.push_token(TokenKind.AmpAmp, "&&", span)
    return
  end

  if c == '|' and next == '|'
    self.advance()
    self.push_token(TokenKind.PipePipe, "||", span)
    return
  end

  # Sinon, 1-caractère

  if c == '('
    self.push_token(TokenKind.LParen, "(", span)
    return
  end

  if c == ')'
    self.push_token(TokenKind.RParen, ")", span)
    return
  end

  if c == '{'
    self.push_token(TokenKind.LBrace, "{", span)
    return
  end

  if c == '}'
    self.push_token(TokenKind.RBrace, "}", span)
    return
  end

  if c == '['
    self.push_token(TokenKind.LBracket, "[", span)
    return
  end

  if c == ']'
    self.push_token(TokenKind.RBracket, "]", span)
    return
  end

  if c == ','
    self.push_token(TokenKind.Comma, ",", span)
    return
  end

  if c == ':'
    if next == ':'
      self.advance()
      self.push_token(TokenKind.ColonColon, "::", span)
      return
    end
    self.push_token(TokenKind.Colon, ":", span)
    return
  end

  if c == '.'
    self.push_token(TokenKind.Dot, ".", span)
    return
  end

  if c == '='
    self.push_token(TokenKind.Equal, "=", span)
    return
  end

  if c == '+'
    self.push_token(TokenKind.Plus, "+", span)
    return
  end

  if c == '-'
    self.push_token(TokenKind.Minus, "-", span)
    return
  end

  if c == '*'
    self.push_token(TokenKind.Star, "*", span)
    return
  end

  if c == '/'
    self.push_token(TokenKind.Slash, "/", span)
    return
  end

  if c == '%'
    self.push_token(TokenKind.Percent, "%", span)
    return
  end

  if c == '<'
    self.push_token(TokenKind.Less, "<", span)
    return
  end

  if c == '>'
    self.push_token(TokenKind.Greater, ">", span)
    return
  end

  # Caractère inconnu : produire Unknown et signaler immédiatement.
  let s = str.from_char(c)
  self.push_token(TokenKind.Unknown, s, span)
  self.diags.add_error(
    "Caractère invalide",
    span,
    diag.code_for_message("Caractère invalide"),
  )
.end

# -----------------------------------------------------------------------------
# Indentation – stubs pour préparer un lexing sensible à l'indentation
# -----------------------------------------------------------------------------

fn Lexer.handle_indent_after_newline(self: &mut Lexer) -> Unit
  # Placeholder : on pourra ici mesurer l'indentation et émettre Indent/Dedent.
  return
.end

# -----------------------------------------------------------------------------
# Helpers de classification de caractères
# -----------------------------------------------------------------------------

fn is_alpha(c: Char) -> Bool
  return (c >= 'a' and c <= 'z') or (c >= 'A' and c <= 'Z')
.end

fn is_digit(c: Char) -> Bool
  return c >= '0' and c <= '9'
.end

fn is_alnum(c: Char) -> Bool
  return is_alpha(c) or is_digit(c)
.end

fn is_ident_start(c: Char) -> Bool
  return is_alpha(c) or c == '_'
.end

fn is_ident_continue(c: Char) -> Bool
  return is_alnum(c) or c == '_'
.end
