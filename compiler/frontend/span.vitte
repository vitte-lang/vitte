module vitte.compiler.span

import std.collections as coll

# =============================================================================
# Span utilities shared by the lexer, parser and diagnostics.
# =============================================================================

struct LineCol
  line: Int
  column: Int
.end

struct Span
  file: String
  start_line: Int
  start_col: Int
  end_line: Int
  end_col: Int
.end

fn Span.new(file: String, start_line: Int, start_col: Int, end_line: Int, end_col: Int) -> Span
  # Normalise the range so start is <= end.
  let s_line = start_line
  let s_col = start_col
  let e_line = end_line
  let e_col = end_col

  if e_line < s_line or (e_line == s_line and e_col < s_col)
    let tmp_line = s_line
    let tmp_col = s_col
    s_line = e_line
    s_col = e_col
    e_line = tmp_line
    e_col = tmp_col
  end

  return Span(
    file = file,
    start_line = s_line,
    start_col = s_col,
    end_line = e_line,
    end_col = e_col,
  )
.end

fn Span.single(file: String, line: Int, col: Int) -> Span
  return Span.new(file, line, col, line, col)
.end

fn Span.from_positions(file: String, start: LineCol, end: LineCol) -> Span
  return Span.new(file, start.line, start.column, end.line, end.column)
.end

fn Span.dummy(file: String) -> Span
  return Span(
    file = file,
    start_line = 0,
    start_col = 0,
    end_line = 0,
    end_col = 0,
  )
.end

fn Span.is_dummy(self: Span) -> Bool
  return self.start_line == 0 and self.end_line == 0
.end

fn Span.same_file(a: Span, b: Span) -> Bool
  return a.file == b.file
.end

fn Span.merge(a: Span, b: Span) -> Span
  if a.is_dummy()
    return b
  end
  if b.is_dummy()
    return a
  end

  if not Span.same_file(a, b)
    return a
  end

  let start_line =
    if a.start_line <= b.start_line then a.start_line else b.start_line end
  let start_col =
    if a.start_col <= b.start_col then a.start_col else b.start_col end
  let end_line =
    if a.end_line >= b.end_line then a.end_line else b.end_line end
  let end_col =
    if a.end_col >= b.end_col then a.end_col else b.end_col end

  return Span(
    file = a.file,
    start_line = start_line,
    start_col = start_col,
    end_line = end_line,
    end_col = end_col,
  )
.end

fn Span.enclose_points(file: String, points: coll.Vec[LineCol]) -> Span
  if points.len() == 0
    return Span.dummy(file)
  end
  let first = points[0]
  let span = Span.single(file, first.line, first.column)
  let i = 1
  while i < points.len()
    let p = points[i]
    let pt_span = Span.single(file, p.line, p.column)
    span = Span.merge(span, pt_span)
    i = i + 1
  end
  return span
.end

# -----------------------------------------------------------------------------
# Line index helpers: map byte offsets to (line, column).
# -----------------------------------------------------------------------------

struct LineIndex
  file: String
  line_starts: coll.Vec[Int]
  text_len: Int
.end

fn LineIndex.build(file: String, text: String) -> LineIndex
  let starts = coll.Vec[Int].new()
  starts.push(0)

  let i = 0
  let len = text.len()
  while i < len
    let ch = text[i]
    if ch == '\r'
      let next = i + 1
      if next < len and text[next] == '\n'
        i = i + 1
        next = next + 1
      end
      starts.push(next)
    else if ch == '\n'
      starts.push(i + 1)
    end
    i = i + 1
  end

  return LineIndex(
    file = file,
    line_starts = starts,
    text_len = len,
  )
.end

fn LineIndex.line_count(self: LineIndex) -> Int
  return self.line_starts.len()
.end

fn LineIndex.clamp_offset(self: LineIndex, offset: Int) -> Int
  if offset < 0
    return 0
  end
  if offset > self.text_len
    return self.text_len
  end
  return offset
.end

fn LineIndex.line_col_for_offset(self: LineIndex, offset: Int) -> LineCol
  if self.line_starts.len() == 0
    return LineCol(line = 0, column = 0)
  end

  let off = self.clamp_offset(offset)
  let lo = 0
  let hi = self.line_starts.len() - 1
  while lo <= hi
    let mid = lo + (hi - lo) / 2
    let start = self.line_starts[mid]
    let next =
      if mid + 1 < self.line_starts.len()
        then self.line_starts[mid + 1]
        else self.text_len + 1
      end

    if off < start
      hi = mid - 1
      continue
    end

    if off >= next
      lo = mid + 1
      continue
    end

    let column = (off - start) + 1
    return LineCol(line = mid + 1, column = column)
  end

  # Fallback: point to the last known line.
  let last_index = self.line_starts.len() - 1
  let last_start = self.line_starts[last_index]
  let column = (off - last_start) + 1
  return LineCol(line = last_index + 1, column = column)
.end

fn LineIndex.span_for_range(self: LineIndex, start_offset: Int, end_offset: Int) -> Span
  # Les offsets fournis correspondent aux positions dans la chaŒne source.
  # Le point de d'entrÇ¸e est inclusif, celui de sortie exclusif : on rÇ¸assigne
  # donc l'offset de fin au dernier caractŠre consommÇ¸ (ou au dÇ¸but si vide).
  let clamped_start = self.clamp_offset(start_offset)
  let adjusted_end =
    if end_offset <= clamped_start
      clamped_start
    else
      self.clamp_offset(end_offset - 1)
    end

  let start = self.line_col_for_offset(clamped_start)
  let end = self.line_col_for_offset(adjusted_end)
  return Span.from_positions(self.file, start, end)
.end
