module vitte.compiler.frontend.ast

import std.collections as coll
import vitte.compiler.frontend.diagnostics as diag

# -----------------------------------------------------------------------------
# Identifiants, visibilité, types, fonctions
# -----------------------------------------------------------------------------

struct Ident
  name: String
  span: diag.Span
.end

enum Visibility
  Private
  Pub
  PubCrate
.end

# Expressions de type (types déclarés dans le code source)
enum TypeExprKind
  # ex: "i32", "String", "foo.Bar"
  Named
    path: coll.Vec[Ident]

  # ex: (T, U)
  Tuple
    items: coll.Vec[TypeExpr]

  # ex: ()
  Unit

  # ex: type inféré (par le typechecker)
  Infer
.end

struct TypeExpr
  kind: TypeExprKind
  span: diag.Span
.end

fn TypeExpr.from_name(name: String, span: diag.Span) -> TypeExpr
  let ident = Ident(name = name, span = span)
  let path = coll.Vec[Ident].new()
  path.push(ident)
  return TypeExpr.named_from_path(path, span)
.end

fn TypeExpr.named_from_ident(name: Ident) -> TypeExpr
  let path = coll.Vec[Ident].new()
  path.push(name)

  return TypeExpr.named_from_path(path, name.span)
.end

fn TypeExpr.named_from_path(path: coll.Vec[Ident], span: diag.Span) -> TypeExpr
  let kind = TypeExprKind.Named(path = path)
  return TypeExpr(kind = kind, span = span)
.end

# Handles logiques pour référencer des blocs/expressions dans d'autres
# structures (le stockage réel peut se faire dans une arène ailleurs).
type BlockId = Int
type ExprId = Int
type StmtId = Int

struct Block
  stmts: coll.Vec[StmtId]
  span: diag.Span
.end

enum StmtKind
  Expr
    expr: ExprId
  Return
    value: Option[ExprId]
  Let
    name: Ident
    mutable: Bool
    ty: Option[TypeExpr]
    value: Option[ExprId]
  While
    cond: ExprId
    body: BlockId
  If
    cond: ExprId
    then_block: BlockId
    else_block: Option[BlockId]
  Match
    scrutinee: ExprId
    arms: coll.Vec[MatchArm]
  Empty
.end

struct Stmt
  kind: StmtKind
  span: diag.Span
.end

enum BinaryOp
  Add      # +
  Sub      # -
  Mul      # *
  Div      # /
  Assign   # =
  Eq       # ==
  Ne       # !=
  Lt       # <
  Le       # <=
  Gt       # >
  Ge       # >=
.end

enum ExprKind
  # foo.bar, Foo::Bar::baz
  PathName
    path: coll.Vec[Ident]

  # Opérations unaires (-x, !flag)
  Unary
    op: UnaryOp
    operand: ExprId

  # x, foo, my_module.some_name, etc.
  Name
    ident: Ident

  # 42, 0, 123456
  IntLiteral
    value: String

  # 42.0, 1.5
  FloatLiteral
    value: String

  # 'x'
  CharLiteral
    value: String

  # "hello"
  StringLiteral
    value: String

  # (a, b, c)
  TupleLiteral
    items: coll.Vec[ExprId]

  # true / false
  BoolLiteral
    value: Bool

  # Foo { x = 1, y = 2 }
  StructLiteral
    type_path: coll.Vec[Ident]
    fields: coll.Vec[StructField]

  # foo(a, b, c)
  Call
    callee: ExprId
    args: coll.Vec[ExprId]

  # a + b, x * y, a == b, etc.
  Binary
    op: BinaryOp
    lhs: ExprId
    rhs: ExprId

  # Bloc utilisé comme expression (notamment pour les match arms)
  BlockExpr
    block: BlockId

  # if ... else ... en expression
  IfExpr
    cond: ExprId
    then_block: BlockId
    else_block: Option[BlockId]

  # match en expression (ou statement)
  MatchExpr
    scrutinee: ExprId
    arms: coll.Vec[MatchArm]
.end

enum UnaryOp
  Neg
  Not
.end

struct MatchArm
  pattern: MatchPattern
  guard: Option[ExprId]
  body: BlockId
.end

enum MatchPatternKind
  Wildcard
  Path
    path: coll.Vec[Ident]
  Int
    value: String
  Float
    value: String
  Char
    value: String
  Bool
    value: Bool
  String
    value: String
  Tuple
    items: coll.Vec[MatchPattern]
  Struct
    type_path: coll.Vec[Ident]
    fields: coll.Vec[StructPatternField]
.end

struct StructPatternField
  name: Ident
  pattern: MatchPattern
  span: diag.Span
.end

struct MatchPattern
  kind: MatchPatternKind
  span: diag.Span
.end

struct StructField
  name: Ident
  value: ExprId
  span: diag.Span
.end

struct Expr
  kind: ExprKind
  span: diag.Span
.end

struct TypeInfo
  expr_types: coll.HashMap[ExprId, TypeExpr]
  symbol_types: coll.HashMap[String, TypeExpr]
  return_types: coll.HashMap[String, TypeExpr]
.end

fn TypeInfo.empty() -> TypeInfo
  return TypeInfo(
    expr_types = coll.HashMap[ExprId, TypeExpr].new(),
    symbol_types = coll.HashMap[String, TypeExpr].new(),
    return_types = coll.HashMap[String, TypeExpr].new(),
  )
.end

struct FnParam
  name: Ident
  ty: Option[TypeExpr]
  default_value: Option[ExprId]
  span: diag.Span
.end

enum FnKind
  Normal
  Extern
  Intrinsic
.end

struct FnDecl
  name: Ident
  vis: Visibility
  kind: FnKind
  params: coll.Vec[FnParam]
  return_type: Option[TypeExpr]
  body: Option[BlockId]
  span: diag.Span
.end

fn FnParam.new(name: Ident, ty: Option[TypeExpr], default_value: Option[ExprId], span: diag.Span) -> FnParam
  return FnParam(
    name = name,
    ty = ty,
    default_value = default_value,
    span = span,
  )
.end

fn FnDecl.new(
  name: Ident,
  vis: Visibility,
  kind: FnKind,
  params: coll.Vec[FnParam],
  return_type: Option[TypeExpr],
  body: Option[BlockId],
  span: diag.Span,
) -> FnDecl
  return FnDecl(
    name = name,
    vis = vis,
    kind = kind,
    params = params,
    return_type = return_type,
    body = body,
    span = span,
  )
.end

# -----------------------------------------------------------------------------
# Déclarations de haut niveau (items)
# -----------------------------------------------------------------------------

enum ModuleItemKind
  ModuleDecl
  ImportDecl
  StructDecl
  FnDecl
  EnumDecl
  TypeAliasDecl
  ConstDecl
.end

struct ModuleItem
  kind: ModuleItemKind
  name: String
  span: diag.Span

  # Payload optionnel pour chaque genre d'item.
  # Pour l'instant, on ne modèle que les fonctions de façon détaillée.
  fn_decl: Option[FnDecl]
.end

fn ModuleItem.new(kind: ModuleItemKind, name: String, span: diag.Span) -> ModuleItem
  return ModuleItem(
    kind = kind,
    name = name,
    span = span,
    fn_decl = None,
  )
.end

fn ModuleItem.from_fn(decl: FnDecl) -> ModuleItem
  return ModuleItem(
    kind = ModuleItemKind.FnDecl,
    name = decl.name.name,
    span = decl.span,
    fn_decl = Some(decl),
  )
.end

# -----------------------------------------------------------------------------
# Module
# -----------------------------------------------------------------------------

struct Module
  file: String
  items: coll.Vec[ModuleItem]
  blocks: coll.Vec[Block]
  stmts: coll.Vec[Stmt]
  exprs: coll.Vec[Expr]
  type_info: TypeInfo
.end

fn empty_module(file: String) -> Module
  # Helper utilisé par le parser tant que la construction fine des items
  # n'est pas encore implémentée.
  return Module(
    file = file,
    items = coll.Vec[ModuleItem].new(),
    blocks = coll.Vec[Block].new(),
    stmts = coll.Vec[Stmt].new(),
    exprs = coll.Vec[Expr].new(),
    type_info = TypeInfo.empty(),
  )
.end

fn Module.new(file: String) -> Module
  return empty_module(file)
.end

fn Module.add_item(self: &mut Module, item: ModuleItem) -> Unit
  self.items.push(item)
.end

fn Module.len(self: Module) -> Int
  return self.items.len()
.end

fn Module.is_empty(self: Module) -> Bool
  return self.items.len() == 0
.end

fn Module.add_block(self: &mut Module, block: Block) -> BlockId
  let id = self.blocks.len()
  self.blocks.push(block)
  return id
.end

fn Module.get_block(self: &Module, id: BlockId) -> Block
  return self.blocks[id]
.end

fn Module.add_stmt(self: &mut Module, stmt: Stmt) -> StmtId
  let id = self.stmts.len()
  self.stmts.push(stmt)
  return id
.end

fn Module.get_stmt(self: &Module, id: StmtId) -> Stmt
  return self.stmts[id]
.end

fn Module.add_expr(self: &mut Module, expr: Expr) -> ExprId
  let id = self.exprs.len()
  self.exprs.push(expr)
  return id
.end

fn Module.get_expr(self: &Module, id: ExprId) -> Expr
  return self.exprs[id]
.end

fn Module.set_expr_type(self: &mut Module, id: ExprId, ty: TypeExpr) -> Unit
  self.type_info.expr_types.insert(id, ty)
.end

fn Module.get_expr_type(self: Module, id: ExprId) -> Option[TypeExpr]
  if self.type_info.expr_types.contains_key(id)
    return Some(self.type_info.expr_types[id])
  end
  return None
.end

fn Module.set_symbol_type(self: &mut Module, name: String, ty: TypeExpr) -> Unit
  self.type_info.symbol_types.insert(name, ty)
.end

fn Module.get_symbol_type(self: Module, name: String) -> Option[TypeExpr]
  if self.type_info.symbol_types.contains_key(name)
    return Some(self.type_info.symbol_types[name])
  end
  return None
.end

fn Module.set_return_type(self: &mut Module, fn_name: String, ty: TypeExpr) -> Unit
  self.type_info.return_types.insert(fn_name, ty)
.end

fn Module.get_return_type(self: Module, fn_name: String) -> Option[TypeExpr]
  if self.type_info.return_types.contains_key(fn_name)
    return Some(self.type_info.return_types[fn_name])
  end
  return None
.end
