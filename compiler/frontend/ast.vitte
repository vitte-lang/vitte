module vitte.compiler.frontend.ast

import std.collections as coll
import vitte.compiler.frontend.diagnostics as diag

# -----------------------------------------------------------------------------
# Identifiants, visibilité, types, fonctions
# -----------------------------------------------------------------------------

struct Ident
  name: String
  span: diag.Span
.end

enum Visibility
  Private
  Pub
  PubCrate
.end

# Expressions de type (types déclarés dans le code source)
enum TypeExprKind
  # ex: "i32", "String", "foo.Bar"
  Named
    path: coll.Vec[Ident]

  # ex: (T, U)
  Tuple
    items: coll.Vec[TypeExpr]

  # ex: ()
  Unit

  # ex: type inféré (par le typechecker)
  Infer
.end

struct TypeExpr
  kind: TypeExprKind
  span: diag.Span
.end

fn TypeExpr.named_from_ident(name: Ident) -> TypeExpr
  let path = coll.Vec[Ident].new()
  path.push(name)

  let span = name.span
  let kind = TypeExprKind.Named(
    path = path,
  )

  return TypeExpr(
    kind = kind,
    span = span,
  )
.end

# Handles logiques pour référencer des blocs/expressions dans d'autres
# structures (le stockage réel peut se faire dans une arène ailleurs).
type BlockId = Int
type ExprId = Int
type StmtId = Int

struct Block
  stmts: coll.Vec[StmtId]
  span: diag.Span
.end

enum StmtKind
  Expr
    expr: ExprId
  Return
    value: Option[ExprId]
  Empty
.end

struct Stmt
  kind: StmtKind
  span: diag.Span
.end

enum BinaryOp
  Add      # +
  Sub      # -
  Mul      # *
  Div      # /
  Eq       # ==
  Ne       # !=
  Lt       # <
  Le       # <=
  Gt       # >
  Ge       # >=
.end

enum ExprKind
  # x, foo, my_module.some_name, etc.
  Name
    ident: Ident

  # 42, 0, 123456
  IntLiteral
    value: String

  # foo(a, b, c)
  Call
    callee: ExprId
    args: coll.Vec[ExprId]

  # a + b, x * y, a == b, etc.
  Binary
    op: BinaryOp
    lhs: ExprId
    rhs: ExprId
.end

struct Expr
  kind: ExprKind
  span: diag.Span
.end

struct FnParam
  name: Ident
  ty: Option[TypeExpr]
  default_value: Option[ExprId]
  span: diag.Span
.end

enum FnKind
  Normal
  Extern
  Intrinsic
.end

struct FnDecl
  name: Ident
  vis: Visibility
  kind: FnKind
  params: coll.Vec[FnParam]
  return_type: Option[TypeExpr]
  body: Option[BlockId]
  span: diag.Span
.end

fn FnParam.new(name: Ident, ty: Option[TypeExpr], default_value: Option[ExprId], span: diag.Span) -> FnParam
  return FnParam(
    name = name,
    ty = ty,
    default_value = default_value,
    span = span,
  )
.end

fn FnDecl.new(
  name: Ident,
  vis: Visibility,
  kind: FnKind,
  params: coll.Vec[FnParam],
  return_type: Option[TypeExpr],
  body: Option[BlockId],
  span: diag.Span,
) -> FnDecl
  return FnDecl(
    name = name,
    vis = vis,
    kind = kind,
    params = params,
    return_type = return_type,
    body = body,
    span = span,
  )
.end

# -----------------------------------------------------------------------------
# Déclarations de haut niveau (items)
# -----------------------------------------------------------------------------

enum ModuleItemKind
  ModuleDecl
  ImportDecl
  StructDecl
  FnDecl
  EnumDecl
  TypeAliasDecl
  ConstDecl
.end

struct ModuleItem
  kind: ModuleItemKind
  name: String
  span: diag.Span

  # Payload optionnel pour chaque genre d'item.
  # Pour l'instant, on ne modèle que les fonctions de façon détaillée.
  fn_decl: Option[FnDecl]
.end

fn ModuleItem.new(kind: ModuleItemKind, name: String, span: diag.Span) -> ModuleItem
  return ModuleItem(
    kind = kind,
    name = name,
    span = span,
    fn_decl = None,
  )
.end

fn ModuleItem.from_fn(decl: FnDecl) -> ModuleItem
  return ModuleItem(
    kind = ModuleItemKind.FnDecl,
    name = decl.name.name,
    span = decl.span,
    fn_decl = Some(decl),
  )
.end

# -----------------------------------------------------------------------------
# Module
# -----------------------------------------------------------------------------

struct Module
  file: String
  items: coll.Vec[ModuleItem]
  blocks: coll.Vec[Block]
  stmts: coll.Vec[Stmt]
  exprs: coll.Vec[Expr]
.end

fn empty_module(file: String) -> Module
  # Helper utilisé par le parser tant que la construction fine des items
  # n'est pas encore implémentée.
  return Module(
    file = file,
    items = coll.Vec[ModuleItem].new(),
    blocks = coll.Vec[Block].new(),
    stmts = coll.Vec[Stmt].new(),
    exprs = coll.Vec[Expr].new(),
  )
.end

fn Module.new(file: String) -> Module
  return empty_module(file)
.end

fn Module.add_item(self: &mut Module, item: ModuleItem) -> Unit
  self.items.push(item)
.end

fn Module.len(self: Module) -> Int
  return self.items.len()
.end

fn Module.is_empty(self: Module) -> Bool
  return self.items.len() == 0
.end

fn Module.add_block(self: &mut Module, block: Block) -> BlockId
  let id = self.blocks.len()
  self.blocks.push(block)
  return id
.end

fn Module.get_block(self: &Module, id: BlockId) -> Block
  return self.blocks[id]
.end

fn Module.add_stmt(self: &mut Module, stmt: Stmt) -> StmtId
  let id = self.stmts.len()
  self.stmts.push(stmt)
  return id
.end

fn Module.get_stmt(self: &Module, id: StmtId) -> Stmt
  return self.stmts[id]
.end

fn Module.add_expr(self: &mut Module, expr: Expr) -> ExprId
  let id = self.exprs.len()
  self.exprs.push(expr)
  return id
.end

fn Module.get_expr(self: &Module, id: ExprId) -> Expr
  return self.exprs[id]
.end