module vitte.compiler.frontend.symbol

import std.collections as coll
import vitte.compiler.frontend.ast as ast
import vitte.compiler.frontend.resolve as res
import vitte.compiler.frontend.diagnostics as diag

# ============================================================================
# Vitte compiler front-end – Modèle logique des symboles & types
# (maximal, déclaratif, sans I/O)
#
# Objectifs :
#   - Définir une représentation purement déclarative pour :
#       * le système de types "normalisé" côté front-end,
#       * les symboles "sémantiques" (instances typées),
#       * les bindings AST -> types, pour expr/pattern/item/etc.,
#       * les contraintes génériques et régions (simplifié),
#       * les résumés/statistiques de typage.
#   - Servir de contrat entre :
#       * la résolution (`bt_resolve`),
#       * le typage / vérification de types,
#       * les passes suivantes (HIR/MIR/IR),
#       * les outils (IDE, lints, visualisation de types).
#   - Ne contenir :
#       * aucune fonction,
#       * aucune logique de typage,
#       * aucune I/O ni formatage.
# ============================================================================

# ---------------------------------------------------------------------------
# Identifiants internes
# ---------------------------------------------------------------------------

struct SyTypeId
    raw: u32
.end

struct SySymbolInstanceId
    raw: u32
.end

struct SyRegionId
    raw: u32
.end

struct SyConstraintId
    raw: u32
.end

# ---------------------------------------------------------------------------
# Types primitifs et genres de types
# ---------------------------------------------------------------------------

enum SyPrimitiveTypeKind
    Bool
    I8
    I16
    I32
    I64
    I128
    Isize

    U8
    U16
    U32
    U64
    U128
    Usize

    F32
    F64

    Char
    Str

    Unit
    Never
    UnknownPrimitive
.end

enum SyTypeKind
    Primitive          # SyPrimitiveTypeKind
    Named              # type nommé résolu (struct, enum, alias, etc.)
    Tuple
    Array
    Slice
    Reference
    Pointer
    Fn
    GenericParam       # paramètre générique (T, U, const N, etc.)
    AssociatedType
    ErrorType          # type d’erreur (fallback)
    UnknownType        # type inconnu / non encore inféré
    InferType          # type à inférer
.end

enum SyMutability
    SyImmutable
    SyMutable
.end

enum SyPointerKind
    SyRawConst
    SyRawMut
    SyOther
.end

# ---------------------------------------------------------------------------
# Signatures de fonctions
# ---------------------------------------------------------------------------

struct SyFnParamType
    name: string                  # nom logique (peut être vide)
    ty: SyTypeId
    mutability: SyMutability
    is_self: bool                 # true pour self / &self / &mut self
.end

struct SyFnSignature
    params: coll.Vec<SyFnParamType>
    return_type: SyTypeId
    is_async: bool
    is_unsafe: bool
    calling_convention: string    # ex: "vitte", "C"
.end

# ---------------------------------------------------------------------------
# Représentation normalisée des types
# ---------------------------------------------------------------------------

struct SyType
    id: SyTypeId
    kind: SyTypeKind

    # Span d’origine (optionnel, peut être un span d’erreur)
    origin_span: ast.AstSpan

    # Pour Primitive
    primitive: SyPrimitiveTypeKind

    # Pour Named / AssociatedType
    resolved_symbol: res.ResSymbolId
    type_arguments: coll.Vec<SyTypeId>

    # Pour tuples
    tuple_elements: coll.Vec<SyTypeId>

    # Pour Array / Slice
    element_type: SyTypeId
    array_size_expr: ast.AstNodeId    # expression constante dans l’AST, si connue

    # Pour Reference / Pointer
    ref_target: SyTypeId
    ref_mutability: SyMutability
    region: SyRegionId                # région/logique de vie simplifiée

    ptr_target: SyTypeId
    ptr_kind: SyPointerKind

    # Pour Fn
    fn_sig: SyFnSignature

    # Pour GenericParam / AssociatedType
    generic_param_name: string
    generic_param_index: u32          # index dans la liste de params
    generic_param_owner: res.ResSymbolId   # symbole propriétaire (fn, type, etc.)

    # Pour ErrorType / UnknownType / InferType
    error_diag: diag.DiagId

    # Données additionnelles
    tags: coll.Vec<string>
    extra: coll.HashMap<string, string>
.end

# ---------------------------------------------------------------------------
# Régions / lifetimes (modèle simplifié)
# ---------------------------------------------------------------------------

enum SyRegionKind
    RegionStatic
    RegionLocal
    RegionParam
    RegionUnknown
    RegionError
.end

struct SyRegion
    id: SyRegionId
    kind: SyRegionKind

    # Nom logique (pour paramètres de région explicites, si supportés)
    name: string

    # AST / span d’origine
    ast_id: ast.AstNodeId
    span: ast.AstSpan

    # Région "parent" dans une hiérarchie simplifiée
    parent: SyRegionId

    notes: string
    extra: coll.HashMap<string, string>
.end

# ---------------------------------------------------------------------------
# Contraintes génériques et bounds
# ---------------------------------------------------------------------------

enum SyConstraintKind
    TraitBound            # T: Trait
    LifetimeOutlives      # 'a: 'b
    TypeEquality          # T = U
    ConstEquality         # const N = const M
    WherePredicateOther
.end

struct SyConstraint
    id: SyConstraintId
    kind: SyConstraintKind

    # AST d’origine (where clause, param, etc.)
    ast_id: ast.AstNodeId
    span: ast.AstSpan

    # Types / régions impliqués
    lhs_type: SyTypeId
    rhs_type: SyTypeId

    lhs_region: SyRegionId
    rhs_region: SyRegionId

    # Traits / symboles associés (pour TraitBound, AssociatedType)
    trait_symbol: res.ResSymbolId
    associated_item: res.ResSymbolId

    # Diagnostic éventuel lié à cette contrainte
    diag_id: diag.DiagId

    notes: string
    extra: coll.HashMap<string, string>
.end

# ---------------------------------------------------------------------------
# Invariants de portée (module vs bloc)
# ---------------------------------------------------------------------------

struct SyScopeRules
    # Règles héritées de la résolution (module = items, bloc = locals uniquement)
    resolve_rules: res.ResScopeRules

    # Scopes concrets concernés par l’unité courante
    module_scope: res.ResScopeId                   # scope module du fichier
    block_scopes: coll.Vec<res.ResScopeId>         # blocs/branches/fn body
    fn_scope: res.ResScopeId                       # scope englobant les params/return (raw=0 si absent)

    # Contraintes spécifiques côté typage
    blocks_cannot_declare_types: bool              # aucune struct/enum/alias dans un bloc
    modules_own_type_resolution: bool              # les types se résolvent toujours dans le module courant
    locals_shadow_only_within_block: bool          # un local masque uniquement dans son bloc/descendants

    notes: string
    extra: coll.HashMap<string, string>
.end

# ---------------------------------------------------------------------------
# Instances de symboles (vue typée de ResSymbol)
# ---------------------------------------------------------------------------

enum SySymbolInstanceKind
    SyItemInstance          # instance globale (fn, const, static, type, etc.)
    SyLocalInstance         # variable locale, paramètre, binding de pattern
    SyFieldInstance         # champ d’un struct/tuple struct
    SyEnumVariantInstance   # variant d’un enum
    SyLabelInstance
    SyOtherInstance
.end

struct SySymbolInstance
    id: SySymbolInstanceId
    kind: SySymbolInstanceKind

    # Symbole résolu d’origine
    symbol: res.ResSymbolId

    # Type inféré / vérifié pour cette instance
    ty: SyTypeId

    # Pour les fonctions / méthodes
    fn_sig: SyFnSignature

    # Contexte générique instancié (mapping nom -> SyTypeId)
    generic_args: coll.HashMap<string, SyTypeId>

    # Région locale dominante (pour locals / params)
    region: SyRegionId

    # AST d’origine
    ast_id: ast.AstNodeId
    span: ast.AstSpan

    # Diagnostics liés à cette instance
    diagnostics: coll.Vec<diag.DiagId>

    # Données additionnelles
    tags: coll.Vec<string>
    extra: coll.HashMap<string, string>
.end

# ---------------------------------------------------------------------------
# Bindings AST -> types
# ---------------------------------------------------------------------------

enum SyBindingKind
    SyExprTypeBinding        # type d’une expression
    SyPatternTypeBinding     # type d’un pattern
    SyItemTypeBinding        # type d’un item (fn, const, type alias, etc.)
    SyReturnTypeBinding      # type de retour d’une fn / program / scenario
    SyParamTypeBinding       # type de paramètre
    SyFieldTypeBinding       # type d’un champ de struct/enum
    SyTypeAliasBinding       # type d’un alias
    SyOtherBinding
.end

struct SyTypeBinding
    kind: SyBindingKind

    # AST
    ast_id: ast.AstNodeId
    span: ast.AstSpan

    # Type inféré / vérifié
    ty: SyTypeId

    # Type attendu (optionnel, peut être UnknownType/InferType)
    expected_ty: SyTypeId

    # Instance de symbole associée (pour expr/item qui réfèrent à un symbole)
    symbol_instance: SySymbolInstanceId

    # Diagnostics associés à ce binding
    diagnostics: coll.Vec<diag.DiagId>

    notes: string
    extra: coll.HashMap<string, string>
.end

struct SyBindingIndex
    # ast_id.raw -> index dans une table de SyTypeBinding
    binding_index_by_ast_id: coll.HashMap<u32, u32>

    # symbol_instance_id.raw -> indices de bindings
    binding_indices_by_symbol_instance: coll.HashMap<u32, coll.Vec<u32>>

    notes: string
    extra: coll.HashMap<string, string>
.end

# ---------------------------------------------------------------------------
# Résumé et statistiques de typage
# ---------------------------------------------------------------------------

struct SyTypingSummary
    total_types: u32
    total_symbol_instances: u32
    total_bindings: u32
    total_constraints: u32
    total_regions: u32

    # Diagnostics
    total_type_errors: u32
    total_type_warnings: u32

    has_errors: bool
.end

# ---------------------------------------------------------------------------
# Unité de typage (par fichier/module)
# ---------------------------------------------------------------------------

struct BtSymbolUnitMetadata
    file_path: string
    module_name: string
    edition: string              # ex: "2025"
    profile: string              # ex: "core-bootstrap"
    notes: string
.end

struct BtSymbolUnit
    meta: BtSymbolUnitMetadata

    # Référence au résultat de résolution
    resolve_file: res.ResFileId
    scope_rules: SyScopeRules

    # Tables de types, régions, contraintes
    types: coll.Vec<SyType>
    regions: coll.Vec<SyRegion>
    constraints: coll.Vec<SyConstraint>

    # Instances de symboles typées
    symbol_instances: coll.Vec<SySymbolInstance>

    # Bindings AST -> types
    bindings: coll.Vec<SyTypeBinding>
    binding_index: SyBindingIndex

    # Résumé de typage
    summary: SyTypingSummary

    # Diagnostics supplémentaires liés au typage
    diagnostics: diag.BtDiagnostics

    # Données annexes
    extra: coll.HashMap<string, string>
.end

# ---------------------------------------------------------------------------
# Bundle global de typage pour un ensemble d’unités
# ---------------------------------------------------------------------------

struct BtSymbolBundleSummary
    units_total: u32
    units_with_errors: u32

    total_types: u32
    total_symbol_instances: u32
    total_bindings: u32
    total_constraints: u32
    total_regions: u32

    total_type_errors: u32
    total_type_warnings: u32

    has_errors: bool
.end

struct BtSymbolIndex
    # Index global pour navigation typée
    unit_index_by_file_path: coll.HashMap<string, u32>

    # ast_id.raw -> (unit index, binding index)
    binding_index_by_ast_id: coll.HashMap<u32, string>

    # Résolution inverse : type id -> occurrences (symbol instances)
    symbol_instance_ids_by_type: coll.HashMap<u32, coll.Vec<u32>>

    notes: string
    extra: coll.HashMap<string, string>
.end

struct BtSymbolBundle
    units: coll.Vec<BtSymbolUnit>
    summary: BtSymbolBundleSummary
    index: BtSymbolIndex

    extra: coll.HashMap<string, string>
.end
