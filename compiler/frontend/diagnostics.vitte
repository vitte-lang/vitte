module vitte.compiler.frontend.diagnostics

import std.collections as coll

# =============================================================================
# Vitte compiler – Diagnostics de frontend (version projet complète)
#
# Objectifs :
#   - Fournir des types stables pour représenter :
#       * les spans (fichier + positions),
#       * la sévérité (error / warning / note),
#       * les labels multiples (primary/secondary) par diagnostic,
#       * un diagnostic individuel,
#       * un bag de diagnostics (DiagnosticBag) accumulé pendant le frontend.
#   - Servir de contrat entre :
#       * le lexer / parser,
#       * la résolution / typage,
#       * le driver du compilateur,
#       * les outils (LSP, formatters, etc.).
#
# Conventions :
#   - Pas d'I/O dans ce module : uniquement des structures de données
#     et des helpers purs (construction, requêtes, fusion).
#   - L'affichage (formatage texte) est laissé à un autre module
#     (ex. vitte.compiler.frontend.reporter).
# =============================================================================

# -----------------------------------------------------------------------------
# Spans
# -----------------------------------------------------------------------------

struct Span
  file: String
  start_line: Int
  start_col: Int
  end_line: Int
  end_col: Int
.end

fn Span.dummy(file: String) -> Span
  # Span artificiel pour les cas où l'on n'a pas encore de position précise.
  return Span(
    file = file,
    start_line = 0,
    start_col = 0,
    end_line = 0,
    end_col = 0,
  )
.end

fn Span.is_dummy(self: Span) -> Bool
  return self.start_line == 0 and self.end_line == 0
.end

fn Span.same_file(a: Span, b: Span) -> Bool
  return a.file == b.file
.end

fn Span.merge(a: Span, b: Span) -> Span
  # Fusion grossière de deux spans sur le même fichier.
  if a.file != b.file
    # Si les fichiers diffèrent, on retourne simplement a.
    return a
  end

  let start_line =
    if a.start_line <= b.start_line then a.start_line else b.start_line end
  let start_col =
    if a.start_col <= b.start_col then a.start_col else b.start_col end
  let end_line =
    if a.end_line >= b.end_line then a.end_line else b.end_line end
  let end_col =
    if a.end_col >= b.end_col then a.end_col else b.end_col end

  return Span(
    file = a.file,
    start_line = start_line,
    start_col = start_col,
    end_line = end_line,
    end_col = end_col,
  )
.end

# -----------------------------------------------------------------------------
# Sévérité
# -----------------------------------------------------------------------------

enum Severity
  Error
  Warning
  Note
.end

fn Severity.is_error(self: Severity) -> Bool
  return self == Severity.Error
.end

fn Severity.is_warning(self: Severity) -> Bool
  return self == Severity.Warning
.end

fn Severity.is_note(self: Severity) -> Bool
  return self == Severity.Note
.end

# -----------------------------------------------------------------------------
# Labels de diagnostic
# -----------------------------------------------------------------------------

struct DiagnosticLabel
  message: String
  span: Span
  is_primary: Bool
.end

fn DiagnosticLabel.primary(message: String, span: Span) -> DiagnosticLabel
  return DiagnosticLabel(
    message = message,
    span = span,
    is_primary = true,
  )
.end

fn DiagnosticLabel.secondary(message: String, span: Span) -> DiagnosticLabel
  return DiagnosticLabel(
    message = message,
    span = span,
    is_primary = false,
  )
.end

# -----------------------------------------------------------------------------
# Diagnostic principal
# -----------------------------------------------------------------------------

struct Diagnostic
  message: String
  span: Span
  severity: Severity
  code: String            # ex : "E0001", "W0001"
  labels: coll.Vec[DiagnosticLabel]
.end

fn Diagnostic.error(msg: String, span: Span, code: String) -> Diagnostic
  let labels = coll.Vec[DiagnosticLabel].new()
  labels.push(DiagnosticLabel.primary(msg, span))
  return Diagnostic(
    message = msg,
    span = span,
    severity = Severity.Error,
    code = code,
    labels = labels,
  )
.end

fn Diagnostic.warning(msg: String, span: Span, code: String) -> Diagnostic
  let labels = coll.Vec[DiagnosticLabel].new()
  labels.push(DiagnosticLabel.primary(msg, span))
  return Diagnostic(
    message = msg,
    span = span,
    severity = Severity.Warning,
    code = code,
    labels = labels,
  )
.end

fn Diagnostic.note(msg: String, span: Span, code: String) -> Diagnostic
  let labels = coll.Vec[DiagnosticLabel].new()
  labels.push(DiagnosticLabel.primary(msg, span))
  return Diagnostic(
    message = msg,
    span = span,
    severity = Severity.Note,
    code = code,
    labels = labels,
  )
.end

fn Diagnostic.add_secondary_label(self: &mut Diagnostic, msg: String, span: Span) -> Unit
  let lbl = DiagnosticLabel.secondary(msg, span)
  self.labels.push(lbl)
.end

# -----------------------------------------------------------------------------
# Bag de diagnostics
# -----------------------------------------------------------------------------

struct DiagnosticBag
  items: coll.Vec[Diagnostic]
.end

# Constructeur et helpers principaux ------------------------------------------

fn DiagnosticBag.new() -> DiagnosticBag
  return DiagnosticBag(
    items = coll.Vec[Diagnostic].new(),
  )
.end

fn DiagnosticBag.is_empty(self: DiagnosticBag) -> Bool
  return self.items.len() == 0
.end

fn DiagnosticBag.len(self: DiagnosticBag) -> Int
  return self.items.len()
.end

fn DiagnosticBag.get(self: DiagnosticBag, index: Int) -> Diagnostic
  # Lève si index hors bornes, comportement conforme à Vec.
  return self.items[index]
.end

fn DiagnosticBag.add(self: &mut DiagnosticBag, diag: Diagnostic) -> Unit
  self.items.push(diag)
.end

fn DiagnosticBag.add_error(self: &mut DiagnosticBag, msg: String, span: Span, code: String) -> Unit
  let d = Diagnostic.error(msg, span, code)
  self.items.push(d)
.end

fn DiagnosticBag.add_warning(self: &mut DiagnosticBag, msg: String, span: Span, code: String) -> Unit
  let d = Diagnostic.warning(msg, span, code)
  self.items.push(d)
.end

fn DiagnosticBag.add_note(self: &mut DiagnosticBag, msg: String, span: Span, code: String) -> Unit
  let d = Diagnostic.note(msg, span, code)
  self.items.push(d)
.end

fn DiagnosticBag.has_error(self: DiagnosticBag) -> Bool
  for d in self.items
    if d.severity == Severity.Error
      return true
    end
  end
  return false
.end

fn DiagnosticBag.clear(self: &mut DiagnosticBag) -> Unit
  # Réinitialise le bag sans allouer de nouveau vecteur.
  # Implémentation naïve : tant que len > 0, pop.
  # Pour l'instant, on se contente de recréer un Vec vide.
  self.items = coll.Vec[Diagnostic].new()
.end

fn DiagnosticBag.extend(self: &mut DiagnosticBag, other: DiagnosticBag) -> Unit
  # Ajoute tous les diagnostics de `other` dans `self`.
  for d in other.items
    self.items.push(d)
  end
.end
