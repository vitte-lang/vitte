module vitte.compiler.frontend.diagnostics

import std.collections as coll

# =============================================================================
# Vitte compiler – Diagnostics de frontend (version projet complète)
#
# Objectifs :
#   - Fournir des types stables pour représenter :
#       * les spans (fichier + positions),
#       * la sévérité (error / warning / note),
#       * les labels multiples (primary/secondary) par diagnostic,
#       * un diagnostic individuel,
#       * un bag de diagnostics (DiagnosticBag) accumulé pendant le frontend.
#   - Servir de contrat entre :
#       * le lexer / parser,
#       * la résolution / typage,
#       * le driver du compilateur,
#       * les outils (LSP, formatters, etc.).
#
# Conventions :
#   - Pas d'I/O dans ce module : uniquement des structures de données
#     et des helpers purs (construction, requêtes, fusion).
#   - L'affichage (formatage texte) est laissé à un autre module
#     (ex. vitte.compiler.frontend.reporter).
# =============================================================================

# -----------------------------------------------------------------------------
# Spans
# -----------------------------------------------------------------------------

struct Span
  file: String
  start_line: Int
  start_col: Int
  end_line: Int
  end_col: Int
.end

fn Span.dummy(file: String) -> Span
  # Span artificiel pour les cas où l'on n'a pas encore de position précise.
  return Span(
    file = file,
    start_line = 0,
    start_col = 0,
    end_line = 0,
    end_col = 0,
  )
.end

fn Span.is_dummy(self: Span) -> Bool
  return self.start_line == 0 and self.end_line == 0
.end

fn Span.same_file(a: Span, b: Span) -> Bool
  return a.file == b.file
.end

fn Span.merge(a: Span, b: Span) -> Span
  # Fusion grossière de deux spans sur le même fichier.
  if a.file != b.file
    # Si les fichiers diffèrent, on retourne simplement a.
    return a
  end

  let start_line =
    if a.start_line <= b.start_line then a.start_line else b.start_line end
  let start_col =
    if a.start_col <= b.start_col then a.start_col else b.start_col end
  let end_line =
    if a.end_line >= b.end_line then a.end_line else b.end_line end
  let end_col =
    if a.end_col >= b.end_col then a.end_col else b.end_col end

  return Span(
    file = a.file,
    start_line = start_line,
    start_col = start_col,
    end_line = end_line,
    end_col = end_col,
  )
.end

# -----------------------------------------------------------------------------
# Sévérité
# -----------------------------------------------------------------------------

enum Severity
  Error
  Warning
  Note
.end

fn Severity.is_error(self: Severity) -> Bool
  return self == Severity.Error
.end

fn Severity.is_warning(self: Severity) -> Bool
  return self == Severity.Warning
.end

fn Severity.is_note(self: Severity) -> Bool
  return self == Severity.Note
.end

# -----------------------------------------------------------------------------
# Labels de diagnostic
# -----------------------------------------------------------------------------

struct DiagnosticLabel
  message: String
  span: Span
  is_primary: Bool
.end

fn DiagnosticLabel.primary(message: String, span: Span) -> DiagnosticLabel
  return DiagnosticLabel(
    message = message,
    span = span,
    is_primary = true,
  )
.end

fn DiagnosticLabel.secondary(message: String, span: Span) -> DiagnosticLabel
  return DiagnosticLabel(
    message = message,
    span = span,
    is_primary = false,
  )
.end

# -----------------------------------------------------------------------------
# Diagnostic principal
# -----------------------------------------------------------------------------

fn default_code_registry() -> coll.HashMap[String, String]
  # Table de correspondance message -> code pour éviter les codes génériques.
  # Aligner au maximum avec les diagnostics du frontend Python (goldens).
  let table = coll.HashMap[String, String]()

  table["',' ou '}' attendu après un champ de pattern struct"] = "E1208"
  table["Utiliser '}' pour fermer un pattern de struct (pas '.end')"] = "E1206"
  table["',' ou ')' attendu après un paramètre de fonction"] = "E1033"
  table["',' ou '}' attendu après un champ de struct"] = "E2007"
  table["Un littéral de struct se ferme avec '}' (et non '.end')"] = "E2009"
  table["Bloc non terminé ('.end' manquant)"] = "E1300"
  table["Utiliser '}' pour fermer ce bloc"] = "E1302"
  table["Manifest Muffin introuvable"] = "E0001"
  table["Impossible de lire le fichier source"] = "E0002"
  table["Déclaration de haut niveau inattendue"] = "E1000"
  table["Type attendu"] = "E1034"
  table["Nom de paramètre attendu"] = "E1036"
  table["Nom de struct attendu après 'struct'"] = "E1021"
  table["Nom de fonction attendu après 'fn'"] = "E1031"
  table["Expression attendue"] = "E2000"
  table["Identifiant attendu après 'let'"] = "E1101"
  table["Nom de champ attendu dans un littéral de struct"] = "E2005"
  table["Nom de champ attendu dans un pattern de struct"] = "E1207"
  table["Symbole '=>' attendu dans un bras de match"] = "E1201"
  table["Pattern de match invalide"] = "E1203"
  table["Parenthèse fermante ')' attendue"] = "E2002"
  table["',' ou ')' attendu dans la liste d'arguments"] = "E2003"
  table["',' ou ')' attendu dans un pattern de tuple"] = "E1205"
  table["Littéral de chaîne non terminé"] = "E0102"
  table["Littéral de caractère non terminé"] = "E0103"
  table["Caractère invalide"] = "E0101"

  return table
.end

fn code_for_message(msg: String) -> String
  let table = default_code_registry()
  if table.contains_key(msg)
    return table[msg]
  end
  return "E0000"
.end

fn resolve_diag_code(msg: String, provided: String) -> String
  # Si une entrée existe dans la table, elle prime sur tout le reste.
  let mapped = code_for_message(msg)
  if mapped != "E0000"
    return mapped
  end

  # Sinon, on garde le code fourni s'il est présent.
  if provided != "" and provided != "E0000"
    return provided
  end

  # Fallback sur un code générique.
  return "E0000"
.end

struct Diagnostic
  message: String
  span: Span
  severity: Severity
  code: String            # ex : "E0001", "W0001"
  labels: coll.Vec[DiagnosticLabel]
.end

fn diagnostic_severity_name(sev: Severity) -> String
  if sev == Severity.Error
    return "error"
  end
  if sev == Severity.Warning
    return "warning"
  end
  return "note"
.end

fn Diagnostic.error(msg: String, span: Span, code: String) -> Diagnostic
  let labels = coll.Vec[DiagnosticLabel].new()
  labels.push(DiagnosticLabel.primary(msg, span))
  let normalized_code = resolve_diag_code(msg, code)
  return Diagnostic(
    message = msg,
    span = span,
    severity = Severity.Error,
    code = normalized_code,
    labels = labels,
  )
.end

fn Diagnostic.warning(msg: String, span: Span, code: String) -> Diagnostic
  let labels = coll.Vec[DiagnosticLabel].new()
  labels.push(DiagnosticLabel.primary(msg, span))
  let normalized_code = resolve_diag_code(msg, code)
  return Diagnostic(
    message = msg,
    span = span,
    severity = Severity.Warning,
    code = normalized_code,
    labels = labels,
  )
.end

fn Diagnostic.note(msg: String, span: Span, code: String) -> Diagnostic
  let labels = coll.Vec[DiagnosticLabel].new()
  labels.push(DiagnosticLabel.primary(msg, span))
  let normalized_code = resolve_diag_code(msg, code)
  return Diagnostic(
    message = msg,
    span = span,
    severity = Severity.Note,
    code = normalized_code,
    labels = labels,
  )
.end

fn Diagnostic.add_secondary_label(self: &mut Diagnostic, msg: String, span: Span) -> Unit
  let lbl = DiagnosticLabel.secondary(msg, span)
  self.labels.push(lbl)
.end

fn diagnostic_primary_label(d: Diagnostic) -> DiagnosticLabel
  for lbl in d.labels
    if lbl.is_primary
      return lbl
    end
  end
  # Fallback : aucun label primaire explicite, on synthétise à partir du span
  return DiagnosticLabel.primary(d.message, d.span)
.end

fn diagnostic_primary_span(d: Diagnostic) -> Span
  let lbl = diagnostic_primary_label(d)
  return lbl.span
.end

# -----------------------------------------------------------------------------
# Bag de diagnostics
# -----------------------------------------------------------------------------

struct DiagnosticBag
  items: coll.Vec[Diagnostic]
.end

# Compatibilité minimale avec l'ancien vocabulaire "DiagSink"
# (utilisé par quelques appels CLI/tests).
type DiagSink = DiagnosticBag

# Constructeur et helpers principaux ------------------------------------------

fn DiagnosticBag.new() -> DiagnosticBag
  return DiagnosticBag(
    items = coll.Vec[Diagnostic].new(),
  )
.end

fn DiagnosticBag.is_empty(self: DiagnosticBag) -> Bool
  return self.items.len() == 0
.end

fn DiagnosticBag.len(self: DiagnosticBag) -> Int
  return self.items.len()
.end

fn DiagnosticBag.get(self: DiagnosticBag, index: Int) -> Diagnostic
  # Lève si index hors bornes, comportement conforme à Vec.
  return self.items[index]
.end

fn DiagnosticBag.add(self: &mut DiagnosticBag, diag: Diagnostic) -> Unit
  self.items.push(diag)
.end

fn DiagnosticBag.add_error(self: &mut DiagnosticBag, msg: String, span: Span, code: String) -> Unit
  let d = Diagnostic.error(msg, span, code)
  self.items.push(d)
.end

fn DiagnosticBag.add_warning(self: &mut DiagnosticBag, msg: String, span: Span, code: String) -> Unit
  let d = Diagnostic.warning(msg, span, code)
  self.items.push(d)
.end

fn DiagnosticBag.add_note(self: &mut DiagnosticBag, msg: String, span: Span, code: String) -> Unit
  let d = Diagnostic.note(msg, span, code)
  self.items.push(d)
.end

fn DiagnosticBag.has_error(self: DiagnosticBag) -> Bool
  for d in self.items
    if d.severity == Severity.Error
      return true
    end
  end
  return false
.end

fn DiagnosticBag.clear(self: &mut DiagnosticBag) -> Unit
  # Réinitialise le bag sans allouer de nouveau vecteur.
  # Implémentation naïve : tant que len > 0, pop.
  # Pour l'instant, on se contente de recréer un Vec vide.
  self.items = coll.Vec[Diagnostic].new()
.end

fn DiagnosticBag.extend(self: &mut DiagnosticBag, other: DiagnosticBag) -> Unit
  # Ajoute tous les diagnostics de `other` dans `self`.
  for d in other.items
    self.items.push(d)
  end
.end

# -----------------------------------------------------------------------------
# Helpers conviviaux (compat shim pour le CLI)
# -----------------------------------------------------------------------------

fn diag_sink_new() -> DiagSink
  return DiagnosticBag.new()
.end

fn diag_error(sink: &mut DiagSink, code: String, file: String, line: Int, col: Int, msg: String) -> Unit
  let span = Span(
    file = file,
    start_line = line,
    start_col = col,
    end_line = line,
    end_col = col,
  )
  sink.add_error(msg, span, code)
.end

fn diag_warning(sink: &mut DiagSink, code: String, file: String, line: Int, col: Int, msg: String) -> Unit
  let span = Span(
    file = file,
    start_line = line,
    start_col = col,
    end_line = line,
    end_col = col,
  )
  sink.add_warning(msg, span, code)
.end

fn diag_note(sink: &mut DiagSink, code: String, file: String, line: Int, col: Int, msg: String) -> Unit
  let span = Span(
    file = file,
    start_line = line,
    start_col = col,
    end_line = line,
    end_col = col,
  )
  sink.add_note(msg, span, code)
.end

fn diag_has_errors(sink: &DiagSink) -> Bool
  return sink.has_error()
.end

fn diag_print_all(sink: &DiagSink) -> Unit
  for d in sink.items
    let sev = diagnostic_severity_name(d.severity)
    let span = diagnostic_primary_span(d)
    say sev "[" d.code "] " span.file ":" span.start_line ":" span.start_col ": " d.message
  end
.end

# -----------------------------------------------------------------------------
# JSON-friendly payloads (propagation vers le host)
# -----------------------------------------------------------------------------

struct DiagnosticSpanJson
  file: String
  start_line: Int
  start_col: Int
  end_line: Int
  end_col: Int
.end

struct DiagnosticLabelJson
  message: String
  span: DiagnosticSpanJson
  is_primary: Bool
.end

struct DiagnosticJson
  message: String
  span: DiagnosticSpanJson
  severity: String
  code: String
  labels: coll.Vec[DiagnosticLabelJson]
.end

struct DiagnosticOutput
  code: String
  severity: String
  message: String
  labels: coll.Vec[DiagnosticLabelJson]
.end

fn span_to_json(span: Span) -> DiagnosticSpanJson
  return DiagnosticSpanJson(
    file = span.file,
    start_line = span.start_line,
    start_col = span.start_col,
    end_line = span.end_line,
    end_col = span.end_col,
  )
.end

fn DiagnosticLabel.to_json(self: DiagnosticLabel) -> DiagnosticLabelJson
  return DiagnosticLabelJson(
    message = self.message,
    span = span_to_json(self.span),
    is_primary = self.is_primary,
  )
.end

fn Diagnostic.to_json(self: Diagnostic) -> DiagnosticJson
  let labels_json = coll.Vec[DiagnosticLabelJson].new()
  for lbl in self.labels
    labels_json.push(lbl.to_json())
  end

  return DiagnosticJson(
    message = self.message,
    span = span_to_json(diagnostic_primary_span(self)),
    severity = diagnostic_severity_name(self.severity),
    code = self.code,
    labels = labels_json,
  )
.end

fn Diagnostic.to_output(self: Diagnostic) -> DiagnosticOutput
  let labels_json = coll.Vec[DiagnosticLabelJson].new()
  for lbl in self.labels
    labels_json.push(lbl.to_json())
  end

  return DiagnosticOutput(
    code = self.code,
    severity = diagnostic_severity_name(self.severity),
    message = self.message,
    labels = labels_json,
  )
.end

fn DiagnosticBag.to_json_list(self: DiagnosticBag) -> coll.Vec[DiagnosticJson]
  let arr = coll.Vec[DiagnosticJson].new()
  for d in self.items
    arr.push(d.to_json())
  end
  return arr
.end

fn DiagnosticBag.to_output_list(self: DiagnosticBag) -> coll.Vec[DiagnosticOutput]
  let arr = coll.Vec[DiagnosticOutput].new()
  for d in self.items
    arr.push(d.to_output())
  end
  return arr
.end

fn diag_emit_json(diags: DiagnosticBag) -> coll.Vec[DiagnosticJson]
  return diags.to_json_list()
.end
