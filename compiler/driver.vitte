module vitte.compiler.driver

import std.fs as fs
import std.path as path
import std.string as str
import std.time as time
import std.collections as coll

import vitte.compiler.frontend.lexer as lexer
import vitte.compiler.frontend.parser as parser
import vitte.compiler.frontend.diagnostics as diag
import vitte.compiler.frontend.reporter as reporter
import vitte.compiler.frontend.ast as ast
import vitte.compiler.ir as ir
import vitte.compiler.ir.builder as ir_builder
import vitte.compiler.ir.dump as ir_dump
import vitte.compiler.sema.typecheck as sema

# =============================================================================
# Vitte compiler – Driver de haut niveau (contrat host / driver)
#
# Objectifs :
#   - Point d'entrée unique pour le host (actuellement Python vittec_stage1.py).
#   - Orchestration complète :
#       * chargement du manifest Muffin,
#       * collecte des fichiers .vitte,
#       * frontend (lex + parse + resolve + typecheck),
#       * IR,
#       * backend (C ou VM),
#       * écriture du binaire out_bin.
#   - Fournir des codes retour stables :
#       * 0 = succès,
#       * 1 = erreurs de compilation (user),
#       * 2 = bug interne / I/O critique.
# =============================================================================

struct DriverConfig
  project_path: String
  out_bin: String
  log_path: String?
  emit_text_diags: Bool
  emit_ir_text: Bool
  emit_bytecode: Bool
.end

pub struct DriverFlags
  emit_ir_text: Bool
  emit_bytecode: Bool
.end

fn DriverFlags.build_defaults() -> DriverFlags
  return DriverFlags(
    emit_ir_text = true,
    emit_bytecode = true,
  )
.end

fn DriverFlags.check_defaults() -> DriverFlags
  return DriverFlags(
    emit_ir_text = false,
    emit_bytecode = false,
  )
.end

struct DriverContext
  cfg: DriverConfig
  sources: coll.Vec[String]
  diags: diag.DiagnosticBag
  modules: coll.Vec[ast.Module]
  ir_program: ir.Program
.end

struct DriverResult
  exit_code: Int
  diagnostics: coll.Vec[diag.Diagnostic]
  diagnostics_json: coll.Vec[diag.DiagnosticJson]
  diagnostics_output: coll.Vec[diag.DiagnosticOutput]
.end

fn driver_result(ctx: DriverContext, exit_code: Int) -> DriverResult
  return DriverResult(
    exit_code = exit_code,
    diagnostics = ctx.diags.items,
    diagnostics_json = ctx.diags.to_json_list(),
    diagnostics_output = ctx.diags.to_output_list(),
  )
.end

# -----------------------------------------------------------------------------
# Points d'entrée publics – appelés par le host Python
# -----------------------------------------------------------------------------

fn run_build(project_path: String, out_bin: String, log_path: String?) -> DriverResult
  return run_build_with_flags(project_path, out_bin, log_path, DriverFlags.build_defaults())
.end

fn run_build_with_flags(project_path: String, out_bin: String, log_path: String?, flags: DriverFlags) -> DriverResult
  let cfg = DriverConfig(
    project_path = project_path,
    out_bin = out_bin,
    log_path = log_path,
    emit_text_diags = true,
    emit_ir_text = flags.emit_ir_text,
    emit_bytecode = flags.emit_bytecode,
  )

  let ctx = DriverContext(
    cfg = cfg,
    sources = coll.Vec[String].new(),
    diags = diag.DiagnosticBag.new(),
    modules = coll.Vec[ast.Module].new(),
    ir_program = ir.Program.empty(),
  )

  # Étape 1 : manifest Muffin
  let manifest_res = load_manifest(ctx)
  if manifest_res.is_err()
    # load_manifest doit avoir déposé au moins un diagnostic exploitable.
    report_diagnostics(ctx)
    return driver_result(ctx, 1)
  end

  # Étape 2 : collecte des sources
  let files_res = collect_project_sources(ctx)
  if files_res.is_err()
    report_diagnostics(ctx)
    return driver_result(ctx, 1)
  end

  # Étape 3 : frontend (lex + parse, plus tard resolve/typecheck)
  let front_res = run_frontend(ctx)
  if front_res.is_err()
    report_diagnostics(ctx)
    return driver_result(ctx, 1)
  end

  # Étape 4 : typage minimal
  let sema_res = run_sema(ctx)
  if sema_res.is_err()
    report_diagnostics(ctx)
    return driver_result(ctx, 1)
  end

  # Étape 5 : IR + backend
  let ir_res = build_ir(ctx)
  if ir_res.is_err()
    log_internal_error(ctx, "build_ir a échoué")
    report_diagnostics(ctx)
    return driver_result(ctx, 2)
  end

  let be_res = run_backend(ctx)
  if be_res.is_err()
    # Erreurs backend souvent assimilables à des erreurs user
    # (fichiers manquants, toolchain C, etc.), mais on peut affiner plus tard.
    report_diagnostics(ctx)
    return driver_result(ctx, 1)
  end

  flush_logs(ctx)
  return driver_result(ctx, 0)
.end

fn run_check(project_path: String, log_path: String?) -> DriverResult
  return run_check_with_flags(project_path, log_path, DriverFlags.check_defaults())
.end

fn run_check_with_flags(project_path: String, log_path: String?, flags: DriverFlags) -> DriverResult
  let cfg = DriverConfig(
    project_path = project_path,
    out_bin = "",
    log_path = log_path,
    emit_text_diags = true,
    emit_ir_text = flags.emit_ir_text,
    emit_bytecode = flags.emit_bytecode,
  )

  let ctx = DriverContext(
    cfg = cfg,
    sources = coll.Vec[String].new(),
    diags = diag.DiagnosticBag.new(),
    modules = coll.Vec[ast.Module].new(),
    ir_program = ir.Program.empty(),
  )

  let manifest_res = load_manifest(ctx)
  if manifest_res.is_err()
    report_diagnostics(ctx)
    return driver_result(ctx, 1)
  end

  let files_res = collect_project_sources(ctx)
  if files_res.is_err()
    report_diagnostics(ctx)
    return driver_result(ctx, 1)
  end

  let front_res = run_frontend(ctx)
  if front_res.is_err()
    report_diagnostics(ctx)
    return driver_result(ctx, 1)
  end

  let sema_res = run_sema(ctx)
  if sema_res.is_err()
    report_diagnostics(ctx)
    return driver_result(ctx, 1)
  end

  flush_logs(ctx)
  return driver_result(ctx, 0)
.end

# -----------------------------------------------------------------------------
# Manifest & collecte des sources
# -----------------------------------------------------------------------------

fn load_manifest(ctx: DriverContext) -> Result[Unit, Unit]
  let manifest = ctx.cfg.project_path

  # Vérifier que le manifest existe bien sur disque.
  let exists = fs.exists(manifest)
  if not exists
    let span = diag.Span.dummy(manifest)
    ctx.diags.add_error(
      "Manifest Muffin introuvable",
      span,
      "E0000",
    )
    return Err(())
  end

  let read_res = fs.read_to_string(manifest)
  if read_res.is_err()
    let span = diag.Span.dummy(manifest)
    ctx.diags.add_error(
      "Impossible de lire le manifest",
      span,
      "E0002",
    )
    return Err(())
  end

  # TODO:
  #   - parser Muffin
  #   - initialiser la configuration interne du projet dans le contexte
  return Ok(())
.end

fn collect_project_sources(ctx: DriverContext) -> Result[Unit, Unit]
  let manifest = ctx.cfg.project_path
  let root     = path.dirname(manifest)

  let sources = coll.Vec[String].new()

  for subdir_name in ["bootstrap", "compiler", "src"]
    let base = path.join(root, subdir_name)
    if not fs.is_dir(base)
      continue
    end

    let entries = fs.walk_recursive(base)
    for entry in entries
      if entry.is_file() and str.ends_with(entry.path, ".vitte")
        sources.push(entry.path)
      end
    end
  end

  sort_strings(&mut sources)

  ctx.sources = sources

  if ctx.sources.len() == 0
    let span = diag.Span.dummy(root)
    ctx.diags.add_warning(
      "Aucun fichier .vitte trouvé dans bootstrap/, compiler/ ou src/",
      span,
      "W0001",
    )
  end

  return Ok(())
.end

fn sort_strings(vec: &mut coll.Vec[String]) -> Unit
  # Tri déterministe simple (bubble sort) en attendant un sort standard dans Vec.
  let n = vec.len()
  if n <= 1
    return
  end

  let i = 0
  while i < n
    let j = 0
    while j + 1 < n - i
      if vec[j] > vec[j + 1]
        let tmp = vec[j]
        vec[j] = vec[j + 1]
        vec[j + 1] = tmp
      end
      j = j + 1
    end
    i = i + 1
  end
.end

# -----------------------------------------------------------------------------
# Frontend : lecture, lexing, parsing
# -----------------------------------------------------------------------------

fn run_frontend(ctx: DriverContext) -> Result[Unit, Unit]
  # Frontend Vitte :
  #   - pour chaque fichier .vitte dans ctx.sources :
  #       * lire le texte,
  #       * lexer,
  #       * parser,
  #       * accumuler diagnostics dans ctx.diags,
  #       * stocker le module AST dans ctx.modules.
  #
  # Si au moins une erreur est rencontrée, on renvoie Err(()).
  # Sinon, Ok(()).

  for file_path in ctx.sources
    # 1) Lecture du fichier source
    let text_res = fs.read_to_string(file_path)
    if text_res.is_err()
      let span = diag.Span.dummy(file_path)
      ctx.diags.add_error(
        "Impossible de lire le fichier source",
        span,
        "E0001",
      )
      # On continue quand même les autres fichiers pour accumuler un max d'erreurs.
      continue
    end
    let text = text_res.unwrap()

    # 2) Lexing
    let tokens = lexer.lex(text, file_path, &mut ctx.diags)

    # 3) Parsing
    let module = parser.parse_module(tokens, file_path, &mut ctx.diags)

    # 4) Stocker l'AST dans le contexte
    ctx.modules.push(module)
  end

  if ctx.diags.has_error()
    return Err(())
  end

  return Ok(())
.end

# -----------------------------------------------------------------------------
# IR + backend (stubs pour l'instant)
# -----------------------------------------------------------------------------

fn build_ir(ctx: DriverContext) -> Result[Unit, Unit]
  # Construction du programme IR à partir des modules AST.
  let result = ir_builder.build_program(ctx.modules)
  let dlen = result.diagnostics.len()
  let di = 0usize
  while di < dlen
    let d = result.diagnostics[di]
    ctx.diags.add(d)
    di = di + 1usize
  end
  let errs = ir.validate_program(result.program)
  let i = 0usize
  while i < errs.len()
    let e = errs[i]
    ctx.diags.add_error(e.message, e.span, "E3000")
    i = i + 1usize
  end
  ctx.ir_program = result.program

  if ctx.diags.has_error()
    return Err(())
  end

  # TODO: brancher backend bytecode/dump
  return Ok(())
.end

fn run_sema(ctx: DriverContext) -> Result[Unit, Unit]
  let res = sema.run_typecheck(&mut ctx.modules, &mut ctx.diags)
  if res.is_err()
    return Err(())
  end
  return Ok(())
.end

fn ir_text_output_path(cfg: DriverConfig) -> String
  if cfg.out_bin != ""
    return cfg.out_bin + ".ir.txt"
  end
  let root = path.dirname(cfg.project_path)
  return path.join(root, "target/core/ir_dump.txt")
.end

fn bytecode_output_path(cfg: DriverConfig) -> String
  if cfg.out_bin != ""
    return cfg.out_bin
  end
  let root = path.dirname(cfg.project_path)
  return path.join(root, "target/core/out.vbc")
.end

fn run_backend(ctx: DriverContext) -> Result[Unit, Unit]
  if ctx.cfg.emit_ir_text
    let ir_path = ir_text_output_path(ctx.cfg)
    let ir_dir = path.dirname(ir_path)
    if ir_dir != ""
      fs.create_dir_all(ir_dir)
    end
    let dump = ir_dump.format_program(ctx.ir_program)
    fs.write_all(ir_path, dump.as_bytes())
  end

  if ctx.cfg.emit_bytecode
    let bc_path = bytecode_output_path(ctx.cfg)
    let bc_dir = path.dirname(bc_path)
    if bc_dir != ""
      fs.create_dir_all(bc_dir)
    end
    let stub = "# vitte bytecode placeholder\n"
      + "modules=" + str.from_int(ctx.ir_program.modules.len() as Int) + "\n"
    fs.write_all(bc_path, stub.as_bytes())
  end

  return Ok(())
.end

# -----------------------------------------------------------------------------
# Diagnostics & logging (affichage délégué pour l'instant)
# -----------------------------------------------------------------------------

fn report_diagnostics(ctx: DriverContext) -> Unit
  if not ctx.cfg.emit_text_diags
    return
  end

  let mut cache = reporter.ReporterCache.new()
  for d in ctx.diags.items
    let text = reporter.format_diagnostic_with_cache(d, &mut cache)
    say text
  end
.end

fn log_internal_error(ctx: DriverContext, msg: String) -> Unit
  # TODO:
  #   - enregistrer un diagnostic "bug interne" avec un code dédié (ex: "E9999")
  let span = diag.Span.dummy(ctx.cfg.project_path)
  ctx.diags.add_error(
    msg,
    span,
    "E9999",
  )
.end

fn flush_logs(ctx: DriverContext) -> Unit
  # TODO:
  #   - flush vers un fichier de log si ctx.cfg.log_path est présent
  pass
.end
