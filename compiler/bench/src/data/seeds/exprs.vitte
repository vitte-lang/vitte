# -----------------------------------------------------------------------------
# exprs.vitte
# -----------------------------------------------------------------------------
# Expression seed corpus (hand-curated) for lexer/parser/lowerer/sema smoke.
#
# Goals:
# - maximize operator/precedence surface
# - include nested calls, indexing, field access, grouping
# - include tricky literals and boundary values
# - keep syntax portable: blocks end with `.end` (no braces)
# -----------------------------------------------------------------------------

fn id(x)
  ret x
.end

fn add(a, b)
  ret a + b
.end

fn sub(a, b)
  ret a - b
.end

fn mul(a, b)
  ret a * b
.end

fn div(a, b)
  ret a / b
.end

fn mod(a, b)
  ret a % b
.end

fn neg(x)
  ret -x
.end

fn not_(x)
  ret !x
.end

fn bitnot(x)
  ret ~x
.end

fn band(a, b)
  ret a & b
.end

fn bor(a, b)
  ret a | b
.end

fn bxor(a, b)
  ret a ^ b
.end

fn shl(a, b)
  ret a << b
.end

fn shr(a, b)
  ret a >> b
.end

fn pick(a, b, c)
  # intentionally mix precedence: (a + b) * c vs a + (b * c)
  let x0 = (a + b) * c
  let x1 = a + (b * c)
  ret x0 + x1
.end

fn call_chain(a, b)
  # nested calls and grouping
  ret add(mul(a, 2), sub(b, 3))
.end

fn literal_pack()
  # integers
  let i0 = 0
  let i1 = 1
  let i2 = -1
  let i3 = 2
  let i4 = 10
  let i5 = 123456789
  let i6 = 2147483647
  let i7 = -2147483648

  # floats (no exponent to keep parser-simple)
  let f0 = 0.0
  let f1 = 1.0
  let f2 = -1.5
  let f3 = 3.14159
  let f4 = 2.71828

  # bools
  let b0 = true
  let b1 = false

  # strings
  let s0 = ""
  let s1 = "a"
  let s2 = "hello"
  let s3 = "a/b:c"

  # mixed
  ret add(i1, i4) + id(i0)
.end

fn precedence_suite(a, b, c, d)
  # unary + multiplicative + additive
  let e0 = -a * b + c
  let e1 = -(a * b) + c
  let e2 = -a * (b + c)

  # comparisons + logical
  let e3 = (a + b) < (c + d)
  let e4 = (a + b) <= (c + d)
  let e5 = (a + b) > (c + d)
  let e6 = (a + b) >= (c + d)
  let e7 = (a + b) == (c + d)
  let e8 = (a + b) != (c + d)

  let e9  = (a < b) && (c < d)
  let e10 = (a < b) || (c < d)
  let e11 = !(a < b)

  # bitwise precedence
  let e12 = (a & b) | (c ^ d)
  let e13 = a & (b | c)
  let e14 = (a << 1) + (b >> 2)

  # grouped
  let e15 = (((a + b) * c) - d) / (a + 1)

  ret id(e0)
.end

fn assoc_suite(a, b, c, d)
  # left-associative chains
  let e0 = a - b - c - d
  let e1 = a / b / c / d
  let e2 = a % b % c

  # mixed chaining
  let e3 = a + b * c + d
  let e4 = (a + b) * (c + d)

  # equality chain (depending on semantics, this may be rejected by sema; keep as parser seed)
  let e5 = (a == b) == (c == d)

  ret e0 + e1 + e2 + e3 + e4
.end

fn string_ops()
  let a = "hello"
  let b = "world"
  let c = a + " " + b
  let d = (a + b) + ("-" + "!")
  ret c
.end

fn deep_nesting(x)
  # nesting depth / parentheses stress
  let y = (((((((((id(x))))))))))
  ret y
.end

fn short_circuit(a, b, c)
  # keep operands non-trivial
  let x0 = (a != 0) && (div(b, a) > c)
  let x1 = (a == 0) || (div(b, a) > c)
  ret x0 || x1
.end

fn bitmix(a, b)
  let x0 = (a ^ (b << 3)) & (~a | b)
  let x1 = (a | b) ^ (a & b)
  let x2 = (a << 1) | (b >> 1)
  ret x0 + x1 + x2
.end

fn table_ops(arr, idx)
  # Indexing + field/method-like access seeds.
  # NOTE: arr/index semantics may be handled later; this is mainly parser surface.
  let x0 = arr[idx]
  let x1 = arr[idx + 1]
  let x2 = arr[(idx * 2) + 3]
  let x3 = id(arr[idx])
  ret x0
.end

fn dotted_ops(obj)
  # Dot access seeds.
  let a = obj.x
  let b = obj.y
  let c = obj.x + obj.y
  let d = obj.inner.value
  ret a + b + c + d
.end

fn call_dot_mix(obj, a, b)
  # Dot + call + nested call.
  let x0 = obj.f(a)
  let x1 = obj.f(add(a, b))
  let x2 = obj.inner.g(sub(a, b), mul(a, b))
  ret x0 + x1 + x2
.end

fn if_expr_like(a, b)
  # Seed typical patterns used by lowerer/sema even if language doesn't have ternary.
  let x0 = (a > b)
  if x0
    ret a
  else
    ret b
  .end
.end

fn match_like(x)
  # Keep a simple branching surface.
  if x == 0
    ret 0
  elif x == 1
    ret 1
  else
    ret x + 2
  .end
.end

fn main()
  # Drive all seeds to ensure they are reachable by compilation.
  let a = 7
  let b = 3
  let c = 5
  let d = 11

  let _lits = literal_pack()
  let _p0 = precedence_suite(a, b, c, d)
  let _p1 = assoc_suite(a, b, c, d)
  let _p2 = pick(a, b, c)
  let _p3 = call_chain(a, b)
  let _p4 = string_ops()
  let _p5 = deep_nesting(a)
  let _p6 = short_circuit(a, b, c)
  let _p7 = bitmix(a, b)

  # The following are parser-surface only; runtime may not provide these types.
  # Keep calls but do not require execution.
  # let _p8 = table_ops(arr, 0)
  # let _p9 = dotted_ops(obj)
  # let _p10 = call_dot_mix(obj, a, b)

  let _m0 = if_expr_like(a, b)
  let _m1 = match_like(a)

  ret 0
.end
