# -----------------------------------------------------------------------------
# fib.vitte
# -----------------------------------------------------------------------------
# Fibonacci seed corpus for:
# - parser smoke (functions, if/elif/else, returns)
# - lowerer/sema smoke (loops, recursion, locals)
# - basic codegen smoke (arith, comparisons, calls)
#
# Conventions:
# - blocks end with `.end`
# - keep it portable (no platform IO required)
# -----------------------------------------------------------------------------

fn fib_rec(n)
  if n <= 0
    ret 0
  elif n == 1
    ret 1
  else
    ret fib_rec(n - 1) + fib_rec(n - 2)
  .end
.end

fn fib_iter(n)
  if n <= 0
    ret 0
  .end

  let a = 0
  let b = 1
  let i = 1

  while i < n
    let t = a + b
    a = b
    b = t
    i = i + 1
  .end

  ret b
.end

fn fib_pair(n)
  # Returns (F(n), F(n+1)) using an iterative doubling-like method.
  # This stays integer-only and avoids big recursion.
  if n <= 0
    # (0, 1)
    ret 0
  .end

  let a = 0
  let b = 1
  let i = 0

  # simple iterative pair advance
  while i < n
    let t = a + b
    a = b
    b = t
    i = i + 1
  .end

  # a = F(n), b = F(n+1)
  ret a
.end

fn fib_sum(n)
  # Sum_{k=0..n} F(k)
  if n < 0
    ret 0
  .end

  let s = 0
  let i = 0
  while i <= n
    s = s + fib_iter(i)
    i = i + 1
  .end

  ret s
.end

fn fib_mod(n, m)
  # Fibonacci modulo m (fast enough for seeds)
  if m == 0
    ret 0
  .end

  if n <= 0
    ret 0
  elif n == 1
    ret 1 % m
  .end

  let a = 0
  let b = 1
  let i = 1

  while i < n
    let t = (a + b) % m
    a = b
    b = t
    i = i + 1
  .end

  ret b
.end

fn fib_table(n)
  # Build a small table [F(0)..F(n)] for allocator/array smoke in later stages.
  # If arrays are not implemented yet, this still seeds parsing of loops/lets.
  let i = 0
  let last = 0
  while i <= n
    last = fib_iter(i)
    i = i + 1
  .end
  ret last
.end

fn smoke()
  let a = fib_rec(10)
  let b = fib_iter(10)
  let c = fib_pair(10)
  let d = fib_sum(10)
  let e = fib_mod(50, 97)
  let f = fib_table(25)

  # Avoid unused warnings in strict modes
  let _x = a + b + c + d + e + f
  ret _x
.end

fn main()
  let r = smoke()

  # Minimal behavior: return 0 on success-like condition.
  if r >= 0
    ret 0
  else
    ret 1
  .end
.end
