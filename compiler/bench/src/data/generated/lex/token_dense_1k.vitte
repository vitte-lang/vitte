

# generated/lex/token_dense_1k.vitte
#
# Lexer stress: dense token soup (~1k tokens) that exercises:
# - identifiers (ascii + unicode)
# - keywords (mod/use/type/fn/prog/when/loop/match/ret/set/do/break/continue)
# - literals (int/float/string/bool)
# - operators (+ - * / % == != < <= > >= && || ! ~ & | ^ << >>)
# - punctuation ((), [], :, ., ,)
# - comments and tricky spacing
#
# NOTE: This file is generated and intended for lex/parse stress in benches.

mod generated.lex.token_dense_1k

# --- types -------------------------------------------------------------------

type Point
  x: i32
  y: i32
.end

type Pair
  a: i32
  b: i32
.end

type Flags
  ok: bool
  verbose: bool
  quiet: bool
.end

# --- helpers -----------------------------------------------------------------

fn mix_i32(x: i32) -> i32
  let v = x
  set v = v ^ (v << 13)
  set v = v ^ (v >> 17)
  set v = v ^ (v << 5)
  ret v
.end

fn sum_point(p: Point) -> i32
  ret p.x + p.y
.end

fn make_point(ax: i32, ay: i32) -> Point
  let p: Point
  set p.x = ax
  set p.y = ay
  ret p
.end

fn select(a: i32, b: i32, c: i32) -> i32
  when (a < b && b < c) || (c < b && b < a)
    ret b
  .end
  when (b < a && a < c) || (c < a && a < b)
    ret a
  .end
  ret c
.end

fn ascii_digit_value(c: str) -> i32
  match c
    "0" => do ret 0 .end
    "1" => do ret 1 .end
    "2" => do ret 2 .end
    "3" => do ret 3 .end
    "4" => do ret 4 .end
    "5" => do ret 5 .end
    "6" => do ret 6 .end
    "7" => do ret 7 .end
    "8" => do ret 8 .end
    "9" => do ret 9 .end
    _ => do ret -1 .end
  .end
.end

# --- token soup --------------------------------------------------------------

prog generated.lex.token_dense_1k
  # scalar literals
  let i0 = 0
  let i1 = 1
  let i2 = 2
  let ineg = 0 - 123
  let ibig = 2147483647
  let f0 = 0.0
  let f1 = 1.25
  let f2 = 3.14159
  let f3 = 2.0e3
  let b0 = false
  let b1 = true

  # string literals (escapes + unicode)
  let s0 = ""
  let s1 = "hello"
  let s2 = "tab=\t nl=\n cr=\r quote=\" backslash=\\"
  let s3 = "utf8: caf√© ‚Äî Êù±‰∫¨ ‚Äî üòÄ"
  let s4 = "path: C:\\Users\\vincent\\Documents\\Github\\vitte"

  # identifiers
  let snake_case_123 = 7
  let CamelCase = 11
  let _leading = 13
  let trailing_ = 17
  let __ = 19
  let Œ±Œ≤Œ≥ = 23
  let Êù±‰∫¨ = 29
  let caf√© = 31

  # struct usage + field tokens
  let p0 = make_point(1, 2)
  let p1 = make_point(3, 4)
  let ps = sum_point(p0) + sum_point(p1)

  # array tokens
  let arr: [i32]
  do arr

  # arithmetic / bitwise operators (dense)
  let a = (i1 + i2) * (ibig / 3) % 97
  let b = (a << 3) ^ (a >> 2) | (a & 255)
  let c = (b + 42) - (b * 2) + (b / 7)
  let d = mix_i32(c) ^ mix_i32(c + 1)

  # comparisons / boolean ops
  let cmp0 = (a == b) || (a != b)
  let cmp1 = (a < b) && (b <= c) && (c > d) && (d >= a)
  let cmp2 = !cmp0 && (cmp1 || b0) && (b1 || !b0)

  # ternary-like selection via `when`
  let picked = 0
  when cmp2
    set picked = select(a, b, c)
  .end
  when !cmp2
    set picked = select(c, b, a)
  .end

  # match tokens + patterns
  let ch0 = "7"
  let dv = ascii_digit_value(ch0)
  match dv
    0 => do set picked = picked + 0 .end
    7 => do set picked = picked + 7 .end
    _ => do set picked = picked + 1 .end
  .end

  # loop + break/continue tokens
  let k = 0
  let acc = 0
  loop
    when k >= 64
      break
    .end

    # inline comment to test lexer: !!! ### ???
    # operators: + - * / % == != < <= > >= && || ! ~ & | ^ << >>

    let t = mix_i32(k + picked) + (k * 17) - (k / 3)
    set acc = acc ^ t

    when (k & 7) == 0
      set k = k + 1
      continue
    .end

    set k = k + 1
  .end

  # more dense statements (keep parse valid)
  let z0 = (acc + 1) ^ (acc + 2) ^ (acc + 3)
  let z1 = (z0 | 0x0) & (z0 | 1)
  let z2 = (z1 << 1) + (z1 >> 1)

  # note: if hex literal unsupported by your lexer, treat 0x0 as identifier+tokens
  do z2
  do s0
  do s1
  do s2
  do s3
  do s4

  # final sink
  ret acc + ps + picked + snake_case_123 + CamelCase + _leading + trailing_ + __ + Œ±Œ≤Œ≥ + Êù±‰∫¨ + caf√©
.end