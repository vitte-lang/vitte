

# mini_stdlib/core.vitte
#
# Minimal “core” library used by the bench corpus.
# Goal: provide stable, deterministic helpers commonly needed by examples.
#
# Assumptions (bench corpus / language surface):
# - `str` supports `len(s)` and indexing `s[i]` returning a 1-length `str`.
# - `+` concatenates strings.
# - Arrays support `len(a)` and indexing `a[i]`.
# - `when`, `loop`, `break`, `ret`, `set`, `do` are available (phrase desugared).
#
# NOTE: This is not a full standard library.

# -----------------------------------------------------------------------------
# Basic numeric helpers
# -----------------------------------------------------------------------------

fn min_i32(a: i32, b: i32) -> i32
  when a < b
    ret a
  .end
  ret b
.end

fn max_i32(a: i32, b: i32) -> i32
  when a > b
    ret a
  .end
  ret b
.end

fn abs_i32(x: i32) -> i32
  when x < 0
    ret 0 - x
  .end
  ret x
.end

fn clamp_i32(x: i32, lo: i32, hi: i32) -> i32
  when x < lo
    ret lo
  .end
  when x > hi
    ret hi
  .end
  ret x
.end

# -----------------------------------------------------------------------------
# Character predicates (char is 1-length `str`)
# -----------------------------------------------------------------------------

fn is_digit(c: str) -> bool
  when c == "0" || c == "1" || c == "2" || c == "3" || c == "4"
    ret true
  .end
  when c == "5" || c == "6" || c == "7" || c == "8" || c == "9"
    ret true
  .end
  ret false
.end

fn is_space(c: str) -> bool
  when c == " " || c == "\t" || c == "\n" || c == "\r"
    ret true
  .end
  ret false
.end

fn is_sign(c: str) -> bool
  when c == "+" || c == "-"
    ret true
  .end
  ret false
.end

# -----------------------------------------------------------------------------
# String helpers
# -----------------------------------------------------------------------------

fn starts_with(s: str, pfx: str) -> bool
  let ns = len(s)
  let np = len(pfx)

  when np == 0
    ret true
  .end
  when np > ns
    ret false
  .end

  let i = 0
  loop
    when i >= np
      break
    .end
    when s[i] != pfx[i]
      ret false
    .end
    set i = i + 1
  .end

  ret true
.end

fn ends_with(s: str, sfx: str) -> bool
  let ns = len(s)
  let nf = len(sfx)

  when nf == 0
    ret true
  .end
  when nf > ns
    ret false
  .end

  let i = 0
  let off = ns - nf
  loop
    when i >= nf
      break
    .end
    when s[off + i] != sfx[i]
      ret false
    .end
    set i = i + 1
  .end

  ret true
.end

fn substr_range(s: str, start: i32, end_excl: i32) -> str
  # safe substring builder [start, end_excl)
  let n = len(s)
  let a = start
  let b = end_excl

  when a < 0
    set a = 0
  .end
  when b < 0
    set b = 0
  .end
  when a > n
    set a = n
  .end
  when b > n
    set b = n
  .end
  when b < a
    set b = a
  .end

  let out = ""
  let i = a
  loop
    when i >= b
      break
    .end
    set out = out + s[i]
    set i = i + 1
  .end

  ret out
.end

fn substr_from(s: str, start: i32) -> str
  ret substr_range(s, start, len(s))
.end

fn trim_left(s: str) -> str
  let n = len(s)
  let i = 0
  loop
    when i >= n
      ret ""
    .end
    when !is_space(s[i])
      break
    .end
    set i = i + 1
  .end
  ret substr_from(s, i)
.end

fn trim_right(s: str) -> str
  let n = len(s)
  when n == 0
    ret s
  .end

  let j = n - 1
  loop
    when j < 0
      ret ""
    .end
    when !is_space(s[j])
      break
    .end
    set j = j - 1
  .end

  ret substr_range(s, 0, j + 1)
.end

fn trim(s: str) -> str
  ret trim_right(trim_left(s))
.end

fn join2(a: str, b: str) -> str
  ret a + b
.end

fn join3(a: str, b: str, c: str) -> str
  ret a + b + c
.end

# -----------------------------------------------------------------------------
# Lossy integer parsing
# -----------------------------------------------------------------------------

fn to_int_lossy(s: str) -> i32
  # Parses: [space]* [+-]? [0-9]+ then stops on first non-digit.
  # On overflow, clamps to i32 range.
  let t = trim_left(s)
  let n = len(t)

  when n == 0
    ret 0
  .end

  let i = 0
  let neg = false

  when i < n && is_sign(t[i])
    when t[i] == "-"
      set neg = true
    .end
    set i = i + 1
  .end

  # constants for clamp
  let I32_MAX = 2147483647
  let I32_MIN = -2147483648

  let acc = 0
  let any = false

  loop
    when i >= n
      break
    .end

    let c = t[i]
    when !is_digit(c)
      break
    .end

    set any = true

    # digit value
    let d = 0
    when c == "0"; set d = 0 .end
    when c == "1"; set d = 1 .end
    when c == "2"; set d = 2 .end
    when c == "3"; set d = 3 .end
    when c == "4"; set d = 4 .end
    when c == "5"; set d = 5 .end
    when c == "6"; set d = 6 .end
    when c == "7"; set d = 7 .end
    when c == "8"; set d = 8 .end
    when c == "9"; set d = 9 .end

    # overflow check for positive path
    when !neg
      when acc > (I32_MAX - d) / 10
        ret I32_MAX
      .end
      set acc = acc * 10 + d
    .end

    # overflow check for negative path (acc is positive magnitude)
    when neg
      # compare against abs(I32_MIN) = 2147483648
      let LIM = 2147483648
      when acc > (LIM - d) / 10
        ret I32_MIN
      .end
      set acc = acc * 10 + d
    .end

    set i = i + 1
  .end

  when !any
    ret 0
  .end

  when neg
    # acc in [0..2147483648]
    when acc == 2147483648
      ret I32_MIN
    .end
    ret 0 - acc
  .end

  ret acc
.end

# -----------------------------------------------------------------------------
# Deterministic small hash (useful for bench sinks)
# -----------------------------------------------------------------------------

fn hash_u32(x: i32) -> i32
  # xorshift32-style mix
  let v = x
  set v = v ^ (v << 13)
  set v = v ^ (v >> 17)
  set v = v ^ (v << 5)
  ret v
.end

fn hash_str(s: str) -> i32
  # FNV-1a like (lossy; char is 1 byte here)
  let h = 2166136261
  let n = len(s)
  let i = 0
  loop
    when i >= n
      break
    .end
    set h = h ^ to_int_lossy(s[i])
    set h = h * 16777619
    set i = i + 1
  .end
  ret h
.end

# -----------------------------------------------------------------------------
# Debug/diagnostics stubs
# -----------------------------------------------------------------------------

type Diag
  # Minimal diag object for the corpus; real implementation lives in host.
  quiet: bool
.end

fn diag_make() -> Diag
  let d: Diag
  set d.quiet = false
  ret d
.end

fn diag_set_quiet(d: Diag, q: bool) -> Diag
  let x = d
  set x.quiet = q
  ret x
.end

fn diag_warn(o: any, msg: str) -> void
  # The corpus expects a warning hook. In the mini stdlib, this is a no-op
  # unless the object exposes a `quiet` field (common pattern).
  #
  # Real harness may override this function when integrating.
  do o
  do msg
.end

fn diag_error(o: any, msg: str) -> void
  do o
  do msg
.end