mod mini_app.args

# -----------------------------------------------------------------------------
# mini_app/args.vitte
# Corpus mini-app: argument parsing + small utilities.
# - exercises: loops, match, indexing, string ops, error handling
# - style: Vitte "phrase" surface with `.end` blocks
# -----------------------------------------------------------------------------

type Opts
  help: bool
  verbose: bool
  quiet: bool
  count: i32
  name: str
  cmd: str
  value: str
.end

fn opts_default() -> Opts
  let o: Opts
  set o.help = false
  set o.verbose = false
  set o.quiet = false
  set o.count = 1
  set o.name = "world"
  set o.cmd = ""
  set o.value = ""
  ret o
.end

fn is_digit(c: i32) -> bool
  ret c >= 48 && c <= 57
.end

fn to_int_lossy(s: str) -> i32
  # parses optional leading '-' and digits; stops at first non-digit
  let i = 0
  let n = len(s)
  let sign = 1
  let acc = 0

  when n == 0
    ret 0
  .end

  when s[0] == "-"
    set sign = -1
    set i = 1
  .end

  loop
    when i >= n
      break
    .end

    let ch = s[i]
    # assume indexing returns 1-char string; convert via ord()
    let oc = ord(ch)
    when !is_digit(oc)
      break
    .end

    set acc = acc * 10 + (oc - 48)
    set i = i + 1
  .end

  ret acc * sign
.end

fn streq(a: str, b: str) -> bool
  ret a == b
.end

fn starts_with(s: str, pfx: str) -> bool
  let ns = len(s)
  let np = len(pfx)
  when np > ns
    ret false
  .end

  let i = 0
  loop
    when i >= np
      break
    .end
    when s[i] != pfx[i]
      ret false
    .end
    set i = i + 1
  .end

  ret true
.end

fn substr_range(s: str, start: i32, end_excl: i32) -> str
  # safe substring builder [start, end_excl)
  let n = len(s)
  let a = start
  let b = end_excl

  when a < 0
    set a = 0
  .end
  when b < 0
    set b = 0
  .end
  when a > n
    set a = n
  .end
  when b > n
    set b = n
  .end
  when b < a
    set b = a
  .end

  let out = ""
  let i = a
  loop
    when i >= b
      break
    .end
    set out = out + s[i]
    set i = i + 1
  .end

  ret out
.end

fn substr_from(s: str, start: i32) -> str
  ret substr_range(s, start, len(s))
.end

fn clamp_i32(x: i32, lo: i32, hi: i32) -> i32
  when x < lo
    ret lo
  .end
  when x > hi
    ret hi
  .end
  ret x
.end

fn print_usage(prog: str)
  say "Vitte mini_app: args"
  say ""
  say "Usage:"
  say "  " + prog + " [options] <command> [value]"
  say ""
  say "Commands:"
  say "  echo <value>         print value (respecting -q/-v)"
  say "  repeat <value>       print value N times (see --count)"
  say "  greet                greet --name (default: world)"
  say "  sum <value>          sum digits in <value> (lossy)"
  say ""
  say "Options:"
  say "  -h, --help           show help"
  say "  -v, --verbose        verbose output"
  say "  -q, --quiet          quiet mode (only command output)"
  say "  -n, --name <str>     name for greet"
  say "  -c, --count <int>    repeat count (default 1)"
  say ""
.end

fn diag_info(o: Opts, msg: str)
  when o.quiet
    ret
  .end
  when o.verbose
    say "[info] " + msg
  .end
.end

fn diag_warn(o: Opts, msg: str)
  when o.quiet
    ret
  .end
  say "[warn] " + msg
.end

fn diag_error(msg: str)
  say "[error] " + msg
.end

fn parse_short_bundle(o: Opts, bundle: str) -> Opts
  # bundle like "-vqn" => apply flags char by char
  # note: does not consume value flags
  let i = 1
  let n = len(bundle)

  loop
    when i >= n
      break
    .end

    let ch = bundle[i]
    match ch
      "h" => do
        set o.help = true
      .end
      "v" => do
        set o.verbose = true
      .end
      "q" => do
        set o.quiet = true
      .end
      _ => do
        # unknown short
        .end
    .end

    set i = i + 1
  .end

  ret o
.end

fn parse_args(argv: [str]) -> Opts
  let o = opts_default()
  let i = 1
  let n = len(argv)

  loop
    when i >= n
      break
    .end

    let a = argv[i]

    # stop on first non-option
    when !starts_with(a, "-") || streq(a, "-")
      break
    .end

    # end-of-options marker
    when streq(a, "--")
      set i = i + 1
      break
    .end

    # inline long options: --name=vincent, --count=3
    let handled = false

    when starts_with(a, "--name=")
      set o.name = substr_from(a, 7)
      set handled = true
    .end

    when starts_with(a, "--count=")
      set o.count = to_int_lossy(substr_from(a, 8))
      set handled = true
    .end

    # fused short value flags: -nvincent, -c10
    when !handled && starts_with(a, "-n") && !starts_with(a, "--") && len(a) > 2
      set o.name = substr_from(a, 2)
      set handled = true
    .end

    when !handled && starts_with(a, "-c") && !starts_with(a, "--") && len(a) > 2
      set o.count = to_int_lossy(substr_from(a, 2))
      set handled = true
    .end

    when !handled
      match a
        "-h" => do
          set o.help = true
        .end
        "--help" => do
          set o.help = true
        .end
        "-v" => do
          set o.verbose = true
        .end
        "--verbose" => do
          set o.verbose = true
        .end
        "-q" => do
          set o.quiet = true
        .end
        "--quiet" => do
          set o.quiet = true
        .end
        "-n" => do
          when i + 1 >= n
            diag_warn(o, "missing value for -n")
            set o.help = true
            ret o
          .end
          set o.name = argv[i + 1]
          set i = i + 1
        .end
        "--name" => do
          when i + 1 >= n
            diag_warn(o, "missing value for --name")
            set o.help = true
            ret o
          .end
          set o.name = argv[i + 1]
          set i = i + 1
        .end
        "-c" => do
          when i + 1 >= n
            diag_warn(o, "missing value for -c")
            set o.help = true
            ret o
          .end
          set o.count = to_int_lossy(argv[i + 1])
          set i = i + 1
        .end
        "--count" => do
          when i + 1 >= n
            diag_warn(o, "missing value for --count")
            set o.help = true
            ret o
          .end
          set o.count = to_int_lossy(argv[i + 1])
          set i = i + 1
        .end
        _ => do
          # combined shorts: -vqn
          when starts_with(a, "-") && !starts_with(a, "--") && len(a) > 2
            set o = parse_short_bundle(o, a)
          .end

          # unknown option diagnostics
          when starts_with(a, "--")
            diag_warn(o, "unknown option: " + a)
          .end
          when starts_with(a, "-") && !starts_with(a, "--") && len(a) == 2
            diag_warn(o, "unknown option: " + a)
          .end
        .end
      .end
    .end

    set i = i + 1
  .end

  # remaining positional args
  when i < n
    set o.cmd = argv[i]
    set i = i + 1
  .end

  when i < n
    set o.value = argv[i]
  .end

  # normalize count into a safe range for repeat
  set o.count = clamp_i32(o.count, 0, 1000000)

  ret o
.end

fn cmd_echo(o: Opts) -> i32
  diag_info(o, "cmd=echo")
  say o.value
  ret 0
.end

fn cmd_repeat(o: Opts) -> i32
  diag_info(o, "cmd=repeat")

  let k = 0
  let c = clamp_i32(o.count, 0, 1000000)

  loop
    when k >= c
      break
    .end
    say o.value
    set k = k + 1
  .end

  ret 0
.end

fn cmd_greet(o: Opts) -> i32
  diag_info(o, "cmd=greet")
  say "hello " + o.name
  ret 0
.end

fn sum_digits_lossy(s: str) -> i32
  let i = 0
  let n = len(s)
  let acc = 0

  loop
    when i >= n
      break
    .end

    let oc = ord(s[i])
    when is_digit(oc)
      set acc = acc + (oc - 48)
    .end

    set i = i + 1
  .end

  ret acc
.end

fn cmd_sum(o: Opts) -> i32
  diag_info(o, "cmd=sum")
  let r = sum_digits_lossy(o.value)
  say "sum=" + itos(r)
  ret 0
.end

fn dispatch(o: Opts, prog: str) -> i32
  when o.help
    print_usage(prog)
    ret 0
  .end

  when o.cmd == ""
    diag_warn(o, "missing command")
    print_usage(prog)
    ret 2
  .end

  match o.cmd
    "echo" => do
      ret cmd_echo(o)
    .end
    "repeat" => do
      ret cmd_repeat(o)
    .end
    "greet" => do
      ret cmd_greet(o)
    .end
    "sum" => do
      ret cmd_sum(o)
    .end
    _ => do
      diag_error("unknown command: " + o.cmd)
      print_usage(prog)
      ret 2
    .end
  .end
.end
