mod fuzz.long_identifiers

# -----------------------------------------------------------------------------
# fuzz/long_identifiers.vitte
# Purpose: stress lexer/parser/name-resolution/diagnostics with very long idents.
# - long module/type/field/function/variable names
# - deep member access chains
# - match/when/loop blocks with `.end` only
# - deterministic, silent (no IO)
# -----------------------------------------------------------------------------

# Long type names + long field identifiers

type ExtremelyLongIdentifierRecordForCompilerFuzzingWithManyFieldsAndPredictableValues
  field__this_is_a_very_long_identifier_name_used_to_stress_the_lexer_and_parser__a0: i32
  field__this_is_a_very_long_identifier_name_used_to_stress_the_lexer_and_parser__a1: i32
  field__this_is_a_very_long_identifier_name_used_to_stress_the_lexer_and_parser__a2: i32
  field__this_is_a_very_long_identifier_name_used_to_stress_the_lexer_and_parser__a3: i32
  field__this_is_a_very_long_identifier_name_used_to_stress_the_lexer_and_parser__a4: i32
  field__this_is_a_very_long_identifier_name_used_to_stress_the_lexer_and_parser__a5: i32
  field__this_is_a_very_long_identifier_name_used_to_stress_the_lexer_and_parser__a6: i32
  field__this_is_a_very_long_identifier_name_used_to_stress_the_lexer_and_parser__a7: i32
  field__this_is_a_very_long_identifier_name_used_to_stress_the_lexer_and_parser__a8: i32
  field__this_is_a_very_long_identifier_name_used_to_stress_the_lexer_and_parser__a9: i32
.end

type DeeplyNestedContainerWithLongTypeNameForAccessChains
  nested__level0__record__with_long_name: ExtremelyLongIdentifierRecordForCompilerFuzzingWithManyFieldsAndPredictableValues
  nested__level0__tag_value__with_long_name_for_switching: i32
.end

fn make_ExtremelyLongIdentifierRecordForCompilerFuzzingWithManyFieldsAndPredictableValues(seed_value_for_initialization__long: i32) -> ExtremelyLongIdentifierRecordForCompilerFuzzingWithManyFieldsAndPredictableValues
  let r: ExtremelyLongIdentifierRecordForCompilerFuzzingWithManyFieldsAndPredictableValues
  set r.field__this_is_a_very_long_identifier_name_used_to_stress_the_lexer_and_parser__a0 = seed_value_for_initialization__long + 0
  set r.field__this_is_a_very_long_identifier_name_used_to_stress_the_lexer_and_parser__a1 = seed_value_for_initialization__long + 1
  set r.field__this_is_a_very_long_identifier_name_used_to_stress_the_lexer_and_parser__a2 = seed_value_for_initialization__long + 2
  set r.field__this_is_a_very_long_identifier_name_used_to_stress_the_lexer_and_parser__a3 = seed_value_for_initialization__long + 3
  set r.field__this_is_a_very_long_identifier_name_used_to_stress_the_lexer_and_parser__a4 = seed_value_for_initialization__long + 4
  set r.field__this_is_a_very_long_identifier_name_used_to_stress_the_lexer_and_parser__a5 = seed_value_for_initialization__long + 5
  set r.field__this_is_a_very_long_identifier_name_used_to_stress_the_lexer_and_parser__a6 = seed_value_for_initialization__long + 6
  set r.field__this_is_a_very_long_identifier_name_used_to_stress_the_lexer_and_parser__a7 = seed_value_for_initialization__long + 7
  set r.field__this_is_a_very_long_identifier_name_used_to_stress_the_lexer_and_parser__a8 = seed_value_for_initialization__long + 8
  set r.field__this_is_a_very_long_identifier_name_used_to_stress_the_lexer_and_parser__a9 = seed_value_for_initialization__long + 9
  ret r
.end

fn make_DeeplyNestedContainerWithLongTypeNameForAccessChains(seed_value_for_initialization__long: i32) -> DeeplyNestedContainerWithLongTypeNameForAccessChains
  let c: DeeplyNestedContainerWithLongTypeNameForAccessChains
  set c.nested__level0__record__with_long_name = make_ExtremelyLongIdentifierRecordForCompilerFuzzingWithManyFieldsAndPredictableValues(seed_value_for_initialization__long)
  set c.nested__level0__tag_value__with_long_name_for_switching = (seed_value_for_initialization__long % 6)
  ret c
.end

fn checksum_from_ExtremelyLongIdentifierRecordForCompilerFuzzingWithManyFieldsAndPredictableValues(input__extremely_long_record_variable_name: ExtremelyLongIdentifierRecordForCompilerFuzzingWithManyFieldsAndPredictableValues) -> i32
  # XOR fold over fields to prevent DCE
  let acc__checksum_accumulator_with_long_name = 0
  set acc__checksum_accumulator_with_long_name = acc__checksum_accumulator_with_long_name ^ input__extremely_long_record_variable_name.field__this_is_a_very_long_identifier_name_used_to_stress_the_lexer_and_parser__a0
  set acc__checksum_accumulator_with_long_name = acc__checksum_accumulator_with_long_name ^ input__extremely_long_record_variable_name.field__this_is_a_very_long_identifier_name_used_to_stress_the_lexer_and_parser__a1
  set acc__checksum_accumulator_with_long_name = acc__checksum_accumulator_with_long_name ^ input__extremely_long_record_variable_name.field__this_is_a_very_long_identifier_name_used_to_stress_the_lexer_and_parser__a2
  set acc__checksum_accumulator_with_long_name = acc__checksum_accumulator_with_long_name ^ input__extremely_long_record_variable_name.field__this_is_a_very_long_identifier_name_used_to_stress_the_lexer_and_parser__a3
  set acc__checksum_accumulator_with_long_name = acc__checksum_accumulator_with_long_name ^ input__extremely_long_record_variable_name.field__this_is_a_very_long_identifier_name_used_to_stress_the_lexer_and_parser__a4
  set acc__checksum_accumulator_with_long_name = acc__checksum_accumulator_with_long_name ^ input__extremely_long_record_variable_name.field__this_is_a_very_long_identifier_name_used_to_stress_the_lexer_and_parser__a5
  set acc__checksum_accumulator_with_long_name = acc__checksum_accumulator_with_long_name ^ input__extremely_long_record_variable_name.field__this_is_a_very_long_identifier_name_used_to_stress_the_lexer_and_parser__a6
  set acc__checksum_accumulator_with_long_name = acc__checksum_accumulator_with_long_name ^ input__extremely_long_record_variable_name.field__this_is_a_very_long_identifier_name_used_to_stress_the_lexer_and_parser__a7
  set acc__checksum_accumulator_with_long_name = acc__checksum_accumulator_with_long_name ^ input__extremely_long_record_variable_name.field__this_is_a_very_long_identifier_name_used_to_stress_the_lexer_and_parser__a8
  set acc__checksum_accumulator_with_long_name = acc__checksum_accumulator_with_long_name ^ input__extremely_long_record_variable_name.field__this_is_a_very_long_identifier_name_used_to_stress_the_lexer_and_parser__a9
  ret acc__checksum_accumulator_with_long_name
.end

fn long_identifier_state_machine__with_excessively_descriptive_name(container__deeply_nested_container_with_long_type_name: DeeplyNestedContainerWithLongTypeNameForAccessChains, iterations__very_long_name: i32) -> i32
  let extremely_long_local_accumulator_name_used_for_state_machine = 0
  let i__loop_counter_with_long_name = 0

  loop
    when i__loop_counter_with_long_name >= iterations__very_long_name
      break
    .end

    # long member chain reads
    let v0__this_is_a_very_long_local_variable_name = container__deeply_nested_container_with_long_type_name.nested__level0__record__with_long_name.field__this_is_a_very_long_identifier_name_used_to_stress_the_lexer_and_parser__a0
    let v7__this_is_a_very_long_local_variable_name = container__deeply_nested_container_with_long_type_name.nested__level0__record__with_long_name.field__this_is_a_very_long_identifier_name_used_to_stress_the_lexer_and_parser__a7

    # tag-based branch via match
    match container__deeply_nested_container_with_long_type_name.nested__level0__tag_value__with_long_name_for_switching
      0 => do
        set extremely_long_local_accumulator_name_used_for_state_machine = extremely_long_local_accumulator_name_used_for_state_machine + (v0__this_is_a_very_long_local_variable_name ^ v7__this_is_a_very_long_local_variable_name)
      .end
      1 => do
        set extremely_long_local_accumulator_name_used_for_state_machine = extremely_long_local_accumulator_name_used_for_state_machine + checksum_from_ExtremelyLongIdentifierRecordForCompilerFuzzingWithManyFieldsAndPredictableValues(container__deeply_nested_container_with_long_type_name.nested__level0__record__with_long_name)
      .end
      2 => do
        when (i__loop_counter_with_long_name % 2) == 0
          set extremely_long_local_accumulator_name_used_for_state_machine = extremely_long_local_accumulator_name_used_for_state_machine + 3
          set i__loop_counter_with_long_name = i__loop_counter_with_long_name + 1
          continue
        .end
        set extremely_long_local_accumulator_name_used_for_state_machine = extremely_long_local_accumulator_name_used_for_state_machine + 5
      .end
      3 => do
        when (i__loop_counter_with_long_name % 5) == 0
          break
        .end
        set extremely_long_local_accumulator_name_used_for_state_machine = extremely_long_local_accumulator_name_used_for_state_machine + 7
      .end
      4 => do
        set extremely_long_local_accumulator_name_used_for_state_machine = extremely_long_local_accumulator_name_used_for_state_machine ^ (v0__this_is_a_very_long_local_variable_name + v7__this_is_a_very_long_local_variable_name)
      .end
      _ => do
        set extremely_long_local_accumulator_name_used_for_state_machine = extremely_long_local_accumulator_name_used_for_state_machine + 11
      .end
    .end

    set i__loop_counter_with_long_name = i__loop_counter_with_long_name + 1
  .end

  ret extremely_long_local_accumulator_name_used_for_state_machine
.end

fn longest_reasonably_practical_identifier_for_smoke_testing_of_the_lexer_and_parser_pipeline__do_not_use_in_real_code_because_it_is_terrible(baseline_seed_value_with_long_name: i32) -> i32
  let container__deeply_nested_container_with_long_type_name = make_DeeplyNestedContainerWithLongTypeNameForAccessChains(baseline_seed_value_with_long_name)
  let result__deep_pipeline_result_with_long_name = long_identifier_state_machine__with_excessively_descriptive_name(container__deeply_nested_container_with_long_type_name, 37)

  # a final nested `when` chain with long names
  when result__deep_pipeline_result_with_long_name >= 0
    when (result__deep_pipeline_result_with_long_name % 3) == 0
      ret result__deep_pipeline_result_with_long_name + 1
    .end
    when (result__deep_pipeline_result_with_long_name % 3) != 0
      ret result__deep_pipeline_result_with_long_name + 2
    .end
  .end

  ret result__deep_pipeline_result_with_long_name
.end

prog long_identifiers
  # Keep output silent for fuzzing.
  let rc__very_long_return_code_variable_name = longest_reasonably_practical_identifier_for_smoke_testing_of_the_lexer_and_parser_pipeline__do_not_use_in_real_code_because_it_is_terrible(12345)

  # normalize to a small exit range
  when rc__very_long_return_code_variable_name < 0
    ret 1
  .end

  ret (rc__very_long_return_code_variable_name % 4)
.end
