

# vitte_arena/src/lib.vit
#
# Arena allocator utilities (segment-based bump allocator).
#
# Design
# - Zero dynamic allocation inside the arena implementation.
# - The caller provides one or more contiguous memory segments.
# - Allocation is a bump pointer per segment, with alignment.
# - Supports checkpoint/rollback (marks) and reset.
#
# Use cases
# - Compiler pipelines: AST/IR nodes, temporary buffers, scratch allocations.
# - Deterministic, fast allocation; bulk free via reset/rollback.
#
# Constraints
# - No `{}` blocks; `.end` only.

mod vitte_arena

# -----------------------------------------------------------------------------
# Low-level helpers
# -----------------------------------------------------------------------------

fn arena_is_pow2(x: usize) -> bool
    if x == 0
        ret false
    .end
    ret (x & (x - 1)) == 0
.end

fn arena_align_up(value: usize, align: usize) -> usize
    # Generic align-up that works even if align is not pow2.
    if align == 0
        ret value
    .end

    let rem = value % align
    if rem == 0
        ret value
    .end

    ret value + (align - rem)
.end

fn arena_checked_add(a: usize, b: usize, out: *usize) -> bool
    let c = a + b
    if c < a
        ret false
    .end
    out[0] = c
    ret true
.end

fn arena_ptr_to_usize(p: *u8) -> usize
    # Expected to be supported by the core runtime. If not, adapt here.
    ret p.as_usize()
.end

fn arena_usize_to_ptr(x: usize) -> *u8
    # Expected to be supported by the core runtime. If not, adapt here.
    ret x.as_ptr_u8()
.end

# -----------------------------------------------------------------------------
# Core types
# -----------------------------------------------------------------------------

type ArenaError enum
    ok
    invalid_args
    invalid_segment
    out_of_segments
    out_of_memory
    overflow
    bad_mark
.end

type ArenaResult struct
    ok: bool
    err: ArenaError
.end

fn arena_ok() -> ArenaResult
    let r: ArenaResult
    r.ok = true
    r.err = ArenaError.ok
    ret r
.end

fn arena_err(e: ArenaError) -> ArenaResult
    let r: ArenaResult
    r.ok = false
    r.err = e
    ret r
.end

# A memory segment provided by the caller.
# - base: start pointer
# - cap: total bytes in segment
# - used: bytes consumed in segment

type ArenaSegment struct
    base: *u8
    cap: usize
    used: usize
.end

# Arena state across segments.

type Arena struct
    segs: *ArenaSegment
    seg_count: usize

    # current segment index
    seg_index: usize

    # default alignment when caller uses `arena_alloc`
    default_align: usize

    # If true, allocation APIs may be used in contexts where OOM must be treated
    # as a hard error by the caller. This module remains pure (no panic/I/O).
    strict: bool
.end

# Checkpoint mark for rollback.
# Captures the current segment index + used offset of that segment.

type ArenaMark struct
    seg_index: usize
    used: usize
.end

# Statistics snapshot.

type ArenaStats struct
    seg_count: usize
    seg_index: usize
    used_total: usize
    cap_total: usize
.end

# -----------------------------------------------------------------------------
# Segment utilities
# -----------------------------------------------------------------------------

fn arena_segment_init(seg: *ArenaSegment, base: *u8, cap: usize) -> ArenaResult
    if base == 0
        ret arena_err(ArenaError.invalid_segment)
    .end

    if cap == 0
        ret arena_err(ArenaError.invalid_segment)
    .end

    seg.base = base
    seg.cap = cap
    seg.used = 0
    ret arena_ok()
.end

fn arena_segment_remaining(seg: ArenaSegment) -> usize
    if seg.used >= seg.cap
        ret 0
    .end
    ret seg.cap - seg.used
.end

fn arena_segment_cursor(seg: ArenaSegment) -> *u8
    ret arena_usize_to_ptr(arena_ptr_to_usize(seg.base) + seg.used)
.end

# -----------------------------------------------------------------------------
# Arena init/reset
# -----------------------------------------------------------------------------

fn arena_init(ar: *Arena, segs: *ArenaSegment, seg_count: usize, default_align: usize, strict: bool) -> ArenaResult
    if ar == 0
        ret arena_err(ArenaError.invalid_args)
    .end

    if segs == 0
        ret arena_err(ArenaError.invalid_args)
    .end

    if seg_count == 0
        ret arena_err(ArenaError.invalid_args)
    .end

    if default_align == 0
        default_align = 1
    .end

    ar.segs = segs
    ar.seg_count = seg_count
    ar.seg_index = 0
    ar.default_align = default_align
    ar.strict = strict

    # Ensure segments are valid.
    let i: usize = 0
    while i < seg_count
        let s = segs[i]
        if s.base == 0 || s.cap == 0
            ret arena_err(ArenaError.invalid_segment)
        .end
        if s.used > s.cap
            ret arena_err(ArenaError.invalid_segment)
        .end
        i = i + 1
    .end

    ret arena_ok()
.end

fn arena_reset(ar: *Arena) -> ArenaResult
    if ar == 0
        ret arena_err(ArenaError.invalid_args)
    .end

    if ar.segs == 0 || ar.seg_count == 0
        ret arena_err(ArenaError.invalid_args)
    .end

    let i: usize = 0
    while i < ar.seg_count
        ar.segs[i].used = 0
        i = i + 1
    .end

    ar.seg_index = 0
    ret arena_ok()
.end

fn arena_current_index(ar: Arena) -> usize
    ret ar.seg_index
.end

fn arena_current_seg(ar: *Arena) -> *ArenaSegment
    if ar == 0
        ret 0
    .end

    if ar.segs == 0 || ar.seg_count == 0
        ret 0
    .end

    if ar.seg_index >= ar.seg_count
        ret 0
    .end

    ret &ar.segs[ar.seg_index]
.end

# -----------------------------------------------------------------------------
# Marks (checkpoint/rollback)
# -----------------------------------------------------------------------------

fn arena_mark(ar: Arena) -> ArenaMark
    let m: ArenaMark
    m.seg_index = ar.seg_index

    if ar.segs != 0 && ar.seg_index < ar.seg_count
        m.used = ar.segs[ar.seg_index].used
    else
        m.used = 0
    .end

    ret m
.end

fn arena_rollback(ar: *Arena, m: ArenaMark) -> ArenaResult
    if ar == 0
        ret arena_err(ArenaError.invalid_args)
    .end

    if ar.segs == 0 || ar.seg_count == 0
        ret arena_err(ArenaError.invalid_args)
    .end

    if m.seg_index >= ar.seg_count
        ret arena_err(ArenaError.bad_mark)
    .end

    # Reset segments after mark.
    let i: usize = m.seg_index + 1
    while i < ar.seg_count
        ar.segs[i].used = 0
        i = i + 1
    .end

    # Restore marked segment.
    let seg = &ar.segs[m.seg_index]
    if m.used > seg.cap
        ret arena_err(ArenaError.bad_mark)
    .end

    seg.used = m.used
    ar.seg_index = m.seg_index

    ret arena_ok()
.end

# -----------------------------------------------------------------------------
# Allocation
# -----------------------------------------------------------------------------

fn arena_try_alloc_in_seg(seg: *ArenaSegment, size: usize, align: usize, out_ptr: *(*u8)) -> ArenaError
    if seg == 0
        ret ArenaError.invalid_segment
    .end

    if align == 0
        align = 1
    .end

    # Compute aligned cursor.
    let base_u = arena_ptr_to_usize(seg.base)
    let cur_u = base_u + seg.used
    let aligned_u = arena_align_up(cur_u, align)

    # New used = (aligned - base) + size
    let rel_u = aligned_u - base_u

    let new_used: usize = 0
    if !arena_checked_add(rel_u, size, &new_used)
        ret ArenaError.overflow
    .end

    if new_used > seg.cap
        ret ArenaError.out_of_memory
    .end

    seg.used = new_used
    out_ptr[0] = arena_usize_to_ptr(aligned_u)
    ret ArenaError.ok
.end

fn arena_try_alloc(ar: *Arena, size: usize, align: usize, out_ptr: *(*u8)) -> ArenaResult
    if ar == 0 || out_ptr == 0
        ret arena_err(ArenaError.invalid_args)
    .end

    if ar.segs == 0 || ar.seg_count == 0
        ret arena_err(ArenaError.invalid_args)
    .end

    if size == 0
        out_ptr[0] = 0
        ret arena_ok()
    .end

    if align == 0
        align = ar.default_align
        if align == 0
            align = 1
        .end
    .end

    let idx: usize = ar.seg_index
    while idx < ar.seg_count
        let seg = &ar.segs[idx]

        let p: *u8 = 0
        let e = arena_try_alloc_in_seg(seg, size, align, &p)
        if e == ArenaError.ok
            ar.seg_index = idx
            out_ptr[0] = p
            ret arena_ok()
        .end

        # Otherwise, try next segment.
        idx = idx + 1
    .end

    out_ptr[0] = 0
    ret arena_err(ArenaError.out_of_segments)
.end

fn arena_alloc(ar: *Arena, size: usize) -> *u8
    let p: *u8 = 0
    let _ = arena_try_alloc(ar, size, 0, &p)
    ret p
.end

fn arena_alloc_aligned(ar: *Arena, size: usize, align: usize) -> *u8
    let p: *u8 = 0
    let _ = arena_try_alloc(ar, size, align, &p)
    ret p
.end

fn arena_alloc_zeroed(ar: *Arena, size: usize, align: usize) -> *u8
    let p = arena_alloc_aligned(ar, size, align)
    if p == 0
        ret 0
    .end

    # Zero memory without relying on std.
    let i: usize = 0
    while i < size
        p[i] = 0
        i = i + 1
    .end

    ret p
.end

# -----------------------------------------------------------------------------
# Introspection
# -----------------------------------------------------------------------------

fn arena_used_total(ar: Arena) -> usize
    if ar.segs == 0
        ret 0
    .end

    let total: usize = 0
    let i: usize = 0
    while i < ar.seg_count
        total = total + ar.segs[i].used
        i = i + 1
    .end

    ret total
.end

fn arena_cap_total(ar: Arena) -> usize
    if ar.segs == 0
        ret 0
    .end

    let total: usize = 0
    let i: usize = 0
    while i < ar.seg_count
        total = total + ar.segs[i].cap
        i = i + 1
    .end

    ret total
.end

fn arena_remaining_total(ar: Arena) -> usize
    let cap = arena_cap_total(ar)
    let used = arena_used_total(ar)
    if used >= cap
        ret 0
    .end
    ret cap - used
.end

fn arena_stats(ar: Arena) -> ArenaStats
    let s: ArenaStats
    s.seg_count = ar.seg_count
    s.seg_index = ar.seg_index
    s.used_total = arena_used_total(ar)
    s.cap_total = arena_cap_total(ar)
    ret s
.end

# -----------------------------------------------------------------------------
# Convenience: single-segment arena builder
# -----------------------------------------------------------------------------

# This helper makes it easy to embed an arena in structs.

type ArenaOne struct
    seg: ArenaSegment
    arena: Arena
.end

fn arena_one_init(a: *ArenaOne, base: *u8, cap: usize, default_align: usize, strict: bool) -> ArenaResult
    if a == 0
        ret arena_err(ArenaError.invalid_args)
    .end

    let r0 = arena_segment_init(&a.seg, base, cap)
    if !r0.ok
        ret r0
    .end

    ret arena_init(&a.arena, &a.seg, 1, default_align, strict)
.end

fn arena_one_reset(a: *ArenaOne) -> ArenaResult
    if a == 0
        ret arena_err(ArenaError.invalid_args)
    .end
    ret arena_reset(&a.arena)
.end

# -----------------------------------------------------------------------------
# Pure smoke tests (no external memory required)
# -----------------------------------------------------------------------------

fn arena_smoke_align() -> bool
    if arena_align_up(0, 8) != 0
        ret false
    .end
    if arena_align_up(1, 8) != 8
        ret false
    .end
    if arena_align_up(8, 8) != 8
        ret false
    .end
    if arena_align_up(9, 8) != 16
        ret false
    .end

    # non-pow2 align
    if arena_align_up(10, 6) != 12
        ret false
    .end

    if !arena_is_pow2(1)
        ret false
    .end
    if !arena_is_pow2(8)
        ret false
    .end
    if arena_is_pow2(0)
        ret false
    .end
    if arena_is_pow2(6)
        ret false
    .end

    ret true
.end

fn arena_smoke_all() -> bool
    ret arena_smoke_align()
.end
