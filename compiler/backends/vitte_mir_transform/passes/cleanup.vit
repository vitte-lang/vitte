# ============================================================
# vitte_mir_transform::passes::cleanup
# Nettoyage final du MIR
# ============================================================

space vitte/compiler/backends/vitte_mir_transform/passes


pull vitte/compiler/backends/vitte_mir_build/mir/mod as mir
pull vitte/compiler/backends/vitte_mir_build/analysis/cfg as cfg

pull std/collections/set as Set
pull std/collections/list as List


# ------------------------------------------------------------
# Helpers : copies triviales
# ------------------------------------------------------------

# dst = dst  -> inutile
proc is_trivial_copy
    instr: &mir::Instr
-> bool

    select instr
        when mir::Instr::Copy(dst, src)
            give dst == src
        otherwise
            give false
    .end
.end


# ------------------------------------------------------------
# Nettoyage intra-bloc
# ------------------------------------------------------------

proc cleanup_block
    block: &mut mir::Block
-> bool

    let mut changed = false
    let mut new_instrs = List::new()

    for inst in block.instructions.iter()

        # supprimer copies triviales
        if is_trivial_copy(&inst)
            changed = true
        .end
        otherwise
            new_instrs.push(inst)
        .end
    .end

    block.instructions = new_instrs

    # normaliser terminator unreachable vide
    if block.instructions.is_empty() and
       block.terminator.is_some()

        let t = block.terminator.unwrap()

        select t
            when mir::Terminator::Unreachable
                # OK
            otherwise
                # rien
        .end
    .end

    give changed
.end


# ------------------------------------------------------------
# Suppression de blocs vides redondants
# ------------------------------------------------------------

proc remove_empty_blocks
    func: &mut mir::Function
-> bool

    let cfg = cfg::build_cfg(func)
    let mut changed = false

    let mut keep = Set::new()

    # conserver bloc d’entrée
    keep.insert(func.entry)

    # conserver blocs ayant au moins une instruction
    for b in func.blocks.iter()
        if not b.instructions.is_empty()
            keep.insert(b.id)
        .end
    .end

    let mut new_blocks = List::new()

    for b in func.blocks.iter()
        if keep.contains(b.id)
            new_blocks.push(b)
        .end
        otherwise
            changed = true
        .end
    .end

    func.blocks = new_blocks
    give changed
.end


# ------------------------------------------------------------
# Passe cleanup complète
# ------------------------------------------------------------

proc run_cleanup
    func: &mut mir::Function
-> void

    let mut changed = true

    while changed
        changed = false

        for b in func.blocks.iter_mut()
            if cleanup_block(b)
                changed = true
            .end
        .end

        if remove_empty_blocks(func)
            changed = true
        .end
    .end
.end
