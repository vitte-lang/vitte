# ============================================================
# vitte_mir_transform::passes::inlining
# Inlining de fonctions MIR
# ============================================================

space vitte/compiler/backends/vitte_mir_transform/passes


pull vitte/compiler/backends/vitte_mir_build/mir/mod as mir
pull vitte/compiler/backends/vitte_mir_build/analysis/cfg as cfg

pull std/collections/map as Map
pull std/collections/list as List
pull std/collections/set as Set


# ------------------------------------------------------------
# Options d’inlining
# ------------------------------------------------------------

form InlineOptions
    max_instructions: u32     # taille max de la fonction appelée
    forbid_recursive: bool
.end


proc InlineOptions::default
-> InlineOptions

    give InlineOptions {
        max_instructions = 32
        forbid_recursive = true
    }
.end


# ------------------------------------------------------------
# Heuristique simple : fonction inlinable ?
# ------------------------------------------------------------

proc is_inline_candidate
    callee: &mir::Function
    caller: &mir::Function
    opts: &InlineOptions
-> bool

    if opts.forbid_recursive and
       callee.id == caller.id
        give false
    .end

    let mut count = 0
    for b in callee.blocks.iter()
        count = count + b.instructions.len
    .end

    give count <= opts.max_instructions
.end


# ------------------------------------------------------------
# Clonage du corps de fonction
# ------------------------------------------------------------

proc clone_function_body
    callee: &mir::Function
    value_map: &mut Map[mir::ValueId, mir::ValueId]
    block_offset: mir::BlockId
    next_value: &mut mir::ValueId
-> List[mir::Block]

    let mut blocks = List::new()

    for b in callee.blocks.iter()

        let new_id = b.id + block_offset
        let mut nb = mir::Block::new(new_id)

        # instructions
        for inst in b.instructions.iter()

            let cloned =
                inst.clone_with(
                    value_map,
                    next_value
                )

            nb.instructions.push(cloned)
        .end

        # terminator
        if b.terminator.is_some()
            nb.terminator =
                Some(
                    b.terminator
                        .unwrap()
                        .clone_with_offset(
                            block_offset,
                            value_map
                        )
                )
        .end

        blocks.push(nb)
    .end

    give blocks
.end


# ------------------------------------------------------------
# Inlining dans un bloc
# ------------------------------------------------------------

proc inline_block
    caller: &mut mir::Function
    callee: &mir::Function
    block: &mut mir::Block
    opts: &InlineOptions
    next_value: &mut mir::ValueId
-> bool

    let mut changed = false
    let mut new_instrs = List::new()

    for inst in block.instructions.iter()

        select inst

            when mir::Instr::Call(dst, name, args)

                if name == callee.name and
                   is_inline_candidate(callee, caller, opts)

                    # mapping valeurs
                    let mut value_map = Map::new()

                    for p in callee.params.iter()
                        let a = args.pop_front()
                        value_map.insert(p, a)
                    .end

                    let block_offset =
                        caller.blocks.len as mir::BlockId + 1

                    let cloned =
                        clone_function_body(
                            callee,
                            &mut value_map,
                            block_offset,
                            next_value
                        )

                    # injecter blocs
                    for b in cloned.iter()
                        caller.blocks.push(b)
                    .end

                    # valeur de retour
                    if callee.ret.is_some()
                        let rv = value_map.get(callee.ret.unwrap())
                        value_map.insert(dst, rv)
                    .end

                    changed = true
                .end
                otherwise
                    new_instrs.push(inst)
                .end

            otherwise
                new_instrs.push(inst)
        .end
    .end

    block.instructions = new_instrs
    give changed
.end


# ------------------------------------------------------------
# Passe d’inlining complète
# ------------------------------------------------------------

proc run_inlining
    caller: &mut mir::Function
    callees: &Map[string, mir::Function]
    opts: InlineOptions
-> void

    let mut changed = true
    let mut next_value = 0

    while changed
        changed = false

        for b in caller.blocks.iter_mut()
            for (_, callee) in callees.iter()
                if inline_block(
                    caller,
                    callee,
                    b,
                    &opts,
                    &mut next_value
                )
                    changed = true
                .end
            .end
        .end
    .end
.end
