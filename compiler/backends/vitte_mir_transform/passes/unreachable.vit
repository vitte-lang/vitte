# ============================================================
# vitte_mir_transform::passes::unreachable
# Suppression des blocs MIR inatteignables
# ============================================================

space vitte/compiler/backends/vitte_mir_transform/passes


# ------------------------------------------------------------
# Imports
# ------------------------------------------------------------

pull vitte/compiler/backends/vitte_mir_build/mir/mod as mir
pull vitte/compiler/backends/vitte_mir_build/analysis/cfg as cfg

pull std/collections/set as Set
pull std/collections/list as List


# ------------------------------------------------------------
# Marquage des blocs atteignables
# ------------------------------------------------------------

proc mark_reachable
    graph: &cfg::ControlFlowGraph
    entry: mir::BlockId
-> Set[mir::BlockId]

    let mut visited = Set::new()
    let mut stack = List::new()

    stack.push(entry)

    while not stack.is_empty()
        let b = stack.pop()
        if visited.contains(b)
            continue
        .end

        visited.insert(b)

        let node = graph.nodes.get(b)
        for s in node.succs.iter()
            stack.push(s)
        .end
    .end

    give visited
.end


# ------------------------------------------------------------
# Suppression des blocs inatteignables
# ------------------------------------------------------------

proc remove_unreachable_blocks
    func: &mut mir::Function
-> bool

    let graph = cfg::build_cfg(func)
    let reachable = mark_reachable(&graph, func.entry)

    let mut new_blocks = List::new()
    let mut changed = false

    for b in func.blocks.iter()
        if reachable.contains(b.id)
            new_blocks.push(b)
        .end
        otherwise
            changed = true
        .end
    .end

    func.blocks = new_blocks
    give changed
.end


# ------------------------------------------------------------
# Nettoyage des terminators invalides
# ------------------------------------------------------------

proc cleanup_terminators
    func: &mut mir::Function
-> bool

    let valid = Set::new()
    for b in func.blocks.iter()
        valid.insert(b.id)
    .end

    let mut changed = false

    for b in func.blocks.iter_mut()
        if b.terminator.is_some()
            let t = b.terminator.unwrap()

            select t
                when mir::Terminator::Goto(target)
                    if not valid.contains(target)
                        b.terminator = Some(mir::Terminator::Unreachable)
                        changed = true
                    .end

                when mir::Terminator::Branch(_, t_true, t_false)
                    if not valid.contains(t_true) or
                       not valid.contains(t_false)
                        b.terminator = Some(mir::Terminator::Unreachable)
                        changed = true
                    .end
            .end
        .end
    .end

    give changed
.end


# ------------------------------------------------------------
# Passe unreachable complÃ¨te
# ------------------------------------------------------------

proc run_unreachable
    func: &mut mir::Function
-> void

    let mut changed = true

    while changed
        changed = false

        if remove_unreachable_blocks(func)
            changed = true
        .end

        if cleanup_terminators(func)
            changed = true
        .end
    .end
.end
