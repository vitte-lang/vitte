# ============================================================
# Vitte â€” Sanitizers
# File: passes/tsan.vit
#
# Role:
#   Inject ThreadSanitizer (TSan) instrumentation into MIR.
#
# Responsibilities:
#   - Instrument memory loads / stores
#   - Instrument thread lifecycle
#   - Instrument synchronization primitives
#
# Non-goals:
#   - Runtime implementation
#   - Scheduling semantics
#   - Codegen-specific lowering
#
# ============================================================

space compiler/backends/vitte_sanitizers/passes/tsan

pull compiler/backends/vitte_mir_dataflow/mir
pull compiler/backends/vitte_mir_dataflow/types
pull compiler/backends/vitte_mir_dataflow/context

pull compiler/backends/vitte_sanitizers/config
pull compiler/backends/vitte_sanitizers/context as san_ctx
pull compiler/backends/vitte_sanitizers/errors


# ============================================================
# Public entry point
# ============================================================

proc run_tsan(
    ctx: &mut san_ctx::SanitizerContext,
    mir: &mut mir::MirModule
)
gives ()
.end
    if !ctx.options.is_enabled()
        ret
    end

    if !ctx.options.has(config::SanitizerKind::Thread)
        ret
    end

    let pass = TsanPass::new(ctx)
    pass.visit_module(mir)
.end


# ============================================================
# TSan Pass
# ============================================================

form TsanPass
    ctx: &mut san_ctx::SanitizerContext
.end


proc TsanPass::new(
    ctx: &mut san_ctx::SanitizerContext
)
gives TsanPass
.end
    give TsanPass { ctx }
.end


# ============================================================
# Module traversal
# ============================================================

proc TsanPass::visit_module(
    self,
    module: &mut mir::MirModule
)
gives ()
.end
    for fn in module.functions.iter_mut()
        self.visit_function(fn)
    end
.end


proc TsanPass::visit_function(
    self,
    fn: &mut mir::MirFunction
)
gives ()
.end
    for block in fn.body.blocks
        self.visit_block(block)
    end
.end


proc TsanPass::visit_block(
    self,
    block: &mut mir::MirBlock
)
gives ()
.end
    let mut new_stmts = Vec::new()

    for stmt in block.statements
        select stmt

        # ----------------------------------------------------
        # Memory access instrumentation
        # ----------------------------------------------------
        when mir::MirStatement::Load(ptr, ty)
            new_stmts.push(
                self.make_read(ptr, ty)
            )
            new_stmts.push(stmt)

        when mir::MirStatement::Store(ptr, val)
            new_stmts.push(
                self.make_write(ptr, val.ty)
            )
            new_stmts.push(stmt)

        # ----------------------------------------------------
        # Synchronization & threading
        # ----------------------------------------------------
        when mir::MirStatement::Call(call)
            self.maybe_instrument_thread(call, &mut new_stmts)
            self.maybe_instrument_sync(call, &mut new_stmts)
            new_stmts.push(stmt)

        otherwise
            new_stmts.push(stmt)
        end
    end

    block.statements = new_stmts
.end


# ============================================================
# Memory access hooks
# ============================================================

proc TsanPass::make_read(
    self,
    ptr: mir::ValueId,
    ty: types::Type
)
gives mir::MirStatement
.end
    let size = self.size_of(ty)

    give mir::MirStatement::IntrinsicCall(
        "__tsan_read",
        [ptr],
        [size]
    )
.end


proc TsanPass::make_write(
    self,
    ptr: mir::ValueId,
    ty: types::Type
)
gives mir::MirStatement
.end
    let size = self.size_of(ty)

    give mir::MirStatement::IntrinsicCall(
        "__tsan_write",
        [ptr],
        [size]
    )
.end


# ============================================================
# Thread lifecycle instrumentation
# ============================================================

proc TsanPass::maybe_instrument_thread(
    self,
    call: &mir::MirCall,
    out: &mut Vec<mir::MirStatement>
)
gives ()
.end
    if call.is_thread_spawn()
        out.push(
            mir::MirStatement::IntrinsicCall(
                "__tsan_thread_create",
                call.args,
                []
            )
        )
    end

    if call.is_thread_join()
        out.push(
            mir::MirStatement::IntrinsicCall(
                "__tsan_thread_join",
                call.args,
                []
            )
        )
    end
.end


# ============================================================
# Synchronization instrumentation
# ============================================================

proc TsanPass::maybe_instrument_sync(
    self,
    call: &mir::MirCall,
    out: &mut Vec<mir::MirStatement>
)
gives ()
.end
    if call.is_mutex_lock()
        out.push(
            mir::MirStatement::IntrinsicCall(
                "__tsan_mutex_lock",
                call.args,
                []
            )
        )
    end

    if call.is_mutex_unlock()
        out.push(
            mir::MirStatement::IntrinsicCall(
                "__tsan_mutex_unlock",
                call.args,
                []
            )
        )
    end

    if call.is_atomic()
        out.push(
            mir::MirStatement::IntrinsicCall(
                "__tsan_atomic",
                call.args,
                []
            )
        )
    end
.end


# ============================================================
# Helpers
# ============================================================

proc TsanPass::size_of(
    self,
    ty: types::Type
)
gives Int
.end
    # Placeholder: real size comes from target ABI / layout
    give types::sizeof(ty)
.end
