# ============================================================
# vitte_codegen_cranelift::context
# Contexte central de génération Cranelift
# ============================================================

space vitte/compiler/backends/vitte_codegen_cranelift

pull vitte/compiler/mir/ast as mir
pull vitte/compiler/mir/types as mir_ty

pull vitte/compiler/backends/vitte_codegen_cranelift/errors as cl_err
pull vitte/compiler/backends/vitte_codegen_cranelift/types as cl_ty

pull cranelift/frontend as clif
pull cranelift/codegen/ir as ir
pull cranelift/codegen/isa as isa
pull cranelift/module as cl_mod

pull std/collections/map as Map
pull std/collections/list as List


# ------------------------------------------------------------
# Contexte global de codegen
# ------------------------------------------------------------

form CodegenCtx
    module: &mut cl_mod::Module
    isa: &isa::TargetIsa

    pointer_type: ir::Type

    functions: Map<mir::FnId, ir::FuncRef>
    signatures: Map<mir::FnId, cl_mod::Signature>
.end


proc CodegenCtx::new
    module: &mut cl_mod::Module
    isa: &isa::TargetIsa
-> CodegenCtx
    give CodegenCtx
        module = module
        isa = isa
        pointer_type = isa.pointer_type()
        functions = Map::new()
        signatures = Map::new()
    .end
.end


# ------------------------------------------------------------
# Déclaration des fonctions (phase pré-pass)
# ------------------------------------------------------------

proc CodegenCtx::declare_function
    self: &mut CodegenCtx
    fn_id: mir::FnId
    sig: &mir::FnSig
-> ir::FuncRef

    let mut cl_sig = cl_mod::Signature::new(
        self.module.isa().default_call_conv()
    )

    # Paramètres
    for p in sig.params
        cl_sig.params.push(
            ir::AbiParam::new(
                cl_ty::lower_type_global(self, p)
            )
        )
    .end

    # Retour
    if not sig.returns_void()
        cl_sig.returns.push(
            ir::AbiParam::new(
                cl_ty::lower_type_global(self, sig.ret)
            )
        )
    .end

    let func_ref = self.module.declare_function(
        sig.mangled_name,
        cl_mod::Linkage::Export,
        cl_sig
    )

    self.functions.insert(fn_id, func_ref)
    self.signatures.insert(fn_id, cl_sig)

    give func_ref
.end


# ------------------------------------------------------------
# Contexte local par fonction
# ------------------------------------------------------------

form LowerCtx
    builder: &mut clif::FunctionBuilder

    fn_id: mir::FnId
    func_ref: ir::FuncRef

    locals: Map<mir::LocalId, clif::Variable>
    blocks: Map<mir::BlockId, ir::Block>

    functions: Map<mir::FnId, ir::FuncRef>
    signatures: Map<mir::FnId, cl_mod::Signature>

    pointer_type: ir::Type

    source_name: string
    panic_on_error: bool
.end


proc CodegenCtx::enter_function
    self: &mut CodegenCtx
    builder: &mut clif::FunctionBuilder
    fn_id: mir::FnId
    source_name: string
-> LowerCtx

    let func_ref = self.functions.get(fn_id)
    if func_ref.is_none()
        cl_err::panic(
            "enter_function on undeclared function"
        )
    .end

    give LowerCtx
        builder = builder
        fn_id = fn_id
        func_ref = func_ref.unwrap()
        locals = Map::new()
        blocks = Map::new()
        functions = self.functions.clone()
        signatures = self.signatures.clone()
        pointer_type = self.pointer_type
        source_name = source_name
        panic_on_error = true
    .end
.end


# ------------------------------------------------------------
# Gestion des variables locales
# ------------------------------------------------------------

proc LowerCtx::declare_local
    self: &mut LowerCtx
    local_id: mir::LocalId
    ty: &mir_ty::Type
-> clif::Variable

    let var = clif::Variable::new(local_id.index())
    let cl_type = cl_ty::lower_type(self, ty)

    self.builder.declare_var(var, cl_type)
    self.locals.insert(local_id, var)

    give var
.end


proc LowerCtx::get_local
    self: &LowerCtx
    local_id: mir::LocalId
-> clif::Variable

    let v = self.locals.get(local_id)
    if v.is_none()
        cl_err::fatal_ctx(
            self,
            "use of undeclared local variable"
        )
    .end

    give v.unwrap()
.end


# ------------------------------------------------------------
# Gestion des blocs MIR → CLIF
# ------------------------------------------------------------

proc LowerCtx::get_or_create_block
    self: &mut LowerCtx
    block_id: mir::BlockId
-> ir::Block

    let blk = self.blocks.get(block_id)
    if blk.is_some()
        give blk.unwrap()
    .end

    let new_blk = self.builder.create_block()
    self.blocks.insert(block_id, new_blk)

    give new_blk
.end


proc LowerCtx::switch_to_block
    self: &mut LowerCtx
    block_id: mir::BlockId
-> ir::Block

    let blk = self.get_or_create_block(block_id)
    self.builder.switch_to_block(blk)

    give blk
.end


# ------------------------------------------------------------
# Utilitaires backend
# ------------------------------------------------------------

proc LowerCtx::emit_trap
    self: &mut LowerCtx
    reason: string
-> ()
    if self.panic_on_error
        cl_err::panic(reason)
    .end

    self.builder.ins().trap(
        ir::TrapCode::User(0)
    )
.end


proc LowerCtx::current_block
    self: &LowerCtx
-> ir::Block
    give self.builder.current_block().unwrap()
.end


# ------------------------------------------------------------
# Finalisation de fonction
# ------------------------------------------------------------

proc LowerCtx::finalize
    self: &mut LowerCtx
-> ()
    self.builder.seal_all_blocks()
    self.builder.finalize()
.end
