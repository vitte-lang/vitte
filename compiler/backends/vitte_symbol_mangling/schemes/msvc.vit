# ============================================================
# Vitte â€” Symbol Mangling Scheme
# File: schemes/msvc.vit
#
# Scheme:
#   MSVC-like (Windows / COFF)
#
# Role:
#   Provide a Windows-friendly mangling scheme compatible
#   with MSVC / lld-link expectations, while remaining
#   fully controlled by Vitte.
#
# Design principles:
#   - Inspired by MSVC, but NOT MSVC C++ mangling
#   - Deterministic and readable
#   - Stable across compiler versions
#   - ABI-explicit (win64)
#
# ============================================================

space compiler/backends/vitte_symbol_mangling/schemes/msvc

pull compiler/backends/vitte_mir_dataflow/mir
pull compiler/backends/vitte_mir_dataflow/types
pull compiler/backends/vitte_symbol_mangling/desc
pull compiler/backends/vitte_symbol_mangling/features
pull compiler/backends/vitte_symbol_mangling/errors


# ============================================================
# Constants
# ============================================================

const PREFIX: String = "?"     # MSVC-style prefix
const SEP: String = "@"
const END: String = "@@"


# ============================================================
# Public API
# ============================================================

# ------------------------------------------------------------
# Function mangling
# ------------------------------------------------------------

proc mangle_function(
    fn: &mir::MirFunction,
    target: desc::TargetDesc,
    cpu: features::CpuDesc,
    ext: features::ExtensionsDesc
)
gives String
.end
    let mut out = String::new()

    # MSVC-style prefix
    out.push_str(PREFIX)

    # Function name
    out.push_str(fn.name)

    # Namespace / module path
    out.push_str(SEP)
    if !fn.path.is_empty()
        for p in fn.path
            out.push_str(p)
            out.push_str(SEP)
        end
    end

    # ABI marker
    out.push_str("win64")
    out.push_str(SEP)

    # Return type
    if fn.signature.ret_ty.is_some()
        out.push_str(
            encode_type(fn.signature.ret_ty.unwrap())
        )
    else
        out.push_str("X")   # void
    end

    # Parameters
    if fn.signature.params.is_empty()
        out.push_str("X")   # no params
    else
        for p in fn.signature.params
            out.push_str(
                encode_type(p.ty)
            )
        end
    end

    # Feature suffix
    let cpu_suf = cpu.mangle_suffix()
    let ext_suf = ext.mangle_suffix()
    if !cpu_suf.is_empty() || !ext_suf.is_empty()
        out.push_str(SEP)
        out.push_str("feat")
        out.push_str(cpu_suf)
        out.push_str(ext_suf)
    end

    out.push_str(END)
    give out
.end


# ------------------------------------------------------------
# Global symbol mangling
# ------------------------------------------------------------

proc mangle_global(
    name: String,
    ty: types::Type,
    target: desc::TargetDesc
)
gives String
.end
    let mut out = String::new()

    out.push_str(PREFIX)
    out.push_str(name)
    out.push_str(SEP)
    out.push_str("global")
    out.push_str(SEP)
    out.push_str("win64")
    out.push_str(SEP)
    out.push_str(encode_type(ty))
    out.push_str(END)

    give out
.end


# ============================================================
# Type encoding (MSVC-like)
# ============================================================

proc encode_type(
    ty: types::Type
)
gives String
.end
    select ty

    # --------------------------------------------------------
    # Primitive types
    # --------------------------------------------------------
    when types::Type::Bool
        give "_N"        # bool

    when types::Type::Int(bits, signed)
        if signed
            match bits
            when 8   give "_C"   # char
            when 16  give "_F"   # short
            when 32  give "_H"   # int
            when 64  give "_J"   # long long
            otherwise
                give "_I" + bits.to_string()
            end
        else
            match bits
            when 8   give "_E"
            when 16  give "_G"
            when 32  give "_I"
            when 64  give "_K"
            otherwise
                give "_U" + bits.to_string()
            end
        end

    when types::Type::Float(bits)
        match bits
        when 32 give "_M"    # float
        when 64 give "_N"    # double
        otherwise
            give "_F" + bits.to_string()
        end

    # --------------------------------------------------------
    # Pointer / reference
    # --------------------------------------------------------
    when types::Type::Pointer(inner)
        give "P" + encode_type(inner)

    when types::Type::Ref(inner, mutability)
        if mutability
            give "Q" + encode_type(inner)
        else
            give "A" + encode_type(inner)
        end

    # --------------------------------------------------------
    # Arrays
    # --------------------------------------------------------
    when types::Type::Array(inner, size)
        give "Y" + size.to_string() + encode_type(inner)

    # --------------------------------------------------------
    # Slice (fat pointer)
    # --------------------------------------------------------
    when types::Type::Slice(inner)
        give "S" + encode_type(inner)

    # --------------------------------------------------------
    # Tuple
    # --------------------------------------------------------
    when types::Type::Tuple(items)
        let mut out = "T".to_string()
        out.push(items.len().to_string())
        for t in items
            out.push_str(encode_type(t))
        end
        give out

    # --------------------------------------------------------
    # Named / user-defined
    # --------------------------------------------------------
    when types::Type::Named(id)
        give "U" + id.to_string()

    # --------------------------------------------------------
    # Function pointer
    # --------------------------------------------------------
    when types::Type::Fn(params, ret)
        let mut out = "F".to_string()
        for p in params
            out.push_str(encode_type(p))
        end
        out.push_str("_R")
        if ret.is_some()
            out.push_str(encode_type(ret.unwrap()))
        else
            out.push_str("X")
        end
        give out

    otherwise
        errors::unsupported_type_for_scheme("msvc", ty)
        give "Z"
    end
.end
