# ============================================================
# Vitte â€” Symbol Mangling
# File: lib.vit
#
# Role:
#   Public entry point for all symbol mangling operations.
#
# Responsibilities:
#   - Assemble target, features and scheme into a context
#   - Provide simple, stable APIs for mangling
#   - Enforce validation and linker constraints
#
# Consumers:
#   - Driver
#   - Codegen backends (LLVM / Cranelift)
#   - Runtime / FFI
#   - Tests / bootstrap
#
# ============================================================

space compiler/backends/vitte_symbol_mangling

# ------------------------------------------------------------
# Subsystems
# ------------------------------------------------------------

pull compiler/backends/vitte_symbol_mangling/desc
pull compiler/backends/vitte_symbol_mangling/features
pull compiler/backends/vitte_symbol_mangling/layout
pull compiler/backends/vitte_symbol_mangling/schemes
pull compiler/backends/vitte_symbol_mangling/utils
pull compiler/backends/vitte_symbol_mangling/context
pull compiler/backends/vitte_symbol_mangling/errors

pull compiler/backends/vitte_mir_dataflow/mir
pull compiler/backends/vitte_mir_dataflow/types


# ============================================================
# High-level API
# ============================================================

# ------------------------------------------------------------
# Context construction helpers
# ------------------------------------------------------------

proc create_context(
    target: desc::TargetDesc,
    cpu: features::CpuDesc,
    extensions: features::ExtensionsDesc
)
gives context::ManglingContext
.end
    let ctx = context::ManglingContext::new(
        target,
        cpu,
        extensions
    )
    ctx.validate()
    give ctx
.end


# ------------------------------------------------------------
# Function mangling
# ------------------------------------------------------------

proc mangle_function(
    ctx: context::ManglingContext,
    fn: &mir::MirFunction
)
gives String
.end
    give ctx.mangle_function(fn)
.end


# ------------------------------------------------------------
# Global mangling
# ------------------------------------------------------------

proc mangle_global(
    ctx: context::ManglingContext,
    name: String,
    ty: types::Type
)
gives String
.end
    give ctx.mangle_global(name, ty)
.end


# ------------------------------------------------------------
# Convenience helpers
# ------------------------------------------------------------

# One-shot mangling without manually keeping a context
proc mangle_function_once(
    target: desc::TargetDesc,
    cpu: features::CpuDesc,
    extensions: features::ExtensionsDesc,
    fn: &mir::MirFunction
)
gives String
.end
    let ctx = create_context(target, cpu, extensions)
    give ctx.mangle_function(fn)
.end


proc mangle_global_once(
    target: desc::TargetDesc,
    cpu: features::CpuDesc,
    extensions: features::ExtensionsDesc,
    name: String,
    ty: types::Type
)
gives String
.end
    let ctx = create_context(target, cpu, extensions)
    give ctx.mangle_global(name, ty)
.end


# ============================================================
# Layout helpers (re-exported convenience)
# ============================================================

# Compute layout for a type under a given target
proc compute_type_layout(
    ty: types::Type,
    target: desc::TargetDesc
)
gives layout::TypeLayout
.end
    give layout::compute_layout(ty, target)
.end


# ============================================================
# Diagnostics helpers
# ============================================================

proc debug_mangle_function(
    ctx: context::ManglingContext,
    fn: &mir::MirFunction
)
gives String
.end
    let sym = ctx.mangle_function(fn)
    give "[mangled] " + sym
.end
