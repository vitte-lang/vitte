# ============================================================
# Vitte â€” Type Layout
# File: layout/types.vit
#
# Role:
#   Canonical description of memory layout for types.
#
# Used by:
#   - Symbol mangling (ABI-stable types)
#   - Codegen (size, align, field offsets)
#   - Sanitizers (bounds, redzones)
#   - FFI (C / system interop)
#
# Design goals:
#   - Deterministic
#   - ABI-aware
#   - Backend-agnostic
#
# ============================================================

space compiler/backends/vitte_symbol_mangling/layout/types

pull compiler/backends/vitte_symbol_mangling/desc
pull compiler/backends/vitte_symbol_mangling/errors
pull compiler/backends/vitte_mir_dataflow/types


# ============================================================
# Core layout structures
# ============================================================

# Final resolved layout for a type
form TypeLayout
    size: Int            # size in bytes
    align: Int           # alignment in bytes
    abi_align: Int       # ABI-required alignment
    stride: Int          # size incl. padding (arrays)
    is_packed: Bool
.end


# Field layout (struct / tuple)
form FieldLayout
    index: Int
    offset: Int
    layout: TypeLayout
.end


# Struct / tuple layout
form StructLayout
    fields: Vec<FieldLayout>
    layout: TypeLayout
.end


# ============================================================
# Entry point
# ============================================================

# Compute layout for any type
proc compute_layout(
    ty: types::Type,
    target: desc::TargetDesc
)
gives TypeLayout
.end
    select ty

    # --------------------------------------------------------
    # Primitives
    # --------------------------------------------------------
    when types::Type::Bool
        give scalar_layout(1, 1, target)

    when types::Type::Int(bits, _signed)
        let bytes = bits / 8
        give scalar_layout(bytes, bytes, target)

    when types::Type::Float(bits)
        let bytes = bits / 8
        give scalar_layout(bytes, bytes, target)

    # --------------------------------------------------------
    # Pointer / reference
    # --------------------------------------------------------
    when types::Type::Pointer(_)
        let bytes = target.pointer_width / 8
        give scalar_layout(bytes, bytes, target)

    when types::Type::Ref(_, _)
        let bytes = target.pointer_width / 8
        give scalar_layout(bytes, bytes, target)

    # --------------------------------------------------------
    # Array
    # --------------------------------------------------------
    when types::Type::Array(inner, count)
        let elem = compute_layout(inner, target)

        let size = elem.stride * count
        give TypeLayout {
            size,
            stride: size,
            align: elem.align,
            abi_align: elem.abi_align,
            is_packed: false,
        }

    # --------------------------------------------------------
    # Slice (fat pointer)
    # --------------------------------------------------------
    when types::Type::Slice(_inner)
        # ptr + length
        let ptr = target.pointer_width / 8
        let size = ptr * 2
        give TypeLayout {
            size,
            stride: size,
            align: ptr,
            abi_align: ptr,
            is_packed: false,
        }

    # --------------------------------------------------------
    # Tuple
    # --------------------------------------------------------
    when types::Type::Tuple(items)
        let s = compute_struct_layout(items, target)
        give s.layout

    # --------------------------------------------------------
    # Named / user-defined
    # --------------------------------------------------------
    when types::Type::Named(id)
        # Layout resolved after monomorphization
        errors::unresolved_type_layout(id)
        give TypeLayout {
            size: 0,
            stride: 0,
            align: 1,
            abi_align: 1,
            is_packed: false,
        }

    # --------------------------------------------------------
    # Function pointer
    # --------------------------------------------------------
    when types::Type::Fn(_, _)
        let bytes = target.pointer_width / 8
        give scalar_layout(bytes, bytes, target)

    otherwise
        errors::unsupported_type_layout(ty)
        give TypeLayout {
            size: 0,
            stride: 0,
            align: 1,
            abi_align: 1,
            is_packed: false,
        }
    end
.end


# ============================================================
# Struct / tuple layout
# ============================================================

proc compute_struct_layout(
    fields: Vec<types::Type>,
    target: desc::TargetDesc
)
gives StructLayout
.end
    let mut offset = 0
    let mut max_align = 1
    let mut layouts = Vec::new()

    for i in 0 .. fields.len()
        let fl = compute_layout(fields[i], target)

        let align = fl.align
        offset = align_to(offset, align)

        layouts.push(
            FieldLayout {
                index: i,
                offset,
                layout: fl,
            }
        )

        offset += fl.size
        max_align = max(max_align, align)
    end

    let size = align_to(offset, max_align)

    give StructLayout {
        fields: layouts,
        layout: TypeLayout {
            size,
            stride: size,
            align: max_align,
            abi_align: max_align,
            is_packed: false,
        },
    }
.end


# ============================================================
# Helpers
# ============================================================

proc scalar_layout(
    size: Int,
    align: Int,
    target: desc::TargetDesc
)
gives TypeLayout
.end
    let abi_align = min(align, target.stack_align)

    give TypeLayout {
        size,
        stride: align_to(size, abi_align),
        align,
        abi_align,
        is_packed: false,
    }
.end


proc align_to(
    value: Int,
    align: Int
)
gives Int
.end
    if align <= 1
        give value
    end

    let rem = value % align
    if rem == 0
        give value
    end

    give value + (align - rem)
.end
