# ============================================================
# Vitte â€” Platform / Runtime Extensions
# File: features/extensions.vit
#
# Role:
#   Describe non-CPU features that affect ABI compatibility,
#   runtime availability and symbol mangling.
#
# Used by:
#   - Symbol mangling (extension-qualified symbols)
#   - Codegen (feature gating)
#   - Driver / CLI (target-env, target-ext)
#   - Linker & runtime selection
#
# Design goals:
#   - Clear separation from CPU features
#   - Deterministic mangling
#   - Cross-platform extensibility
#
# ============================================================

space compiler/backends/vitte_symbol_mangling/features/extensions

pull compiler/backends/vitte_symbol_mangling/errors


# ============================================================
# Extension kinds
# ============================================================

pick ExtensionKind
    # -------------------------
    # OS / Kernel capabilities
    # -------------------------
    POSIX
    WINDOWS_API
    LINUX_API
    BSD_API
    DARWIN_API

    # -------------------------
    # Runtime / libc
    # -------------------------
    GLIBC
    MUSL
    MSVCRT
    UCRT
    BIONIC
    LIBCXX
    LIBSTDCPP

    # -------------------------
    # Threading / async
    # -------------------------
    PTHREADS
    WIN32_THREADS
    WASM_THREADS
    ASYNC_AWAIT

    # -------------------------
    # Memory / system
    # -------------------------
    MMAP
    VIRTUAL_MEMORY
    SHARED_MEMORY
    ATOMICS

    # -------------------------
    # Security / sandbox
    # -------------------------
    SECCOMP
    CAPSICUM
    SANDBOX
    WASI_SANDBOX

    # -------------------------
    # Language / ABI layers
    # -------------------------
    C_ABI
    CPP_ABI
    VITTE_ABI
.end


# ============================================================
# Extensions descriptor
# ============================================================

form ExtensionsDesc
    extensions: Set<ExtensionKind>

    # Tuning flags
    freestanding: Bool
    hosted: Bool
.end


# ============================================================
# Constructors
# ============================================================

proc ExtensionsDesc::new()
gives ExtensionsDesc
.end
    give ExtensionsDesc {
        extensions: Set::new(),
        freestanding: false,
        hosted: true,
    }
.end


# ============================================================
# Presets
# ============================================================

# -------------------------
# Linux (glibc)
# -------------------------
proc ExtensionsDesc::linux_glibc()
gives ExtensionsDesc
.end
    let mut e = ExtensionsDesc::new()

    e.extensions.insert(ExtensionKind::POSIX)
    e.extensions.insert(ExtensionKind::LINUX_API)
    e.extensions.insert(ExtensionKind::GLIBC)
    e.extensions.insert(ExtensionKind::PTHREADS)
    e.extensions.insert(ExtensionKind::MMAP)
    e.extensions.insert(ExtensionKind::VIRTUAL_MEMORY)
    e.extensions.insert(ExtensionKind::ATOMICS)

    give e
.end


# -------------------------
# Linux (musl)
# -------------------------
proc ExtensionsDesc::linux_musl()
gives ExtensionsDesc
.end
    let mut e = ExtensionsDesc::linux_glibc()
    e.extensions.remove(ExtensionKind::GLIBC)
    e.extensions.insert(ExtensionKind::MUSL)
    give e
.end


# -------------------------
# Windows (MSVC / UCRT)
# -------------------------
proc ExtensionsDesc::windows_ucrt()
gives ExtensionsDesc
.end
    let mut e = ExtensionsDesc::new()

    e.extensions.insert(ExtensionKind::WINDOWS_API)
    e.extensions.insert(ExtensionKind::UCRT)
    e.extensions.insert(ExtensionKind::WIN32_THREADS)
    e.extensions.insert(ExtensionKind::VIRTUAL_MEMORY)
    e.extensions.insert(ExtensionKind::ATOMICS)

    give e
.end


# -------------------------
# macOS
# -------------------------
proc ExtensionsDesc::darwin()
gives ExtensionsDesc
.end
    let mut e = ExtensionsDesc::new()

    e.extensions.insert(ExtensionKind::POSIX)
    e.extensions.insert(ExtensionKind::DARWIN_API)
    e.extensions.insert(ExtensionKind::LIBCXX)
    e.extensions.insert(ExtensionKind::PTHREADS)
    e.extensions.insert(ExtensionKind::MMAP)
    e.extensions.insert(ExtensionKind::VIRTUAL_MEMORY)

    give e
.end


# -------------------------
# WASI (freestanding)
# -------------------------
proc ExtensionsDesc::wasi()
gives ExtensionsDesc
.end
    let mut e = ExtensionsDesc::new()

    e.freestanding = true
    e.hosted = false

    e.extensions.insert(ExtensionKind::WASI_SANDBOX)
    e.extensions.insert(ExtensionKind::ATOMICS)

    give e
.end


# ============================================================
# Queries
# ============================================================

proc ExtensionsDesc::has(self, ext: ExtensionKind)
gives Bool
.end
    give self.extensions.contains(ext)
.end


proc ExtensionsDesc::enable(self, ext: ExtensionKind)
gives ()
.end
    self.extensions.insert(ext)
.end


proc ExtensionsDesc::disable(self, ext: ExtensionKind)
gives ()
.end
    self.extensions.remove(ext)
.end


# ============================================================
# Validation
# ============================================================

proc ExtensionsDesc::validate(self)
gives ()
.end
    if self.freestanding && self.hosted
        errors::invalid_extension("cannot be both freestanding and hosted")
    end

    if self.has(ExtensionKind::GLIBC) && self.has(ExtensionKind::MUSL)
        errors::invalid_extension("glibc and musl are mutually exclusive")
    end

    if self.has(ExtensionKind::PTHREADS) && self.has(ExtensionKind::WIN32_THREADS)
        errors::invalid_extension("pthread and win32 threads are incompatible")
    end
.end


# ============================================================
# Mangling helpers
# ============================================================

# Deterministic extension suffix for symbol mangling
# Example: +glibc+pthreads+mmap
proc ExtensionsDesc::mangle_suffix(self)
gives String
.end
    if self.extensions.is_empty()
        give ""
    end

    let mut exts = self.extensions.to_vec()
    exts.sort_by_name()

    let mut out = String::new()
    for e in exts
        out.push('+')
        out.push_str(extension_name(e))
    end

    give out
.end


proc extension_name(e: ExtensionKind)
gives String
.end
    match e
    when ExtensionKind::POSIX           give "posix"
    when ExtensionKind::WINDOWS_API     give "winapi"
    when ExtensionKind::LINUX_API       give "linux"
    when ExtensionKind::BSD_API         give "bsd"
    when ExtensionKind::DARWIN_API      give "darwin"

    when ExtensionKind::GLIBC           give "glibc"
    when ExtensionKind::MUSL            give "musl"
    when ExtensionKind::MSVCRT          give "msvcrt"
    when ExtensionKind::UCRT            give "ucrt"
    when ExtensionKind::BIONIC          give "bionic"
    when ExtensionKind::LIBCXX          give "libcxx"
    when ExtensionKind::LIBSTDCPP       give "libstdc++"

    when ExtensionKind::PTHREADS        give "pthreads"
    when ExtensionKind::WIN32_THREADS   give "win32-threads"
    when ExtensionKind::WASM_THREADS    give "wasm-threads"
    when ExtensionKind::ASYNC_AWAIT     give "async"

    when ExtensionKind::MMAP            give "mmap"
    when ExtensionKind::VIRTUAL_MEMORY  give "vm"
    when ExtensionKind::SHARED_MEMORY   give "shm"
    when ExtensionKind::ATOMICS         give "atomics"

    when ExtensionKind::SECCOMP         give "seccomp"
    when ExtensionKind::CAPSICUM        give "capsicum"
    when ExtensionKind::SANDBOX         give "sandbox"
    when ExtensionKind::WASI_SANDBOX    give "wasi"

    when ExtensionKind::C_ABI           give "c-abi"
    when ExtensionKind::CPP_ABI         give "cpp-abi"
    when ExtensionKind::VITTE_ABI       give "vitte-abi"
    end
.end
