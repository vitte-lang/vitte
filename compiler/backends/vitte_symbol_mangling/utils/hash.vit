# ============================================================
# Vitte â€” Symbol Mangling Utilities
# File: utils/hash.vit
#
# Role:
#   Deterministic, portable hashing utilities for symbol
#   mangling and name disambiguation.
#
# Design goals:
#   - Fully deterministic
#   - Cross-platform stable
#   - No external dependencies
#   - Fast enough for compiler usage
#
# Non-goals:
#   - Cryptographic security
#   - Runtime randomness
#
# ============================================================

space compiler/backends/vitte_symbol_mangling/utils/hash


# ============================================================
# Hash algorithms
# ============================================================

pick HashAlgo
    FNV1A_32
    FNV1A_64
.end


# ============================================================
# Constants
# ============================================================

const FNV1A_32_OFFSET: U32 = 2166136261
const FNV1A_32_PRIME:  U32 = 16777619

const FNV1A_64_OFFSET: U64 = 14695981039346656037
const FNV1A_64_PRIME:  U64 = 1099511628211


# ============================================================
# Public API
# ============================================================

# Generic hash entry point
proc hash_string(
    algo: HashAlgo,
    value: String
)
gives U64
.end
    match algo
    when HashAlgo::FNV1A_32
        give fnv1a_32(value) as U64
    when HashAlgo::FNV1A_64
        give fnv1a_64(value)
    end
.end


# Short hexadecimal hash (for symbol suffixes)
# Example: "abcdef012345"
proc hash_hex(
    algo: HashAlgo,
    value: String,
    digits: Int
)
gives String
.end
    let h = hash_string(algo, value)
    let hex = h.to_hex_string()

    if digits <= 0 || digits >= hex.len()
        give hex
    end

    give hex.slice(0, digits)
.end


# ============================================================
# FNV-1a implementations
# ============================================================

proc fnv1a_32(value: String)
gives U32
.end
    let mut hash = FNV1A_32_OFFSET

    for b in value.bytes()
        hash = hash ^ (b as U32)
        hash = hash * FNV1A_32_PRIME
    end

    give hash
.end


proc fnv1a_64(value: String)
gives U64
.end
    let mut hash = FNV1A_64_OFFSET

    for b in value.bytes()
        hash = hash ^ (b as U64)
        hash = hash * FNV1A_64_PRIME
    end

    give hash
.end


# ============================================================
# Mangling helpers
# ============================================================

# Produce a compact, deterministic suffix for long symbols
# Example: "__H3fa92c1b"
proc mangling_hash_suffix(
    value: String
)
gives String
.end
    let h = hash_hex(HashAlgo::FNV1A_64, value, 8)
    give "__H" + h
.end


# Conditionally hash a symbol if it exceeds max_len
proc shorten_symbol(
    symbol: String,
    max_len: Int
)
gives String
.end
    if symbol.len() <= max_len
        give symbol
    end

    let suffix = mangling_hash_suffix(symbol)
    let keep = max_len - suffix.len()

    if keep <= 0
        give suffix
    end

    give symbol.slice(0, keep) + suffix
.end


# ============================================================
# Debug / tests helpers
# ============================================================

proc debug_hash_32(value: String)
gives String
.end
    give fnv1a_32(value).to_hex_string()
.end


proc debug_hash_64(value: String)
gives String
.end
    give fnv1a_64(value).to_hex_string()
.end
