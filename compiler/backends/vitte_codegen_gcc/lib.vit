# ============================================================
# vitte_codegen_gcc::lib
# Point d’entrée du backend GCC
# ============================================================

space vitte/compiler/backends/vitte_codegen_gcc

# ------------------------------------------------------------
# MIR
# ------------------------------------------------------------

pull vitte/compiler/mir/ast as mir


# ------------------------------------------------------------
# Sous-modules backend GCC
# ------------------------------------------------------------

pull vitte/compiler/backends/vitte_codegen_gcc/context
pull vitte/compiler/backends/vitte_codegen_gcc/errors
pull vitte/compiler/backends/vitte_codegen_gcc/types
pull vitte/compiler/backends/vitte_codegen_gcc/function

pull vitte/compiler/backends/vitte_codegen_gcc/lower/expr
pull vitte/compiler/backends/vitte_codegen_gcc/lower/stmt


# ------------------------------------------------------------
# Backend GCC — façade publique
# ------------------------------------------------------------

form GccBackend
    ctx: context::CodegenCtx
.end


# ------------------------------------------------------------
# Création du backend
# ------------------------------------------------------------

proc GccBackend::new
    global_scope: context::Tree
-> GccBackend

    let ctx = context::CodegenCtx::new(
        global_scope
    )

    give GccBackend
        ctx = ctx
    .end
.end


# ------------------------------------------------------------
# Phase 1 — Déclaration des symboles
# ------------------------------------------------------------

proc GccBackend::declare
    self: &mut GccBackend
    program: &mir::Program
-> ()

    for func in program.functions
        self.ctx.declare_function(
            func.id,
            func.sig
        )
    .end
.end


# ------------------------------------------------------------
# Phase 2 — Génération du code
# ------------------------------------------------------------

proc GccBackend::codegen
    self: &mut GccBackend
    program: &mir::Program
-> ()

    for func in program.functions
        function::lower_fn(
            &mut self.ctx,
            func
        )
    .end
.end


# ------------------------------------------------------------
# Phase 3 — Finalisation
# ------------------------------------------------------------

proc GccBackend::finalize
    self: &mut GccBackend
-> ()

    # À ce stade, GCC a reçu toutes les fonctions
    # La finalisation réelle dépend du mode :
    #  - plugin GCC
    #  - libgccjit
    #  - génération GIMPLE / RTL
    gcc_finalize_unit()
.end


# ------------------------------------------------------------
# API convenience (tout-en-un)
# ------------------------------------------------------------

proc compile
    program: &mir::Program
    global_scope: context::Tree
-> ()

    let mut backend = GccBackend::new(
        global_scope
    )

    backend.declare(program)
    backend.codegen(program)
    backend.finalize()
.end


# ------------------------------------------------------------
# Helpers GCC externes (FFI)
# ------------------------------------------------------------

# Finalisation de l’unité de compilation GCC
proc gcc_finalize_unit
-> ()
.end
