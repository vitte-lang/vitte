# ============================================================
# vitte_mir_dataflow::analysis::passes::const_prop
# Constant Propagation (MIR, dataflow)
# ============================================================

space vitte/compiler/backends/vitte_mir_dataflow/analysis/passes


# ------------------------------------------------------------
# Imports
# ------------------------------------------------------------

pull vitte/compiler/backends/vitte_mir_dataflow/analysis/framework/mod
    as df

pull vitte/compiler/backends/vitte_mir_build/mir/mod
    as mir

pull std/collections/map as Map
pull std/collections/set as Set


# ------------------------------------------------------------
# Lattice des constantes
# ------------------------------------------------------------

pick ConstValue
    case Bottom        # ⊥ : non initialisé / impossible
    case Const(lit)    # constante connue
    case Top           # ⊤ : valeur inconnue / variable
.end


# ------------------------------------------------------------
# État dataflow : ValueId -> ConstValue
# ------------------------------------------------------------

type ConstState = Map[mir::ValueId, ConstValue]


# ------------------------------------------------------------
# Domaine dataflow
# ------------------------------------------------------------

proc const_domain
-> df::DataflowDomain

    give df::DataflowDomain {
        name = "constant-propagation"
        bottom = Map::new()
        top = None
    }
.end


# ------------------------------------------------------------
# Join du domaine
# ------------------------------------------------------------

proc join_state
    a: ConstState
    b: ConstState
-> ConstState

    let mut out = Map::new()
    let keys = Set::new()

    for (k, _) in a.iter()
        keys.insert(k)
    .end
    for (k, _) in b.iter()
        keys.insert(k)
    .end

    for k in keys.iter()
        let va = a.get_or(k, ConstValue::Bottom)
        let vb = b.get_or(k, ConstValue::Bottom)

        let r =
            select (va, vb)
                when (ConstValue::Const(x), ConstValue::Const(y))
                    if x == y
                        ConstValue::Const(x)
                    .end
                    otherwise
                        ConstValue::Top
                when (ConstValue::Bottom, v) give v
                when (v, ConstValue::Bottom) give v
                otherwise
                    ConstValue::Top
            .end

        out.insert(k, r)
    .end

    give out
.end


proc equals_state
    a: ConstState
    b: ConstState
-> bool

    if a.len != b.len
        give false
    .end

    for (k, v) in a.iter()
        if not b.contains(k)
            give false
        .end
        if b.get(k) != v
            give false
        .end
    .end

    give true
.end


# ------------------------------------------------------------
# Helpers d’évaluation
# ------------------------------------------------------------

proc eval_binop
    op: mir::BinOp
    a
    b
-> Option

    select op
        when mir::BinOp::Add give Some(a + b)
        when mir::BinOp::Sub give Some(a - b)
        when mir::BinOp::Mul give Some(a * b)
        when mir::BinOp::Div
            if b == 0
                give None
            .end
            give Some(a / b)
        otherwise
            give None
    .end
.end


# ------------------------------------------------------------
# Fonction de transfert (bloc)
# ------------------------------------------------------------

proc transfer_block
    block: &mir::Block
    in_state: ConstState
-> ConstState

    let mut state = in_state.clone()

    for inst in block.instructions.iter()

        select inst

            when mir::Instr::Const(dst, lit)
                state.insert(
                    dst,
                    ConstValue::Const(lit)
                )

            when mir::Instr::Copy(dst, src)
                let v = state.get_or(src, ConstValue::Top)
                state.insert(dst, v)

            when mir::Instr::Binary(dst, op, lhs, rhs)
                let l = state.get_or(lhs, ConstValue::Top)
                let r = state.get_or(rhs, ConstValue::Top)

                let res =
                    select (l, r)
                        when (ConstValue::Const(a), ConstValue::Const(b))
                            let e = eval_binop(op, a, b)
                            if e.is_some()
                                ConstValue::Const(e.unwrap())
                            .end
                            otherwise
                                ConstValue::Top
                        otherwise
                            ConstValue::Top
                    .end

                state.insert(dst, res)

            when mir::Instr::Call(dst, _, _)
                # appel : valeur inconnue
                state.insert(dst, ConstValue::Top)

            when mir::Instr::Cast(dst, src, _)
                let v = state.get_or(src, ConstValue::Top)
                state.insert(dst, v)
        .end
    .end

    give state
.end


# ------------------------------------------------------------
# Description de l’analyse dataflow
# ------------------------------------------------------------

proc const_prop_analysis
-> df::DataflowAnalysis

    let dom = const_domain()

    let transfer =
        df::TransferFunctions {
            transfer_block = transfer_block
        }

    give df::DataflowAnalysis {
        name = "constant-propagation"
        direction = df::DataflowDirection::Forward
        domain = dom
        transfer = transfer
    }
.end
