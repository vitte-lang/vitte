# ============================================================
# vitte_transmute::rules::primitive
# Règles de transmutation pour types primitifs
# ============================================================

space vitte/compiler/backends/vitte_transmute/rules

pull vitte/compiler/backends/vitte_transmute/ir/type as tm_ty
pull vitte/compiler/backends/vitte_transmute/analysis/size as tm_size
pull vitte/compiler/backends/vitte_transmute/analysis/alignment as tm_align
pull vitte/compiler/backends/vitte_transmute/analysis/validity as tm_valid


# ------------------------------------------------------------
# API principale
# ------------------------------------------------------------

proc analyze_primitive_validity
    from: &tm_ty::Type
    to: &tm_ty::Type
    vctx: &tm_valid::ValidityContext
-> tm_valid::Validity

    # --------------------------------------------------------
    # Taille stricte
    # --------------------------------------------------------

    let sz_from = tm_size::size_of(from)
    let sz_to   = tm_size::size_of(to)

    if sz_from != sz_to
        give tm_valid::Validity::Invalid(
            "primitive size mismatch"
        )
    .end


    # --------------------------------------------------------
    # Alignement compatible
    # --------------------------------------------------------

    let a_from = tm_align::alignment_of(from)
    let a_to   = tm_align::alignment_of(to)

    if a_to > a_from
        give tm_valid::Validity::Invalid(
            "primitive alignment mismatch"
        )
    .end


    # --------------------------------------------------------
    # Dispatch par catégorie
    # --------------------------------------------------------

    if is_integer(from) and is_integer(to)
        give tm_valid::Validity::Valid
    .end

    if is_float(from) and is_float(to)
        give tm_valid::Validity::Valid
    .end

    if is_integer(from) and is_float(to)
        give tm_valid::Validity::Unsafe(
            "integer to float transmute"
        )
    .end

    if is_float(from) and is_integer(to)
        give tm_valid::Validity::Unsafe(
            "float to integer transmute"
        )
    .end

    if is_bool(from) and is_bool(to)
        give tm_valid::Validity::Valid
    .end

    if is_pointer(from) and is_pointer(to)
        give tm_valid::Validity::Valid
    .end

    if is_pointer(from) and is_integer(to)
        if vctx.allow_ptr_cast
            give tm_valid::Validity::Unsafe(
                "pointer to integer transmute"
            )
        .end

        give tm_valid::Validity::Invalid(
            "pointer to integer transmute forbidden"
        )
    .end

    if is_integer(from) and is_pointer(to)
        if vctx.allow_ptr_cast
            give tm_valid::Validity::Unsafe(
                "integer to pointer transmute"
            )
        .end

        give tm_valid::Validity::Invalid(
            "integer to pointer transmute forbidden"
        )
    .end

    give tm_valid::Validity::Invalid(
        "unsupported primitive transmute"
    )
.end


# ------------------------------------------------------------
# Helpers
# ------------------------------------------------------------

proc is_bool
    ty: &tm_ty::Type
-> bool

    give ty.kind == tm_ty::TypeKind::Bool
.end


proc is_integer
    ty: &tm_ty::Type
-> bool

    select ty.kind
        when tm_ty::TypeKind::I8,
             tm_ty::TypeKind::I16,
             tm_ty::TypeKind::I32,
             tm_ty::TypeKind::I64
            give true
        otherwise
            give false
    .end
.end


proc is_float
    ty: &tm_ty::Type
-> bool

    select ty.kind
        when tm_ty::TypeKind::F32,
             tm_ty::TypeKind::F64
            give true
        otherwise
            give false
    .end
.end


proc is_pointer
    ty: &tm_ty::Type
-> bool

    give ty.kind == tm_ty::TypeKind::Pointer
.end
