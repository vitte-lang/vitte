# ============================================================
# vitte_transmute::analysis::alignment
# Analyse d’alignement mémoire (ABI-aware)
# ============================================================

space vitte/compiler/backends/vitte_transmute/analysis

pull vitte/compiler/backends/vitte_transmute/ir/type as tm_ty
pull vitte/compiler/backends/vitte_transmute/analysis/layout as tm_layout

pull std/collections/map as Map
pull std/collections/list as List
pull std/math as math


# ------------------------------------------------------------
# Résultat d’analyse d’alignement
# ------------------------------------------------------------

form Alignment
    min: u32        # alignement minimal requis (ABI)
    pref: u32       # alignement préféré (perf)
.end


proc Alignment::new
    min: u32
    pref: u32
-> Alignment

    give Alignment {
        min = min
        pref = pref
    }
.end


# ------------------------------------------------------------
# Politique d’alignement cible
# ------------------------------------------------------------

form AlignPolicy
    pointer_align: u32
    max_align: u32
.end


proc AlignPolicy::default
-> AlignPolicy

    # Valeurs sûres et portables (x86_64-like)
    give AlignPolicy {
        pointer_align = 8
        max_align = 16
    }
.end


# ------------------------------------------------------------
# Cache d’analyse
# ------------------------------------------------------------

form AlignCache
    map: Map<tm_ty::TypeId, Alignment>
.end


proc AlignCache::new
-> AlignCache

    give AlignCache {
        map = Map::new()
    }
.end


# ------------------------------------------------------------
# API principale
# ------------------------------------------------------------

proc analyze_alignment
    ty: &tm_ty::Type
    policy: &AlignPolicy
    cache: &mut AlignCache
-> Alignment

    if cache.map.contains(ty.id)
        give cache.map.get(ty.id).unwrap()
    .end

    let align =
        compute_alignment(
            ty,
            policy,
            cache
        )

    cache.map.insert(
        ty.id,
        align
    )

    give align
.end


# ------------------------------------------------------------
# Calcul cœur
# ------------------------------------------------------------

proc compute_alignment
    ty: &tm_ty::Type
    policy: &AlignPolicy
    cache: &mut AlignCache
-> Alignment

    select ty.kind

        # ----------------------------------------------------
        # Types scalaires
        # ----------------------------------------------------

        when tm_ty::TypeKind::Bool
            give Alignment::new(1, 1)

        when tm_ty::TypeKind::I8
            give Alignment::new(1, 1)

        when tm_ty::TypeKind::I16
            give Alignment::new(2, 2)

        when tm_ty::TypeKind::I32
            give Alignment::new(4, 4)

        when tm_ty::TypeKind::I64
            give Alignment::new(8, 8)

        when tm_ty::TypeKind::F32
            give Alignment::new(4, 4)

        when tm_ty::TypeKind::F64
            give Alignment::new(8, 8)


        # ----------------------------------------------------
        # Pointeurs
        # ----------------------------------------------------

        when tm_ty::TypeKind::Pointer
            let a = policy.pointer_align
            give Alignment::new(a, a)


        # ----------------------------------------------------
        # Tableaux
        # ----------------------------------------------------

        when tm_ty::TypeKind::Array
            let elem_align =
                analyze_alignment(
                    ty.elem,
                    policy,
                    cache
                )
            # Un tableau est aligné comme son élément
            give Alignment::new(
                elem_align.min,
                elem_align.pref
            )


        # ----------------------------------------------------
        # Structs (records)
        # ----------------------------------------------------

        when tm_ty::TypeKind::Struct
            let mut max_min = 1
            let mut max_pref = 1

            for field in ty.fields
                let a =
                    analyze_alignment(
                        field.ty,
                        policy,
                        cache
                    )
                max_min = math::max(max_min, a.min)
                max_pref = math::max(max_pref, a.pref)
            .end

            # Limite par la politique cible
            max_pref = math::min(max_pref, policy.max_align)

            give Alignment::new(
                max_min,
                max_pref
            )


        # ----------------------------------------------------
        # Unions
        # ----------------------------------------------------

        when tm_ty::TypeKind::Union
            let mut max_min = 1
            let mut max_pref = 1

            for variant in ty.variants
                let a =
                    analyze_alignment(
                        variant.ty,
                        policy,
                        cache
                    )
                max_min = math::max(max_min, a.min)
                max_pref = math::max(max_pref, a.pref)
            .end

            max_pref = math::min(max_pref, policy.max_align)

            give Alignment::new(
                max_min,
                max_pref
            )


        # ----------------------------------------------------
        # Opaque / extern
        # ----------------------------------------------------

        when tm_ty::TypeKind::Opaque
            # Alignement conservateur
            give Alignment::new(
                policy.pointer_align,
                policy.pointer_align
            )


        otherwise
            # Fallback sûr
            give Alignment::new(1, 1)
    .end
.end


# ------------------------------------------------------------
# Helpers publics
# ------------------------------------------------------------

proc alignment_of
    ty: &tm_ty::Type
-> u32

    let policy = AlignPolicy::default()
    let mut cache = AlignCache::new()

    let a =
        analyze_alignment(
            ty,
            &policy,
            &mut cache
        )

    give a.min
.end


proc preferred_alignment_of
    ty: &tm_ty::Type
-> u32

    let policy = AlignPolicy::default()
    let mut cache = AlignCache::new()

    let a =
        analyze_alignment(
            ty,
            &policy,
            &mut cache
        )

    give a.pref
.end
