# ============================================================
# vitte_codegen_ssa::opt::cfg
# Optimisations et normalisation du CFG SSA
# ============================================================

space vitte/compiler/backends/vitte_codegen_ssa/opt

pull vitte/compiler/backends/vitte_codegen_ssa/ir/mod as ssa_mod
pull vitte/compiler/backends/vitte_codegen_ssa/ir/function as ssa_fn
pull vitte/compiler/backends/vitte_codegen_ssa/ir/block as ssa_block
pull vitte/compiler/backends/vitte_codegen_ssa/ir/terminator as ssa_term

pull std/collections/map as Map
pull std/collections/set as Set
pull std/collections/list as List


# ------------------------------------------------------------
# API publique — optimisation CFG module
# ------------------------------------------------------------

proc optimize_cfg
    module: &mut ssa_mod::Module
-> ()

    for (_, func) in module.functions
        optimize_function_cfg(func)
    .end
.end


# ------------------------------------------------------------
# CFG par fonction
# ------------------------------------------------------------

proc optimize_function_cfg
    func: &mut ssa_fn::Function
-> ()

    remove_unreachable_blocks(func)
    simplify_trivial_branches(func)
    merge_linear_blocks(func)
.end


# ------------------------------------------------------------
# Suppression des blocs inaccessibles
# ------------------------------------------------------------

proc remove_unreachable_blocks
    func: &mut ssa_fn::Function
-> ()

    let mut reachable = Set::new()

    dfs_mark(
        func,
        func.entry,
        &mut reachable
    )

    let mut to_remove = List::new()

    for (bid, _) in func.blocks
        if not reachable.contains(bid)
            to_remove.push(bid)
        .end
    .end

    for bid in to_remove
        remove_block(func, bid)
    .end
.end


proc dfs_mark
    func: &ssa_fn::Function
    bid: ssa_block::BlockId
    visited: &mut Set<ssa_block::BlockId>
-> ()

    if visited.contains(bid)
        return
    .end

    visited.insert(bid)

    let block = func.get_block(bid)
    for succ in block.succs
        dfs_mark(func, succ, visited)
    .end
.end


proc remove_block
    func: &mut ssa_fn::Function
    bid: ssa_block::BlockId
-> ()

    let block = func.blocks.remove(bid)
    if block.is_none()
        return
    .end

    # Mise à jour des prédécesseurs / successeurs
    let blk = block.unwrap()

    for pred in blk.preds
        let pb = func.get_block_mut(pred)
        pb.remove_succ(bid)
    .end

    for succ in blk.succs
        let sb = func.get_block_mut(succ)
        sb.remove_pred(bid)
    .end
.end


# ------------------------------------------------------------
# Simplification des branches triviales
# ------------------------------------------------------------

proc simplify_trivial_branches
    func: &mut ssa_fn::Function
-> ()

    for (_, block) in func.blocks
        let term = block.terminator

        if term.kind == ssa_term::TerminatorKind::Branch
            if term.then_block == term.else_block
                # br cond A A  =>  jmp A
                let target = term.then_block

                block.set_terminator(
                    ssa_term::Terminator::jump(
                        target
                    )
                )

                # CFG update
                block.succs.clear()
                block.add_succ(target)

                let tb = func.get_block_mut(target)
                tb.preds.insert(block.id)
            .end
        .end
    .end
.end


# ------------------------------------------------------------
# Fusion de blocs linéaires
# ------------------------------------------------------------

proc merge_linear_blocks
    func: &mut ssa_fn::Function
-> ()

    let mut changed = true

    while changed
        changed = false

        for (bid, block) in func.blocks
            # bloc avec un seul successeur
            if block.succs.len() != 1
                continue
            .end

            let succ = block.succs.first()

            # ne pas fusionner l’entrée
            if bid == func.entry
                continue
            .end

            let succ_block = func.get_block(succ)

            # successeur avec un seul prédécesseur
            if succ_block.preds.len() != 1
                continue
            .end

            # Fusion possible
            merge_blocks(func, bid, succ)
            changed = true
            break
        .end
    .end
.end


proc merge_blocks
    func: &mut ssa_fn::Function
    from: ssa_block::BlockId
    to: ssa_block::BlockId
-> ()

    let from_block =
        func.get_block_mut(from)
    let to_block =
        func.get_block(to)

    # déplacer les instructions
    for inst in to_block.instructions
        from_block.append(inst)
    .end

    # remplacer le terminator
    from_block.set_terminator(
        to_block.terminator
    )

    # mettre à jour successeurs
    from_block.succs.clear()
    for succ in to_block.succs
        from_block.add_succ(succ)
        let sb = func.get_block_mut(succ)
        sb.remove_pred(to)
        sb.add_pred(from)
    .end

    # supprimer le bloc cible
    func.blocks.remove(to)
.end
