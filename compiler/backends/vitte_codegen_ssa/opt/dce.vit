# ============================================================
# vitte_codegen_ssa::opt::dce
# Dead Code Elimination (SSA)
# ============================================================

space vitte/compiler/backends/vitte_codegen_ssa/opt

pull vitte/compiler/backends/vitte_codegen_ssa/ir/mod as ssa_mod
pull vitte/compiler/backends/vitte_codegen_ssa/ir/function as ssa_fn
pull vitte/compiler/backends/vitte_codegen_ssa/ir/block as ssa_block
pull vitte/compiler/backends/vitte_codegen_ssa/ir/instruction as ssa_inst
pull vitte/compiler/backends/vitte_codegen_ssa/ir/value as ssa_val
pull vitte/compiler/backends/vitte_codegen_ssa/ir/terminator as ssa_term

pull std/collections/map as Map
pull std/collections/set as Set
pull std/collections/list as List


# ------------------------------------------------------------
# API publique — DCE module
# ------------------------------------------------------------

proc optimize_dce
    module: &mut ssa_mod::Module
-> ()

    for (_, func) in module.functions
        eliminate_function_dead_code(func)
    .end
.end


# ------------------------------------------------------------
# DCE par fonction
# ------------------------------------------------------------

proc eliminate_function_dead_code
    func: &mut ssa_fn::Function
-> ()

    let live = compute_live_values(func)

    for (_, block) in func.blocks
        let mut new_insts = List<ssa_inst::Instruction>::new()

        for inst in block.instructions
            if inst.has_result()
                let res = inst.result.unwrap()
                if live.contains(res.id)
                    new_insts.push(inst)
                .end
            otherwise
                # instruction sans résultat (ex: call void)
                new_insts.push(inst)
            .end
        .end

        block.instructions = new_insts
    .end
.end


# ------------------------------------------------------------
# Analyse de vivacité SSA
# ------------------------------------------------------------

proc compute_live_values
    func: &ssa_fn::Function
-> Set<ssa_val::ValueId>

    let mut live = Set<ssa_val::ValueId>::new()
    let mut work = List<ssa_val::ValueId>::new()

    # --------------------------------------------------------
    # Racines de vivacité
    # --------------------------------------------------------

    for (_, block) in func.blocks
        let term = block.terminator

        select term.kind
            when ssa_term::TerminatorKind::Return
                if term.value.is_some()
                    let v = term.value.unwrap()
                    live.insert(v.id)
                    work.push(v.id)
                .end

            when ssa_term::TerminatorKind::Branch
                let c = term.cond
                live.insert(c.id)
                work.push(c.id)

            otherwise
                ()
        .end
    .end

    # Instructions à effets de bord
    for (_, block) in func.blocks
        for inst in block.instructions
            if has_side_effect(inst)
                if inst.has_result()
                    let r = inst.result.unwrap()
                    live.insert(r.id)
                    work.push(r.id)
                .end
            .end
        .end
    .end

    # --------------------------------------------------------
    # Propagation arrière SSA
    # --------------------------------------------------------

    while not work.is_empty()
        let vid = work.pop()

        let def_inst = find_def(func, vid)
        if def_inst.is_none()
            continue
        .end

        let inst = def_inst.unwrap()

        for op in inst.operands
            if not live.contains(op.id)
                live.insert(op.id)
                work.push(op.id)
            .end
        .end
    .end

    give live
.end


# ------------------------------------------------------------
# Détection des effets de bord
# ------------------------------------------------------------

proc has_side_effect
    inst: &ssa_inst::Instruction
-> bool

    select inst.opcode
        when ssa_inst::Opcode::Call
            give true        # appel inconnu
        when ssa_inst::Opcode::Store
            give true
        when ssa_inst::Opcode::Load
            give true
        otherwise
            give false
    .end
.end


# ------------------------------------------------------------
# Recherche de l’instruction définissant une valeur
# ------------------------------------------------------------

proc find_def
    func: &ssa_fn::Function
    vid: ssa_val::ValueId
-> Option<&ssa_inst::Instruction>

    for (_, block) in func.blocks
        for inst in block.instructions
            if inst.has_result()
                if inst.result.unwrap().id == vid
                    give Some(inst)
                .end
            .end
        .end
    .end

    give None
.end
