# ============================================================
# vitte_codegen_ssa::emit::mod
# Émission du backend SSA (référence, debug, tests)
# ============================================================

space vitte/compiler/backends/vitte_codegen_ssa/emit

pull vitte/compiler/backends/vitte_codegen_ssa/ir as ssa
pull vitte/compiler/backends/vitte_codegen_ssa/context as ssa_ctx
pull vitte/compiler/backends/vitte_codegen_ssa/errors as ssa_err

pull std/io as io
pull std/collections/list as List


# ------------------------------------------------------------
# Formats de sortie SSA
# ------------------------------------------------------------

pick EmitFormat
    case Text        # SSA lisible (debug)
    case Binary      # SSA sérialisé (interne)
.end


# ------------------------------------------------------------
# API principale — émission d’un module SSA
# ------------------------------------------------------------

proc emit_module
    ctx: &ssa_ctx::CodegenCtx
    module: &ssa::Module
    format: EmitFormat
-> bytes

    select format
        when EmitFormat::Text
            give emit_text(ctx, module)
        when EmitFormat::Binary
            give emit_binary(ctx, module)
        otherwise
            ssa_err::panic(
                "unsupported SSA emit format"
            )
    .end
.end


# ------------------------------------------------------------
# Émission texte (SSA lisible)
# ------------------------------------------------------------

proc emit_text
    ctx: &ssa_ctx::CodegenCtx
    module: &ssa::Module
-> bytes

    let mut out = io::Buffer::new()

    out.write("; =============================================\n")
    out.write("; Vitte SSA Module\n")
    out.write("; name: ")
    out.write(module.name)
    out.write("\n")
    out.write("; =============================================\n\n")

    for func in module.functions
        emit_function_text(out, func)
        out.write("\n")
    .end

    give out.into_bytes()
.end


proc emit_function_text
    out: &mut io::Buffer
    func: &ssa::Function
-> ()

    out.write("func ")
    out.write(func.name)
    out.write("(")

    let mut first = true
    for param in func.params
        if not first
            out.write(", ")
        .end
        first = false

        out.write("%")
        out.write(param.name)
        out.write(": ")
        out.write(param.ty.to_string())
    .end

    out.write(")")
    out.write(" -> ")
    out.write(func.ret_ty.to_string())
    out.write(" {\n")

    for block in func.blocks
        emit_block_text(out, block)
    .end

    out.write("}\n")
.end


proc emit_block_text
    out: &mut io::Buffer
    block: &ssa::Block
-> ()

    out.write("  ")
    out.write(block.label)
    out.write(":\n")

    for inst in block.instructions
        out.write("    ")
        emit_inst_text(out, inst)
        out.write("\n")
    .end

    out.write("    ")
    emit_terminator_text(out, block.terminator)
    out.write("\n")
.end


proc emit_inst_text
    out: &mut io::Buffer
    inst: &ssa::Instruction
-> ()

    if inst.has_result()
        out.write("%")
        out.write(inst.result.name)
        out.write(" = ")
    .end

    out.write(inst.opcode.to_string())

    for op in inst.operands
        out.write(" ")
        emit_value_text(out, op)
    .end
.end


proc emit_terminator_text
    out: &mut io::Buffer
    term: &ssa::Terminator
-> ()

    select term.kind
        when ssa::TerminatorKind::Return
            out.write("ret")
            if term.value.is_some()
                out.write(" ")
                emit_value_text(out, term.value.unwrap())
            .end

        when ssa::TerminatorKind::Jump
            out.write("jmp ")
            out.write(term.target)

        when ssa::TerminatorKind::Branch
            out.write("br ")
            emit_value_text(out, term.cond)
            out.write(" ")
            out.write(term.then_block)
            out.write(" ")
            out.write(term.else_block)

        otherwise
            out.write("unreachable")
    .end
.end


proc emit_value_text
    out: &mut io::Buffer
    val: &ssa::Value
-> ()

    select val.kind
        when ssa::ValueKind::Const
            out.write(val.const_value.to_string())

        when ssa::ValueKind::Param
            out.write("%")
            out.write(val.name)

        when ssa::ValueKind::Temp
            out.write("%")
            out.write(val.name)

        otherwise
            out.write("<invalid>")
    .end
.end


# ------------------------------------------------------------
# Émission binaire (SSA sérialisé)
# ------------------------------------------------------------

proc emit_binary
    ctx: &ssa_ctx::CodegenCtx
    module: &ssa::Module
-> bytes

    # Format volontairement simple :
    # [magic][version][functions...]

    let mut out = io::Buffer::new()

    out.write_u32(0x56535341)   # 'VSSA'
    out.write_u16(1)            # version

    out.write_u32(module.functions.len())

    for func in module.functions
        emit_function_binary(out, func)
    .end

    give out.into_bytes()
.end


proc emit_function_binary
    out: &mut io::Buffer
    func: &ssa::Function
-> ()

    out.write_string(func.name)
    out.write_u32(func.params.len())

    for param in func.params
        out.write_string(param.name)
        out.write_u16(param.ty.id)
    .end

    out.write_u16(func.ret_ty.id)
    out.write_u32(func.blocks.len())

    for block in func.blocks
        emit_block_binary(out, block)
    .end
.end


proc emit_block_binary
    out: &mut io::Buffer
    block: &ssa::Block
-> ()

    out.write_string(block.label)
    out.write_u32(block.instructions.len())

    for inst in block.instructions
        emit_inst_binary(out, inst)
    .end

    emit_terminator_binary(out, block.terminator)
.end


proc emit_inst_binary
    out: &mut io::Buffer
    inst: &ssa::Instruction
-> ()

    out.write_u16(inst.opcode.id)

    if inst.has_result()
        out.write_string(inst.result.name)
        out.write_u16(inst.result.ty.id)
    .end

    out.write_u16(inst.operands.len())
    for op in inst.operands
        out.write_u16(op.id)
    .end
.end


proc emit_terminator_binary
    out: &mut io::Buffer
    term: &ssa::Terminator
-> ()

    out.write_u8(term.kind.id)

    select term.kind
        when ssa::TerminatorKind::Return
            if term.value.is_some()
                out.write_u16(term.value.unwrap().id)
            otherwise
                out.write_u16(0xFFFF)
            .end

        when ssa::TerminatorKind::Jump
            out.write_string(term.target)

        when ssa::TerminatorKind::Branch
            out.write_u16(term.cond.id)
            out.write_string(term.then_block)
            out.write_string(term.else_block)

        otherwise
            ()
    .end
.end
