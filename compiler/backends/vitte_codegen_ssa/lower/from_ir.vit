# ============================================================
# vitte_codegen_ssa::lower::from_ir
# Abaissement MIR -> SSA canonique
# ============================================================

space vitte/compiler/backends/vitte_codegen_ssa/lower

# MIR source
pull vitte/compiler/mir/ast as mir
pull vitte/compiler/mir/types as mir_ty

# SSA cible
pull vitte/compiler/backends/vitte_codegen_ssa/ir/module as ssa_mod
pull vitte/compiler/backends/vitte_codegen_ssa/ir/function as ssa_fn
pull vitte/compiler/backends/vitte_codegen_ssa/ir/block as ssa_block
pull vitte/compiler/backends/vitte_codegen_ssa/ir/value as ssa_val
pull vitte/compiler/backends/vitte_codegen_ssa/ir/instruction as ssa_inst
pull vitte/compiler/backends/vitte_codegen_ssa/ir/terminator as ssa_term
pull vitte/compiler/backends/vitte_codegen_ssa/ir/type as ssa_ty

pull vitte/compiler/backends/vitte_codegen_ssa/context as ssa_ctx
pull vitte/compiler/backends/vitte_codegen_ssa/errors as ssa_err

pull std/collections/map as Map
pull std/collections/list as List


# ------------------------------------------------------------
# Contexte de lowering MIR -> SSA
# ------------------------------------------------------------

form LowerCtx
    ctx: &mut ssa_ctx::CodegenCtx
    module: &mut ssa_mod::Module
    func: &mut ssa_fn::Function

    # mapping MIR local -> SSA value
    locals: Map<mir::LocalId, ssa_val::Value>

    # mapping MIR block -> SSA block
    blocks: Map<mir::BlockId, ssa_block::BlockId>
.end


# ------------------------------------------------------------
# Entrée principale
# ------------------------------------------------------------

proc lower_from_mir
    ctx: &mut ssa_ctx::CodegenCtx
    program: &mir::Program
-> ssa_mod::Module

    let mut module =
        ssa_mod::Module::new(
            program.name
        )

    for func in program.functions
        lower_function(
            ctx,
            &mut module,
            func
        )
    .end

    give module
.end


# ------------------------------------------------------------
# Fonction MIR -> SSA
# ------------------------------------------------------------

proc lower_function
    ctx: &mut ssa_ctx::CodegenCtx
    module: &mut ssa_mod::Module
    mir_fn: &mir::Function
-> ()

    # Paramètres SSA
    let mut params = List::new()
    for p in mir_fn.params
        let ty = lower_type(p.ty)
        params.push(
            ssa_fn::Param {
                id = p.id,
                name = p.name,
                ty = ty
            }
        )
    .end

    let ret_ty =
        if mir_fn.returns_void
            ssa_ty::Type::unit()
        otherwise
            lower_type(mir_fn.ret_ty)
        .end

    let mut func =
        ssa_fn::Function::new(
            mir_fn.id,
            mir_fn.name,
            params,
            ret_ty
        )

    let mut lctx =
        LowerCtx {
            ctx = ctx
            module = module
            func = &mut func
            locals = Map::new()
            blocks = Map::new()
        }

    # --------------------------------------------------------
    # Création des blocs SSA
    # --------------------------------------------------------

    for b in mir_fn.blocks
        let bid =
            lctx.func.new_block(
                b.label
            )
        lctx.blocks.insert(
            b.id,
            bid
        )
    .end

    # --------------------------------------------------------
    # Paramètres -> valeurs SSA
    # --------------------------------------------------------

    for param in func.params
        let val =
            lctx.func.new_value(
                ssa_val::ValueKind::Param,
                param.ty,
                param.name
            )
        lctx.locals.insert(
            param.id,
            val
        )
    .end

    # --------------------------------------------------------
    # Blocs MIR -> SSA
    # --------------------------------------------------------

    for b in mir_fn.blocks
        lower_block(
            &mut lctx,
            b
        )
    .end

    # Validation SSA locale
    if not func.validate()
        ssa_err::panic(
            "SSA validation failed for function " + func.name
        )
    .end

    module.add_function(func)
.end


# ------------------------------------------------------------
# Bloc MIR -> SSA
# ------------------------------------------------------------

proc lower_block
    lctx: &mut LowerCtx
    mir_block: &mir::Block
-> ()

    let bid = lctx.blocks.get(mir_block.id).unwrap()
    let block = lctx.func.get_block_mut(bid)

    # --------------------------------------------------------
    # Instructions MIR
    # --------------------------------------------------------

    for stmt in mir_block.stmts
        lower_stmt(
            lctx,
            block,
            stmt
        )
    .end

    # --------------------------------------------------------
    # Terminator
    # --------------------------------------------------------

    let term =
        lower_terminator(
            lctx,
            mir_block.terminator
        )

    block.set_terminator(term)
.end


# ------------------------------------------------------------
# Statement MIR -> SSA
# ------------------------------------------------------------

proc lower_stmt
    lctx: &mut LowerCtx
    block: &mut ssa_block::Block
    stmt: &mir::Stmt
-> ()

    select stmt.kind
        when mir::StmtKind::Assign
            let rhs =
                lower_expr(
                    lctx,
                    block,
                    stmt.value
                )

            lctx.locals.insert(
                stmt.target,
                rhs
            )

        when mir::StmtKind::Expr
            lower_expr(
                lctx,
                block,
                stmt.expr
            )

        otherwise
            ssa_err::panic(
                "unsupported MIR stmt in SSA lowering"
            )
    .end
.end


# ------------------------------------------------------------
# Expression MIR -> SSA
# ------------------------------------------------------------

proc lower_expr
    lctx: &mut LowerCtx
    block: &mut ssa_block::Block
    expr: &mir::Expr
-> ssa_val::Value

    select expr.kind
        when mir::ExprKind::Const
            give lctx.func.new_value(
                ssa_val::ValueKind::Const,
                lower_type(expr.ty),
                expr.value.to_string()
            )

        when mir::ExprKind::Local
            give lctx.locals.get(expr.local).unwrap()

        when mir::ExprKind::Binary
            let lhs =
                lower_expr(
                    lctx,
                    block,
                    expr.lhs
                )
            let rhs =
                lower_expr(
                    lctx,
                    block,
                    expr.rhs
                )

            let res =
                lctx.func.new_value(
                    ssa_val::ValueKind::Temp,
                    lower_type(expr.ty),
                    "t" + lctx.func.next_value_id.to_string()
                )

            block.append(
                ssa_inst::Instruction::binary(
                    expr.op,
                    lhs,
                    rhs,
                    res
                )
            )

            give res

        when mir::ExprKind::Call
            let mut args = List::new()
            for a in expr.args
                args.push(
                    lower_expr(
                        lctx,
                        block,
                        a
                    )
                )
            .end

            let res =
                if expr.ty.is_void()
                    ssa_val::Value::invalid()
                otherwise
                    lctx.func.new_value(
                        ssa_val::ValueKind::Temp,
                        lower_type(expr.ty),
                        "call" + lctx.func.next_value_id.to_string()
                    )
                .end

            block.append(
                ssa_inst::Instruction::call(
                    expr.fn,
                    args,
                    res
                )
            )

            give res

        otherwise
            ssa_err::panic(
                "unsupported MIR expr in SSA lowering"
            )
    .end
.end


# ------------------------------------------------------------
# Terminator MIR -> SSA
# ------------------------------------------------------------

proc lower_terminator
    lctx: &mut LowerCtx
    term: &mir::Terminator
-> ssa_term::Terminator

    select term.kind
        when mir::TerminatorKind::Return
            if term.value.is_some()
                give ssa_term::Terminator::ret(
                    lower_expr(
                        lctx,
                        lctx.func.get_block_mut(
                            lctx.blocks.get(term.block).unwrap()
                        ),
                        term.value.unwrap()
                    )
                )
            otherwise
                give ssa_term::Terminator::ret_void()
            .end

        when mir::TerminatorKind::Goto
            let to =
                lctx.blocks.get(term.target).unwrap()
            lctx.func.connect(
                lctx.blocks.get(term.block).unwrap(),
                to
            )
            give ssa_term::Terminator::jump(to)

        when mir::TerminatorKind::If
            let cond =
                lower_expr(
                    lctx,
                    lctx.func.get_block_mut(
                        lctx.blocks.get(term.block).unwrap()
                    ),
                    term.cond
                )

            let then_b =
                lctx.blocks.get(term.then_block).unwrap()
            let else_b =
                lctx.blocks.get(term.else_block).unwrap()

            lctx.func.connect(
                lctx.blocks.get(term.block).unwrap(),
                then_b
            )
            lctx.func.connect(
                lctx.blocks.get(term.block).unwrap(),
                else_b
            )

            give ssa_term::Terminator::branch(
                cond,
                then_b,
                else_b
            )

        otherwise
            ssa_err::panic(
                "unsupported MIR terminator in SSA lowering"
            )
    .end
.end


# ------------------------------------------------------------
# Types MIR -> SSA
# ------------------------------------------------------------

proc lower_type
    ty: &mir_ty::Type
-> ssa_ty::Type

    select ty.kind
        when mir_ty::TypeKind::I32
            give ssa_ty::Type::i32()
        when mir_ty::TypeKind::I64
            give ssa_ty::Type::i64()
        when mir_ty::TypeKind::Bool
            give ssa_ty::Type::bool()
        when mir_ty::TypeKind::Unit
            give ssa_ty::Type::unit()
        otherwise
            ssa_err::panic(
                "unsupported MIR type in SSA lowering"
            )
    .end
.end
