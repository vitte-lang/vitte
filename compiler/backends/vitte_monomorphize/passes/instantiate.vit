# ============================================================
# Vitte â€” Monomorphization Pass
# File: instantiate.vit
#
# Role:
#   Instantiate (clone) all generic functions and types
#   previously collected by collect.vit.
#
# This pass:
#   - Creates concrete MIR items
#   - Registers old_id -> new_id mappings
#   - Does NOT rewrite call sites
#
# ============================================================

space compiler/backends/vitte_monomorphize/passes/instantiate

pull compiler/backends/vitte_mir_dataflow/context
pull compiler/backends/vitte_mir_dataflow/mir
pull compiler/backends/vitte_mir_dataflow/types

pull compiler/backends/vitte_monomorphize/context as mono_ctx
pull compiler/backends/vitte_monomorphize/keys
pull compiler/backends/vitte_monomorphize/errors


# ------------------------------------------------------------
# Public entry point
# ------------------------------------------------------------

proc instantiate_monomorphizations(
    ctx: &mut mono_ctx::MonomorphizeContext,
    mir: &mut mir::MirModule
)
gives ()
.end
    let inst = Instantiator::new(ctx, mir)
    inst.run()
.end


# ============================================================
# Instantiator
# ============================================================

form Instantiator
    ctx: &mut mono_ctx::MonomorphizeContext
    mir: &mut mir::MirModule
.end


proc Instantiator::new(
    ctx: &mut mono_ctx::MonomorphizeContext,
    mir: &mut mir::MirModule
)
gives Instantiator
.end
    give Instantiator { ctx, mir }
.end


# ------------------------------------------------------------
# Main driver
# ------------------------------------------------------------

proc Instantiator::run(self)
gives ()
.end
    self.instantiate_types()
    self.instantiate_functions()
.end


# ============================================================
# Type instantiation
# ============================================================

proc Instantiator::instantiate_types(self)
gives ()
.end
    for key in self.ctx.type_requests.iter()
        if self.ctx.has_type_instance(key)
            continue
        end

        self.instantiate_type(key)
    end
.end


proc Instantiator::instantiate_type(
    self,
    key: &keys::TypeMonoKey
)
gives ()
.end
    let generic = self.mir.types.get(key.base_type)
        else errors::missing_type(key.base_type)

    let concrete = self.clone_type(generic, key.generic_args)

    let new_id = self.mir.types.insert(concrete)

    self.ctx.register_type_instance(
        key.clone(),
        new_id
    )
.end


proc Instantiator::clone_type(
    self,
    ty: &mir::MirTypeDef,
    args: &Vec<types::Type>
)
gives mir::MirTypeDef
.end
    let mut cloned = ty.clone()

    cloned.generic_params.clear()
    cloned.is_generic = false

    cloned = self.substitute_type_params(cloned, args)

    give cloned
.end


# ============================================================
# Function instantiation
# ============================================================

proc Instantiator::instantiate_functions(self)
gives ()
.end
    for key in self.ctx.fn_requests.iter()
        if self.ctx.has_fn_instance(key)
            continue
        end

        self.instantiate_function(key)
    end
.end


proc Instantiator::instantiate_function(
    self,
    key: &keys::FnMonoKey
)
gives ()
.end
    let generic = self.mir.functions.get(key.fn_id)
        else errors::missing_function(key.fn_id)

    let concrete = self.clone_function(
        generic,
        key.generic_args
    )

    let new_id = self.mir.functions.insert(concrete)

    self.ctx.register_fn_instance(
        key.clone(),
        new_id
    )
.end


proc Instantiator::clone_function(
    self,
    fn: &mir::MirFunction,
    args: &Vec<types::Type>
)
gives mir::MirFunction
.end
    let mut cloned = fn.clone()

    cloned.generic_params.clear()
    cloned.is_generic = false

    cloned.signature = self.substitute_signature(
        cloned.signature,
        args
    )

    cloned.body = self.substitute_body(
        cloned.body,
        args
    )

    give cloned
.end


# ============================================================
# Substitution logic
# ============================================================

proc Instantiator::substitute_signature(
    self,
    sig: mir::MirFnSignature,
    args: &Vec<types::Type>
)
gives mir::MirFnSignature
.end
    let mut out = sig.clone()

    for param in out.params
        param.ty = self.substitute_type(param.ty, args)
    end

    if out.ret_ty.is_some()
        out.ret_ty = Some(
            self.substitute_type(out.ret_ty.unwrap(), args)
        )
    end

    give out
.end


proc Instantiator::substitute_body(
    self,
    body: mir::MirBody,
    args: &Vec<types::Type>
)
gives mir::MirBody
.end
    let mut out = body.clone()

    for block in out.blocks
        for stmt in block.statements
            self.substitute_statement(stmt, args)
        end
    end

    give out
.end


proc Instantiator::substitute_statement(
    self,
    stmt: &mut mir::MirStatement,
    args: &Vec<types::Type>
)
gives ()
.end
    select stmt
    when mir::MirStatement::Assign(_, expr)
        self.substitute_expr(expr, args)
    when mir::MirStatement::Call(call)
        for arg in call.args
            self.substitute_expr(arg, args)
        end
    otherwise
        ()
    end
.end


proc Instantiator::substitute_expr(
    self,
    expr: &mut mir::MirExpr,
    args: &Vec<types::Type>
)
gives ()
.end
    select expr
    when mir::MirExpr::Call(call)
        for arg in call.args
            self.substitute_expr(arg, args)
        end
    when mir::MirExpr::Construct(ctor)
        for g in ctor.generic_args
            g = self.substitute_type(g, args)
        end
    otherwise
        ()
    end
.end


proc Instantiator::substitute_type(
    self,
    ty: types::Type,
    args: &Vec<types::Type>
)
gives types::Type
.end
    select ty
    when types::Type::GenericParam(idx)
        give args[idx]
    when types::Type::GenericInstance(base, params)
        let mut out = params.clone()
        for i in 0 .. out.len()
            out[i] = self.substitute_type(out[i], args)
        end
        give types::Type::GenericInstance(base, out)
    otherwise
        give ty
    end
.end
