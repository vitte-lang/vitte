# ============================================================
# vitte_mir_build::lower::from_hir
# Lowering HIR -> MIR
# ============================================================

space vitte/compiler/backends/vitte_mir_build/lower


# ------------------------------------------------------------
# Imports
# ------------------------------------------------------------

pull vitte/compiler/backends/vitte_hir/ir/function as hir_fn
pull vitte/compiler/backends/vitte_hir/ir/block as hir_block
pull vitte/compiler/backends/vitte_hir/ir/expr as hir_expr
pull vitte/compiler/backends/vitte_hir/ir/stmt as hir_stmt

pull vitte/compiler/backends/vitte_mir/ir/function as mir_fn
pull vitte/compiler/backends/vitte_mir/ir/block as mir_block
pull vitte/compiler/backends/vitte_mir/ir/instr as mir_instr
pull vitte/compiler/backends/vitte_mir/ir/value as mir_val

pull std/collections/map as Map
pull std/collections/list as List


# ------------------------------------------------------------
# Contexte de lowering
# ------------------------------------------------------------

form LowerCtx
    next_block: u32
    next_value: u32
    locals: Map[hir_expr::ExprId, mir_val::ValueId]
.end


proc LowerCtx::new
-> LowerCtx

    give LowerCtx {
        next_block = 0
        next_value = 0
        locals = Map::new()
    }
.end


proc LowerCtx::new_block
    self: &mut LowerCtx
-> mir_block::BlockId

    let id = self.next_block
    self.next_block = self.next_block + 1
    give id
.end


proc LowerCtx::new_value
    self: &mut LowerCtx
-> mir_val::ValueId

    let id = self.next_value
    self.next_value = self.next_value + 1
    give id
.end


# ------------------------------------------------------------
# Point d’entrée principal
# ------------------------------------------------------------

proc lower_function_from_hir
    func: &hir_fn::Function
-> mir_fn::Function

    let mut ctx = LowerCtx::new()

    let mut blocks = List::new()

    # --------------------------------------------------------
    # Bloc d’entrée
    # --------------------------------------------------------

    let entry_id = ctx.new_block()
    let mut entry =
        mir_block::Block::new(entry_id)

    for stmt in func.body.iter()
        lower_stmt(&mut ctx, stmt, &mut entry)
    .end

    # Si aucun terminator explicite
    if not entry.has_terminator()
        entry.set_terminator(
            mir_block::Terminator::Return(None)
        )
    .end

    blocks.push(entry)

    # --------------------------------------------------------
    # Fonction MIR
    # --------------------------------------------------------

    give mir_fn::Function {
        name = func.name
        entry = entry_id
        blocks = blocks
    }
.end


# ------------------------------------------------------------
# Lowering des statements
# ------------------------------------------------------------

proc lower_stmt
    ctx: &mut LowerCtx
    stmt: &hir_stmt::Stmt
    block: &mut mir_block::Block
-> void

    select stmt.kind

        when hir_stmt::StmtKind::Let(id, expr)
            let v = lower_expr(ctx, expr, block)
            ctx.locals.insert(id, v)

        when hir_stmt::StmtKind::Expr(expr)
            lower_expr(ctx, expr, block)
            give

        when hir_stmt::StmtKind::Return(expr_opt)
            let mut v = None
            if expr_opt.is_some()
                v = Some(lower_expr(ctx, expr_opt.unwrap(), block))
            .end

            block.set_terminator(
                mir_block::Terminator::Return(v)
            )

        otherwise
            panic("unsupported HIR statement")
    .end
.end


# ------------------------------------------------------------
# Lowering des expressions
# ------------------------------------------------------------

proc lower_expr
    ctx: &mut LowerCtx
    expr: &hir_expr::Expr
    block: &mut mir_block::Block
-> mir_val::ValueId

    select expr.kind

        when hir_expr::ExprKind::Literal(lit)
            let id = ctx.new_value()
            block.push(
                mir_instr::Instr::Const(id, lit)
            )
            give id

        when hir_expr::ExprKind::Var(var_id)
            give ctx.locals.get(var_id)

        when hir_expr::ExprKind::Binary(op, lhs, rhs)
            let l = lower_expr(ctx, lhs, block)
            let r = lower_expr(ctx, rhs, block)

            let id = ctx.new_value()
            block.push(
                mir_instr::Instr::Binary(id, op, l, r)
            )
            give id

        when hir_expr::ExprKind::Call(name, args)
            let mut mir_args = List::new()
            for a in args.iter()
                mir_args.push(lower_expr(ctx, a, block))
            .end

            let id = ctx.new_value()
            block.push(
                mir_instr::Instr::Call(id, name, mir_args)
            )
            give id

        otherwise
            panic("unsupported HIR expression")
    .end
.end
