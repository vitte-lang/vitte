# ============================================================
# vitte_mir_build::opt::dce
# Dead Code Elimination (MIR)
# ============================================================

space vitte/compiler/backends/vitte_mir_build/opt


pull vitte/compiler/backends/vitte_mir_build/mir/mod as mir
pull vitte/compiler/backends/vitte_mir_build/analysis/mod as analysis

pull std/collections/set as Set
pull std/collections/list as List


# ------------------------------------------------------------
# Effets de bord
# ------------------------------------------------------------

# Détermine si une instruction a des effets de bord
# (doit être conservée même si son résultat n'est pas utilisé)
proc has_side_effects
    instr: &mir::Instr
-> bool

    select instr
        when mir::Instr::Call(_, _, _)
            give true
        otherwise
            give false
    .end
.end


# ------------------------------------------------------------
# DCE intra-bloc
# ------------------------------------------------------------

proc dce_block
    block: &mut mir::Block
    live_out: &Set[mir::ValueId]
-> bool

    let mut changed = false

    # Ensemble des valeurs vivantes à la sortie du bloc
    let mut live = live_out.clone()

    # Parcours inverse des instructions
    let mut new_instrs = List::new()

    let i = block.instructions.len
    while i > 0
        let idx = i - 1
        let instr = block.instructions[idx]

        if instr.defines()
            let def = instr.def_id()

            if not live.contains(def) and not has_side_effects(&instr)
                # instruction morte -> supprimée
                changed = true
                # ne pas ajouter l'instruction
            .end
            otherwise
                # instruction conservée
                # mettre à jour la vivacité
                for v in instr.uses().iter()
                    live.insert(v)
                .end
                new_instrs.push_front(instr)
            .end
        .end
        otherwise
            # instruction sans définition (sécurité)
            for v in instr.uses().iter()
                live.insert(v)
            .end
            new_instrs.push_front(instr)
        .end

        i = idx
    .end

    block.instructions = new_instrs
    give changed
.end


# ------------------------------------------------------------
# DCE sur une fonction MIR
# ------------------------------------------------------------

proc dce_function
    func: &mut mir::Function
-> bool

    let mut changed = false

    # Analyse de vivacité
    let live = analysis::analyze_liveness(func)

    # Appliquer DCE bloc par bloc
    for b in func.blocks.iter_mut()
        let info = live.per_block.get(b.id)

        let c =
            dce_block(
                b,
                &info.live_out
            )

        if c
            changed = true
        .end
    .end

    give changed
.end


# ------------------------------------------------------------
# Passe DCE complète (point fixe)
# ------------------------------------------------------------

proc run_dce
    func: &mut mir::Function
-> void

    let mut changed = true

    while changed
        changed = dce_function(func)
    .end
.end
