# ============================================================
# vitte_mir_build::opt::simplify
# Simplifications MIR
# ============================================================

space vitte/compiler/backends/vitte_mir_build/opt


pull vitte/compiler/backends/vitte_mir_build/mir/mod as mir
pull vitte/compiler/backends/vitte_mir_build/analysis/mod as analysis

pull std/collections/set as Set
pull std/collections/list as List


# ------------------------------------------------------------
# Simplification des terminators
# ------------------------------------------------------------

proc simplify_terminator
    block: &mut mir::Block
-> bool

    if block.terminator.is_none()
        give false
    .end

    let term = block.terminator.unwrap()

    select term
        # if cond goto A else A  => goto A
        when mir::Terminator::If(_, then_bb, else_bb)
            if then_bb == else_bb
                block.terminator =
                    Some(mir::Terminator::Goto(then_bb))
                give true
            .end
        otherwise
            give false
    .end
.end


# ------------------------------------------------------------
# Suppression des blocs inaccessibles
# ------------------------------------------------------------

proc remove_unreachable_blocks
    func: &mut mir::Function
-> bool

    let cfg = analysis::build_cfg(func)
    let dead = analysis::unreachable_blocks(&cfg)

    if dead.is_empty()
        give false
    .end

    let mut new_blocks = List::new()

    for b in func.blocks.iter()
        if not dead.contains(b.id)
            new_blocks.push(b)
        .end
    .end

    func.blocks = new_blocks
    give true
.end


# ------------------------------------------------------------
# Fusion de blocs simples
# ------------------------------------------------------------

# Cas:
#   A -> goto B
#   B a un seul prédécesseur (A)
# => fusion A + B
proc merge_linear_blocks
    func: &mut mir::Function
-> bool

    let cfg = analysis::build_cfg(func)
    let mut changed = false

    for b in func.blocks.iter_mut()

        if b.terminator.is_some()
            let term = b.terminator.unwrap()

            select term
                when mir::Terminator::Goto(target)

                    let preds =
                        cfg.predecessors(&cfg, target)

                    if preds.len == 1 and preds.contains(b.id)

                        let target_block =
                            func.get_block_mut(target)

                        # déplacer instructions
                        for i in target_block.instructions.iter()
                            b.instructions.push(i)
                        .end

                        # reprendre terminator
                        b.terminator = target_block.terminator

                        # marquer bloc cible vide
                        target_block.instructions = List::new()
                        target_block.terminator =
                            Some(mir::Terminator::Unreachable)

                        changed = true
                    .end
                otherwise
            .end
        .end
    .end

    give changed
.end


# ------------------------------------------------------------
# Passe globale de simplification
# ------------------------------------------------------------

proc run_simplify
    func: &mut mir::Function
-> void

    let mut changed = true

    while changed
        changed = false

        if remove_unreachable_blocks(func)
            changed = true
        .end

        if merge_linear_blocks(func)
            changed = true
        .end

        for b in func.blocks.iter_mut()
            if simplify_terminator(b)
                changed = true
            .end
        .end
    .end
.end
