(* =============================================================================
   Grammaire Vitte – syntaxe nouvelle simple inspirée de Python/Ruby

   L'objectif est de proposer une syntaxe lisible, accessible dès le lycée, avec :
   * une indentation significative ou des blocs entre accolades,
   * une collection de mots-clés maîtrisée (lexique décrit ci-dessous),
   * des fichiers Muffin (.muf) comme unités de compilation décrivant modules,
   * des commandes spécifiques du langage pour structurer logiciels, programmes, kernels,
     services et outils système.
 ============================================================================= *)

(* ----------------------------------------------------------------------------- *)
(* Lexique, identifiants et mots-clés réservés                                    *)
(* ----------------------------------------------------------------------------- *)
reserved_keyword
               = "module" | "import" | "export" | "muffin"
               | "program" | "software" | "kernel" | "service" | "driver" | "utility"
               | "scenario" | "capsule" | "bridge" | "device"
               | "blueprint" | "realm" | "tool" | "command" | "route" | "pipeline"
               | "build" | "stage" | "artifact" | "profile"
               | "use" | "requires" | "package" | "link" | "depends" | "feature" | "option"
               | "struct" | "union" | "enum" | "typedef" | "inline" | "fn"
               | "extern" | "static" | "restrict" | "sizeof" | "alignof"
               | "let" | "const"
               | "if" | "elif" | "else" | "while" | "for" | "repeat" | "match"
               | "and" | "or" | "not"
               | "true" | "false" | "null" ;

(* Les identifiants ne peuvent pas commencer par un mot-clé réservé. *)

(* Notes sémantiques :
   - Les blocs sont valides soit via indentation, soit via accolades explicites.
   - Les constructeurs de haut niveau doivent produire un module exportable.
   - Exemple minimal :
        module demo.app {
            import std.io
            program hello:
                scenario main(args):
                    println("bonjour Vitte")
        }
   - Chaque exemple de ce fichier doit être transformé en test parser (TODO: scripts/tests/parser/*.vitte). *)

(* ----------------------------------------------------------------------------- *)
program        = { top_level_declaration } ;

top_level_declaration
               = module_declaration
               | import_declaration
               | export_declaration
               | muffin_manifest
               | command_definition
               | build_declaration
               | type_declaration
               | function_declaration
               | advanced_declaration
               | statement ;

(* ----------------------------------------------------------------------------- *)
(* Déclarations de module / import/export                                           *)
(* ----------------------------------------------------------------------------- *)
module_declaration
               = "module" module_name [ "as" alias ] block ;

module_name    = identifier { "." identifier } ;
alias          = identifier ;

import_declaration
               = "import" module_name [ "as" alias ] [ import_clause ] newline ;

import_clause  = "from" module_source ;
module_source  = identifier [ "." identifier ] ;

export_declaration
               = "export" [ "all" ] [ export_clause ] newline ;

export_clause  = "from" module_source | "only" "(" identifier { "," identifier } ")" ;

(* ----------------------------------------------------------------------------- *)
(* Manifestes Muffin (.muf)                                                        *)
(* ----------------------------------------------------------------------------- *)
muffin_manifest
               = "muffin" file_path module_properties ;

file_path      = string_literal ;
module_properties
               = "{" { module_property } "}" ;
module_property
               = property_name ":" property_value newline ;
property_name  = identifier ;
property_value = literal | identifier | list_literal ;
list_literal   = "[" [ literal { "," literal } ] "]" ;

(* Chaque fichier Muffin (.muf) est une unité de compilation décrivant un module,
   ses dépendances, sa version et ses entrées publiques que les outils de build
   consomment comme un manifeste Python-style.
   TODO: préciser la sémantique des options (ex: dépendances optionnelles, profils ciblés). *)

(* ----------------------------------------------------------------------------- *)
(* Commandes spécifiques Vitte                                                    *)
(* ----------------------------------------------------------------------------- *)
command_definition
               = command_keyword command_name block ;

command_keyword
               = "program" | "software" | "kernel" | "service" | "driver" | "utility" ;

command_name   = identifier ;

(* ----------------------------------------------------------------------------- *)
(* Déclarations type/fonction                                      *)
(* ----------------------------------------------------------------------------- *)
type_declaration
               = struct_declaration
               | union_declaration
               | enum_declaration
               | typedef_declaration ;

struct_declaration
               = "struct" identifier composite_body ;

union_declaration
               = "union" identifier composite_body ;

enum_declaration
               = "enum" identifier enum_body ;

typedef_declaration
               = "typedef" type_expression identifier newline ;

composite_body = ":" newline INDENT { field_declaration } DEDENT
               | "{" newline? { field_declaration } "}" newline? ;

field_declaration
               = type_expression identifier [ ":" expression ] newline ;

enum_body      = ":" newline INDENT { enum_entry newline } DEDENT
               | "{" newline? { enum_entry newline } "}" newline? ;

enum_entry     = identifier [ "=" expression ] ;

function_declaration
               = [ storage_specifier ] [ "inline" ] "fn" identifier
                 "(" parameter_list ")" [ "->" type_expression ] block ;

storage_specifier
               = "extern" | "static" ;

parameter_list = [ parameter { "," parameter } ] ;
parameter      = type_expression identifier ;

type_expression
               = [ type_qualifier { type_qualifier } ]
                 identifier { "." identifier }
                 { pointer_modifier | array_modifier }
                 [ function_pointer_suffix ] ;

type_qualifier = "const" | "volatile" | "restrict" ;

pointer_modifier
               = "*" | "&" ;

array_modifier = "[" [ expression ] "]" ;

function_pointer_suffix
               = "(" parameter_list ")" ;

(* ----------------------------------------------------------------------------- *)
(* Construction / compilation                                                    *)
(* ----------------------------------------------------------------------------- *)
build_declaration
               = "build" identifier build_block ;

build_block    = ":" newline INDENT { build_statement } DEDENT
               | "{" newline? { build_statement } "}" newline? ;

build_statement
               = stage_declaration
               | artifact_declaration
               | profile_declaration
               | build_dependency
               | build_option_statement
               | statement ;

stage_declaration
               = "stage" identifier block ;

artifact_declaration
               = "artifact" identifier artifact_body ;

artifact_body  = "from" identifier [ artifact_options ] newline ;
artifact_options
               = "{" { artifact_option } "}" ;
artifact_option
               = option_key ":" option_value newline ;
option_key     = identifier ;
option_value   = literal | identifier | list_literal ;

profile_declaration
               = "profile" identifier block ;

build_dependency
               = "depends" "(" identifier { "," identifier } ")" newline ;

build_option_statement
               = "option" identifier "=" expression newline
               | "target" "=" expression newline ;

(* ----------------------------------------------------------------------------- *)
(* Déclarations avancées et nouveaux points d’entrée                              *)
(* ----------------------------------------------------------------------------- *)
advanced_declaration
               = advanced_keyword identifier [ "(" identifier { "," identifier } ")" ] block ;

advanced_keyword
               = "scenario" | "capsule" | "bridge" | "device" | "blueprint"
               | "realm" | "tool" | "command" | "route" | "pipeline" ;

(* ----------------------------------------------------------------------------- *)
(* Blocs et instructions                                                         *)
(* ----------------------------------------------------------------------------- *)
statement      = assignment
               | expression_statement
               | control_flow
               | declaration
               | compile_directive ;

assignment     = assignable assignment_operator expression newline ;
assignable     = expression ;
assignment_operator
               = "=" | "+=" | "-=" | "*=" | "/=" | "&=" | "|=" | "^=" | "<<=" | ">>=" ;
expression_statement
               = expression newline ;

declaration    = "let" target "=" expression newline
               | "const" target "=" expression newline ;

control_flow   = if_statement | loop_statement | match_statement ;

if_statement   = "if" expression block [ "elif" expression block ] [ "else" block ] ;

loop_statement = "while" expression block
               | "for" identifier "in" expression block
               | "repeat" expression block ;

match_statement
               = "match" expression block ;

block          = ":" newline INDENT { statement } DEDENT
               | "{" newline? { statement } "}" newline? ;

(* Une instruction simple (assignment/expression) est évidente ; les constructions
   composées (contrôle, boucles, blocs commandes/narratifs) sont définies
   plus bas pour rester lisibles. *)

(* ----------------------------------------------------------------------------- *)
(* Directives de compilation / packaging                                         *)
(* ----------------------------------------------------------------------------- *)
compile_directive
               = use_directive
               | requires_directive
               | package_directive
               | link_directive
               | feature_directive ;

use_directive  = "use" identifier [ "as" alias ] newline ;

requires_directive
               = "requires" "(" identifier { "," identifier } ")" newline ;

package_directive
               = "package" identifier [ package_options ] newline ;

package_options= "{" { artifact_option } "}" ;

link_directive = "link" identifier newline ;

feature_directive
               = "feature" identifier [ "enable" expression ] newline ;

(* Les directives d'inclusion de code asm, la gestion système bas niveau,
   la concurrence avancée, l'instrumentation et les extensions UI sont
   volontairement exclues du noyau pour garder un EBNF concis. *)

(* ----------------------------------------------------------------------------- *)
(* Expressions                                                                   *)
(* ----------------------------------------------------------------------------- *)
expression     = literal
               | target
               | call_expression
               | binary_expression
               | unary_expression
               | cast_expression
               | sizeof_expression
               | alignof_expression
               | parenthesized_expression
               | list_expression
               | map_expression ;

binary_expression
               = expression binary_operator expression ;
binary_operator
               = "+" | "-" | "*" | "/" | "%" | "==" | "!=" | "<" | "<=" | ">" | ">="
               | "and" | "or" | "&" | "|" | "^" | "<<" | ">>" ;
(* TODO precedence: confirmer que "and"/"or" suivent la même associativité que "&" "|" ;
   documenter ordre complet pour le parser. *)

unary_expression
               = unary_operator expression ;
unary_operator  = "-" | "not" | "&" | "*" | "~" ;

cast_expression
               = "(" type_expression ")" expression ;

sizeof_expression
               = "sizeof" "(" type_expression ")" ;

alignof_expression
               = "alignof" "(" type_expression ")" ;

call_expression= target "(" [ argument_list ] ")" ;
argument_list  = expression { "," expression } ;

parenthesized_expression
               = "(" expression ")" ;

list_expression
               = "[" [ expression { "," expression } ] "]" ;

map_expression = "{" [ map_entry { "," map_entry } ] "}" ;
map_entry      = expression ":" expression ;

target         = identifier { target_suffix } ;
target_suffix  = "." identifier
               | "[" expression "]"
               | "->" identifier ;

(* ----------------------------------------------------------------------------- *)
(* Littéraux et identifiants                                                      *)
(* ----------------------------------------------------------------------------- *)
literal        = number | string_literal | boolean_literal | "null" ;

number         = integer | float ;
integer        = digit { digit } ;
float          = digit { digit } "." digit { digit } ;

string_literal = "\"" string_characters "\"" ;
string_characters
               = { character } ;

boolean_literal
               = "true" | "false" ;

identifier     = letter { letter | digit | "_" } ;

letter         = ? ASCII letter ? ;
digit          = ? ASCII digit ? ;
character      = ? printable except quote/backslash ? ;

(* ----------------------------------------------------------------------------- *)
(* Sauts, indentations, commentaires                                              *)
(* ----------------------------------------------------------------------------- *)
newline        = ? platform-dependent newline ? ;
INDENT         = ? indentation token produced by lexer ? ;
DEDENT         = ? dedentation token produced by lexer ? ;
comment        = "#" { ? any until newline ? } newline ;

(* ----------------------------------------------------------------------------- *)
(* Notes pour l’implémentation                                                     *)
(* ----------------------------------------------------------------------------- *)
(* 1. L’analyseur lexical génère les tokens NEWLINE, INDENT, DEDENT en se basant *)
(*    sur l’indentation significative.                                          *)
(* 2. Les blocs peuvent être entourés d’accolades pour faciliter les générateurs *)
(*    ou l’édition assistée, mais la préférence reste à la lisibilité verticale. *)
(* 3. Les fichiers .muf décrivent les dépendances, les versions et les entrées   *)
(*    publiques des modules pour l’outil de build. Exemple :                     *)
(*                                                                            *)
(*      muffin "std/io.muf" {                                                *)
(*          version: "0.1"                                                    *)
(*          entry: io.read                                                     *)
(*          depends: ["std/core"]                                           *)
(*      }                                                                     *)
(*                                                                            *)
(* 4. Les commandes spécifiques définissent des points d’entrée clairs :       *)
(*      program app_name:                                                       *)
(*          ...                                                               *)
(*    Les moteurs de build peuvent associer chaque commande à un exécutable,   *)
(*    à un kernel ou à un module système.                                      *)
