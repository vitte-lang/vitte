# Vitte MVP 2025 – Grammaire EBNF (alignée sur le frontend actuel)
#
# Remarques :
# - Les blocs peuvent être écrits soit avec des accolades `{ ... }`, soit avec
#   des terminators `.end`. Le parser accepte les deux formes.
# - Les types sont actuellement des chemins nommés simples (pas de génériques).
# - Les structs déclarées sont encore stubs (pas de champs parsés), mais les
#   littéraux de struct et les patterns de struct sont supportés.

program        ::= module_decl? { toplevel_item } ;

module_decl    ::= "module" ident_path ;
import_decl    ::= "import" ident_path ;

toplevel_item  ::= module_decl
                 | import_decl
                 | struct_decl
                 | fn_decl
                 | let_stmt ;

struct_decl    ::= "struct" IDENT block_stub ;
# Stub de déclaration de struct : tout ce qui suit jusqu'à fin de ligne ou .end
block_stub     ::= { NEWLINE | token } [ ".end" ] ;

fn_decl        ::= "fn" IDENT "(" [ param_list ] ")" [ "->" type_expr ] block ;
param_list     ::= param { "," param } ;
param          ::= IDENT [ ":" type_expr ] ;

block          ::= "{" { statement } "}"
                 | NEWLINE? { statement } ".end" ;

statement      ::= let_stmt
                 | while_stmt
                 | if_stmt
                 | match_stmt
                 | return_stmt
                 | expr_stmt ;

let_stmt       ::= "let" [ "mut" ] IDENT [ ":" type_expr ] [ "=" expression ] ;
while_stmt     ::= "while" expression block ;
if_stmt        ::= "if" expression block [ "else" block ] ;
match_stmt     ::= "match" expression { match_arm } ".end" ;
match_arm      ::= pattern [ "if" expression ] "=>" block ;
return_stmt    ::= "return" [ expression ] ;
expr_stmt      ::= expression ;

expression     ::= binary_expr ;
binary_expr    ::= call_expr { binary_op call_expr } ;
binary_op      ::= "=" | "==" | "!=" | "<" | "<=" | ">" | ">=" | "+" | "-" | "*" | "/" ;

call_expr      ::= primary_expr { "(" [ argument_list ] ")" } ;
argument_list  ::= expression { "," expression } ;

primary_expr   ::= literal
                 | struct_literal
                 | "(" expression ")"
                 | block_expr
                 | ident_path ;

block_expr     ::= "{" { statement } "}" ;

struct_literal ::= ident_path "{" [ struct_field { "," struct_field } ] "}" ;
struct_field   ::= IDENT "=" expression ;

literal        ::= INTEGER | FLOAT | CHAR | STRING | "true" | "false" ;

ident_path     ::= IDENT { ("." | "::") IDENT } ;

type_expr      ::= ident_path ;

pattern        ::= "_"
                 | literal
                 | ident_path [ "{" [ struct_pat_field { "," struct_pat_field } ] "}" ]
                 | tuple_pattern ;

tuple_pattern  ::= "(" [ pattern { "," pattern } ] ")" ;
struct_pat_field ::= IDENT [ "=" pattern ] ;
