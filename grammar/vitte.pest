// =============================================================================
// Vitte core grammar (Pest) â€” without Muffin manifests
// =============================================================================

// Whitespace & comments -------------------------------------------------------

WHITESPACE = _{ " " | "\t" | NEWLINE }
NEWLINE    = _{ "\r\n" | "\n" }
COMMENT    = _{ "#" ~ (!NEWLINE ~ ANY)* ~ NEWLINE? }

WS  = _{ (WHITESPACE | COMMENT)* }
WS1 = _{ (WHITESPACE | COMMENT)+ }

// ASCII helpers ---------------------------------------------------------------

ASCII_ALPHA = _{ 'a'..'z' | 'A'..'Z' }
ASCII_DIGIT = _{ '0'..'9' }

ident_start = _{ ASCII_ALPHA | "_" }
ident_char  = _{ ASCII_ALPHA | ASCII_DIGIT | "_" }

// Reserved keywords (core + phrase) ------------------------------------------

keyword = _{
      "module"
    | "import"
    | "export"
    | "program" | "service" | "kernel" | "driver" | "tool" | "scenario" | "pipeline"
    | "struct" | "union" | "enum" | "typedef" | "inline" | "fn"
    | "extern" | "static" | "sizeof" | "alignof"
    | "let" | "const"
    | "if" | "elif" | "else" | "while" | "for" | "in" | "match"
    | "break" | "continue" | "return"
    | "and" | "or" | "not"
    | "true" | "false" | "null"
    | "as" | "all"
    | "volatile" | "restrict"
    // Phrase syntax keywords
    | "mod" | "use" | "type" | "field" | "scn" | "prog"
    | "set" | "say" | "do" | "ret"
    | "when" | "loop" | "from" | "to" | "step"
}

identifier = @{ !keyword ~ ident_start ~ ident_char* }

// Literals --------------------------------------------------------------------

integer = @{ ASCII_DIGIT+ }
float   = @{ ASCII_DIGIT+ ~ "." ~ ASCII_DIGIT+ }

number  = { float | integer }

boolean_literal = { "true" | "false" }

string_literal = @{
    "\"" ~ string_char* ~ "\""
}

string_char = _{
      "\\\""                // escaped quote
    | "\\\\"                 // escaped backslash
    | !"\"" ~ !NEWLINE ~ ANY  // any non-quote, non-newline
}

literal = { number | string_literal | boolean_literal }

// =============================================================================
// Core Vitte grammar (no Muffin)
// =============================================================================

program = { SOI ~ WS ~ top_level_declaration* ~ WS ~ EOI }

// Top-level -------------------------------------------------------------------

top_level_declaration = _{
      module_declaration
    | import_declaration
    | export_declaration
    | type_declaration
    | function_declaration
    | scenario_declaration
    | entry_point_declaration
    | declaration          // global let/const
}

// Modules, import, export -----------------------------------------------------

module_declaration = {
    "module" ~ WS1 ~ module_name
}

module_name = { identifier ~ (WS* ~ "." ~ WS* ~ identifier)* }

import_declaration = _{
      "import" ~ WS1 ~ module_name ~ (WS1 ~ "as" ~ WS1 ~ alias)?
}

export_declaration = _{
      "export" ~ WS1 ~ "all" ~ (WS1 ~ "from" ~ WS1 ~ module_name)?
    | "export" ~ WS1 ~ export_list ~ (WS1 ~ "from" ~ WS1 ~ module_name)?
}

export_list = { identifier ~ (WS* ~ "," ~ WS* ~ identifier)* }

alias = { identifier }

// Types & type declarations ---------------------------------------------------

// For the parser, we use .end-terminated bodies (no curly braces).
// Indentation-based surface syntax can be normalised to this form before parsing si besoin.

type_declaration = _{
      struct_declaration
    | union_declaration
    | enum_declaration
    | typedef_declaration
}

struct_declaration = {
    "struct" ~ WS1 ~ identifier ~ WS* ~ type_body
}

union_declaration = {
    "union" ~ WS1 ~ identifier ~ WS* ~ type_body
}

type_body = {
    NEWLINE? ~ WS* ~ field_declaration* ~ WS* ~ ".end"
}

field_declaration = {
    "let" ~ WS1 ~ identifier ~ WS* ~ ":" ~ WS* ~ type_expression
        ~ (WS* ~ "=" ~ WS* ~ expression)?
}

enum_declaration = {
    "enum" ~ WS1 ~ identifier ~ WS* ~ enum_body
}

enum_body = {
    NEWLINE? ~ WS* ~ enum_entry* ~ WS* ~ ".end"
}

enum_entry = {
    identifier ~ (WS* ~ "=" ~ WS* ~ expression)? ~ WS*
}

typedef_declaration = {
    "typedef" ~ WS1 ~ type_expression ~ WS1 ~ identifier
}

// Scenarios & functions -------------------------------------------------------

scenario_declaration = {
    "scenario" ~ WS1 ~ identifier ~ WS* ~ "(" ~ WS* ~ parameter_list? ~ WS* ~ ")" ~ WS* ~ block
}

function_declaration = {
    storage_specifier? ~ WS* ~ "inline"? ~ WS* ~ "fn" ~ WS1 ~ identifier
        ~ WS* ~ "(" ~ WS* ~ parameter_list? ~ WS* ~ ")"
        ~ (WS* ~ "->" ~ WS* ~ type_expression)?
        ~ WS* ~ block
}

storage_specifier = { "extern" | "static" }

parameter_list = { parameter ~ (WS* ~ "," ~ WS* ~ parameter)* }

parameter = { type_expression ~ WS1 ~ identifier }

// Type expressions ------------------------------------------------------------

type_expression = {
    type_qualifier* ~ type_name ~ (pointer_modifier_or_array)* ~ function_pointer_suffix?
}

type_qualifier = { "const" | "volatile" | "restrict" }

type_name = { identifier ~ (WS* ~ "." ~ WS* ~ identifier)* }

pointer_modifier_or_array = { pointer_modifier | array_modifier }

pointer_modifier = { "*" | "&" }

array_modifier = { "[" ~ WS* ~ expression? ~ WS* ~ "]" }

function_pointer_suffix = {
    "(" ~ WS* ~ parameter_list? ~ WS* ~ ")"
}

// Entry points ----------------------------------------------------------------

entry_point_declaration = _{
      "program"  ~ WS1 ~ module_name ~ WS* ~ block
    | "service"  ~ WS1 ~ module_name ~ WS* ~ block
    | "kernel"   ~ WS1 ~ module_name ~ WS* ~ block
    | "driver"   ~ WS1 ~ module_name ~ WS* ~ block
    | "tool"     ~ WS1 ~ module_name ~ WS* ~ block
    | "scenario" ~ WS1 ~ module_name ~ WS* ~ block
    | "pipeline" ~ WS1 ~ module_name ~ WS* ~ block
}

// Blocks & statements ---------------------------------------------------------

block = {
    NEWLINE? ~ WS* ~ statement* ~ WS* ~ ".end"
}

statement = _{
      declaration
    | assignment
    | control_flow
    | jump_statement
    | return_statement
    | expression_statement
}

// Declarations & assignment ---------------------------------------------------

declaration = _{
      "let"   ~ WS1 ~ identifier ~ WS* ~ "=" ~ WS* ~ expression
    | "const" ~ WS1 ~ identifier ~ WS* ~ "=" ~ WS* ~ expression
}

assignment = {
    assignable ~ WS* ~ assignment_operator ~ WS* ~ expression
}

assignable = { target }

assignment_operator = {
      "="  | "+=" | "-=" | "*=" | "/="
    | "&=" | "|=" | "^=" | "<<=" | ">>="
}

expression_statement = { expression }

// Control-flow ----------------------------------------------------------------

control_flow = _{
      if_statement
    | loop_statement
    | match_statement
}

if_statement = {
    "if" ~ WS1 ~ expression ~ WS* ~ block
        ~ (WS* ~ "elif" ~ WS1 ~ expression ~ WS* ~ block)*
        ~ (WS* ~ "else" ~ WS* ~ block)?
}

loop_statement = _{
      "while" ~ WS1 ~ expression ~ WS* ~ block
    | "for"   ~ WS1 ~ identifier ~ WS1 ~ "in" ~ WS1 ~ expression ~ WS* ~ block
}

match_statement = {
    "match" ~ WS1 ~ expression ~ WS* ~ match_block
}

match_block = {
    NEWLINE? ~ WS* ~ match_arm* ~ WS* ~ ".end"
}

match_arm = {
    pattern ~ WS* ~ "=>" ~ WS* ~ block
}

pattern = _{
      "_"
    | literal
    | identifier
    | pattern_tuple
    | pattern_list
}

pattern_tuple = {
    "(" ~ WS* ~ pattern ~ (WS* ~ "," ~ WS* ~ pattern)* ~ WS* ~ ")"
}

pattern_list = {
    "[" ~ WS* ~ pattern? ~ (WS* ~ "," ~ WS* ~ pattern)* ~ WS* ~ "]"
}

// Jumps & return --------------------------------------------------------------

jump_statement = _{
      "break"
    | "continue"
}

return_statement = {
    "return" ~ (WS1 ~ expression)?
}

// Expressions -----------------------------------------------------------------

expression = { unary_expression ~ (WS* ~ binary_operator ~ WS* ~ unary_expression)* }

unary_expression = {
    unary_operator* ~ postfix_expression
}

unary_operator = { "-" | "not" | "&" | "*" | "~" }

postfix_expression = {
    primary_expression ~ postfix_op*
}

postfix_op = _{
      WS* ~ "."  ~ WS* ~ identifier
    | WS* ~ "["  ~ WS* ~ expression ~ WS* ~ "]"
    | WS* ~ "->" ~ WS* ~ identifier
    | WS* ~ "("  ~ WS* ~ argument_list? ~ WS* ~ ")"
}

primary_expression = _{
      literal
    | "null"
    | sizeof_expression
    | alignof_expression
    | map_expression
    | list_expression
    | "(" ~ WS* ~ expression ~ WS* ~ ")"
    | identifier
}

argument_list = {
    expression ~ (WS* ~ "," ~ WS* ~ expression)*
}

binary_operator = {
      "+" | "-" | "*" | "/" | "%"
    | "==" | "!=" | "<" | "<=" | ">" | ">="
    | "and" | "or"
    | "&" | "|" | "^" | "<<" | ">>"
    | "|>"      // pipeline operator
}

sizeof_expression = {
    "sizeof" ~ WS* ~ "(" ~ WS* ~ type_expression ~ WS* ~ ")"
}

alignof_expression = {
    "alignof" ~ WS* ~ "(" ~ WS* ~ type_expression ~ WS* ~ ")"
}

list_expression = {
    "[" ~ WS* ~ expression? ~ (WS* ~ "," ~ WS* ~ expression)* ~ WS* ~ "]"
}

map_expression = {
    "[" ~ WS* ~ map_entry? ~ (WS* ~ "," ~ WS* ~ map_entry)* ~ WS* ~ "]"
}

map_entry = {
    expression ~ WS* ~ ":" ~ WS* ~ expression
}

// =============================================================================
// Phrase syntax (surface language desugared to core Vitte)
// =============================================================================

phrase_program = { SOI ~ WS ~ phrase_top_level* ~ WS ~ EOI }

phrase_top_level = _{
      module_line
    | use_line
    | type_block
    | fn_block
    | scenario_block
    | program_block
}

// Modules & imports (phrase) --------------------------------------------------

module_line = {
    "mod" ~ WS1 ~ phrase_module_path
}

phrase_module_path = {
    phrase_module_segment ~ ("/" ~ phrase_module_segment)*
}

phrase_module_segment = {
    identifier ~ ("." ~ identifier)*
}

use_line = {
    "use" ~ WS1 ~ phrase_module_path ~ (WS1 ~ "as" ~ WS1 ~ identifier)?
}

// Types (type / field) --------------------------------------------------------

// Example:
//   type Point
//       field x : Int
//       field y : Int
//   .end

type_block = {
    "type" ~ WS1 ~ identifier ~ WS* ~ type_block_body ~ WS* ~ ".end"
}

type_block_body = {
    field_line*
}

field_line = {
    "field" ~ WS1 ~ identifier ~ WS* ~ ":" ~ WS* ~ phrase_type_name
}

phrase_type_name = {
    identifier ~ ("." ~ identifier)*
}

// Functions (fn) --------------------------------------------------------------

// Example:
//   fn add a:Int b:Int -> Int
//       set sum = a + b
//       ret sum
//   .end

fn_block = {
    "fn" ~ WS1 ~ identifier ~ phrase_param_list? ~ phrase_return_type? ~ WS* ~ fn_block_body ~ WS* ~ ".end"
}

// Scenarios (scn) -------------------------------------------------------------

// Example:
//   scn demo
//       set a = 2
//       say "hello"
//   .end

scenario_block = {
    "scn" ~ WS1 ~ identifier ~ WS* ~ scenario_block_body ~ WS* ~ ".end"
}

scenario_block_body = {
    phrase_stmt*
}

// Programs (prog) -------------------------------------------------------------

// Example:
//   prog core.math/point.main
//       do demo
//   .end

program_block = {
    "prog" ~ WS1 ~ phrase_module_path ~ "." ~ identifier ~ WS* ~ program_block_body ~ WS* ~ ".end"
}

program_block_body = {
    phrase_stmt*
}

// Phrase-level statements -----------------------------------------------------

phrase_stmt = _{
      set_line
    | say_line
    | do_line
    | ret_line
    | when_block
    | loop_block
}

set_line = {
    "set" ~ WS1 ~ phrase_assign_target ~ WS* ~ "=" ~ WS* ~ phrase_expr
}

phrase_assign_target = {
    identifier ~ ("." ~ identifier)*
}

say_line = {
    "say" ~ WS1 ~ phrase_string_interpolated
}

do_line = {
    "do" ~ WS1 ~ identifier ~ (WS1 ~ phrase_expr)*
}

ret_line = {
    "ret" ~ (WS1 ~ phrase_expr)?
}

// When / Else When / Else -----------------------------------------------------

// Example:
//   when a > 0
//       say "pos"
//   else when a < 0
//       say "neg"
//   else
//       say "zero"
//   .end

when_block = {
    "when" ~ WS1 ~ phrase_expr ~ WS* ~ phrase_block_body
        ~ (WS* ~ "else" ~ WS1 ~ "when" ~ WS1 ~ phrase_expr ~ WS* ~ phrase_block_body)*
        ~ (WS* ~ "else" ~ WS* ~ phrase_block_body)?
        ~ WS* ~ ".end"
}

phrase_block_body = {
    phrase_stmt*
}

// Loop / from / to / step -----------------------------------------------------

// Example:
//   loop i from 0 to 10 step 1
//       say i
//   .end

loop_block = {
    "loop" ~ WS1 ~ identifier ~ WS1 ~ "from" ~ WS1 ~ phrase_expr ~ WS1 ~ "to" ~ WS1 ~ phrase_expr
        ~ (WS1 ~ "step" ~ WS1 ~ phrase_expr)?
        ~ WS* ~ phrase_block_body ~ WS* ~ ".end"
}