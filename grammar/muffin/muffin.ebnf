(*
  Muffin Bakefile v2 — EBNF
  - fichier unique type "Muffinfile" / "build.muf"
  - blocs top-level, terminés par .end
  - commentaires '# ...' (line comment)
  - syntaxe orientée lignes, mais EBNF reste whitespace-tolérante
*)

muffin_file        ::= ws? header nl { ws? stmt ws? nl } ws? eof ;

header             ::= "muffin" ws1 "bake" ws1 int_lit ;

stmt               ::= store_block
                     | capsule_block
                     | var_decl
                     | profile_block
                     | tool_block
                     | bake_block
                     | wire_stmt
                     | export_stmt
                     | plan_block
                     | switch_block
                     | set_stmt
                     ;

(*
  Global setters (optionnel) : set profile "debug"
*)
set_stmt           ::= "set" ws1 ident ws1 value ;

(* ---------------------------
   Store
--------------------------- *)
store_block         ::= "store" ws1 ident nl
                        { ws? store_item ws? nl }
                        end_block ;

store_item          ::= "path" ws1 string_lit
                      | "mode" ws1 store_mode ;

store_mode          ::= "content" | "mtime" | "off" ;

(* ---------------------------
   Capsule (sandbox policy)
--------------------------- *)
capsule_block       ::= "capsule" ws1 ident nl
                        { ws? capsule_item ws? nl }
                        end_block ;

capsule_item        ::= "env" ws1 env_policy
                      | "fs"  ws1 fs_policy
                      | "net" ws1 net_policy
                      | "time" ws1 time_policy ;

env_policy          ::= "allow" ws1 list_string
                      | "deny"  ws1 list_string ;

fs_policy           ::= "allow_read"  ws1 list_string
                      | "allow_write" ws1 list_string
                      | "deny"        ws1 list_string
                      | "allow_write_exact" ws1 list_string ;  (* variante stricte *)

net_policy          ::= "allow" | "deny" ;

time_policy         ::= "stable" ws1 bool_lit ;

(* ---------------------------
   Vars (typées)
--------------------------- *)
var_decl            ::= "var" ws1 ident ws? ":" ws? type_ref ws?
                        ws? "=" ws? value ;

type_ref            ::= prim_type | artifact_type ;

prim_type           ::= "text" | "int" | "bool" | "bytes" ;

artifact_type       ::= ident "." ident { "." ident } ;  (* ex: src.glob, ir.module, bin.exe *)

(* ---------------------------
   Profile
--------------------------- *)
profile_block       ::= "profile" ws1 ident nl
                        { ws? profile_item ws? nl }
                        end_block ;

profile_item        ::= "set" ws1 ident ws1 value ;

(* ---------------------------
   Tool
--------------------------- *)
tool_block          ::= "tool" ws1 ident nl
                        { ws? tool_item ws? nl }
                        end_block ;

tool_item           ::= "exec" ws1 string_lit
                      | "expect_version" ws1 string_lit
                      | "sandbox" ws1 bool_lit
                      | "capsule" ws1 ident ;

(* ---------------------------
   Bake
--------------------------- *)
bake_block          ::= "bake" ws1 ident nl
                        { ws? bake_item ws? nl }
                        end_block ;

bake_item           ::= port_in
                      | port_out
                      | make_stmt
                      | run_block
                      | cache_stmt
                      | output_stmt ;

port_in             ::= "in"  ws1 ident ws? ":" ws? type_ref ;
port_out            ::= "out" ws1 ident ws? ":" ws? type_ref ;

(*
  Ingredients builder (source nodes)
  ex:
    bake app_src
      out files: src.glob
      make files glob "src/**/*.vit"
    .end
*)
make_stmt           ::= "make" ws1 ident ws1 make_kind ws1 string_lit ;

make_kind           ::= "glob" | "file" | "text" | "value" ;

(*
  Run tool binding ports <-> tool flags
  ex:
    run tool vittec
      takes src as "--src"
      takes prof as "--profile"
      emits exe as "--out"
      set "--emit" "exe"
    .end
*)
run_block           ::= "run" ws1 "tool" ws1 ident nl
                        { ws? run_item ws? nl }
                        end_block ;

run_item            ::= takes_stmt
                      | emits_stmt
                      | run_set_stmt ;

takes_stmt          ::= "takes" ws1 ident ws1 "as" ws1 string_lit ;
emits_stmt          ::= "emits" ws1 ident ws1 "as" ws1 string_lit ;
run_set_stmt        ::= "set" ws1 string_lit ws1 value ;

cache_stmt          ::= "cache" ws1 cache_mode ;
cache_mode          ::= "content" | "mtime" | "off" ;

(*
  Forcer un chemin final pour un output (root workspace)
  ex: output exe at "./app"
*)
output_stmt         ::= "output" ws1 ident ws1 "at" ws1 string_lit ;

(* ---------------------------
   Wiring
--------------------------- *)
wire_stmt           ::= "wire" ws1 ref ws1 "->" ws1 ref ;

ref                 ::= ident                      (* var globale *)
                      | ident "." ident ;          (* bake.port *)

export_stmt         ::= "export" ws1 ref ;         (* doit référencer un port out *)

(* ---------------------------
   Plan
--------------------------- *)
plan_block          ::= "plan" ws1 ident nl
                        { ws? plan_item ws? nl }
                        end_block ;

plan_item           ::= "run" ws1 ( "exports" | ref ) ;

(* ---------------------------
   Switch (CLI mapping)
--------------------------- *)
switch_block        ::= "switch" nl
                        { ws? switch_item ws? nl }
                        end_block ;

switch_item         ::= "flag" ws1 string_lit ws1 switch_action ;

switch_action       ::= "set" ws1 ident ws1 value
                      | "set" ws1 "plan" ws1 string_lit
                      | "run" ws1 ( "exports" | ref ) ;

(* ---------------------------
   Common: values / lists
--------------------------- *)
value               ::= string_lit | int_lit | bool_lit | list
                      | ident ;   (* autoriser refs simples comme valeur, selon impl *)

list                ::= "[" ws? [ value { ws? "," ws? value } ] ws? "]" ;
list_string         ::= "[" ws? [ string_lit { ws? "," ws? string_lit } ] ws? "]" ;

(* ---------------------------
   Blocks / tokens / whitespace
--------------------------- *)
end_block           ::= ".end" ;

nl                  ::= "\n" | "\r\n" ;

ws                  ::= { " " | "\t" | nl | comment } ;
ws1                 ::= ( " " | "\t" ) { " " | "\t" } ;

comment             ::= "#" { not_nl } ;

not_nl              ::= ? any char except \n and \r ? ;

ident               ::= ident_start { ident_continue } ;
ident_start         ::= "A".."Z" | "a".."z" | "_" ;
ident_continue      ::= ident_start | "0".."9" ;

int_lit             ::= "0" | ("1".."9") { "0".."9" } ;
bool_lit            ::= "true" | "false" ;

string_lit          ::= "\"" { string_char } "\"" ;
string_char         ::= escaped | not_quote ;
escaped             ::= "\\" ( "\"" | "\\" | "n" | "r" | "t" ) ;
not_quote           ::= ? any char except " and backslash ? ;

eof                 ::= ? end of input ? ;