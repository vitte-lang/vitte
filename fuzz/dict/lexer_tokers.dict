# C:\Users\vince\Documents\GitHub\vitte\fuzz\dict\lexer_tokers.dict
# Dictionary AFL/libFuzzer â€” lexer tokens / keywords / operators / literals (max)
# One token per line, quoted. Keep it ASCII-safe; include unicode samples sparingly.

# --- whitespace / comments / trivia ---
" "
"\t"
"\r"
"\n"
"\r\n"
"//"
"///"
"////"
"/*"
"*/"
"/**"
"*/"
"/*!"
"*/"
"/* */"
"// TODO"
"// FIXME"
"#"
"#!"
"#?"
";"
","
"."
".."
"..."
":"
"::"
"->"
"=>"
"="
"=="
"!="
"<"
">"
"<="
">="
"!"
"~"
"+"
"-"
"*"
"/"
"%"
"**"
"+="
"-="
"*="
"/="
"%="
"&"
"|"
"^"
"&="
"|="
"^="
"<<"
">>"
"<<="
">>="
"&&"
"||"
"??"
"?:"
"?"
"@"
"$"
"`"
"\\"

# --- grouping / delimiters ---
"("
")"
"["
"]"
"{"
"}"
"<"
">"

# --- block terminator (Vitte core/phrase convention) ---
".end"

# --- identifiers / common stems ---
"_"
"__"
"___"
"ident"
"Ident"
"module"
"mod"
"use"
"export"
"as"
"from"
"pub"
"priv"
"internal"
"self"
"super"
"crate"

# --- declarations / items ---
"type"
"struct"
"union"
"enum"
"alias"
"trait"
"impl"
"where"
"fn"
"scn"
"scenario"
"prog"
"program"
"service"
"kernel"
"driver"
"tool"
"pipeline"
"entry"
"entrypoint"
"const"
"let"
"mut"
"static"
"global"

# --- control flow ---
"if"
"elif"
"else"
"match"
"case"
"when"
"while"
"for"
"in"
"loop"
"break"
"continue"
"return"
"ret"
"defer"
"yield"
"await"
"async"
"try"
"catch"
"throw"
"panic"
"assert"
"unreachable"

# --- phrase sugar statements ---
"set"
"say"
"do"

# --- boolean / null-like ---
"true"
"false"
"null"
"none"
"nil"
"some"
"ok"
"err"

# --- primitive types (common) ---
"bool"
"char"
"str"
"string"
"unit"
"void"
"never"
"i8"
"i16"
"i32"
"i64"
"i128"
"isize"
"u8"
"u16"
"u32"
"u64"
"u128"
"usize"
"f16"
"bf16"
"f32"
"f64"
"f80"
"f128"

# --- numeric literals (patterns/fragments) ---
"0"
"1"
"2"
"10"
"42"
"1337"
"-1"
"+1"
"0.0"
"1.0"
"3.14159"
"2.71828"
"1e0"
"1e+3"
"1e-3"
"0e0"
"1.0e10"
"1.0e-10"
"0x0"
"0x1"
"0x2A"
"0xDEAD"
"0xBEEF"
"0xDEADBEEF"
"0b0"
"0b1"
"0b1010"
"0o0"
"0o7"
"0o755"
"_"
"1_000"
"0xDEAD_BEEF"
"0b1010_0101"
"0o12_345"
"u8"
"u16"
"u32"
"u64"
"u128"
"i8"
"i16"
"i32"
"i64"
"i128"
"f32"
"f64"

# --- string literal fragments / escapes ---
"\"\""
"\"a\""
"\"abc\""
"\"hello\""
"\"world\""
"\"\\n\""
"\"\\t\""
"\"\\\\\""
"\"\\\"\""
"\"\\r\""
"\"\\0\""
"\"\\x00\""
"\"\\x7F\""
"\"\\u{0}\""
"\"\\u{41}\""
"\"\\u{20AC}\""
"\"\\u{1F680}\""
"\"${}\""
"\"${name}\""
"\"${0}\""
"\"${path}\""
"\"a${b}c\""
"\"{\""
"\"}\""
"\"[\""
"\"]\""
"\"(\""
"\")\""
"\"::\""
"\"->\""
"\"=>\""
"\".end\""
"\"/*\""
"\"*/\""
"\"//\""
"\"#\""

# raw-ish / triple-ish samples (lexer edge-cases)
"r\"\""
"r\"abc\""
"r\"\\n\""
"\"\"\""
"\"\"\"x\"\"\""
"\"\"\"\n\"\"\""
"\"\"\"line1\nline2\"\"\""

# --- char literals / escapes ---
"'a'"
"'\\n'"
"'\\t'"
"'\\''"
"'\\\\'"
"'\\x41'"
"'\\u{1F680}'"

# --- operators (wordy) ---
"and"
"or"
"not"
"is"
"as?"
"in?"
"contains"
"typeof"
"sizeof"
"alignof"
"offsetof"

# --- punctuation-heavy patterns used by lexers/printers ---
"::"
"::<"
">::"
"<T>"
"<T,U>"
"[T]"
"(T)"
"(a,b)"
"(a, b, c)"
"a.b"
"a::b"
"a/b"
"a/b.c"
"a/b.c::d"
"mod a/b.c"
"use a/b.c"
"export a/b.c"
"type X = Y"
"fn f()"
"fn f(x: i32) -> i32"
"if true .end"
"match x .end"
"loop .end"

# --- annotations / attributes / directives ---
"@test"
"@bench"
"@cfg"
"@cfg(windows)"
"@cfg(unix)"
"@cfg(target=\"x86_64\")"
"@inline"
"@noinline"
"@cold"
"@hot"
"@deprecated"
"@unstable"
"@since(\"0.1.0\")"
"@doc(\"...\")"

# --- common error triggers / malformed ---
"/*/"
"//*/"
"\""
"'"
"\"\\u{\""
"\"\\x\""
"0x"
"0b"
"0o"
"1e"
"1e+"
"1e-"
"__\n"
"."
".e"
"..e"
":::"
"===="
"->>"
"<<>>"
"&&&"
"|||"
"???"
"@@"

# --- unicode samples (optional but useful) ---
"cafÃ©"
"æ±äº¬"
"ğŸš€"
"Ã©"
"â€”"
"âœ“"
