# C:\Users\vince\Documents\GitHub\vitte\fuzz\dict\parsergrammar.dict
# Dictionary AFL/libFuzzer ‚Äî Vitte parser/grammar (core + phrase) (max)
# One token per line, quoted. Mix keywords, punctuation, patterns, and common AST node strings.

# --- core punctuation / delimiters ---
"("
")"
"["
"]"
"{"
"}"
","
":"
";"
"."
".."
"..."
"::"
"->"
"=>"
"="
"=="
"!="
"<"
">"
"<="
">="
"+"
"-"
"*"
"/"
"%"
"**"
"&"
"|"
"^"
"<<"
">>"
"&&"
"||"
"!"
"~"
"?"
"@"
"$"
"\\"

# --- block / terminator ---
".end"

# --- module system / visibility ---
"module"
"mod"
"use"
"export"
"from"
"as"
"pub"
"priv"
"internal"
"self"
"super"

# --- top-level items / decls ---
"type"
"struct"
"union"
"enum"
"fn"
"scn"
"scenario"
"entry"
"entrypoint"
"prog"
"program"
"service"
"kernel"
"driver"
"tool"
"pipeline"
"global"
"const"
"let"
"mut"
"static"

# --- statements (core + phrase) ---
"set"
"say"
"do"
"if"
"elif"
"else"
"match"
"when"
"while"
"for"
"in"
"loop"
"break"
"continue"
"return"
"ret"

# --- expression / literal keywords ---
"true"
"false"
"null"
"none"
"nil"
"ok"
"err"
"and"
"or"
"not"
"is"
"as"
"sizeof"
"alignof"
"offsetof"
"typeof"

# --- patterns / match ---
"_"
"case"
"default"
"|"        # alt pattern separator (if used)
"::"       # variant pattern
"Tuple"
"Variant"
"Literal"
"Wildcard"

# --- type system tokens ---
"bool"
"char"
"str"
"string"
"unit"
"void"
"never"
"i8"
"i16"
"i32"
"i64"
"i128"
"isize"
"u8"
"u16"
"u32"
"u64"
"u128"
"usize"
"f16"
"bf16"
"f32"
"f64"
"f80"
"f128"

# --- generic / type expr fragments ---
"<T>"
"<T,U>"
"<K,V>"
"[T]"
"(T)"
"Result<T,E>"
"Option<T>"
"Vec<T>"
"Map<K,V>"

# --- common identifiers / names ---
"X"
"Y"
"T"
"U"
"K"
"V"
"Self"
"self"
"main"
"init"
"run"
"test"
"bench"
"debug"
"release"
"vitte"
"std"
"core"

# --- path syntaxes (core '.' and phrase '/' variants) ---
"a"
"a.b"
"a.b.c"
"a/b"
"a/b.c"
"a/b.c::d"
"std/io"
"std/io.file"
"std/modules/algo/search"
"std.modules.algo.search"

# --- canonical decl patterns (parser stress) ---
"mod a/b.c .end"
"use a/b.c"
"export all from a/b.c"
"export { a, b, c } from a/b.c"
"type X = Y"
"struct S .end"
"union U .end"
"enum E .end"
"fn f() .end"
"fn f(x: i32) -> i32 .end"
"scn s() .end"
"prog std/app .end"
"entry program std/app .end"

# --- field / param fragments ---
"x"
"y"
"z"
"arg"
"param"
"field"
"value"
"name"
"kind"
"tag"
"flags"
"span"
"range"

# --- statements / blocks fragments ---
"let x = 0"
"let mut x = 0"
"const N = 42"
"set x = 1"
"say \"hello\""
"do f()"
"ret x"
"return x"
"break"
"continue"
"if true .end"
"if true\n.end"
"elif false .end"
"else .end"
"while true .end"
"for i in 0..10 .end"
"loop .end"
"match x .end"
"when x == 0 .end"

# --- expression fragments ---
"()"
"(x)"
"(x, y)"
"(x, y, z)"
"[x]"
"[x, y]"
"[x, y, z]"
"x.y"
"x.y()"
"x::y"
"x::y()"
"x[0]"
"x[1]"
"f()"
"f(x)"
"f(x, y)"
"f(x, y, z)"
"x + y"
"x - y"
"x * y"
"x / y"
"x % y"
"x ** y"
"x && y"
"x || y"
"!x"
"~x"
"x == y"
"x != y"
"x < y"
"x <= y"
"x > y"
"x >= y"
"x = y"
"x += y"
"x -= y"
"x *= y"
"x /= y"
"x %= y"
"x << 1"
"x >> 1"
"x & y"
"x | y"
"x ^ y"
"x ? y : z"
"foo(bar(baz()))"

# --- literals / numeric patterns ---
"0"
"1"
"2"
"10"
"42"
"1337"
"-1"
"+1"
"0.0"
"1.0"
"3.14159"
"2.71828"
"1e0"
"1e+3"
"1e-3"
"0xDEAD"
"0xBEEF"
"0xDEAD_BEEF"
"0b1010_0101"
"0o755"
"1_000_000"
"\"\""
"\"a\""
"\"abc\""
"\"hello\""
"\"\\n\""
"\"\\t\""
"\"\\\\\""
"\"\\\"\""
"\"${name}\""
"\"a${b}c\""
"'a'"
"'\\n'"
"'\\t'"
"'\\''"
"'\\\\'"
"'\\x41'"
"'\\u{1F680}'"

# --- error trigger fragments (grammar edges) ---
""
".end.end"
".end .end"
"if .end"
"match .end"
"fn .end"
"type ="
"struct .end .end"
"enum {"
"union }"
"let = 1"
"return"
"ret"
":::"
"===="
",,"
"->>"
"<<>>"
"&&&"
"|||"
"??"
"??:"
"@@"

# --- AST / node labels that printers might emit ---
"CompilationUnit"
"ModuleDecl"
"UseDecl"
"ExportDecl"
"TypeDecl"
"StructDecl"
"UnionDecl"
"EnumDecl"
"TypeAlias"
"FnItem"
"ScenarioItem"
"EntrypointDecl"
"Block"
"Stmt"
"Expr"
"LetStmt"
"ConstDecl"
"AssignStmt"
"IfStmt"
"WhileStmt"
"ForStmt"
"LoopStmt"
"MatchStmt"
"ReturnStmt"
"BreakStmt"
"ContinueStmt"
"CallExpr"
"IndexExpr"
"DotExpr"
"PathExpr"
"LiteralExpr"
"BinaryExpr"
"UnaryExpr"
"TupleExpr"
"ArrayExpr"
"Pattern"
"VariantPattern"
"WildcardPattern"
"LiteralPattern"
"TypeExpr"
"GenericArgs"
"Params"
"Fields"
"EnumEntry"
"Span"
"Token"
"Error"
"Recover"
"Sync"

# --- unicode probes ---
"caf√©"
"Êù±‰∫¨"
"üöÄ"
"‚Äî"
"‚úì"
