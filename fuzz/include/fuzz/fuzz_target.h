// fuzz_target.h
// Minimal fuzz target ABI + helpers (libFuzzer/AFL/standalone) — C17.
//
// This header defines a consistent target signature and utilities for
// building multiple fuzz targets in a uniform way.
//
// Typical usage (one TU per target):
//
//   #include "fuzz/fuzz_target.h"
//   #include "fuzz/fuzz_driver.h"
//
//   FUZZ_TARGET(MyLexerTarget) {
//     // parse/lex etc.
//     return 0;
//   }
//
//   #define FUZZ_DRIVER_TARGET MyLexerTarget
//   // libFuzzer entrypoint will be generated by fuzz_driver.h.
//
// Notes:
//  - Keep target deterministic; no time, no random unless seeded from input.
//  - Prefer returning 0 always; crashes signal findings.

#ifndef VITTE_FUZZ_INCLUDE_FUZZ_FUZZ_TARGET_H
#define VITTE_FUZZ_INCLUDE_FUZZ_FUZZ_TARGET_H

#if defined(__cplusplus)
extern "C" {
#endif

#include <stddef.h>
#include <stdint.h>

#include "fuzz_assert.h"
#include "fuzz_io.h"

//------------------------------------------------------------------------------
// Target signature
//------------------------------------------------------------------------------

typedef int (*fuzz_target_fn)(const uint8_t* data, size_t size);

// Macro to declare a fuzz target function.
#define FUZZ_TARGET(name) static int name(const uint8_t* data, size_t size)

//------------------------------------------------------------------------------
// Common helpers for targets
//------------------------------------------------------------------------------

FUZZ_INLINE static void
fuzz_target_require_min(const uint8_t* data, size_t size, size_t min_size) {
  (void)data;
  if (size < min_size) {
    // Not a bug, just skip: returning is fine in fuzzing.
    // Keep it non-crashing to avoid false positives.
    return;
  }
}

FUZZ_INLINE static uint64_t
fuzz_target_seed64(const uint8_t* data, size_t size) {
  // Deterministic seed derivation from input prefix.
  // Uses a tiny FNV-1a over up to 32 bytes.
  const size_t n = (size < 32) ? size : 32;
  uint64_t h = 1469598103934665603ull;
  for (size_t i = 0; i < n; ++i) {
    h ^= (uint64_t)data[i];
    h *= 1099511628211ull;
  }
  // Avoid 0
  return h ? h : 0x9E3779B97F4A7C15ull;
}

FUZZ_INLINE static fuzz_reader
fuzz_target_reader(const uint8_t* data, size_t size) {
  return fuzz_reader_from(data, size);
}

// Consume a small “mode” byte to select parsing paths deterministically.
FUZZ_INLINE static uint8_t
fuzz_target_mode(fuzz_reader* r) {
  uint8_t m = 0;
  if (!fuzz_reader_read_u8(r, &m))
    return 0;
  return m;
}

#if defined(__cplusplus)
} // extern "C"
#endif

#endif // VITTE_FUZZ_INCLUDE_FUZZ_FUZZ_TARGET_H
