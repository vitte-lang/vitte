use std/kernel/console as console
use std/kernel/syscall as syscall
use std/kernel/task as task
use std/kernel/user as user

proc user_main() -> Unit {
  syscall.write_byte(117 as u8) # 'u'
  syscall.write_byte(115 as u8) # 's'
  syscall.write_byte(101 as u8) # 'e'
  syscall.write_byte(114 as u8) # 'r'
  syscall.write_byte(62 as u8)  # '>'
  syscall.write_byte(32 as u8)  # ' '

  let last = syscall.ticks()

  loop {
    let k = syscall.read_key()
    if k >= 0 {
      if k == 13 {
        syscall.write_byte(13 as u8)
        syscall.write_byte(10 as u8)
        syscall.write_byte(62 as u8)
        syscall.write_byte(32 as u8)
      } else if k == 8 {
        syscall.write_byte(8 as u8)
        syscall.write_byte(32 as u8)
        syscall.write_byte(8 as u8)
      } else {
        syscall.write_byte(k as u8)
      }
    }

    let now = syscall.ticks()
    if now - last >= 100 {
      syscall.write_byte(46 as u8) # '.'
      last = now
    }

    syscall.yield()
  }

  return Unit.Unit
}

entry main at core/app {
  console.write_byte(75 as u8)  # 'K'
  console.write_byte(58 as u8)  # ':'
  console.write_byte(32 as u8)  # ' '
  console.write_byte(117 as u8) # 'u'
  console.write_byte(115 as u8) # 's'
  console.write_byte(101 as u8) # 'e'
  console.write_byte(114 as u8) # 'r'
  console.write_byte(10 as u8)

  user.enter(user_main)

  loop {
    task.yield()
  }

  return 0
}
