<<<
mod.vit
package vitte/jobs
>>>

space vitte/jobs


pick JobState {
  Pending
  Inflight
  Done
  Failed
}

form Job {
  id: int
  payload: string
  attempts: int
  state: JobState
}

form JobQueue {
  next_id: int
  max_attempts: int
  pending: [Job]
  inflight: [Job]
  done: [Job]
  dlq: [Job]
}

proc queue_new(max_attempts: int) -> JobQueue {
  let max = max_attempts
  if max < 1 { max = 1 }
  give JobQueue(0, max, [], [], [], [])
}

proc enqueue(queue: JobQueue, payload: string) -> JobQueue {
  let job = Job(queue.next_id, payload, 0, JobState.Pending)
  let pending = queue.pending.push(job)
  give JobQueue(queue.next_id + 1, queue.max_attempts, pending, queue.inflight, queue.done, queue.dlq)
}

proc drop_first(jobs: [Job]) -> [Job] {
  let out: [Job] = []
  let i: int = 1
  loop {
    if i >= jobs.len { break }
    out = out.push(jobs[i])
    i = i + 1
  }
  give out
}

proc dequeue(queue: JobQueue) -> JobQueue {
  if queue.pending.len == 0 { give queue }
  let first = queue.pending[0]
  let pending = drop_first(queue.pending)
  let inflight = queue.inflight.push(Job(first.id, first.payload, first.attempts, JobState.Inflight))
  give JobQueue(queue.next_id, queue.max_attempts, pending, inflight, queue.done, queue.dlq)
}

proc ack(queue: JobQueue, job_id: int) -> JobQueue {
  let inflight: [Job] = []
  let done = queue.done
  let i: int = 0
  loop {
    if i >= queue.inflight.len { break }
    let job = queue.inflight[i]
    if job.id == job_id {
      done = done.push(Job(job.id, job.payload, job.attempts, JobState.Done))
    } else {
      inflight = inflight.push(job)
    }
    i = i + 1
  }
  give JobQueue(queue.next_id, queue.max_attempts, queue.pending, inflight, done, queue.dlq)
}

proc nack(queue: JobQueue, job_id: int) -> JobQueue {
  let inflight: [Job] = []
  let pending = queue.pending
  let dlq = queue.dlq

  let i: int = 0
  loop {
    if i >= queue.inflight.len { break }
    let job = queue.inflight[i]
    if job.id == job_id {
      let attempts = job.attempts + 1
      if attempts >= queue.max_attempts {
        dlq = dlq.push(Job(job.id, job.payload, attempts, JobState.Failed))
      } else {
        pending = pending.push(Job(job.id, job.payload, attempts, JobState.Pending))
      }
    } else {
      inflight = inflight.push(job)
    }
    i = i + 1
  }

  give JobQueue(queue.next_id, queue.max_attempts, pending, inflight, queue.done, dlq)
}

proc dead_letter(queue: JobQueue) -> [Job] {
  give queue.dlq
}

proc pending_count(queue: JobQueue) -> int {
  give queue.pending.len
}

proc inflight_count(queue: JobQueue) -> int {
  give queue.inflight.len
}

proc done_count(queue: JobQueue) -> int {
  give queue.done.len
}

proc dlq_count(queue: JobQueue) -> int {
  give queue.dlq.len
}

proc total_count(queue: JobQueue) -> int {
  give pending_count(queue) + inflight_count(queue) + done_count(queue) + dlq_count(queue)
}

proc has_pending(queue: JobQueue) -> bool {
  give pending_count(queue) > 0
}

proc has_inflight(queue: JobQueue) -> bool {
  give inflight_count(queue) > 0
}

proc has_done(queue: JobQueue) -> bool {
  give done_count(queue) > 0
}

proc has_dlq(queue: JobQueue) -> bool {
  give dlq_count(queue) > 0
}

proc next_pending_id(queue: JobQueue) -> int {
  if queue.pending.len == 0 { give -1 }
  give queue.pending[0].id
}

proc attempts_of(queue: JobQueue, job_id: int) -> int {
  let i: int = 0
  loop {
    if i >= queue.pending.len { break }
    if queue.pending[i].id == job_id { give queue.pending[i].attempts }
    i = i + 1
  }

  i = 0
  loop {
    if i >= queue.inflight.len { break }
    if queue.inflight[i].id == job_id { give queue.inflight[i].attempts }
    i = i + 1
  }

  i = 0
  loop {
    if i >= queue.done.len { break }
    if queue.done[i].id == job_id { give queue.done[i].attempts }
    i = i + 1
  }

  i = 0
  loop {
    if i >= queue.dlq.len { break }
    if queue.dlq[i].id == job_id { give queue.dlq[i].attempts }
    i = i + 1
  }

  give -1
}

proc state_of(queue: JobQueue, job_id: int) -> string {
  let i: int = 0
  loop {
    if i >= queue.pending.len { break }
    if queue.pending[i].id == job_id { give "pending" }
    i = i + 1
  }

  i = 0
  loop {
    if i >= queue.inflight.len { break }
    if queue.inflight[i].id == job_id { give "inflight" }
    i = i + 1
  }

  i = 0
  loop {
    if i >= queue.done.len { break }
    if queue.done[i].id == job_id { give "done" }
    i = i + 1
  }

  i = 0
  loop {
    if i >= queue.dlq.len { break }
    if queue.dlq[i].id == job_id { give "failed" }
    i = i + 1
  }

  give "missing"
}

proc requeue_dead(queue: JobQueue, job_id: int) -> JobQueue {
  let dlq: [Job] = []
  let pending = queue.pending

  let i: int = 0
  loop {
    if i >= queue.dlq.len { break }
    let job = queue.dlq[i]
    if job.id == job_id {
      if job.attempts < queue.max_attempts {
        pending = pending.push(Job(job.id, job.payload, job.attempts, JobState.Pending))
      } else {
        dlq = dlq.push(job)
      }
    } else {
      dlq = dlq.push(job)
    }
    i = i + 1
  }

  give JobQueue(queue.next_id, queue.max_attempts, pending, queue.inflight, queue.done, dlq)
}

proc clear_done(queue: JobQueue) -> JobQueue {
  give JobQueue(queue.next_id, queue.max_attempts, queue.pending, queue.inflight, [], queue.dlq)
}

proc clear_dlq(queue: JobQueue) -> JobQueue {
  give JobQueue(queue.next_id, queue.max_attempts, queue.pending, queue.inflight, queue.done, [])
}

proc stats(queue: JobQueue) -> string {
  give "pending=" + pending_count(queue).to_string() +
       ",inflight=" + inflight_count(queue).to_string() +
       ",done=" + done_count(queue).to_string() +
       ",dlq=" + dlq_count(queue).to_string()
}

pick JobError {
  None
  Empty
  NotFound
  RetryExceeded
}

form JobResult {
  queue: JobQueue
  error: JobError
  job_id: int
}

proc pick_next(queue: JobQueue) -> Job {
  if queue.pending.len == 0 { give Job(-1, "", 0, JobState.Pending) }
  give queue.pending[0]
}

proc dequeue_one(queue: JobQueue) -> JobResult {
  if queue.pending.len == 0 { give JobResult(queue, JobError.Empty, -1) }
  let next = pick_next(queue)
  give JobResult(dequeue(queue), JobError.None, next.id)
}

proc ack_one(queue: JobQueue, job_id: int) -> JobResult {
  if state_of(queue, job_id) != "inflight" { give JobResult(queue, JobError.NotFound, job_id) }
  give JobResult(ack(queue, job_id), JobError.None, job_id)
}

proc fail_one(queue: JobQueue, job_id: int) -> JobResult {
  let attempts = attempts_of(queue, job_id)
  if attempts < 0 { give JobResult(queue, JobError.NotFound, job_id) }
  let next = nack(queue, job_id)
  if attempts + 1 >= queue.max_attempts {
    give JobResult(next, JobError.RetryExceeded, job_id)
  }
  give JobResult(next, JobError.None, job_id)
}

proc run_cycle(queue: JobQueue, success: bool) -> JobResult {
  let d = dequeue_one(queue)
  if d.error != JobError.None { give d }
  if success { give ack_one(d.queue, d.job_id) }
  give fail_one(d.queue, d.job_id)
}

proc queue_depth(queue: JobQueue) -> int {
  give pending_count(queue) + inflight_count(queue)
}

proc completion_percent(queue: JobQueue) -> int {
  let total = total_count(queue)
  if total <= 0 { give 0 }
  give done_count(queue) * 100 / total
}

proc failure_percent(queue: JobQueue) -> int {
  let total = total_count(queue)
  if total <= 0 { give 0 }
  give dlq_count(queue) * 100 / total
}

proc is_stuck(queue: JobQueue) -> bool {
  if has_pending(queue) { give false }
  if has_inflight(queue) { give true }
  give false
}

proc health(queue: JobQueue) -> string {
  if dlq_count(queue) > 0 { give "degraded" }
  if is_stuck(queue) { give "warning" }
  give "ok"
}

proc ready() -> bool {
  give true
}



proc package_meta() -> string {
    give "vitte/jobs"
}

<<< ROLE-CONTRACT
package: vitte/jobs
role: File de jobs robuste avec reprise et dead letter
input_contract: Jobs explicites avec tentative et max_attempts definis
output_contract: Transitions d etat deterministes pending inflight done dlq
boundary: Ne remplace pas l orchestrateur externe; gere seulement le cycle de traitement
>>>
