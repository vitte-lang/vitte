<<<
mod.vit
package vitte/mock_http
>>>

space vitte/mock_http


form MockRoute {
  method: string
  path: string
  status: int
  body: string
}

form MockHttp {
  routes: [MockRoute]
}

form MockReply {
  status: int
  body: string
  matched: bool
}

proc canonical_method(method: string) -> string {
  if method == "get" { give "GET" }
  if method == "post" { give "POST" }
  if method == "put" { give "PUT" }
  if method == "delete" { give "DELETE" }
  give method
}

proc mock_new() -> MockHttp {
  give MockHttp([])
}

proc mock_add(mock: MockHttp, method: string, path: string, status: int, body: string) -> MockHttp {
  let meth = canonical_method(method)
  let http_status = status
  if http_status < 100 { http_status = 200 }

  let out: [MockRoute] = []
  let replaced: bool = false
  let i: int = 0
  loop {
    if i >= mock.routes.len { break }
    let route = mock.routes[i]
    if route.method == meth && route.path == path {
      out = out.push(MockRoute(meth, path, http_status, body))
      replaced = true
    } else {
      out = out.push(route)
    }
    i = i + 1
  }

  if !replaced {
    out = out.push(MockRoute(meth, path, http_status, body))
  }

  give MockHttp(out)
}

proc mock_match(mock: MockHttp, method: string, path: string) -> bool {
  let meth = canonical_method(method)
  let i: int = 0
  loop {
    if i >= mock.routes.len { break }
    let route = mock.routes[i]
    if route.method == meth && route.path == path {
      give true
    }
    i = i + 1
  }
  give false
}

proc mock_exists(mock: MockHttp, method: string, path: string) -> bool {
  give mock_match(mock, method, path)
}

proc mock_reply(mock: MockHttp, method: string, path: string) -> MockReply {
  let meth = canonical_method(method)
  let i: int = 0
  loop {
    if i >= mock.routes.len { break }
    let route = mock.routes[i]
    if route.method == meth && route.path == path {
      give MockReply(route.status, route.body, true)
    }
    i = i + 1
  }
  give MockReply(404, "mock_not_found", false)
}

proc mock_body(mock: MockHttp, method: string, path: string, fallback: string) -> string {
  let reply = mock_reply(mock, method, path)
  if !reply.matched { give fallback }
  give reply.body
}

proc mock_clear(mock: MockHttp) -> MockHttp {
  give MockHttp([])
}

proc mock_remove(mock: MockHttp, method: string, path: string) -> MockHttp {
  let meth = canonical_method(method)
  let out: [MockRoute] = []
  let i: int = 0
  loop {
    if i >= mock.routes.len { break }
    let route = mock.routes[i]
    if !(route.method == meth && route.path == path) {
      out = out.push(route)
    }
    i = i + 1
  }
  give MockHttp(out)
}

proc mock_count(mock: MockHttp) -> int {
  give mock.routes.len
}

proc mock_is_empty(mock: MockHttp) -> bool {
  give mock_count(mock) == 0
}

proc mock_count_method(mock: MockHttp, method: string) -> int {
  let meth = canonical_method(method)
  let count: int = 0
  let i: int = 0
  loop {
    if i >= mock.routes.len { break }
    if mock.routes[i].method == meth {
      count = count + 1
    }
    i = i + 1
  }
  give count
}

proc mock_methods(mock: MockHttp) -> [string] {
  let out: [string] = []
  let i: int = 0
  loop {
    if i >= mock.routes.len { break }
    let meth = mock.routes[i].method

    let exists: bool = false
    let j: int = 0
    loop {
      if j >= out.len { break }
      if out[j] == meth {
        exists = true
        break
      }
      j = j + 1
    }

    if !exists {
      out = out.push(meth)
    }
    i = i + 1
  }
  give out
}

proc mock_list_paths(mock: MockHttp, method: string) -> [string] {
  let meth = canonical_method(method)
  let out: [string] = []
  let i: int = 0
  loop {
    if i >= mock.routes.len { break }
    if mock.routes[i].method == meth {
      out = out.push(mock.routes[i].path)
    }
    i = i + 1
  }
  give out
}

proc mock_status(mock: MockHttp, method: string, path: string) -> int {
  let reply = mock_reply(mock, method, path)
  give reply.status
}

proc mock_route_at(mock: MockHttp, index: int) -> MockRoute {
  if index < 0 { give MockRoute("", "", 404, "") }
  if index >= mock.routes.len { give MockRoute("", "", 404, "") }
  give mock.routes[index]
}

proc mock_verify(mock: MockHttp, method: string, path: string, expected_status: int) -> bool {
  let reply = mock_reply(mock, method, path)
  if !reply.matched { give false }
  give reply.status == expected_status
}

proc mock_update_status(mock: MockHttp, method: string, path: string, status: int) -> MockHttp {
  let body = mock_body(mock, method, path, "")
  give mock_add(mock, method, path, status, body)
}

proc mock_update_body(mock: MockHttp, method: string, path: string, body: string) -> MockHttp {
  let status = mock_status(mock, method, path)
  if status < 100 { status = 200 }
  give mock_add(mock, method, path, status, body)
}

proc mock_stats(mock: MockHttp) -> string {
  give "routes=" + mock_count(mock).to_string() +
       ",methods=" + mock_methods(mock).len.to_string()
}

proc ready() -> bool {
  give true
}



proc package_meta() -> string {
    give "vitte/mock_http"
}

<<< ROLE-CONTRACT
package: vitte/mock_http
role: Mock d API externes pour tests deterministes
input_contract: Routes method path status body explicites
output_contract: Match et reponse stables sans I O reseau
boundary: Ne fait pas de transport HTTP reel; sert uniquement de simulateur local
>>>
