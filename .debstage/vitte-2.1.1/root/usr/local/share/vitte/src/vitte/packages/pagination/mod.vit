<<<
mod.vit
package vitte/pagination
>>>

space vitte/pagination


form Page {
  offset: int
  limit: int
  total: int
}

form PageWindow {
  start: int
  end: int
  size: int
}

form PageBounds {
  min_offset: int
  max_offset: int
}

form PageCursor {
  offset: int
  limit: int
}

pick PaginateError {
  None
  InvalidLimit
  InvalidOffset
  InvalidTotal
  InvalidCursor
}

proc clamp_int(value: int, min_value: int, max_value: int) -> int {
  let v = value
  if v < min_value { v = min_value }
  if v > max_value { v = max_value }
  give v
}

proc normalize_limit(limit: int) -> int {
  give clamp_int(limit, 1, 1000)
}

proc normalize_total(total: int) -> int {
  let t = total
  if t < 0 { t = 0 }
  give t
}

proc page(offset: int, limit: int, total: int) -> Page {
  let off = offset
  if off < 0 { off = 0 }

  let lim = normalize_limit(limit)
  let tot = normalize_total(total)

  give Page(off, lim, tot)
}

proc has_next(pg: Page) -> bool {
  give pg.offset + pg.limit < pg.total
}

proc next_cursor(pg: Page) -> int {
  if has_next(pg) { give pg.offset + pg.limit }
  give -1
}

proc window(pg: Page) -> PageWindow {
  let start = pg.offset
  let end = pg.offset + pg.limit
  if end > pg.total { end = pg.total }
  let size = end - start
  if size < 0 { size = 0 }
  give PageWindow(start, end, size)
}

proc page_count(total: int, limit: int) -> int {
  let tot = normalize_total(total)
  if tot <= 0 { give 0 }
  let lim = normalize_limit(limit)
  let count = tot / lim
  if tot % lim != 0 { count = count + 1 }
  give count
}

proc normalized(pg: Page) -> Page {
  let lim = normalize_limit(pg.limit)
  let tot = normalize_total(pg.total)

  let off = pg.offset
  if off < 0 { off = 0 }
  if off > tot { off = tot }

  if off + lim > tot && tot > 0 {
    let last = tot - lim
    if last < 0 { last = 0 }
    if off > last { off = last }
  }

  give Page(off, lim, tot)
}

proc has_prev(pg: Page) -> bool {
  give normalized(pg).offset > 0
}

proc prev_cursor(pg: Page) -> int {
  let n = normalized(pg)
  if n.offset <= 0 { give -1 }
  let prev = n.offset - n.limit
  if prev < 0 { give 0 }
  give prev
}

proc first_page(limit: int, total: int) -> Page {
  give normalized(Page(0, limit, total))
}

proc last_page(limit: int, total: int) -> Page {
  let lim = normalize_limit(limit)
  give normalized(Page(total - lim, lim, total))
}

proc page_index(pg: Page) -> int {
  let n = normalized(pg)
  if n.limit <= 0 { give 0 }
  give n.offset / n.limit
}

proc remaining(pg: Page) -> int {
  let n = normalized(pg)
  let rem = n.total - (n.offset + n.limit)
  if rem < 0 { give 0 }
  give rem
}

proc shift(pg: Page, delta: int) -> Page {
  let n = normalized(pg)
  give normalized(Page(n.offset + delta, n.limit, n.total))
}

proc with_limit(pg: Page, new_limit: int) -> Page {
  let n = normalized(pg)
  give normalized(Page(n.offset, normalize_limit(new_limit), n.total))
}

proc is_valid(pg: Page) -> bool {
  let n = normalized(pg)
  give n.limit > 0 && n.total >= 0 && n.offset >= 0
}

proc stats(pg: Page) -> string {
  let n = normalized(pg)
  let w = window(n)
  give "offset=" + n.offset.to_string() +
       ",limit=" + n.limit.to_string() +
       ",total=" + n.total.to_string() +
       ",size=" + w.size.to_string()
}

proc error(pg: Page) -> PaginateError {
  if pg.limit < 1 { give PaginateError.InvalidLimit }
  if pg.limit > 1000 { give PaginateError.InvalidLimit }
  if pg.offset < 0 { give PaginateError.InvalidOffset }
  if pg.total < 0 { give PaginateError.InvalidTotal }
  give PaginateError.None
}

proc is_empty(pg: Page) -> bool {
  give normalized(pg).total == 0
}

proc is_full(pg: Page) -> bool {
  let n = normalized(pg)
  let w = window(n)
  give w.size >= n.limit
}

proc bounds(pg: Page) -> PageBounds {
  let n = normalized(pg)
  let max_off = n.total - n.limit
  if max_off < 0 { max_off = 0 }
  give PageBounds(0, max_off)
}

proc cursor(pg: Page) -> PageCursor {
  let n = normalized(pg)
  give PageCursor(n.offset, n.limit)
}

proc from_cursor(cur: PageCursor, total: int) -> Page {
  if cur.limit < 1 { give Page(0, 1, normalize_total(total)) }
  if cur.offset < 0 { give Page(0, cur.limit, normalize_total(total)) }
  give normalized(Page(cur.offset, cur.limit, total))
}

proc page_at(index: int, limit: int, total: int) -> Page {
  let idx = index
  if idx < 0 { idx = 0 }
  let lim = normalize_limit(limit)
  give normalized(Page(idx * lim, lim, total))
}

proc next_page(pg: Page) -> Page {
  let n = normalized(pg)
  give page_at(page_index(n) + 1, n.limit, n.total)
}

proc prev_page(pg: Page) -> Page {
  let n = normalized(pg)
  let idx = page_index(n) - 1
  if idx < 0 { idx = 0 }
  give page_at(idx, n.limit, n.total)
}

proc with_total(pg: Page, new_total: int) -> Page {
  let n = normalized(pg)
  give normalized(Page(n.offset, n.limit, normalize_total(new_total)))
}

proc includes_offset(pg: Page, offset: int) -> bool {
  let n = normalized(pg)
  let w = window(n)
  if offset < 0 { give false }
  give offset >= w.start && offset < w.end
}

proc window_intersects(left: Page, right: Page) -> bool {
  let lw = window(normalized(left))
  let rw = window(normalized(right))
  if lw.size == 0 || rw.size == 0 { give false }
  give lw.start < rw.end && rw.start < lw.end
}

proc window_overlap_size(left: Page, right: Page) -> int {
  if !window_intersects(left, right) { give 0 }
  let lw = window(normalized(left))
  let rw = window(normalized(right))
  let start = lw.start
  if rw.start > start { start = rw.start }
  let end = lw.end
  if rw.end < end { end = rw.end }
  let size = end - start
  if size < 0 { size = 0 }
  give size
}

proc align_offset(pg: Page) -> Page {
  let n = normalized(pg)
  let aligned = (n.offset / n.limit) * n.limit
  give normalized(Page(aligned, n.limit, n.total))
}

proc tail(pg: Page, tail_size: int) -> Page {
  let n = normalized(pg)
  let sz = normalize_limit(tail_size)
  let off = n.total - sz
  if off < 0 { off = 0 }
  give normalized(Page(off, sz, n.total))
}

proc ready() -> bool {
  give true
}



proc package_meta() -> string {
    give "vitte/pagination"
}

<<< ROLE-CONTRACT
package: vitte/pagination
role: Pagination stable API DB
input_contract: Offset limit total explicites
output_contract: has_next next_cursor window deterministes
boundary: Ne fait pas la requete DB; calcule seulement la projection de pagination
>>>
