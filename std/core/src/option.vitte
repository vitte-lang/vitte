# std/core/option.vitte
# -----------------------------------------------------------------------------
# std/core/option
# -----------------------------------------------------------------------------
# Optional value type + helpers.
#
# MAX goals:
# - Provide a canonical Option type for stdlib without generics.
# - Bootstrap-friendly: concrete Options for common scalar/std types.
# - Ergonomic helpers: is_some/is_none, unwrap, unwrap_or, map-like helpers.
#
# Design:
# - Generic Option[T] is not available yet; we define:
#     OptionU32, OptionI32, OptionU64, OptionBool, OptionStr
# - Each option stores: ok: Bool + value: T
#
# Notes:
# - unwrap() triggers runtime assert/panic on None.
# - Prefer match on ok in hot paths.
# - All blocks use `.end` only.
# -----------------------------------------------------------------------------

module std.core.option

use std.runtime

type Bool = bool
type U32  = u32
type U64  = u64
type I32  = i32
type Str  = str

# -----------------------------------------------------------------------------
# OptionU32
# -----------------------------------------------------------------------------

type OptionU32 struct
  ok: Bool
  value: U32
.end

fn u32_none() -> OptionU32
  let o: OptionU32
  set o.ok = false
  set o.value = 0
  ret o
.end

fn u32_some(v: U32) -> OptionU32
  let o: OptionU32
  set o.ok = true
  set o.value = v
  ret o
.end

fn u32_is_some(o: &OptionU32) -> Bool
  ret o.ok
.end

fn u32_is_none(o: &OptionU32) -> Bool
  ret !o.ok
.end

fn u32_unwrap(o: &OptionU32) -> U32
  do std.runtime::assert(o.ok, "OptionU32::unwrap on None")
  ret o.value
.end

fn u32_unwrap_or(o: &OptionU32, default: U32) -> U32
  if o.ok
    ret o.value
  .end
  ret default
.end

# -----------------------------------------------------------------------------
# OptionI32
# -----------------------------------------------------------------------------

type OptionI32 struct
  ok: Bool
  value: I32
.end

fn i32_none() -> OptionI32
  let o: OptionI32
  set o.ok = false
  set o.value = 0
  ret o
.end

fn i32_some(v: I32) -> OptionI32
  let o: OptionI32
  set o.ok = true
  set o.value = v
  ret o
.end

fn i32_is_some(o: &OptionI32) -> Bool
  ret o.ok
.end

fn i32_is_none(o: &OptionI32) -> Bool
  ret !o.ok
.end

fn i32_unwrap(o: &OptionI32) -> I32
  do std.runtime::assert(o.ok, "OptionI32::unwrap on None")
  ret o.value
.end

fn i32_unwrap_or(o: &OptionI32, default: I32) -> I32
  if o.ok
    ret o.value
  .end
  ret default
.end

# -----------------------------------------------------------------------------
# OptionU64
# -----------------------------------------------------------------------------

type OptionU64 struct
  ok: Bool
  value: U64
.end

fn u64_none() -> OptionU64
  let o: OptionU64
  set o.ok = false
  set o.value = 0
  ret o
.end

fn u64_some(v: U64) -> OptionU64
  let o: OptionU64
  set o.ok = true
  set o.value = v
  ret o
.end

fn u64_is_some(o: &OptionU64) -> Bool
  ret o.ok
.end

fn u64_is_none(o: &OptionU64) -> Bool
  ret !o.ok
.end

fn u64_unwrap(o: &OptionU64) -> U64
  do std.runtime::assert(o.ok, "OptionU64::unwrap on None")
  ret o.value
.end

fn u64_unwrap_or(o: &OptionU64, default: U64) -> U64
  if o.ok
    ret o.value
  .end
  ret default
.end

# -----------------------------------------------------------------------------
# OptionBool
# -----------------------------------------------------------------------------

type OptionBool struct
  ok: Bool
  value: Bool
.end

fn bool_none() -> OptionBool
  let o: OptionBool
  set o.ok = false
  set o.value = false
  ret o
.end

fn bool_some(v: Bool) -> OptionBool
  let o: OptionBool
  set o.ok = true
  set o.value = v
  ret o
.end

fn bool_is_some(o: &OptionBool) -> Bool
  ret o.ok
.end

fn bool_is_none(o: &OptionBool) -> Bool
  ret !o.ok
.end

fn bool_unwrap(o: &OptionBool) -> Bool
  do std.runtime::assert(o.ok, "OptionBool::unwrap on None")
  ret o.value
.end

fn bool_unwrap_or(o: &OptionBool, default: Bool) -> Bool
  if o.ok
    ret o.value
  .end
  ret default
.end

# -----------------------------------------------------------------------------
# OptionStr
# -----------------------------------------------------------------------------

type OptionStr struct
  ok: Bool
  value: Str
.end

fn str_none() -> OptionStr
  let o: OptionStr
  set o.ok = false
  set o.value = ""
  ret o
.end

fn str_some(v: Str) -> OptionStr
  let o: OptionStr
  set o.ok = true
  set o.value = v
  ret o
.end

fn str_is_some(o: &OptionStr) -> Bool
  ret o.ok
.end

fn str_is_none(o: &OptionStr) -> Bool
  ret !o.ok
.end

fn str_unwrap(o: &OptionStr) -> Str
  do std.runtime::assert(o.ok, "OptionStr::unwrap on None")
  ret o.value
.end

fn str_unwrap_or(o: &OptionStr, default: Str) -> Str
  if o.ok
    ret o.value
  .end
  ret default
.end

# -----------------------------------------------------------------------------
# Utility constructors (overloaded style by name prefix)
# -----------------------------------------------------------------------------

fn option_u32(ok: Bool, v: U32) -> OptionU32
  if ok
    ret u32_some(v)
  .end
  ret u32_none()
.end

fn option_i32(ok: Bool, v: I32) -> OptionI32
  if ok
    ret i32_some(v)
  .end
  ret i32_none()
.end

fn option_u64(ok: Bool, v: U64) -> OptionU64
  if ok
    ret u64_some(v)
  .end
  ret u64_none()
.end

fn option_bool(ok: Bool, v: Bool) -> OptionBool
  if ok
    ret bool_some(v)
  .end
  ret bool_none()
.end

fn option_str(ok: Bool, v: Str) -> OptionStr
  if ok
    ret str_some(v)
  .end
  ret str_none()
.end

# -----------------------------------------------------------------------------
# Smoke tests (scenarios)
# -----------------------------------------------------------------------------

scn test_option_u32
  let a = u32_none()
  do std.runtime::assert(u32_is_none(&a), "none")
  do std.runtime::assert(u32_unwrap_or(&a, 7) == 7, "unwrap_or")

  let b = u32_some(3)
  do std.runtime::assert(u32_is_some(&b), "some")
  do std.runtime::assert(u32_unwrap(&b) == 3, "unwrap")
.end

scn test_option_str
  let a = str_none()
  do std.runtime::assert(str_is_none(&a), "none str")
  do std.runtime::assert(str_unwrap_or(&a, "x") == "x", "unwrap_or str")

  let b = str_some("ok")
  do std.runtime::assert(str_is_some(&b), "some str")
  do std.runtime::assert(str_unwrap(&b) == "ok", "unwrap str")
.end

# End of std.core.option