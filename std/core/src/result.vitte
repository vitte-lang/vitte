# std/core/result.vitte
# -----------------------------------------------------------------------------
# std/core/result
# -----------------------------------------------------------------------------
# Result type + helpers (error handling) without generics.
#
# MAX goals:
# - Canonical Result type family for stdlib modules.
# - Bootstrap-friendly: concrete Results for common value/error combos.
# - Ergonomic helpers: is_ok/is_err, unwrap, unwrap_or, expect.
#
# Design:
# - Generic Result[T,E] not available yet; we define:
#     ResultU32, ResultI32, ResultU64, ResultBool, ResultStr
#   Each uses a shared error type:
#     Error { code: I32, msg: Str }
#
# Notes:
# - unwrap/expect assert on Err (panic in runtime).
# - Prefer matching on ok for hot paths.
# - All blocks use `.end` only.
# -----------------------------------------------------------------------------

module std.core.result

use std.runtime

type Bool = bool
type U32  = u32
type U64  = u64
type I32  = i32
type Str  = str

# -----------------------------------------------------------------------------
# Error
# -----------------------------------------------------------------------------

type Error struct
  code: I32
  msg: Str
.end

fn err_new(code: I32, msg: Str) -> Error
  let e: Error
  set e.code = code
  set e.msg = msg
  ret e
.end

fn err_ok() -> Error
  ret err_new(0, "")
.end

fn err_is_ok(e: &Error) -> Bool
  ret e.code == 0
.end

fn err_is_err(e: &Error) -> Bool
  ret e.code != 0
.end

# Common error constructors (conventions)
fn err_invalid(msg: Str) -> Error
  ret err_new(1, msg)
.end

fn err_oob(msg: Str) -> Error
  ret err_new(2, msg)
.end

fn err_nomem(msg: Str) -> Error
  ret err_new(3, msg)
.end

fn err_io(msg: Str) -> Error
  ret err_new(4, msg)
.end

fn err_not_found(msg: Str) -> Error
  ret err_new(5, msg)
.end

# -----------------------------------------------------------------------------
# ResultU32
# -----------------------------------------------------------------------------

type ResultU32 struct
  ok: Bool
  value: U32
  err: Error
.end

fn u32_ok(v: U32) -> ResultU32
  let r: ResultU32
  set r.ok = true
  set r.value = v
  set r.err = err_ok()
  ret r
.end

fn u32_err(e: Error) -> ResultU32
  let r: ResultU32
  set r.ok = false
  set r.value = 0
  set r.err = e
  ret r
.end

fn u32_is_ok(r: &ResultU32) -> Bool
  ret r.ok
.end

fn u32_is_err(r: &ResultU32) -> Bool
  ret !r.ok
.end

fn u32_unwrap(r: &ResultU32) -> U32
  do std.runtime::assert(r.ok, "ResultU32::unwrap on Err")
  ret r.value
.end

fn u32_expect(r: &ResultU32, msg: Str) -> U32
  do std.runtime::assert(r.ok, msg)
  ret r.value
.end

fn u32_unwrap_or(r: &ResultU32, default: U32) -> U32
  if r.ok
    ret r.value
  .end
  ret default
.end

# -----------------------------------------------------------------------------
# ResultI32
# -----------------------------------------------------------------------------

type ResultI32 struct
  ok: Bool
  value: I32
  err: Error
.end

fn i32_ok(v: I32) -> ResultI32
  let r: ResultI32
  set r.ok = true
  set r.value = v
  set r.err = err_ok()
  ret r
.end

fn i32_err(e: Error) -> ResultI32
  let r: ResultI32
  set r.ok = false
  set r.value = 0
  set r.err = e
  ret r
.end

fn i32_is_ok(r: &ResultI32) -> Bool
  ret r.ok
.end

fn i32_is_err(r: &ResultI32) -> Bool
  ret !r.ok
.end

fn i32_unwrap(r: &ResultI32) -> I32
  do std.runtime::assert(r.ok, "ResultI32::unwrap on Err")
  ret r.value
.end

fn i32_expect(r: &ResultI32, msg: Str) -> I32
  do std.runtime::assert(r.ok, msg)
  ret r.value
.end

fn i32_unwrap_or(r: &ResultI32, default: I32) -> I32
  if r.ok
    ret r.value
  .end
  ret default
.end

# -----------------------------------------------------------------------------
# ResultU64
# -----------------------------------------------------------------------------

type ResultU64 struct
  ok: Bool
  value: U64
  err: Error
.end

fn u64_ok(v: U64) -> ResultU64
  let r: ResultU64
  set r.ok = true
  set r.value = v
  set r.err = err_ok()
  ret r
.end

fn u64_err(e: Error) -> ResultU64
  let r: ResultU64
  set r.ok = false
  set r.value = 0
  set r.err = e
  ret r
.end

fn u64_is_ok(r: &ResultU64) -> Bool
  ret r.ok
.end

fn u64_is_err(r: &ResultU64) -> Bool
  ret !r.ok
.end

fn u64_unwrap(r: &ResultU64) -> U64
  do std.runtime::assert(r.ok, "ResultU64::unwrap on Err")
  ret r.value
.end

fn u64_expect(r: &ResultU64, msg: Str) -> U64
  do std.runtime::assert(r.ok, msg)
  ret r.value
.end

fn u64_unwrap_or(r: &ResultU64, default: U64) -> U64
  if r.ok
    ret r.value
  .end
  ret default
.end

# -----------------------------------------------------------------------------
# ResultBool
# -----------------------------------------------------------------------------

type ResultBool struct
  ok: Bool
  value: Bool
  err: Error
.end

fn bool_ok(v: Bool) -> ResultBool
  let r: ResultBool
  set r.ok = true
  set r.value = v
  set r.err = err_ok()
  ret r
.end

fn bool_err(e: Error) -> ResultBool
  let r: ResultBool
  set r.ok = false
  set r.value = false
  set r.err = e
  ret r
.end

fn bool_is_ok(r: &ResultBool) -> Bool
  ret r.ok
.end

fn bool_is_err(r: &ResultBool) -> Bool
  ret !r.ok
.end

fn bool_unwrap(r: &ResultBool) -> Bool
  do std.runtime::assert(r.ok, "ResultBool::unwrap on Err")
  ret r.value
.end

fn bool_expect(r: &ResultBool, msg: Str) -> Bool
  do std.runtime::assert(r.ok, msg)
  ret r.value
.end

fn bool_unwrap_or(r: &ResultBool, default: Bool) -> Bool
  if r.ok
    ret r.value
  .end
  ret default
.end

# -----------------------------------------------------------------------------
# ResultStr
# -----------------------------------------------------------------------------

type ResultStr struct
  ok: Bool
  value: Str
  err: Error
.end

fn str_ok(v: Str) -> ResultStr
  let r: ResultStr
  set r.ok = true
  set r.value = v
  set r.err = err_ok()
  ret r
.end

fn str_err(e: Error) -> ResultStr
  let r: ResultStr
  set r.ok = false
  set r.value = ""
  set r.err = e
  ret r
.end

fn str_is_ok(r: &ResultStr) -> Bool
  ret r.ok
.end

fn str_is_err(r: &ResultStr) -> Bool
  ret !r.ok
.end

fn str_unwrap(r: &ResultStr) -> Str
  do std.runtime::assert(r.ok, "ResultStr::unwrap on Err")
  ret r.value
.end

fn str_expect(r: &ResultStr, msg: Str) -> Str
  do std.runtime::assert(r.ok, msg)
  ret r.value
.end

fn str_unwrap_or(r: &ResultStr, default: Str) -> Str
  if r.ok
    ret r.value
  .end
  ret default
.end

# -----------------------------------------------------------------------------
# Utility constructors (common pattern)
# -----------------------------------------------------------------------------

fn result_u32(ok: Bool, v: U32, e: Error) -> ResultU32
  if ok
    ret u32_ok(v)
  .end
  ret u32_err(e)
.end

fn result_str(ok: Bool, v: Str, e: Error) -> ResultStr
  if ok
    ret str_ok(v)
  .end
  ret str_err(e)
.end

# -----------------------------------------------------------------------------
# Smoke tests (scenarios)
# -----------------------------------------------------------------------------

scn test_result_ok_err
  let r1 = u32_ok(7)
  do std.runtime::assert(u32_is_ok(&r1), "ok")
  do std.runtime::assert(u32_unwrap(&r1) == 7, "unwrap ok")

  let e = err_invalid("bad")
  let r2 = u32_err(e)
  do std.runtime::assert(u32_is_err(&r2), "err")
  do std.runtime::assert(u32_unwrap_or(&r2, 9) == 9, "unwrap_or")
.end

scn test_result_str
  let r1 = str_ok("x")
  do std.runtime::assert(str_is_ok(&r1), "ok str")
  do std.runtime::assert(str_unwrap(&r1) == "x", "unwrap str")
.end

# End of std.core.result