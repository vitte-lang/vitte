# std/core/prelude.vitte
# -----------------------------------------------------------------------------
# std/core/prelude
# -----------------------------------------------------------------------------
# Prelude: commonly used types and functions re-exported for convenience.
#
# MAX goals:
# - Provide a single import point for core primitives used by most modules.
# - Keep it small and stable: types + a few functions, no heavy modules.
# - Bootstrap-friendly: no generics assumptions.
#
# Exports (conceptual):
# - basic scalar aliases (Bool/U32/I32/U64/Str)
# - Ordering + cmp helpers
# - Hash helpers
# - Option concrete types
#
# NOTE:
# - If your module system supports `export` statements, add them.
# - Otherwise, consumers `use std.core.prelude` and refer to names directly.
#
# All blocks use `.end` only.
# -----------------------------------------------------------------------------

module std.core.prelude

use std.runtime
use std.string

use std.core.cmp
use std.core.hash
use std.core.option

type Bool = bool
type U8   = u8
type U16  = u16
type U32  = u32
type U64  = u64
type I8   = i8
type I16  = i16
type I32  = i32
type I64  = i64
type Str  = str

# -----------------------------------------------------------------------------
# Re-export style aliases / forwards
# -----------------------------------------------------------------------------

# Ordering
type Ordering = std.core.cmp::Ordering

fn ordering_from_i32(x: I32) -> Ordering
  ret std.core.cmp::ordering_from_i32(x)
.end

fn ordering_to_i32(o: Ordering) -> I32
  ret std.core.cmp::ordering_to_i32(o)
.end

# cmp helpers
fn cmp_u32(a: U32, b: U32) -> I32
  ret std.core.cmp::cmp_u32(a, b)
.end

fn cmp_i32(a: I32, b: I32) -> I32
  ret std.core.cmp::cmp_i32(a, b)
.end

fn cmp_u64(a: U64, b: U64) -> I32
  ret std.core.cmp::cmp_u64(a, b)
.end

fn cmp_bool(a: Bool, b: Bool) -> I32
  ret std.core.cmp::cmp_bool(a, b)
.end

fn cmp_str(a: Str, b: Str) -> I32
  ret std.core.cmp::cmp_str(a, b)
.end

fn min_u32(a: U32, b: U32) -> U32
  ret std.core.cmp::min_u32(a, b)
.end

fn max_u32(a: U32, b: U32) -> U32
  ret std.core.cmp::max_u32(a, b)
.end

fn clamp_u32(x: U32, lo: U32, hi: U32) -> U32
  ret std.core.cmp::clamp_u32(x, lo, hi)
.end

# hash helpers
type Hash64 = std.core.hash::Hash64

fn hash_u32(x: U32) -> Hash64
  ret std.core.hash::hash_u32(x)
.end

fn hash_u64(x: U64) -> Hash64
  ret std.core.hash::hash_u64(x)
.end

fn hash_i32(x: I32) -> Hash64
  ret std.core.hash::hash_i32(x)
.end

fn hash_bool(x: Bool) -> Hash64
  ret std.core.hash::hash_bool(x)
.end

fn hash_str(s: Str) -> Hash64
  ret std.core.hash::hash_str(s)
.end

fn hash64_combine(a: Hash64, b: Hash64) -> Hash64
  ret std.core.hash::hash64_combine(a, b)
.end

# Option concrete types
type OptionU32  = std.core.option::OptionU32
type OptionI32  = std.core.option::OptionI32
type OptionU64  = std.core.option::OptionU64
type OptionBool = std.core.option::OptionBool
type OptionStr  = std.core.option::OptionStr

fn u32_some(v: U32) -> OptionU32
  ret std.core.option::u32_some(v)
.end

fn u32_none() -> OptionU32
  ret std.core.option::u32_none()
.end

fn str_some(v: Str) -> OptionStr
  ret std.core.option::str_some(v)
.end

fn str_none() -> OptionStr
  ret std.core.option::str_none()
.end

# runtime assert passthrough (common)
fn assert(cond: Bool, msg: Str)
  do std.runtime::assert(cond, msg)
.end

# End of std.core.prelude