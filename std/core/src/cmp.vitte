# /Users/vincent/Documents/Github/vitte/std/core/src/cmp.vitte
# -----------------------------------------------------------------------------
# std/core/cmp
# -----------------------------------------------------------------------------
# Comparison primitives and ordering helpers.
#
# MAX goals:
# - Provide a unified, low-level comparison API for stdlib modules.
# - Bootstrap-friendly: no generics required; expose concrete comparators.
# - Stable semantics: total ordering where applicable.
#
# Coverage:
# - Ordering enum + helpers
# - Generic-style compare contract: cmp(a,b) -> I32 convention
# - Comparators for: integers (signed/unsigned), bool, str (delegated)
# - Min/max/clamp helpers (U32/I32/U64)
# - Lexicographic compare for Str slices (best-effort via std.string)
#
# All blocks use `.end` only.
# -----------------------------------------------------------------------------

module std.core.cmp

use std.runtime
use std.string

type Bool = bool
type U8   = u8
type U16  = u16
type U32  = u32
type U64  = u64
type I8   = i8
type I16  = i16
type I32  = i32
type I64  = i64
type Str  = str

# -----------------------------------------------------------------------------
# Ordering
# -----------------------------------------------------------------------------

type Ordering enum
  Less
  Equal
  Greater
.end

fn ordering_from_i32(x: I32) -> Ordering
  if x < 0
    ret Ordering::Less
  .end
  if x > 0
    ret Ordering::Greater
  .end
  ret Ordering::Equal
.end

fn ordering_to_i32(o: Ordering) -> I32
  if o == Ordering::Less
    ret -1
  .end
  if o == Ordering::Greater
    ret 1
  .end
  ret 0
.end

fn is_less(o: Ordering) -> Bool
  ret o == Ordering::Less
.end

fn is_equal(o: Ordering) -> Bool
  ret o == Ordering::Equal
.end

fn is_greater(o: Ordering) -> Bool
  ret o == Ordering::Greater
.end

# -----------------------------------------------------------------------------
# Core cmp convention
# -----------------------------------------------------------------------------
# Return value convention:
#   <0  => a < b
#    0  => a == b
#   >0  => a > b
# -----------------------------------------------------------------------------

fn cmp_u32(a: U32, b: U32) -> I32
  if a < b
    ret -1
  .end
  if a > b
    ret 1
  .end
  ret 0
.end

fn cmp_u64(a: U64, b: U64) -> I32
  if a < b
    ret -1
  .end
  if a > b
    ret 1
  .end
  ret 0
.end

fn cmp_i32(a: I32, b: I32) -> I32
  if a < b
    ret -1
  .end
  if a > b
    ret 1
  .end
  ret 0
.end

fn cmp_i64(a: I64, b: I64) -> I32
  if a < b
    ret -1
  .end
  if a > b
    ret 1
  .end
  ret 0
.end

fn cmp_bool(a: Bool, b: Bool) -> I32
  # false < true
  if a == b
    ret 0
  .end
  if a == false
    ret -1
  .end
  ret 1
.end

fn cmp_str(a: Str, b: Str) -> I32
  # Delegate to std.string::cmp if available
  ret std.string::cmp(a, b)
.end

fn ordering_u32(a: U32, b: U32) -> Ordering
  ret ordering_from_i32(cmp_u32(a, b))
.end

fn ordering_u64(a: U64, b: U64) -> Ordering
  ret ordering_from_i32(cmp_u64(a, b))
.end

fn ordering_i32(a: I32, b: I32) -> Ordering
  ret ordering_from_i32(cmp_i32(a, b))
.end

fn ordering_i64(a: I64, b: I64) -> Ordering
  ret ordering_from_i32(cmp_i64(a, b))
.end

fn ordering_bool(a: Bool, b: Bool) -> Ordering
  ret ordering_from_i32(cmp_bool(a, b))
.end

fn ordering_str(a: Str, b: Str) -> Ordering
  ret ordering_from_i32(cmp_str(a, b))
.end

# -----------------------------------------------------------------------------
# Min / Max / Clamp
# -----------------------------------------------------------------------------

fn min_u32(a: U32, b: U32) -> U32
  if a < b
    ret a
  .end
  ret b
.end

fn max_u32(a: U32, b: U32) -> U32
  if a > b
    ret a
  .end
  ret b
.end

fn clamp_u32(x: U32, lo: U32, hi: U32) -> U32
  if x < lo
    ret lo
  .end
  if x > hi
    ret hi
  .end
  ret x
.end

fn min_i32(a: I32, b: I32) -> I32
  if a < b
    ret a
  .end
  ret b
.end

fn max_i32(a: I32, b: I32) -> I32
  if a > b
    ret a
  .end
  ret b
.end

fn clamp_i32(x: I32, lo: I32, hi: I32) -> I32
  if x < lo
    ret lo
  .end
  if x > hi
    ret hi
  .end
  ret x
.end

fn min_u64(a: U64, b: U64) -> U64
  if a < b
    ret a
  .end
  ret b
.end

fn max_u64(a: U64, b: U64) -> U64
  if a > b
    ret a
  .end
  ret b
.end

fn clamp_u64(x: U64, lo: U64, hi: U64) -> U64
  if x < lo
    ret lo
  .end
  if x > hi
    ret hi
  .end
  ret x
.end

# -----------------------------------------------------------------------------
# Lexicographic helpers (Str slices)
# -----------------------------------------------------------------------------

fn str_len(s: Str) -> U32
  ret std.string::len(s)
.end

fn str_slice(s: Str, start: U32, len: U32) -> Str
  ret std.string::slice(s, start, len)
.end

fn cmp_str_lex(a: Str, b: Str) -> I32
  # Compare by code-unit slices (best-effort, depends on std.string semantics).
  let la = str_len(a)
  let lb = str_len(b)
  let n = min_u32(la, lb)

  let i: U32
  set i = 0
  while i < n
    let ca = str_slice(a, i, 1)
    let cb = str_slice(b, i, 1)
    let c = cmp_str(ca, cb)
    if c != 0
      ret c
    .end
    set i = i + 1
  .end

  # all equal prefix: shorter is less
  ret cmp_u32(la, lb)
.end

# -----------------------------------------------------------------------------
# Assertions / test scenarios
# -----------------------------------------------------------------------------

scn test_cmp_ordering
  do std.runtime::assert(ordering_from_i32(-1) == Ordering::Less, "from -1")
  do std.runtime::assert(ordering_from_i32(0) == Ordering::Equal, "from 0")
  do std.runtime::assert(ordering_from_i32(1) == Ordering::Greater, "from 1")

  do std.runtime::assert(ordering_to_i32(Ordering::Less) == -1, "to less")
  do std.runtime::assert(ordering_to_i32(Ordering::Equal) == 0, "to eq")
  do std.runtime::assert(ordering_to_i32(Ordering::Greater) == 1, "to gt")
.end

scn test_cmp_ints
  do std.runtime::assert(cmp_u32(1, 2) < 0, "u32 lt")
  do std.runtime::assert(cmp_u32(2, 2) == 0, "u32 eq")
  do std.runtime::assert(cmp_u32(3, 2) > 0, "u32 gt")

  do std.runtime::assert(cmp_i32(-2, -1) < 0, "i32 lt")
  do std.runtime::assert(cmp_i32(-1, -1) == 0, "i32 eq")
  do std.runtime::assert(cmp_i32(0, -1) > 0, "i32 gt")
.end

scn test_cmp_bool
  do std.runtime::assert(cmp_bool(false, false) == 0, "bool eq ff")
  do std.runtime::assert(cmp_bool(false, true) < 0, "bool f<t")
  do std.runtime::assert(cmp_bool(true, false) > 0, "bool t>f")
.end

scn test_cmp_minmaxclamp
  do std.runtime::assert(min_u32(1, 2) == 1, "min")
  do std.runtime::assert(max_u32(1, 2) == 2, "max")
  do std.runtime::assert(clamp_u32(5, 0, 3) == 3, "clamp hi")
  do std.runtime::assert(clamp_u32(1, 2, 9) == 2, "clamp lo")
  do std.runtime::assert(clamp_u32(5, 2, 9) == 5, "clamp mid")

  do std.runtime::assert(min_i32(-2, 1) == -2, "min i32")
  do std.runtime::assert(max_i32(-2, 1) == 1, "max i32")
.end

# End of std.core.cmp