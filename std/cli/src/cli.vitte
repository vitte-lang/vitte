# C:\Users\gogin\Documents\GitHub\vitte\std\cli\src\cli.vitte
mod std/cli/cli

use std/prelude

use std/core/option
use std/core/result

use std/alloc/vec
use std/alloc/string

use std/os/process
use std/os/env

use std/cli/args
use std/cli/term/tty
use std/cli/term/size
use std/cli/term/input
use std/cli/term/raw_mode

# =============================================================================
# std::cli — façade
# =============================================================================
#
# Objectif:
# - centraliser les points d'entrée CLI:
#   - args parsing (Argv)
#   - tty helpers
#   - user input
#   - process exit helpers
#
# =============================================================================

# -----------------------------------------------------------------------------
# Exit
# -----------------------------------------------------------------------------

fn exit(code: i32) -> void
  process::exit(code)
.end

fn exit_ok() -> void
  process::exit(0)
.end

fn exit_err() -> void
  process::exit(1)
.end

# -----------------------------------------------------------------------------
# Args
# -----------------------------------------------------------------------------

fn argv() -> args::Argv
  ret args::Argv::from_process()
.end

fn has_flag(name: &str) -> bool
  let a = argv()
  ret a.has_flag(name)
.end

fn opt(name: &str) -> option::Option[string::String]
  let a = argv()
  ret a.get_opt(name)
.end

fn opts(name: &str) -> vec::Vec[string::String]
  let a = argv()
  ret a.get_opts(name)
.end

fn positionals() -> vec::Vec[string::String]
  let a = argv()
  ret a.positionals.clone()
.end

fn command() -> option::Option[string::String]
  ret argv().command()
.end

fn command_args() -> vec::Vec[string::String]
  ret argv().command_args()
.end

# -----------------------------------------------------------------------------
# Terminal / TTY
# -----------------------------------------------------------------------------

fn is_tty_stdout() -> bool
  ret tty::is_tty_stdout()
.end

fn is_tty_stdin() -> bool
  ret tty::is_tty_stdin()
.end

fn term_size() -> size::TermSize
  ret tty::size()
.end

fn with_raw_mode(f: fn() -> void) -> result::Result[void, raw_mode::RawModeError]
  ret tty::with_raw_mode(f)
.end

fn read_line(prompt: &str) -> result::Result[string::String, input::InputError]
  ret input::read_line_trimmed(prompt)
.end

fn read_password(prompt: &str) -> result::Result[string::String, input::InputError]
  ret input::read_password(prompt)
.end

fn read_key() -> result::Result[input::KeyEvent, input::InputError]
  ret input::read_key()
.end

# -----------------------------------------------------------------------------
# Printing helpers
# -----------------------------------------------------------------------------

fn print(s: &str) -> void
  stdout_write(s)
.end

fn println(s: &str) -> void
  stdout_write(s)
  stdout_write("\n")
.end

fn eprint(s: &str) -> void
  stderr_write(s)
.end

fn eprintln(s: &str) -> void
  stderr_write(s)
  stderr_write("\n")
.end

fn die(msg: &str) -> void
  eprintln(msg)
  exit_err()
.end

# -----------------------------------------------------------------------------
# Usage helpers
# -----------------------------------------------------------------------------

struct UsageLine
  left: string::String
  right: string::String
.end

fn UsageLine::new(left: &str, right: &str) -> UsageLine
  ret UsageLine
    left: string::String::from_str(left)
    right: string::String::from_str(right)
  .end
.end

fn print_usage(title: &str, lines: &vec::Vec[UsageLine]) -> void
  println(title)
  println("")
  let mut i: usize = 0
  while i < lines.len()
    let l = lines[i]
    println(string::fmt("  {:<24} {}", l.left.as_str(), l.right.as_str()))
    i = i + 1
  .end
.end
