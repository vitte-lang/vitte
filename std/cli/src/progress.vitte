# /Users/vincent/Documents/Github/vitte/std/cli/src/progress.vitte
# -----------------------------------------------------------------------------
# std/cli/progress
# -----------------------------------------------------------------------------
# Progress rendering utilities (pure string rendering).
#
# Goals:
# - Bootstrap-friendly: no timers, no threads, no stdout assumptions.
# - Pure rendering: build a line, caller prints it (optionally with CR).
# - Compatible with std.cli.ansi for line clearing/cursor control.
#
# Features:
# - ProgressBar state: current/total, width, prefix/suffix, show_percent
# - Render modes:
#     * determinate (total > 0) => bar + percent + counts
#     * indeterminate (total == 0) => spinner + current
# - Helpers: clamp, repeat_char
#
# Notes:
# - This module assumes string concatenation via `+`.
# - All blocks use `.end` only.
# -----------------------------------------------------------------------------

module std.cli.progress

use std.runtime
use std.string
use std.cli.ansi

type Bool = bool

type U8  = u8
type U32 = u32
type I32 = i32

type Str = str

# -----------------------------------------------------------------------------
# Internal helpers
# -----------------------------------------------------------------------------

fn str_len(s: Str) -> U32
  ret std.string::len(s)
.end

fn u32_min(a: U32, b: U32) -> U32
  if a < b
    ret a
  .end
  ret b
.end

fn u32_max(a: U32, b: U32) -> U32
  if a > b
    ret a
  .end
  ret b
.end

fn u32_clamp(x: U32, lo: U32, hi: U32) -> U32
  if x < lo
    ret lo
  .end
  if x > hi
    ret hi
  .end
  ret x
.end

fn digit(n: U8) -> Str
  if n == 0
    ret "0"
  .end
  if n == 1
    ret "1"
  .end
  if n == 2
    ret "2"
  .end
  if n == 3
    ret "3"
  .end
  if n == 4
    ret "4"
  .end
  if n == 5
    ret "5"
  .end
  if n == 6
    ret "6"
  .end
  if n == 7
    ret "7"
  .end
  if n == 8
    ret "8"
  .end
  if n == 9
    ret "9"
  .end
  ret "?"
.end

fn u32_to_dec(n: U32) -> Str
  if n == 0
    ret "0"
  .end

  let x: U32
  set x = n

  let s: Str
  set s = ""

  while x > 0
    let d: U8
    set d = (U8)(x % 10)
    set s = digit(d) + s
    set x = x / 10
  .end

  ret s
.end

fn repeat_char(ch: Str, n: U32) -> Str
  let s: Str
  set s = ""
  let i: U32
  set i = 0
  while i < n
    set s = s + ch
    set i = i + 1
  .end
  ret s
.end

fn pct_u32(cur: U32, total: U32) -> U32
  if total == 0
    ret 0
  .end
  ret (cur * 100) / total
.end

# -----------------------------------------------------------------------------
# Public types
# -----------------------------------------------------------------------------

type ProgressStyle struct
  width: U32            # bar width (characters)
  fill: Str             # filled segment (e.g. "=")
  head: Str             # head segment (e.g. ">")
  empty: Str            # empty segment (e.g. " ")
  left: Str             # left bracket (e.g. "[")
  right: Str            # right bracket (e.g. "]")
  show_percent: Bool
  show_counts: Bool
  spinner: Str          # spinner frames, e.g. "|/-\\"
.end

fn style_default() -> ProgressStyle
  let s: ProgressStyle
  set s.width = 28
  set s.fill = "="
  set s.head = ">"
  set s.empty = " "
  set s.left = "["
  set s.right = "]"
  set s.show_percent = true
  set s.show_counts = true
  set s.spinner = "|/-\\"
  ret s
.end

type ProgressBar struct
  style: ProgressStyle
  prefix: Str
  suffix: Str
  current: U32
  total: U32            # 0 => indeterminate
  spin_index: U32
.end

fn progress_new(total: U32) -> ProgressBar
  let p: ProgressBar
  set p.style = style_default()
  set p.prefix = ""
  set p.suffix = ""
  set p.current = 0
  set p.total = total
  set p.spin_index = 0
  ret p
.end

fn progress_set_prefix(p: &ProgressBar, prefix: Str)
  set p.prefix = prefix
.end

fn progress_set_suffix(p: &ProgressBar, suffix: Str)
  set p.suffix = suffix
.end

fn progress_set_total(p: &ProgressBar, total: U32)
  set p.total = total
  if p.current > total && total != 0
    set p.current = total
  .end
.end

fn progress_set_width(p: &ProgressBar, width: U32)
  set p.style.width = u32_max(4, width)
.end

fn progress_set_show_percent(p: &ProgressBar, on: Bool)
  set p.style.show_percent = on
.end

fn progress_set_show_counts(p: &ProgressBar, on: Bool)
  set p.style.show_counts = on
.end

fn progress_set_value(p: &ProgressBar, current: U32)
  if p.total != 0
    set p.current = u32_clamp(current, 0, p.total)
  else
    set p.current = current
  .end
.end

fn progress_inc(p: &ProgressBar, delta: U32)
  do progress_set_value(p, p.current + delta)
.end

fn progress_done(p: &ProgressBar) -> Bool
  if p.total == 0
    ret false
  .end
  ret p.current >= p.total
.end

# -----------------------------------------------------------------------------
# Rendering
# -----------------------------------------------------------------------------

fn _spinner_frame(p: &ProgressBar) -> Str
  let frames = p.style.spinner
  let n = str_len(frames)
  if n == 0
    ret "."
  .end

  let idx = p.spin_index % n
  ret std.string::slice(frames, idx, 1)
.end

fn progress_tick(p: &ProgressBar)
  set p.spin_index = p.spin_index + 1
.end

fn render_determinate(p: &ProgressBar) -> Str
  let w = p.style.width
  let total = p.total
  let cur = u32_clamp(p.current, 0, total)

  let filled: U32
  if total == 0
    set filled = 0
  else
    set filled = (cur * w) / total
  .end

  if filled > w
    set filled = w
  .end

  let s: Str
  set s = ""

  if p.prefix != ""
    set s = s + p.prefix + " "
  .end

  set s = s + p.style.left

  if w == 0
    # nothing
  else
    if filled == 0
      set s = s + repeat_char(p.style.empty, w)
    else
      if filled >= w
        set s = s + repeat_char(p.style.fill, w)
      else
        if filled > 1
          set s = s + repeat_char(p.style.fill, filled - 1)
        .end
        set s = s + p.style.head
        set s = s + repeat_char(p.style.empty, w - filled)
      .end
    .end
  .end

  set s = s + p.style.right

  if p.style.show_percent
    let pct = pct_u32(cur, total)
    set s = s + " " + u32_to_dec(pct) + "%"
  .end

  if p.style.show_counts
    set s = s + " (" + u32_to_dec(cur) + "/" + u32_to_dec(total) + ")"
  .end

  if p.suffix != ""
    set s = s + " " + p.suffix
  .end

  ret s
.end

fn render_indeterminate(p: &ProgressBar) -> Str
  let s: Str
  set s = ""

  if p.prefix != ""
    set s = s + p.prefix + " "
  .end

  set s = s + _spinner_frame(p) + " " + u32_to_dec(p.current)

  if p.suffix != ""
    set s = s + " " + p.suffix
  .end

  ret s
.end

fn progress_render(p: &ProgressBar) -> Str
  if p.total == 0
    ret render_indeterminate(p)
  .end
  ret render_determinate(p)
.end

# Render a line suitable for in-place update:
# - Clears current line, returns CR + line (caller prints without newline).
fn progress_render_inplace(p: &ProgressBar) -> Str
  ret "\r" + std.cli.ansi::clear_line() + "\r" + progress_render(p)
.end

# -----------------------------------------------------------------------------
# Smoke tests (scenarios)
# -----------------------------------------------------------------------------

scn test_progress_determinate
  let p = progress_new(100)
  do progress_set_prefix(&p, "build")
  do progress_set_suffix(&p, "items")

  do progress_set_value(&p, 0)
  let a = progress_render(&p)
  do std.runtime::assert(a != "", "render non-empty")

  do progress_set_value(&p, 50)
  let b = progress_render(&p)
  do std.runtime::assert(b != "", "render non-empty 2")

  do progress_set_value(&p, 100)
  do std.runtime::assert(progress_done(&p), "done")
.end

scn test_progress_indeterminate
  let p = progress_new(0)
  do progress_set_prefix(&p, "scan")
  do progress_set_value(&p, 7)
  let a = progress_render(&p)
  do std.runtime::assert(a != "", "render indeterminate")

  do progress_tick(&p)
  let b = progress_render(&p)
  do std.runtime::assert(b != "", "render tick")
.end

# End of std.cli.progress