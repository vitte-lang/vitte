# C:\Users\gogin\Documents\GitHub\vitte\std\cli\src\progress.vitte
mod std/cli/progress

use std/prelude

use std/core/option
use std/core/result

use std/alloc/string

use std/time/instant
use std/time/duration

use std/cli/colors
use std/cli/term/tty

# =============================================================================
# std::cli::progress — progress bars / spinners (TTY)
# =============================================================================
#
# Objectif:
# - Spinner + ProgressBar
# - auto disable si stdout n'est pas TTY ou couleurs désactivées
# - rendu minimal: CR + clear line (ANSI), fallback plain prints
#
# =============================================================================

# -----------------------------------------------------------------------------
# Render primitives (ANSI)
# -----------------------------------------------------------------------------

fn ansi_clear_line() -> &str
  ret "\x1b[2K"
.end

fn ansi_carriage_return() -> &str
  ret "\r"
.end

fn ansi_hide_cursor() -> &str
  ret "\x1b[?25l"
.end

fn ansi_show_cursor() -> &str
  ret "\x1b[?25h"
.end

fn now_ms() -> u64
  ret instant::now().as_millis_u64()
.end

# -----------------------------------------------------------------------------
# Spinner
# -----------------------------------------------------------------------------

struct Spinner
  enabled: bool
  frames: [char; 10]
  idx: usize
  last_ms: u64
  interval_ms: u64
  msg: string::String
  done: bool
.end

fn Spinner::new(msg: &str) -> Spinner
  let en = tty::is_tty_stdout() && colors::should_color_stdout()
  ret Spinner
    enabled: en
    frames: ['|','/','-','\\','|','/','-','\\','|','/']
    idx: 0
    last_ms: now_ms()
    interval_ms: 80
    msg: string::String::from_str(msg)
    done: false
  .end
.end

fn Spinner::set_interval_ms(self: &mut Spinner, ms: u64) -> &mut Spinner
  self.interval_ms = ms
  ret self
.end

fn Spinner::tick(self: &mut Spinner) -> void
  if !self.enabled || self.done
    ret
  .end

  let t = now_ms()
  if (t - self.last_ms) < self.interval_ms
    ret
  .end
  self.last_ms = t

  let ch = self.frames[self.idx % self.frames.len()]
  self.idx = self.idx + 1

  stdout_write(ansi_carriage_return())
  stdout_write(ansi_clear_line())
  stdout_write(colors::cyan(string::fmt("{}", ch)).as_str())
  stdout_write(" ")
  stdout_write(self.msg.as_str())
  stdout_flush()
.end

fn Spinner::finish_ok(self: &mut Spinner, msg: &str) -> void
  self.finish_with("ok", msg)
.end

fn Spinner::finish_err(self: &mut Spinner, msg: &str) -> void
  self.finish_with("err", msg)
.end

fn Spinner::finish_with(self: &mut Spinner, tag: &str, msg: &str) -> void
  if self.done
    ret
  .end
  self.done = true

  if !self.enabled
    stdout_write(string::fmt("[{}] {}\n", tag, msg))
    ret
  .end

  stdout_write(ansi_carriage_return())
  stdout_write(ansi_clear_line())

  let prefix =
    if tag == "ok"
      colors::green("✔").as_str()
    elif tag == "err"
      colors::red("✘").as_str()
    else
      colors::gray(string::fmt("[{}]", tag).as_str()).as_str()
    .end

  stdout_write(prefix)
  stdout_write(" ")
  stdout_write(msg)
  stdout_write("\n")
  stdout_flush()
.end

# -----------------------------------------------------------------------------
# Progress bar
# -----------------------------------------------------------------------------

struct ProgressBar
  enabled: bool
  total: u64
  cur: u64
  width: u16
  last_ms: u64
  interval_ms: u64
  label: string::String
  done: bool
.end

fn ProgressBar::new(total: u64, label: &str) -> ProgressBar
  let en = tty::is_tty_stdout()
  let ts = tty::size()
  let w = if ts.cols > 20 then (ts.cols - 20) else 30
  ret ProgressBar
    enabled: en
    total: if total == 0 then 1 else total
    cur: 0
    width: w
    last_ms: now_ms()
    interval_ms: 100
    label: string::String::from_str(label)
    done: false
  .end
.end

fn ProgressBar::set_interval_ms(self: &mut ProgressBar, ms: u64) -> &mut ProgressBar
  self.interval_ms = ms
  ret self
.end

fn ProgressBar::set_total(self: &mut ProgressBar, total: u64) -> void
  self.total = if total == 0 then 1 else total
  if self.cur > self.total
    self.cur = self.total
  .end
.end

fn ProgressBar::inc(self: &mut ProgressBar, delta: u64) -> void
  self.set(self.cur + delta)
.end

fn ProgressBar::set(self: &mut ProgressBar, v: u64) -> void
  if self.done
    ret
  .end
  self.cur = if v > self.total then self.total else v
  self.render(false)
.end

fn ProgressBar::render(self: &mut ProgressBar, force: bool) -> void
  if !self.enabled || self.done
    ret
  .end

  let t = now_ms()
  if !force && (t - self.last_ms) < self.interval_ms
    ret
  .end
  self.last_ms = t

  let frac = (self.cur as f64) / (self.total as f64)
  let filled = (frac * (self.width as f64)) as u16
  let mut bar = string::String::new()
  bar.reserve(self.width as usize)

  let mut i: u16 = 0
  while i < self.width
    if i < filled
      bar.push_char('█')
    else
      bar.push_char('░')
    .end
    i = i + 1
  .end

  let pct = (frac * 100.0) as u32

  stdout_write(ansi_carriage_return())
  stdout_write(ansi_clear_line())

  stdout_write(colors::bold().as_str())
  stdout_write(self.label.as_str())
  stdout_write(colors::reset().as_str())
  stdout_write(" ")

  stdout_write(colors::green(bar.as_str()).as_str())
  stdout_write(" ")
  stdout_write(string::fmt("{:>3}%", pct))

  stdout_flush()
.end

fn ProgressBar::finish(self: &mut ProgressBar) -> void
  if self.done
    ret
  .end
  self.done = true

  if !self.enabled
    stdout_write(string::fmt("{}: {}/{}\n", self.label.as_str(), self.cur, self.total))
    ret
  .end

  self.render(true)
  stdout_write("\n")
  stdout_flush()
.end

fn ProgressBar::finish_ok(self: &mut ProgressBar, msg: &str) -> void
  if self.done
    ret
  .end
  self.done = true

  if !self.enabled
    stdout_write(string::fmt("[ok] {}\n", msg))
    ret
  .end

  stdout_write(ansi_carriage_return())
  stdout_write(ansi_clear_line())
  stdout_write(colors::green("✔").as_str())
  stdout_write(" ")
  stdout_write(msg)
  stdout_write("\n")
  stdout_flush()
.end

fn ProgressBar::finish_err(self: &mut ProgressBar, msg: &str) -> void
  if self.done
    ret
  .end
  self.done = true

  if !self.enabled
    stdout_write(string::fmt("[err] {}\n", msg))
    ret
  .end

  stdout_write(ansi_carriage_return())
  stdout_write(ansi_clear_line())
  stdout_write(colors::red("✘").as_str())
  stdout_write(" ")
  stdout_write(msg)
  stdout_write("\n")
  stdout_flush()
.end
