# C:\Users\gogin\Documents\GitHub\vitte\std\cli\src\term\size.vitte
mod std/cli/term/size

use std/prelude

use std/core/option
use std/core/result

use std/alloc/string
use std/alloc/vec

use std/os/env
use std/os/process

# =============================================================================
# std::cli::term::size (portable)
# =============================================================================
#
# Objectif:
# - obtenir la taille du terminal (cols, rows)
#
# Stratégie (fallback, portable):
#  1) variables d'env: COLUMNS / LINES
#  2) heuristique via "stty size" (POSIX) si process::exec_capture dispo
#  3) fallback par défaut (80x24)
#
# Upgrade path:
# - POSIX ioctl(TIOCGWINSZ)
# - Windows GetConsoleScreenBufferInfo
#
# =============================================================================

struct TermSize
  cols: u16
  rows: u16
.end

fn TermSize::new(cols: u16, rows: u16) -> TermSize
  ret TermSize
    cols: cols
    rows: rows
  .end
.end

fn TermSize::default() -> TermSize
  ret TermSize::new(80, 24)
.end

fn TermSize::is_valid(self: &TermSize) -> bool
  ret self.cols > 0 && self.rows > 0
.end

# -----------------------------------------------------------------------------
# Parsing helpers
# -----------------------------------------------------------------------------

fn parse_u16_opt(s: &str) -> option::Option[u16]
  let n = string::parse_u64(s)
  if n.is_none()
    ret option::None
  .end
  let v = n.unwrap()
  if v > 65535
    ret option::None
  .end
  ret option::Some(v as u16)
.end

fn split_ws2(s: &str) -> option::Option[(string::String, string::String)]
  # return first two whitespace-separated tokens
  let mut a: option::Option[string::String] = option::None
  let mut b: option::Option[string::String] = option::None

  let mut cur = string::String::new()
  let mut i: usize = 0
  let bytes = s.as_bytes()

  fn is_ws(c: u8) -> bool
    ret c == (' ' as u8) || c == ('\t' as u8) || c == ('\n' as u8) || c == ('\r' as u8)
  .end

  # skip leading ws
  while i < bytes.len() && is_ws(bytes[i])
    i = i + 1
  .end

  while i < bytes.len()
    if is_ws(bytes[i])
      if cur.len() > 0
        if a.is_none()
          a = option::Some(cur.clone())
          cur.clear()
        elif b.is_none()
          b = option::Some(cur.clone())
          cur.clear()
          break
        else
          break
        .end
      .end
      while i < bytes.len() && is_ws(bytes[i])
        i = i + 1
      .end
      continue
    .end

    cur.push_char(bytes[i] as char)
    i = i + 1
  .end

  if cur.len() > 0
    if a.is_none()
      a = option::Some(cur.clone())
    elif b.is_none()
      b = option::Some(cur.clone())
    .end
  .end

  if a.is_some() && b.is_some()
    ret option::Some((a.unwrap(), b.unwrap()))
  .end
  ret option::None
.end

# -----------------------------------------------------------------------------
# Env path: COLUMNS/LINES
# -----------------------------------------------------------------------------

fn from_env() -> option::Option[TermSize]
  let cols_s = env::get("COLUMNS")
  let rows_s = env::get("LINES")

  if cols_s.is_some() && rows_s.is_some()
    let c = parse_u16_opt(cols_s.unwrap().as_str())
    let r = parse_u16_opt(rows_s.unwrap().as_str())
    if c.is_some() && r.is_some()
      let ts = TermSize::new(c.unwrap(), r.unwrap())
      if ts.is_valid()
        ret option::Some(ts)
      .end
    .end
  .end

  ret option::None
.end

# -----------------------------------------------------------------------------
# POSIX fallback: stty size
# -----------------------------------------------------------------------------
# expects output: "rows cols"
# Requires a process capture helper. If not available, function returns None.

fn from_stty_size() -> option::Option[TermSize]
  # If your std/os/process does not have exec_capture, keep returning None.
  # Convention used here:
  #   process::exec_capture(cmd: &str, args: &vec::Vec[string::String]) -> Option[string::String]
  #
  # Replace accordingly.

  if !process::supports_exec_capture()
    ret option::None
  .end

  let mut args: vec::Vec[string::String] = vec::Vec[string::String]::new()
  args.push(string::String::from_str("size"))

  let out = process::exec_capture("stty", &args)
  if out.is_none()
    ret option::None
  .end

  let s = out.unwrap()
  let parts = split_ws2(s.as_str())
  if parts.is_none()
    ret option::None
  .end

  let (rows_t, cols_t) = parts.unwrap()
  let rows = parse_u16_opt(rows_t.as_str())
  let cols = parse_u16_opt(cols_t.as_str())
  if rows.is_some() && cols.is_some()
    let ts = TermSize::new(cols.unwrap(), rows.unwrap())
    if ts.is_valid()
      ret option::Some(ts)
    .end
  .end

  ret option::None
.end

# -----------------------------------------------------------------------------
# Public API
# -----------------------------------------------------------------------------

fn get() -> TermSize
  let e = from_env()
  if e.is_some()
    ret e.unwrap()
  .end

  let s = from_stty_size()
  if s.is_some()
    ret s.unwrap()
  .end

  ret TermSize::default()
.end

fn get_cols() -> u16
  ret get().cols
.end

fn get_rows() -> u16
  ret get().rows
.end

fn is_tty_sized() -> bool
  let ts = get()
  # heuristic: if default returned, likely unknown
  ret !(ts.cols == 80 && ts.rows == 24)
.end

# -----------------------------------------------------------------------------
# Pretty formatting
# -----------------------------------------------------------------------------

fn to_string(ts: TermSize) -> string::String
  ret string::String::from_str(string::fmt("{}x{}", ts.cols, ts.rows))
.end
