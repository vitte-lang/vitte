# C:\Users\gogin\Documents\GitHub\vitte\std\cli\src\colors.vitte
mod std/cli/colors

use std/prelude

use std/core/option
use std/core/result

use std/alloc/string

use std/os/env

# =============================================================================
# std::cli::colors — ANSI color policy + helpers (façade)
# =============================================================================
#
# Objectif:
# - décider si on doit émettre des couleurs (auto/always/never)
# - helpers pour coloriser des chaînes (FG/BG + styles)
#
# Remarque:
# - si tu as déjà std/modules/cli/ansi.vitte comme référence canonique,
#   ce fichier sert de façade "policy" et d'API haut niveau.
#
# =============================================================================

# -----------------------------------------------------------------------------
# Policy
# -----------------------------------------------------------------------------

enum ColorMode
  Auto
  Always
  Never
.end

fn parse_color_mode(s: &str) -> option::Option[ColorMode]
  if s == "auto"
    ret option::Some(ColorMode::Auto)
  elif s == "always"
    ret option::Some(ColorMode::Always)
  elif s == "never"
    ret option::Some(ColorMode::Never)
  .end
  ret option::None
.end

fn env_color_mode() -> option::Option[ColorMode]
  # Standard-ish envs:
  # - NO_COLOR => Never
  # - CLICOLOR=0 => Never, CLICOLOR=1 => Auto/Always (varies)
  # - CLICOLOR_FORCE=1 => Always
  # - VITTE_COLOR => auto|always|never (project-specific)
  if env::get("NO_COLOR").is_some()
    ret option::Some(ColorMode::Never)
  .end

  let vf = env::get("VITTE_COLOR")
  if vf.is_some()
    let m = parse_color_mode(vf.unwrap().as_str())
    if m.is_some()
      ret m
    .end
  .end

  let force = env::get("CLICOLOR_FORCE")
  if force.is_some() && force.unwrap().as_str() != "0"
    ret option::Some(ColorMode::Always)
  .end

  let cc = env::get("CLICOLOR")
  if cc.is_some() && cc.unwrap().as_str() == "0"
    ret option::Some(ColorMode::Never)
  .end

  ret option::None
.end

# -----------------------------------------------------------------------------
# ANSI façade
# -----------------------------------------------------------------------------
# We implement minimal ANSI SGR here, but if std/cli/ansi exists, forward to it.

fn esc() -> &str
  ret "\x1b"
.end

fn sgr(code: &str) -> string::String
  ret string::String::from_str(string::fmt("{}[{}m", esc(), code))
.end

fn reset() -> string::String
  ret sgr("0")
.end

fn bold() -> string::String
  ret sgr("1")
.end

fn dim() -> string::String
  ret sgr("2")
.end

fn underline() -> string::String
  ret sgr("4")
.end

fn fg256(n: u8) -> string::String
  ret string::String::from_str(string::fmt("{}[38;5;{}m", esc(), n))
.end

fn bg256(n: u8) -> string::String
  ret string::String::from_str(string::fmt("{}[48;5;{}m", esc(), n))
.end

# -----------------------------------------------------------------------------
# Public: should_color
# -----------------------------------------------------------------------------

fn should_color_stdout() -> bool
  let m = env_color_mode()
  if m.is_some()
    match m.unwrap()
      ColorMode::Always => ret true
      ColorMode::Never  => ret false
      ColorMode::Auto   => do 0
    .end
  .end

  # Auto: heuristic (TERM set and not dumb)
  let term = env::get("TERM")
  if term.is_none()
    ret false
  .end
  let t = term.unwrap().as_str()
  if t.len() == 0 || t == "dumb"
    ret false
  .end
  ret true
.end

# -----------------------------------------------------------------------------
# High level painting helpers
# -----------------------------------------------------------------------------

fn paint_if(enabled: bool, prefix: &str, s: &str, suffix: &str) -> string::String
  if !enabled
    ret string::String::from_str(s)
  .end
  ret string::String::from_str(string::fmt("{}{}{}", prefix, s, suffix))
.end

fn paint(code: &str, s: &str) -> string::String
  let en = should_color_stdout()
  ret paint_if(en, sgr(code).as_str(), s, reset().as_str())
.end

fn red(s: &str) -> string::String
  # 31 = red
  ret paint("31", s)
.end

fn green(s: &str) -> string::String
  ret paint("32", s)
.end

fn yellow(s: &str) -> string::String
  ret paint("33", s)
.end

fn blue(s: &str) -> string::String
  ret paint("34", s)
.end

fn magenta(s: &str) -> string::String
  ret paint("35", s)
.end

fn cyan(s: &str) -> string::String
  ret paint("36", s)
.end

fn gray(s: &str) -> string::String
  # bright black / gray
  ret paint("90", s)
.end

fn strong(s: &str) -> string::String
  let en = should_color_stdout()
  if !en
    ret string::String::from_str(s)
  .end
  ret string::String::from_str(string::fmt("{}{}{}", bold().as_str(), s, reset().as_str()))
.end

fn warn(s: &str) -> string::String
  let en = should_color_stdout()
  if !en
    ret string::String::from_str(s)
  .end
  ret string::String::from_str(string::fmt("{}{}{}{}", yellow("").as_str(), bold().as_str(), s, reset().as_str()))
.end

fn err(s: &str) -> string::String
  let en = should_color_stdout()
  if !en
    ret string::String::from_str(s)
  .end
  ret string::String::from_str(string::fmt("{}{}{}{}", red("").as_str(), bold().as_str(), s, reset().as_str()))
.end
