# C:\Users\gogin\Documents\GitHub\vitte\std\cli\src\prompt.vitte
mod std/cli/prompt

use std/prelude

use std/core/option
use std/core/result

use std/alloc/vec
use std/alloc/string

use std/cli/colors
use std/cli/term/input
use std/cli/term/tty

# =============================================================================
# std::cli::prompt â€” interactive prompting helpers
# =============================================================================
#
# Objectif:
# - ask_yes_no
# - ask_string
# - ask_password
# - ask_choice (menu simple)
# - confirm (force)
#
# Comportement:
# - mode non-interactif: si stdin pas TTY => retourne erreur (ou default)
# - toujours trimming CRLF
#
# =============================================================================

enum PromptErrorKind
  NotInteractive
  Cancelled
  Invalid
.end

struct PromptError
  kind: PromptErrorKind
  message: string::String
.end

fn PromptError::new(kind: PromptErrorKind, msg: &str) -> PromptError
  ret PromptError
    kind: kind
    message: string::String::from_str(msg)
  .end
.end

# -----------------------------------------------------------------------------
# Internals
# -----------------------------------------------------------------------------

fn ensure_interactive() -> result::Result[void, PromptError]
  if tty::is_tty_stdin()
    ret result::Ok(())
  .end
  ret result::Err(PromptError::new(PromptErrorKind::NotInteractive, "stdin is not a tty"))
.end

fn print_q(prefix: &str, q: &str) -> void
  if tty::is_tty_stdout() && colors::should_color_stdout()
    stdout_write(colors::cyan(prefix).as_str())
    stdout_write(" ")
    stdout_write(colors::strong(q).as_str())
    stdout_write(" ")
  else
    stdout_write(prefix)
    stdout_write(" ")
    stdout_write(q)
    stdout_write(" ")
  .end
  stdout_flush()
.end

fn read_line_trimmed() -> result::Result[string::String, PromptError]
  let r = input::read_line()
  if r.is_err()
    ret result::Err(PromptError::new(PromptErrorKind::Cancelled, "stdin eof"))
  .end

  let mut s = r.unwrap()
  if s.ends_with("\n")
    s.pop()
    if s.ends_with("\r")
      s.pop()
    .end
  .end

  ret result::Ok(s)
.end

fn lower_ascii(s: &str) -> string::String
  let mut out = string::String::new()
  let mut it = s.chars()
  while it.has_next()
    let c = it.next()
    if c >= 'A' && c <= 'Z'
      out.push_char((c as u8 + 32) as char)
    else
      out.push_char(c)
    .end
  .end
  ret out
.end

# -----------------------------------------------------------------------------
# Public API
# -----------------------------------------------------------------------------

fn ask_string(question: &str) -> result::Result[string::String, PromptError]
  let ok = ensure_interactive()
  if ok.is_err()
    ret result::Err(ok.unwrap_err())
  .end

  print_q("?", question)
  ret read_line_trimmed()
.end

fn ask_string_default(question: &str, default: &str) -> result::Result[string::String, PromptError]
  let ok = ensure_interactive()
  if ok.is_err()
    ret result::Err(ok.unwrap_err())
  .end

  let q = string::fmt("{} [{}]", question, default)
  print_q("?", q)
  let r = read_line_trimmed()
  if r.is_err()
    ret result::Err(r.unwrap_err())
  .end
  let s = r.unwrap()
  if s.len() == 0
    ret result::Ok(string::String::from_str(default))
  .end
  ret result::Ok(s)
.end

fn ask_password(question: &str) -> result::Result[string::String, PromptError]
  let ok = ensure_interactive()
  if ok.is_err()
    ret result::Err(ok.unwrap_err())
  .end

  # raw password support may be stubbed; use input::read_password
  let q = string::fmt("{} (hidden)", question)
  if tty::is_tty_stdout() && colors::should_color_stdout()
    stdout_write(colors::cyan("?").as_str())
    stdout_write(" ")
    stdout_write(colors::strong(q).as_str())
    stdout_write(" ")
  else
    stdout_write("? ")
    stdout_write(q)
    stdout_write(" ")
  .end
  stdout_flush()

  let r = input::read_password("")
  if r.is_err()
    ret result::Err(PromptError::new(PromptErrorKind::Cancelled, "stdin eof"))
  .end
  ret result::Ok(r.unwrap())
.end

fn ask_yes_no(question: &str, default_yes: bool) -> result::Result[bool, PromptError]
  let ok = ensure_interactive()
  if ok.is_err()
    ret result::Err(ok.unwrap_err())
  .end

  let suf = if default_yes then "[Y/n]" else "[y/N]"
  loop
    let q = string::fmt("{} {}", question, suf)
    print_q("?", q)
    let r = read_line_trimmed()
    if r.is_err()
      ret result::Err(r.unwrap_err())
    .end

    let s = lower_ascii(r.unwrap().as_str())
    if s.len() == 0
      ret result::Ok(default_yes)
    .end

    if s == "y" || s == "yes"
      ret result::Ok(true)
    elif s == "n" || s == "no"
      ret result::Ok(false)
    elif s == "q" || s == "quit"
      ret result::Err(PromptError::new(PromptErrorKind::Cancelled, "cancelled"))
    else
      stdout_write(colors::yellow("invalid answer, use y/n").as_str())
      stdout_write("\n")
    .end
  .end
.end

fn confirm(question: &str) -> result::Result[void, PromptError]
  let ok = ask_yes_no(question, false)
  if ok.is_err()
    ret result::Err(ok.unwrap_err())
  .end
  if ok.unwrap()
    ret result::Ok(())
  .end
  ret result::Err(PromptError::new(PromptErrorKind::Cancelled, "not confirmed"))
.end

fn ask_choice(question: &str, choices: &vec::Vec[string::String]) -> result::Result[usize, PromptError]
  let ok = ensure_interactive()
  if ok.is_err()
    ret result::Err(ok.unwrap_err())
  .end

  if choices.len() == 0
    ret result::Err(PromptError::new(PromptErrorKind::Invalid, "empty choices"))
  .end

  # print menu
  if tty::is_tty_stdout() && colors::should_color_stdout()
    stdout_write(colors::strong(question).as_str())
    stdout_write("\n")
  else
    stdout_write(question)
    stdout_write("\n")
  .end

  let mut i: usize = 0
  while i < choices.len()
    stdout_write(string::fmt("  {}. {}\n", i + 1, choices[i].as_str()))
    i = i + 1
  .end

  loop
    print_q(">", "choose number")
    let r = read_line_trimmed()
    if r.is_err()
      ret result::Err(r.unwrap_err())
    .end
    let s = r.unwrap()
    let n = string::parse_u64(s.as_str())
    if n.is_some()
      let v = n.unwrap()
      if v >= 1 && v <= (choices.len() as u64)
        ret result::Ok((v - 1) as usize)
      .end
    .end
    stdout_write(colors::yellow("invalid selection").as_str())
    stdout_write("\n")
  .end
.end
