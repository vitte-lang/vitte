# /Users/vincent/Documents/Github/vitte/std/cli/term/src/input.vitte
# -----------------------------------------------------------------------------
# std/cli/term/input
# -----------------------------------------------------------------------------
# Terminal input decoding (streaming).
#
# Goals:
# - Decode common terminal key sequences from a byte stream.
# - Streaming: feed chunks, pop KeyEvent one by one.
# - Bootstrap-friendly: no IO here; caller reads bytes and feeds decoder.
#
# Supported (best-effort):
# - ASCII chars (single-byte) -> KeyKind::Char (ch set)
# - Control chars: Enter, Tab, Backspace, Escape
# - Arrows: Up/Down/Left/Right via CSI / SS3
# - Home/End, Insert/Delete, PageUp/PageDown via CSI ~
# - Function keys F1..F12 (SS3 + CSI ~ mapping)
# - Modifiers for CSI forms: ESC [ 1 ; m <final>
#   m mapping (xterm):
#     2 shift, 3 alt, 4 shift+alt, 5 ctrl, 6 shift+ctrl, 7 alt+ctrl, 8 shift+alt+ctrl
#
# Notes:
# - This decoder treats strings as byte sequences; UTF-8 multi-byte chars are not
#   decoded (they will appear as multiple Char events). If you need UTF-8, add
#   a higher-level layer on top.
# - All blocks use `.end` only.
# -----------------------------------------------------------------------------

module std.cli.term.input

use std.runtime
use std.string

type Bool = bool
type U8   = u8
type U32  = u32
type I32  = i32
type Str  = str

# -----------------------------------------------------------------------------
# Thin string wrappers
# -----------------------------------------------------------------------------

fn str_len(s: Str) -> U32
  ret std.string::len(s)
.end

fn str_is_empty(s: Str) -> Bool
  ret str_len(s) == 0
.end

fn str_slice(s: Str, start: U32, len: U32) -> Str
  ret std.string::slice(s, start, len)
.end

fn str_starts_with(s: Str, prefix: Str) -> Bool
  ret std.string::starts_with(s, prefix)
.end

fn str_find(s: Str, needle: Str) -> I32
  ret std.string::find(s, needle)
.end

# Remove first n bytes from s (best-effort, expects n <= len)
fn str_drop(s: Str, n: U32) -> Str
  let L = str_len(s)
  if n >= L
    ret ""
  .end
  ret str_slice(s, n, L - n)
.end

# -----------------------------------------------------------------------------
# Numeric parsing helpers (ASCII)
# -----------------------------------------------------------------------------

fn _digit_val(ch: Str) -> (Bool, U32)
  if ch == "0" ret (true, 0) .end
  if ch == "1" ret (true, 1) .end
  if ch == "2" ret (true, 2) .end
  if ch == "3" ret (true, 3) .end
  if ch == "4" ret (true, 4) .end
  if ch == "5" ret (true, 5) .end
  if ch == "6" ret (true, 6) .end
  if ch == "7" ret (true, 7) .end
  if ch == "8" ret (true, 8) .end
  if ch == "9" ret (true, 9) .end
  ret (false, 0)
.end

fn parse_u32_ascii(s: Str) -> (Bool, U32)
  if str_is_empty(s)
    ret (false, 0)
  .end

  let i: U32
  set i = 0

  let acc: U32
  set acc = 0

  while i < str_len(s)
    let ch = str_slice(s, i, 1)
    let ok: Bool
    let dv: U32
    (ok, dv) = _digit_val(ch)
    if !ok
      ret (false, 0)
    .end
    set acc = acc * 10 + dv
    set i = i + 1
  .end

  ret (true, acc)
.end

# Split once on delimiter; returns (ok,left,right)
fn split_once(s: Str, delim: Str) -> (Bool, Str, Str)
  let i: I32
  set i = str_find(s, delim)
  if i < 0
    ret (false, "", "")
  .end

  let left: Str
  let right: Str

  set left = str_slice(s, 0, (U32)i)
  let dl = str_len(delim)
  let start = (U32)i + dl
  set right = str_slice(s, start, str_len(s) - start)

  ret (true, left, right)
.end

# -----------------------------------------------------------------------------
# Key model
# -----------------------------------------------------------------------------

type KeyKind enum
  None
  Char

  Enter
  Tab
  Backspace
  Escape

  Up
  Down
  Left
  Right

  Home
  End
  Insert
  Delete
  PageUp
  PageDown

  F1
  F2
  F3
  F4
  F5
  F6
  F7
  F8
  F9
  F10
  F11
  F12

  Unknown
.end

type Modifiers struct
  shift: Bool
  alt: Bool
  ctrl: Bool
.end

fn mods_none() -> Modifiers
  let m: Modifiers
  set m.shift = false
  set m.alt = false
  set m.ctrl = false
  ret m
.end

fn mods_from_xterm_m(mcode: U32) -> Modifiers
  # xterm modifier parameter:
  # 1 none, 2 shift, 3 alt, 4 shift+alt, 5 ctrl, 6 shift+ctrl, 7 alt+ctrl, 8 shift+alt+ctrl
  let m = mods_none()

  if mcode == 2
    set m.shift = true
    ret m
  .end
  if mcode == 3
    set m.alt = true
    ret m
  .end
  if mcode == 4
    set m.shift = true
    set m.alt = true
    ret m
  .end
  if mcode == 5
    set m.ctrl = true
    ret m
  .end
  if mcode == 6
    set m.shift = true
    set m.ctrl = true
    ret m
  .end
  if mcode == 7
    set m.alt = true
    set m.ctrl = true
    ret m
  .end
  if mcode == 8
    set m.shift = true
    set m.alt = true
    set m.ctrl = true
    ret m
  .end

  ret m
.end

type KeyEvent struct
  kind: KeyKind
  ch: Str         # for Char
  mods: Modifiers
  raw: Str        # raw sequence consumed
.end

fn ev(kind: KeyKind, ch: Str, mods: Modifiers, raw: Str) -> KeyEvent
  let e: KeyEvent
  set e.kind = kind
  set e.ch = ch
  set e.mods = mods
  set e.raw = raw
  ret e
.end

fn ev_simple(kind: KeyKind, raw: Str) -> KeyEvent
  ret ev(kind, "", mods_none(), raw)
.end

fn ev_char(ch: Str, mods: Modifiers, raw: Str) -> KeyEvent
  ret ev(KeyKind::Char, ch, mods, raw)
.end

# -----------------------------------------------------------------------------
# Decoder state
# -----------------------------------------------------------------------------

type InputDecoder struct
  buf: Str
.end

fn decoder_new() -> InputDecoder
  let d: InputDecoder
  set d.buf = ""
  ret d
.end

fn decoder_feed(d: &InputDecoder, chunk: Str)
  set d.buf = d.buf + chunk
.end

fn decoder_has_data(d: &InputDecoder) -> Bool
  ret !str_is_empty(d.buf)
.end

# -----------------------------------------------------------------------------
# ESC sequence parsing
# -----------------------------------------------------------------------------

fn _is_esc_prefix(s: Str) -> Bool
  ret str_starts_with(s, "\x1b")
.end

fn _is_csi_prefix(s: Str) -> Bool
  ret str_starts_with(s, "\x1b[")
.end

fn _is_ss3_prefix(s: Str) -> Bool
  ret str_starts_with(s, "\x1bO")
.end

# Find earliest index (>=0) among a set of needles. Returns -1 if none.
fn _find_first_any(s: Str, a: Str, b: Str, c: Str, d: Str, e: Str, f: Str, g: Str) -> I32
  let best: I32
  set best = -1

  let i: I32

  set i = str_find(s, a)
  if i >= 0
    set best = i
  .end

  set i = str_find(s, b)
  if i >= 0
    if best < 0 || i < best
      set best = i
    .end
  .end

  set i = str_find(s, c)
  if i >= 0
    if best < 0 || i < best
      set best = i
    .end
  .end

  set i = str_find(s, d)
  if i >= 0
    if best < 0 || i < best
      set best = i
    .end
  .end

  set i = str_find(s, e)
  if i >= 0
    if best < 0 || i < best
      set best = i
    .end
  .end

  set i = str_find(s, f)
  if i >= 0
    if best < 0 || i < best
      set best = i
    .end
  .end

  set i = str_find(s, g)
  if i >= 0
    if best < 0 || i < best
      set best = i
    .end
  .end

  ret best
.end

# Parse CSI sequence from buffer.
# Returns (ok, event, consumed_bytes) OR (false, _, 0) when incomplete.
fn _parse_csi(buf: Str) -> (Bool, KeyEvent, U32)
  # Need at least ESC [ X
  if str_len(buf) < 3
    ret (false, ev_simple(KeyKind::None, ""), 0)
  .end

  # Find final byte among common finals we care about:
  # A B C D H F ~
  let idx: I32
  set idx = _find_first_any(buf, "A", "B", "C", "D", "H", "F", "~")

  if idx < 0
    # Incomplete / unsupported; require more bytes
    ret (false, ev_simple(KeyKind::None, ""), 0)
  .end

  # Must be after ESC[
  if idx < 2
    ret (false, ev_simple(KeyKind::None, ""), 0)
  .end

  let final = str_slice(buf, (U32)idx, 1)
  let params = str_slice(buf, 2, (U32)idx - 2)

  let raw = str_slice(buf, 0, (U32)idx + 1)
  let consumed = (U32)idx + 1

  # Modifiers: typically "1;5" etc
  let mods = mods_none()
  let has_sc: Bool
  let left: Str
  let right: Str
  (has_sc, left, right) = split_once(params, ";")
  if has_sc
    # take right as modifier number
    let okm: Bool
    let mv: U32
    (okm, mv) = parse_u32_ascii(right)
    if okm
      set mods = mods_from_xterm_m(mv)
    .end
  .end

  # Arrow/home/end simple finals
  if final == "A" ret (true, ev(KeyKind::Up, "", mods, raw), consumed) .end
  if final == "B" ret (true, ev(KeyKind::Down, "", mods, raw), consumed) .end
  if final == "C" ret (true, ev(KeyKind::Right, "", mods, raw), consumed) .end
  if final == "D" ret (true, ev(KeyKind::Left, "", mods, raw), consumed) .end
  if final == "H" ret (true, ev(KeyKind::Home, "", mods, raw), consumed) .end
  if final == "F" ret (true, ev(KeyKind::End, "", mods, raw), consumed) .end

  if final == "~"
    # params may be "3" or "1;5" etc; take first number before ';'
    let code_str: Str
    set code_str = params
    let has_sc2: Bool
    let p0: Str
    let p1: Str
    (has_sc2, p0, p1) = split_once(params, ";")
    if has_sc2
      set code_str = p0
    .end

    let okc: Bool
    let code: U32
    (okc, code) = parse_u32_ascii(code_str)
    if !okc
      ret (true, ev(KeyKind::Unknown, "", mods, raw), consumed)
    .end

    if code == 1 ret (true, ev(KeyKind::Home, "", mods, raw), consumed) .end
    if code == 2 ret (true, ev(KeyKind::Insert, "", mods, raw), consumed) .end
    if code == 3 ret (true, ev(KeyKind::Delete, "", mods, raw), consumed) .end
    if code == 4 ret (true, ev(KeyKind::End, "", mods, raw), consumed) .end
    if code == 5 ret (true, ev(KeyKind::PageUp, "", mods, raw), consumed) .end
    if code == 6 ret (true, ev(KeyKind::PageDown, "", mods, raw), consumed) .end

    # xterm function key codes:
    if code == 11 ret (true, ev(KeyKind::F1, "", mods, raw), consumed) .end
    if code == 12 ret (true, ev(KeyKind::F2, "", mods, raw), consumed) .end
    if code == 13 ret (true, ev(KeyKind::F3, "", mods, raw), consumed) .end
    if code == 14 ret (true, ev(KeyKind::F4, "", mods, raw), consumed) .end
    if code == 15 ret (true, ev(KeyKind::F5, "", mods, raw), consumed) .end
    if code == 17 ret (true, ev(KeyKind::F6, "", mods, raw), consumed) .end
    if code == 18 ret (true, ev(KeyKind::F7, "", mods, raw), consumed) .end
    if code == 19 ret (true, ev(KeyKind::F8, "", mods, raw), consumed) .end
    if code == 20 ret (true, ev(KeyKind::F9, "", mods, raw), consumed) .end
    if code == 21 ret (true, ev(KeyKind::F10, "", mods, raw), consumed) .end
    if code == 23 ret (true, ev(KeyKind::F11, "", mods, raw), consumed) .end
    if code == 24 ret (true, ev(KeyKind::F12, "", mods, raw), consumed) .end

    ret (true, ev(KeyKind::Unknown, "", mods, raw), consumed)
  .end

  ret (true, ev(KeyKind::Unknown, "", mods, raw), consumed)
.end

# Parse SS3 sequence ESC O <final>
fn _parse_ss3(buf: Str) -> (Bool, KeyEvent, U32)
  if str_len(buf) < 3
    ret (false, ev_simple(KeyKind::None, ""), 0)
  .end

  let final = str_slice(buf, 2, 1)
  let raw = str_slice(buf, 0, 3)

  # SS3 common mapping:
  # P/Q/R/S -> F1..F4
  if final == "P" ret (true, ev_simple(KeyKind::F1, raw), 3) .end
  if final == "Q" ret (true, ev_simple(KeyKind::F2, raw), 3) .end
  if final == "R" ret (true, ev_simple(KeyKind::F3, raw), 3) .end
  if final == "S" ret (true, ev_simple(KeyKind::F4, raw), 3) .end

  # Some terminals use SS3 for arrows/home/end too
  if final == "A" ret (true, ev_simple(KeyKind::Up, raw), 3) .end
  if final == "B" ret (true, ev_simple(KeyKind::Down, raw), 3) .end
  if final == "C" ret (true, ev_simple(KeyKind::Right, raw), 3) .end
  if final == "D" ret (true, ev_simple(KeyKind::Left, raw), 3) .end
  if final == "H" ret (true, ev_simple(KeyKind::Home, raw), 3) .end
  if final == "F" ret (true, ev_simple(KeyKind::End, raw), 3) .end

  ret (true, ev_simple(KeyKind::Unknown, raw), 3)
.end

# -----------------------------------------------------------------------------
# Public decoding: pop next KeyEvent
# -----------------------------------------------------------------------------

# Returns (ok,event). ok=false means: need more bytes.
fn decoder_next(d: &InputDecoder) -> (Bool, KeyEvent)
  if str_is_empty(d.buf)
    ret (false, ev_simple(KeyKind::None, ""))
  .end

  # Handle ESC-prefixed sequences
  if _is_esc_prefix(d.buf)
    # If only ESC present, need more data OR treat as Escape
    if str_len(d.buf) == 1
      # streaming: treat as incomplete (caller can flush to get Escape)
      ret (false, ev_simple(KeyKind::None, ""))
    .end

    if _is_csi_prefix(d.buf)
      let ok: Bool
      let e: KeyEvent
      let n: U32
      (ok, e, n) = _parse_csi(d.buf)
      if !ok
        ret (false, ev_simple(KeyKind::None, ""))
      .end
      set d.buf = str_drop(d.buf, n)
      ret (true, e)
    .end

    if _is_ss3_prefix(d.buf)
      let ok2: Bool
      let e2: KeyEvent
      let n2: U32
      (ok2, e2, n2) = _parse_ss3(d.buf)
      if !ok2
        ret (false, ev_simple(KeyKind::None, ""))
      .end
      set d.buf = str_drop(d.buf, n2)
      ret (true, e2)
    .end

    # Alt+key: ESC <char>
    let ch = str_slice(d.buf, 1, 1)
    let raw = str_slice(d.buf, 0, 2)
    set d.buf = str_drop(d.buf, 2)

    # If ESC followed by another ESC, keep second for next round and emit Escape
    if ch == "\x1b"
      set d.buf = "\x1b" + d.buf
      ret (true, ev_simple(KeyKind::Escape, "\x1b"))
    .end

    let m = mods_none()
    set m.alt = true
    ret (true, ev_char(ch, m, raw))
  .end

  # Non-ESC: single byte handling
  let b0 = str_slice(d.buf, 0, 1)

  # Control keys
  if b0 == "\r" || b0 == "\n"
    set d.buf = str_drop(d.buf, 1)
    ret (true, ev_simple(KeyKind::Enter, b0))
  .end

  if b0 == "\t"
    set d.buf = str_drop(d.buf, 1)
    ret (true, ev_simple(KeyKind::Tab, b0))
  .end

  # Backspace commonly: 0x7f, sometimes 0x08
  if b0 == "\x7f" || b0 == "\x08"
    set d.buf = str_drop(d.buf, 1)
    ret (true, ev_simple(KeyKind::Backspace, b0))
  .end

  if b0 == "\x1b"
    set d.buf = str_drop(d.buf, 1)
    ret (true, ev_simple(KeyKind::Escape, "\x1b"))
  .end

  # Regular char
  set d.buf = str_drop(d.buf, 1)
  ret (true, ev_char(b0, mods_none(), b0))
.end

# Force-flush pending lone ESC as Escape.
# Returns (ok,event) where ok=false means nothing to flush.
fn decoder_flush(d: &InputDecoder) -> (Bool, KeyEvent)
  if d.buf == "\x1b"
    set d.buf = ""
    ret (true, ev_simple(KeyKind::Escape, "\x1b"))
  .end
  ret (false, ev_simple(KeyKind::None, ""))
.end

# -----------------------------------------------------------------------------
# Convenience: decode one event from a fresh buffer
# -----------------------------------------------------------------------------

fn decode_one(chunk: Str) -> (Bool, KeyEvent)
  let d = decoder_new()
  do decoder_feed(&d, chunk)
  ret decoder_next(&d)
.end

# -----------------------------------------------------------------------------
# Smoke tests (scenarios)
# -----------------------------------------------------------------------------

scn test_input_ascii
  let d = decoder_new()
  do decoder_feed(&d, "a")
  let ok: Bool
  let e: KeyEvent
  (ok, e) = decoder_next(&d)
  do std.runtime::assert(ok, "ok")
  do std.runtime::assert(e.kind == KeyKind::Char, "char")
  do std.runtime::assert(e.ch == "a", "a")
.end

scn test_input_arrows_csi
  let d = decoder_new()

  do decoder_feed(&d, "\x1b[A")
  let ok: Bool
  let e: KeyEvent
  (ok, e) = decoder_next(&d)
  do std.runtime::assert(ok, "ok")
  do std.runtime::assert(e.kind == KeyKind::Up, "up")

  do decoder_feed(&d, "\x1b[B")
  (ok, e) = decoder_next(&d)
  do std.runtime::assert(e.kind == KeyKind::Down, "down")

  do decoder_feed(&d, "\x1b[C")
  (ok, e) = decoder_next(&d)
  do std.runtime::assert(e.kind == KeyKind::Right, "right")

  do decoder_feed(&d, "\x1b[D")
  (ok, e) = decoder_next(&d)
  do std.runtime::assert(e.kind == KeyKind::Left, "left")
.end

scn test_input_home_end_delete
  let d = decoder_new()
  let ok: Bool
  let e: KeyEvent

  do decoder_feed(&d, "\x1b[H")
  (ok, e) = decoder_next(&d)
  do std.runtime::assert(ok && e.kind == KeyKind::Home, "home")

  do decoder_feed(&d, "\x1b[F")
  (ok, e) = decoder_next(&d)
  do std.runtime::assert(ok && e.kind == KeyKind::End, "end")

  do decoder_feed(&d, "\x1b[3~")
  (ok, e) = decoder_next(&d)
  do std.runtime::assert(ok && e.kind == KeyKind::Delete, "delete")
.end

scn test_input_function_keys
  let d = decoder_new()
  let ok: Bool
  let e: KeyEvent

  do decoder_feed(&d, "\x1bOP")
  (ok, e) = decoder_next(&d)
  do std.runtime::assert(ok && e.kind == KeyKind::F1, "f1")

  do decoder_feed(&d, "\x1b[24~")
  (ok, e) = decoder_next(&d)
  do std.runtime::assert(ok && e.kind == KeyKind::F12, "f12")
.end

scn test_input_alt_char
  let d = decoder_new()
  let ok: Bool
  let e: KeyEvent

  do decoder_feed(&d, "\x1bx")
  (ok, e) = decoder_next(&d)
  do std.runtime::assert(ok, "ok")
  do std.runtime::assert(e.kind == KeyKind::Char, "char")
  do std.runtime::assert(e.ch == "x", "x")
  do std.runtime::assert(e.mods.alt, "alt")
.end

# End of std.cli.term.input