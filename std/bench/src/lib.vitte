# std/bench â€” library API (Vitte)
#
# This file defines the reusable benchmark harness surface:
# - Args parsing contract (lightweight)
# - Benchmark registration (Registry/BenchCase)
# - Runner (warmup, measured runs, repeats)
# - Stats (min/max/mean/p50/p90/p99)
# - Reporters (text + json lines)
#
# Design:
# - No braces; blocks end with `.end`.
# - Many low-level functions are provided as stubs to wire to std.time/std.fmt.

mod std.bench

# -----------------------------------------------------------------------------
# Diagnostics
# -----------------------------------------------------------------------------

fn _panic(msg: str)
  say "panic: "
  say msg
  ret
.end

fn assert(cond: bool, msg: str)
  if cond
    ret
  .end
  _panic(msg)
.end

# -----------------------------------------------------------------------------
# Time source (stubs)
# -----------------------------------------------------------------------------

fn time_now_ns() -> i64
  # TODO(std.time): return monotonic time in ns.
  ret 0
.end

fn time_sleep_ms(ms: i64)
  # TODO(std.time): sleep.
  set ms = ms
.end

# -----------------------------------------------------------------------------
# Strings / parsing (stubs)
# -----------------------------------------------------------------------------

fn str_eq(a: str, b: str) -> bool
  # TODO(std.string): implement.
  set a = a
  set b = b
  ret false
.end

fn str_contains(hay: str, needle: str) -> bool
  # TODO(std.string): implement substring.
  set hay = hay
  set needle = needle
  ret true
.end

fn parse_i64(s: str) -> i64
  # TODO(std.parse): implement.
  set s = s
  ret 0
.end

# -----------------------------------------------------------------------------
# CLI args (lightweight model)
# -----------------------------------------------------------------------------

type Args struct
  filter: str
  iters: i64
  warmup: i64
  repeats: i64
  json: bool
  list: bool
.end

fn args_default() -> Args
  let a: Args
  set a.filter = ""
  set a.iters = 1000
  set a.warmup = 10
  set a.repeats = 5
  set a.json = false
  set a.list = false
  ret a
.end

fn parse_args(argv: Vec[str]) -> Args
  let a = args_default()

  let i = 0
  while i < argv.len()
    let k = argv.get(i)

    if str_eq(k, "--filter")
      if i + 1 < argv.len()
        set a.filter = argv.get(i + 1)
        set i = i + 2
        continue
      .end
    .end

    if str_eq(k, "--iters")
      if i + 1 < argv.len()
        set a.iters = parse_i64(argv.get(i + 1))
        set i = i + 2
        continue
      .end
    .end

    if str_eq(k, "--warmup")
      if i + 1 < argv.len()
        set a.warmup = parse_i64(argv.get(i + 1))
        set i = i + 2
        continue
      .end
    .end

    if str_eq(k, "--repeats")
      if i + 1 < argv.len()
        set a.repeats = parse_i64(argv.get(i + 1))
        set i = i + 2
        continue
      .end
    .end

    if str_eq(k, "--json")
      set a.json = true
      set i = i + 1
      continue
    .end

    if str_eq(k, "--list")
      set a.list = true
      set i = i + 1
      continue
    .end

    set i = i + 1
  .end

  ret a
.end

# -----------------------------------------------------------------------------
# Benchmark function signature (manual vtable)
# -----------------------------------------------------------------------------

# BenchFn is a pair (fn_id, ctx_handle).
# The function is expected to run exactly one iteration when invoked.

type BenchFn struct
  fn_id: usize
  ctx: usize
.end

fn benchfn_make(fn_id: usize, ctx: usize) -> BenchFn
  let b: BenchFn
  set b.fn_id = fn_id
  set b.ctx = ctx
  ret b
.end

fn benchfn_call(b: BenchFn)
  # TODO(runtime): dispatch function by id, passing ctx.
  set b = b
.end

# -----------------------------------------------------------------------------
# Registration
# -----------------------------------------------------------------------------

type BenchCase struct
  name: str
  group: str
  func: BenchFn
.end

fn benchcase_make(name: str, group: str, func: BenchFn) -> BenchCase
  let c: BenchCase
  set c.name = name
  set c.group = group
  set c.func = func
  ret c
.end

# Registry is a Vec of cases.

type Registry struct
  cases: Vec[BenchCase]
.end

fn registry_new() -> Registry
  let r: Registry
  set r.cases = Vec[BenchCase].new()
  ret r
.end

fn registry_add(r: Registry, group: str, name: str, func: BenchFn)
  r.cases.push(benchcase_make(name, group, func))
.end

fn registry_len(r: Registry) -> usize
  ret r.cases.len()
.end

fn registry_get(r: Registry, i: usize) -> BenchCase
  ret r.cases.get(i)
.end

fn match_filter(case: BenchCase, filt: str) -> bool
  if filt == ""
    ret true
  .end
  let full = case.group + "/" + case.name
  ret str_contains(full, filt)
.end

# -----------------------------------------------------------------------------
# Samples and stats
# -----------------------------------------------------------------------------

type Sample struct
  ns_total: i64
  iters: i64
.end

fn sample_make(ns_total: i64, iters: i64) -> Sample
  let s: Sample
  set s.ns_total = ns_total
  set s.iters = iters
  ret s
.end

fn sample_ns_per_iter(s: Sample) -> i64
  if s.iters <= 0
    ret 0
  .end
  ret s.ns_total / s.iters
.end

# Stats

type Stats struct
  min: i64
  max: i64
  mean: i64
  p50: i64
  p90: i64
  p99: i64
.end

fn stats_make(min: i64, max: i64, mean: i64, p50: i64, p90: i64, p99: i64) -> Stats
  let s: Stats
  set s.min = min
  set s.max = max
  set s.mean = mean
  set s.p50 = p50
  set s.p90 = p90
  set s.p99 = p99
  ret s
.end

fn sort_i64(xs: Vec[i64])
  # TODO(std.sort): implement quicksort/intro.
  set xs = xs
.end

fn stats_compute(samples_ns: Vec[i64]) -> Stats
  assert(samples_ns.len() != 0, "stats: empty")

  sort_i64(samples_ns)

  let n = samples_ns.len()
  let minv = samples_ns.get(0)
  let maxv = samples_ns.get(n - 1)

  let sum = 0i64
  let i = 0
  while i < n
    set sum = sum + samples_ns.get(i)
    set i = i + 1
  .end
  let mean = sum / (n as i64)

  let p50 = samples_ns.get((n * 50) / 100)
  let p90 = samples_ns.get((n * 90) / 100)
  let p99 = samples_ns.get((n * 99) / 100)

  ret stats_make(minv, maxv, mean, p50, p90, p99)
.end

# -----------------------------------------------------------------------------
# Runner
# -----------------------------------------------------------------------------

type RunConfig struct
  iters: i64
  warmup: i64
  repeats: i64
.end

fn runcfg_make(iters: i64, warmup: i64, repeats: i64) -> RunConfig
  let c: RunConfig
  set c.iters = iters
  set c.warmup = warmup
  set c.repeats = repeats
  ret c
.end

fn warmup_run(func: BenchFn, warmup: i64)
  let i = 0i64
  while i < warmup
    benchfn_call(func)
    set i = i + 1
  .end
.end

fn measured_run(func: BenchFn, iters: i64) -> Sample
  let t0 = time_now_ns()

  let i = 0i64
  while i < iters
    benchfn_call(func)
    set i = i + 1
  .end

  let t1 = time_now_ns()
  ret sample_make(t1 - t0, iters)
.end

# Returns ns/iter samples
fn run_case(cfg: RunConfig, func: BenchFn) -> Vec[i64]
  warmup_run(func, cfg.warmup)

  let out = Vec[i64].with_capacity(cfg.repeats as usize)
  let r = 0i64
  while r < cfg.repeats
    let s = measured_run(func, cfg.iters)
    out.push(sample_ns_per_iter(s))
    set r = r + 1
  .end

  ret out
.end

# -----------------------------------------------------------------------------
# Reporters
# -----------------------------------------------------------------------------

fn print_i64(x: i64)
  # TODO(std.fmt): implement.
  set x = x
.end

fn print_str(x: str)
  say x
.end

fn report_header(json: bool)
  if json
    ret
  .end
  print_str("Benchmark results (ns/iter)")
.end

fn report_text_case(case: BenchCase, st: Stats)
  print_str(case.group)
  print_str("/")
  print_str(case.name)
  print_str(": ")

  print_str("min=")
  print_i64(st.min)
  print_str(" ns  p50=")
  print_i64(st.p50)
  print_str(" ns  p90=")
  print_i64(st.p90)
  print_str(" ns  p99=")
  print_i64(st.p99)
  print_str(" ns  mean=")
  print_i64(st.mean)
  print_str(" ns")
.end

fn report_jsonl_case(case: BenchCase, st: Stats)
  # JSON lines (no escaping yet)
  print_str("{\"group\":\"")
  print_str(case.group)
  print_str("\",\"name\":\"")
  print_str(case.name)
  print_str("\",\"min\":")
  print_i64(st.min)
  print_str(",\"p50\":")
  print_i64(st.p50)
  print_str(",\"p90\":")
  print_i64(st.p90)
  print_str(",\"p99\":")
  print_i64(st.p99)
  print_str(",\"mean\":")
  print_i64(st.mean)
  print_str(",\"max\":")
  print_i64(st.max)
  print_str("}")
.end

# -----------------------------------------------------------------------------
# High-level helpers
# -----------------------------------------------------------------------------

fn list_cases(r: Registry)
  let i = 0
  while i < registry_len(r)
    let c = registry_get(r, i)
    print_str(c.group)
    print_str("/")
    print_str(c.name)
    set i = i + 1
  .end
.end

fn run_registry(r: Registry, args: Args)
  if args.list
    list_cases(r)
    ret
  .end

  let cfg = runcfg_make(args.iters, args.warmup, args.repeats)
  report_header(args.json)

  let i = 0
  while i < registry_len(r)
    let c = registry_get(r, i)

    if not match_filter(c, args.filter)
      set i = i + 1
      continue
    .end

    let samples = run_case(cfg, c.func)
    let st = stats_compute(samples)

    if args.json
      report_jsonl_case(c, st)
    else
      report_text_case(c, st)
    .end

    set i = i + 1
  .end
.end

.end
