

# std/bench/src/lib.vitte
#
# Benchmark framework (bootstrap-ready, runtime-agnostic).
#
# This module defines a stable API surface for micro/macro benchmarks:
# - BenchConfig / BenchUnit
# - Bencher: iteration control + timers (backend-wired)
# - BenchCase / BenchSuite registry surface
# - Stats model (min/max/mean/median/p90/p99/stdev)
# - Report sink (text/json) skeleton
#
# NOTE:
# This is a "max" scaffold: implementations are conservative stubs until wired
# to the runtime/host (monotonic clock, allocations, stdout, JSON, etc.).

export all

# -----------------------------------------------------------------------------
# Common aliases
# -----------------------------------------------------------------------------

type U8  = u8
type U16 = u16
type U32 = u32
type U64 = u64

type I32 = i32
type I64 = i64

type F64 = f64

type Bool = bool
type Str  = string

# Opaque pointer-like handle (runtime decides representation)

type Ptr[T] = u64

# -----------------------------------------------------------------------------
# Result
# -----------------------------------------------------------------------------

type Result[T, E] = enum
  Ok(T)
  Err(E)
.end

# -----------------------------------------------------------------------------
# Time units / config
# -----------------------------------------------------------------------------

type BenchUnit = enum
  Ns
  Us
  Ms
.end

fn bench_unit_str(u: BenchUnit) -> Str
  match u
    BenchUnit::Ns => ret "ns"
    BenchUnit::Us => ret "us"
    BenchUnit::Ms => ret "ms"
  .end
.end

# A deterministic configuration for running a benchmark.

type BenchConfig = struct
  warmup_iters: U32
  measure_iters: U32
  repeats: U32
  unit: BenchUnit
  min_time_ns: U64
  max_time_ns: U64
  # Guardrails
  max_cases: U32
  max_suites: U32
.end

fn bench_config_default() -> BenchConfig
  let c = BenchConfig
    warmup_iters: 1000
    measure_iters: 10000
    repeats: 5
    unit: BenchUnit::Ns
    min_time_ns: 1000000      # 1ms target per repeat (best-effort)
    max_time_ns: 5000000000   # 5s safety
    max_cases: 4096
    max_suites: 256
  .end
  ret c
.end

# -----------------------------------------------------------------------------
# Clock + black box (backend hooks)
# -----------------------------------------------------------------------------

# Monotonic clock in nanoseconds.
# Backend should provide an implementation with good resolution.
# Stub returns 0.
fn bench_now_ns() -> U64
  ret 0
.end

# Prevent optimizer from eliding computations.
# Backend should wire to compiler-specific intrinsics.
# Stub returns the value.
fn black_box_u64(x: U64) -> U64
  ret x
.end

fn black_box_i64(x: I64) -> I64
  ret x
.end

fn black_box_f64(x: F64) -> F64
  ret x
.end

fn black_box_str(x: Str) -> Str
  ret x
.end

# -----------------------------------------------------------------------------
# Bencher
# -----------------------------------------------------------------------------

# The Bencher orchestrates iteration loops and timing.
# In a real runtime, Bencher holds state for:
# - calibrated iters
# - start/end stamps
# - last elapsed


type BencherState = enum
  Init
  Warmup
  Measure
  Done
.end

type Bencher = struct
  cfg: BenchConfig
  state: BencherState
  iters: U32
  elapsed_ns: U64
  start_ns: U64
  end_ns: U64
  # Opaque storage reserved for backend data
  opaque: Ptr[U8]
.end

fn bencher_new(cfg: BenchConfig) -> Bencher
  let b = Bencher
    cfg: cfg
    state: BencherState::Init
    iters: 0
    elapsed_ns: 0
    start_ns: 0
    end_ns: 0
    opaque: 0
  .end
  ret b
.end

fn bencher_begin(mut b: Bencher, iters: U32) -> Bencher
  b.iters = iters
  b.start_ns = bench_now_ns()
  b.end_ns = b.start_ns
  b.elapsed_ns = 0
  ret b
.end

fn bencher_end(mut b: Bencher) -> Bencher
  b.end_ns = bench_now_ns()
  if b.end_ns >= b.start_ns
    b.elapsed_ns = b.end_ns - b.start_ns
  else
    b.elapsed_ns = 0
  .end
  ret b
.end

fn bencher_elapsed_ns(b: Bencher) -> U64
  ret b.elapsed_ns
.end

fn bencher_iters(b: Bencher) -> U32
  ret b.iters
.end

# Bench function signature.
# The function is expected to run exactly b.iters iterations internally.
# In future, this can be refined to a closure model.

type BenchFn = fn(b: Ptr[Bencher]) -> void

# -----------------------------------------------------------------------------
# Cases / Suites
# -----------------------------------------------------------------------------

type BenchCase = struct
  name: Str
  fn_ptr: BenchFn
.end

fn bench_case_new(name: Str, fn_ptr: BenchFn) -> BenchCase
  let c = BenchCase
    name: name
    fn_ptr: fn_ptr
  .end
  ret c
.end

# A suite is a named collection of cases.
# Storage is backend/registry-defined; here we keep an opaque handle.

type BenchSuite = struct
  name: Str
  handle: Ptr[U8]
.end

fn bench_suite_new(name: Str) -> BenchSuite
  let s = BenchSuite
    name: name
    handle: 0
  .end
  ret s
.end

# -----------------------------------------------------------------------------
# Samples / Stats
# -----------------------------------------------------------------------------

type BenchSample = struct
  iters: U32
  elapsed_ns: U64
.end

fn bench_sample_new(iters: U32, elapsed_ns: U64) -> BenchSample
  let s = BenchSample
    iters: iters
    elapsed_ns: elapsed_ns
  .end
  ret s
.end

# Computed statistics in nanoseconds per-iteration.

type BenchStats = struct
  n: U32
  min_ns: U64
  max_ns: U64
  mean_ns: F64
  median_ns: F64
  p90_ns: F64
  p99_ns: F64
  stdev_ns: F64
.end

fn bench_stats_zero() -> BenchStats
  let st = BenchStats
    n: 0
    min_ns: 0
    max_ns: 0
    mean_ns: 0.0
    median_ns: 0.0
    p90_ns: 0.0
    p99_ns: 0.0
    stdev_ns: 0.0
  .end
  ret st
.end

# Compute ns/iter as float.
fn ns_per_iter(sample: BenchSample) -> F64
  if sample.iters == 0
    ret 0.0
  .end
  ret (sample.elapsed_ns as F64) / (sample.iters as F64)
.end

# NOTE: Full stats computation requires sorting and aggregation.
# This scaffold exposes the function and returns zeroed stats.

fn bench_compute_stats(samples_ptr: Ptr[BenchSample], samples_len: U32) -> BenchStats
  (void)samples_ptr
  (void)samples_len
  ret bench_stats_zero()
.end

# -----------------------------------------------------------------------------
# Reporting
# -----------------------------------------------------------------------------

type ReportFormat = enum
  Text
  Json
.end

fn report_format_str(f: ReportFormat) -> Str
  match f
    ReportFormat::Text => ret "text"
    ReportFormat::Json => ret "json"
  .end
.end

# Report sink is runtime-defined.
# In a C backend, this can be a FILE* or a callback vtable.

type ReportSink = struct
  fmt: ReportFormat
  opaque: Ptr[U8]
.end

fn report_sink_stdout_text() -> ReportSink
  let s = ReportSink
    fmt: ReportFormat::Text
    opaque: 0
  .end
  ret s
.end

fn report_sink_stdout_json() -> ReportSink
  let s = ReportSink
    fmt: ReportFormat::Json
    opaque: 0
  .end
  ret s
.end

fn report_begin(sink: ReportSink, cfg: BenchConfig) -> void
  (void)sink
  (void)cfg
  # Stub: backend prints header
  ret
.end

fn report_suite_begin(sink: ReportSink, suite: BenchSuite) -> void
  (void)sink
  (void)suite
  ret
.end

fn report_case_result(sink: ReportSink, suite: BenchSuite, case: BenchCase, stats: BenchStats) -> void
  (void)sink
  (void)suite
  (void)case
  (void)stats
  # Stub: backend prints one line per case
  ret
.end

fn report_end(sink: ReportSink) -> void
  (void)sink
  ret
.end

# -----------------------------------------------------------------------------
# Registry (bootstrap surface)
# -----------------------------------------------------------------------------

# A registry provides a stable way to register suites/cases from many modules.
# Implementation can be:
# - static arrays (link-time)
# - runtime dynamic registry
# - generated tables


type RegistryError = enum
  Full
  Duplicate
  Invalid
.end

# Opaque registry handle

type BenchRegistry = struct
  cfg: BenchConfig
  sink: ReportSink
  handle: Ptr[U8]
.end

fn bench_registry_new(cfg: BenchConfig, sink: ReportSink) -> BenchRegistry
  let r = BenchRegistry
    cfg: cfg
    sink: sink
    handle: 0
  .end
  ret r
.end

fn bench_registry_add_suite(mut reg: BenchRegistry, suite: BenchSuite) -> Result[BenchRegistry, RegistryError]
  (void)suite
  # Stub: accept
  ret Result::Ok(reg)
.end

fn bench_registry_add_case(mut reg: BenchRegistry, suite_name: Str, case: BenchCase) -> Result[BenchRegistry, RegistryError]
  (void)suite_name
  (void)case
  ret Result::Ok(reg)
.end

# -----------------------------------------------------------------------------
# Runner
# -----------------------------------------------------------------------------

# Run a single benchmark case.
# Backend should:
# - run warmup
# - run repeats
# - collect samples
# - compute stats
#
# Stub: polls clock twice with configured iters.

fn bench_run_case(cfg: BenchConfig, suite: BenchSuite, case: BenchCase) -> BenchStats
  (void)suite

  let mut b = bencher_new(cfg)
  b = bencher_begin(b, cfg.measure_iters)

  # Call bench function pointer (backend should pass &b)
  # Stub: no call
  (void)case

  b = bencher_end(b)

  let sample = bench_sample_new(bencher_iters(b), bencher_elapsed_ns(b))
  (void)sample

  # Stub: return zeros
  ret bench_stats_zero()
.end

# Run all registered suites/cases.
# Stub: emits begin/end only.

fn bench_run_all(mut reg: BenchRegistry) -> void
  report_begin(reg.sink, reg.cfg)
  # TODO: iterate suites/cases via reg.handle
  report_end(reg.sink)
.end

# -----------------------------------------------------------------------------
# Convenience: minimal micro harness
# -----------------------------------------------------------------------------

# A micro benchmark helper that runs a function N times in a tight loop.
# Useful for bootstrap testing even without full registry.

fn micro_run(cfg: BenchConfig, name: Str, fn_ptr: BenchFn) -> BenchStats
  (void)name
  (void)fn_ptr
  let suite = bench_suite_new("micro")
  let case = bench_case_new(name, fn_ptr)
  ret bench_run_case(cfg, suite, case)
.end

# -----------------------------------------------------------------------------
# Smoke scenarios
# -----------------------------------------------------------------------------

# Basic: ensure symbols link and execution doesn't crash.
scn t_bench_smoke
  let cfg = bench_config_default()
  let sink = report_sink_stdout_text()
  let reg = bench_registry_new(cfg, sink)
  bench_run_all(reg)
.end

# Minimal stats function surface.
scn t_bench_smoke_stats
  let st = bench_stats_zero()
  (void)st
.end
