# C:\Users\gogin\Documents\GitHub\vitte\std\bench\micro\src\bench.vitte
mod std/bench/micro/bench

use std/prelude

use std/core/option
use std/core/result

use std/alloc/vec
use std/alloc/string

use std/time/instant
use std/os/process

use std/bench/micro/reporters/console
use std/bench/micro/reporters/json

# =============================================================================
# std::bench::micro — micro benchmark harness
# =============================================================================
#
# Objectif:
# - runner micro déterministe: warmup + measure + samples
# - suites registrées: alloc/hash/io/regex/sort
# - reporters: console/json
#
# API:
# - Runner::bench(name, fn)
# - Runner::run()
# - suites::*::register(&mut Runner)
#
# Notes:
# - mesure ns/op (normalisé par iters)
# - calibrage automatique des iters_per_sample (optionnel)
#
# =============================================================================

# -----------------------------------------------------------------------------
# Types: Unit / Stats / Result
# -----------------------------------------------------------------------------

enum Unit
  NsOp
.end

struct BenchStats
  samples: usize
  total_ns: u64
  min_ns: u64
  max_ns: u64
  mean_ns: u64
  p50_ns: u64
  p90_ns: u64
  p99_ns: u64
.end

struct BenchMeta
  iters_per_sample: u64
  warmup_ms: u64
  measure_ms: u64
  note: string::String
.end

struct BenchResult
  name: string::String
  unit: Unit
  stats: BenchStats
  meta: BenchMeta
.end

# -----------------------------------------------------------------------------
# Sorting/percentiles
# -----------------------------------------------------------------------------

fn sort_u64(a: &mut [u64]) -> void
  let mut i: usize = 1
  while i < a.len()
    let key = a[i]
    let mut j: usize = i
    while j > 0 && a[j - 1] > key
      a[j] = a[j - 1]
      j = j - 1
    .end
    a[j] = key
    i = i + 1
  .end
.end

fn percentile(sorted: &[u64], p: u32) -> u64
  if sorted.len() == 0
    ret 0
  .end
  if p >= 100
    ret sorted[sorted.len() - 1]
  .end
  let idx = ((sorted.len() - 1) * (p as usize)) / 100
  ret sorted[idx]
.end

fn compute_stats(samples: &mut vec::Vec[u64]) -> BenchStats
  if samples.len() == 0
    ret BenchStats
      samples: 0
      total_ns: 0
      min_ns: 0
      max_ns: 0
      mean_ns: 0
      p50_ns: 0
      p90_ns: 0
      p99_ns: 0
    .end
  .end

  sort_u64(samples.as_mut_slice())

  let mut total: u64 = 0
  let mut i: usize = 0
  while i < samples.len()
    total = total + samples[i]
    i = i + 1
  .end

  let minv = samples[0]
  let maxv = samples[samples.len() - 1]
  let mean = total / (samples.len() as u64)

  ret BenchStats
    samples: samples.len()
    total_ns: total
    min_ns: minv
    max_ns: maxv
    mean_ns: mean
    p50_ns: percentile(samples.as_slice(), 50)
    p90_ns: percentile(samples.as_slice(), 90)
    p99_ns: percentile(samples.as_slice(), 99)
  .end
.end

# -----------------------------------------------------------------------------
# Config / Bencher / Case
# -----------------------------------------------------------------------------

struct Config
  warmup_ms: u64
  measure_ms: u64
  max_samples: usize

  iters_per_sample: u64
  auto_calibrate: bool

  reporter: string::String   # "console"|"json"
  pretty: bool
  verbose: bool
.end

fn Config::default() -> Config
  ret Config
    warmup_ms: 200
    measure_ms: 1000
    max_samples: 100_000
    iters_per_sample: 1
    auto_calibrate: true
    reporter: string::String::from_str("console")
    pretty: true
    verbose: false
  .end
.end

struct Bencher
  iters: u64
.end

fn Bencher::new() -> Bencher
  ret Bencher
    iters: 1
  .end
.end

fn Bencher::set_iters(self: &mut Bencher, n: u64) -> void
  self.iters = if n == 0 then 1 else n
.end

fn Bencher::iter(self: &Bencher, f: fn() -> void) -> void
  let mut i: u64 = 0
  while i < self.iters
    f()
    i = i + 1
  .end
.end

type BenchFn = fn(&mut Bencher) -> void

struct Case
  name: string::String
  f: BenchFn
  note: string::String
.end

fn Case::new(name: &str, f: BenchFn) -> Case
  ret Case
    name: string::String::from_str(name)
    f: f
    note: string::String::new()
  .end
.end

# -----------------------------------------------------------------------------
# Runner
# -----------------------------------------------------------------------------

struct Runner
  cfg: Config
  cases: vec::Vec[Case]
.end

fn Runner::new(cfg: Config) -> Runner
  ret Runner
    cfg: cfg
    cases: vec::Vec[Case]::new()
  .end
.end

fn Runner::bench(self: &mut Runner, name: &str, f: BenchFn) -> void
  self.cases.push(Case::new(name, f))
.end

fn Runner::bench_note(self: &mut Runner, name: &str, note: &str, f: BenchFn) -> void
  let mut c = Case::new(name, f)
  c.note = string::String::from_str(note)
  self.cases.push(c)
.end

fn warmup(cfg: &Config, f: BenchFn, iters: u64) -> void
  let mut b = Bencher::new()
  b.set_iters(iters)

  let start = instant::now()
  while start.elapsed_ms() < cfg.warmup_ms
    f(&mut b)
  .end
.end

fn sample_once(f: BenchFn, iters: u64) -> u64
  let mut b = Bencher::new()
  b.set_iters(iters)
  let t0 = instant::now()
  f(&mut b)
  let dt = t0.elapsed_ns_u64()
  ret dt / iters
.end

fn calibrate_iters(cfg: &Config, f: BenchFn) -> u64
  # target ~1ms per sample (rough)
  let target_ns: u64 = 1_000_000

  let mut it: u64 = cfg.iters_per_sample
  if it == 0
    it = 1
  .end

  let mut tries: u32 = 0
  while tries < 20
    let ns_op = sample_once(f, it)
    let total = ns_op * it
    if total >= target_ns
      ret it
    .end
    # grow
    it = it * 2
    tries = tries + 1
  .end

  ret it
.end

fn measure(cfg: &Config, f: BenchFn, iters: u64) -> BenchStats
  let mut samples: vec::Vec[u64] = vec::Vec[u64]::new()

  let start = instant::now()
  while start.elapsed_ms() < cfg.measure_ms && samples.len() < cfg.max_samples
    let ns_op = sample_once(f, iters)
    samples.push(ns_op)
  .end

  ret compute_stats(&mut samples)
.end

fn Runner::run(self: &mut Runner) -> i32
  if self.cases.len() == 0
    say "no micro benchmarks registered"
    ret 1
  .end

  let mut results: vec::Vec[BenchResult] = vec::Vec[BenchResult]::new()

  let mut i: usize = 0
  while i < self.cases.len()
    let c = self.cases[i]

    let iters = if self.cfg.auto_calibrate then calibrate_iters(&self.cfg, c.f) else self.cfg.iters_per_sample

    if self.cfg.verbose
      say string::fmt("warmup: {} (iters/sample={})", c.name.as_str(), iters)
    .end
    warmup(&self.cfg, c.f, iters)

    if self.cfg.verbose
      say string::fmt("measure: {}", c.name.as_str())
    .end
    let st = measure(&self.cfg, c.f, iters)

    results.push(BenchResult
      name: c.name
      unit: Unit::NsOp
      stats: st
      meta: BenchMeta
        iters_per_sample: iters
        warmup_ms: self.cfg.warmup_ms
        measure_ms: self.cfg.measure_ms
        note: c.note
      .end
    .end)

    i = i + 1
  .end

  # Dispatch reporter
  if self.cfg.reporter.as_str() == "json"
    let rep = if self.cfg.pretty then json::JsonReporter::new() else json::JsonReporter::compact()
    rep.report(&results)
  else
    let rep = console::ConsoleReporter::new()
    rep.report(&results)
  .end

  ret 0
.end

# -----------------------------------------------------------------------------
# CLI
# -----------------------------------------------------------------------------

fn parse_u64(s: &str, default: u64) -> u64
  let n = string::parse_u64(s)
  if n.is_some()
    ret n.unwrap()
  .end
  ret default
.end

fn parse_bool_flag(args: &vec::Vec[string::String], name: &str) -> bool
  let mut i: usize = 0
  while i < args.len()
    if args[i].as_str() == name
      ret true
    .end
    i = i + 1
  .end
  ret false
.end

fn parse_value(args: &vec::Vec[string::String], prefix: &str) -> option::Option[string::String]
  let mut i: usize = 0
  while i < args.len()
    let a = args[i].as_str()
    if a.starts_with(prefix)
      let v = a.split("=").last()
      ret option::Some(string::String::from_str(v))
    .end
    i = i + 1
  .end
  ret option::None
.end

fn config_from_args(args: &vec::Vec[string::String]) -> Config
  let mut cfg = Config::default()

  if parse_bool_flag(args, "--json")
    cfg.reporter = string::String::from_str("json")
  .end
  if parse_bool_flag(args, "--console")
    cfg.reporter = string::String::from_str("console")
  .end
  if parse_bool_flag(args, "--compact")
    cfg.pretty = false
  .end
  if parse_bool_flag(args, "--verbose")
    cfg.verbose = true
  .end
  if parse_bool_flag(args, "--no-calibrate")
    cfg.auto_calibrate = false
  .end

  let w = parse_value(args, "--warmup-ms=")
  if w.is_some()
    cfg.warmup_ms = parse_u64(w.unwrap().as_str(), cfg.warmup_ms)
  .end

  let m = parse_value(args, "--measure-ms=")
  if m.is_some()
    cfg.measure_ms = parse_u64(m.unwrap().as_str(), cfg.measure_ms)
  .end

  let it = parse_value(args, "--iters=")
  if it.is_some()
    cfg.iters_per_sample = parse_u64(it.unwrap().as_str(), cfg.iters_per_sample)
  .end

  ret cfg
.end

# -----------------------------------------------------------------------------
# Suites registration
# -----------------------------------------------------------------------------

use std/bench/micro/suites/alloc_suite
use std/bench/micro/suites/hash_suite
use std/bench/micro/suites/io_suite
use std/bench/micro/suites/regex_suite
use std/bench/micro/suites/sort_suite

fn register_all(r: &mut Runner) -> void
  alloc_suite::register(r)
  hash_suite::register(r)
  io_suite::register(r)
  regex_suite::register(r)
  sort_suite::register(r)
.end

# -----------------------------------------------------------------------------
# Entrypoint
# -----------------------------------------------------------------------------

fn main() -> i32
  let args = process::args()
  let cfg = config_from_args(&args)
  let mut r = Runner::new(cfg)
  register_all(&mut r)
  ret r.run()
.end
