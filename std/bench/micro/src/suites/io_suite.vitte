# C:\Users\gogin\Documents\GitHub\vitte\std\bench\micro\src\suites\io_suite.vitte
mod std/bench/micro/suites/io_suite

use std/prelude

use std/core/option
use std/core/result

use std/alloc/vec
use std/alloc/string

use std/time/instant

# =============================================================================
# Micro benchmark suite: io
# =============================================================================
#
# Objectif:
# - bench IO pure mémoire (read/write buffer) + encodage simple
# - bench "copy" style (memcpy-like)
# - bench parsing minimal (newline scan)
#
# Notes:
# - pas de FS/disque ici (trop instable pour microbench)
# - si tu veux bench FS: faire une suite séparée avec setup/teardown et fichiers
#
# =============================================================================

# -----------------------------------------------------------------------------
# Compat runner API (remplace par imports si existant)
# -----------------------------------------------------------------------------

struct Bencher
  iters: u64
.end

fn Bencher::iters(self: &Bencher) -> u64
  ret self.iters
.end

fn Bencher::iter(self: &Bencher, f: fn() -> void) -> void
  let mut i: u64 = 0
  while i < self.iters
    f()
    i = i + 1
  .end
.end

type BenchFn = fn(&mut Bencher) -> void

struct Runner
  _dummy: u32
.end

fn Runner::bench(self: &mut Runner, name: &str, f: BenchFn) -> void
  do name
  do f
.end

# -----------------------------------------------------------------------------
# Helpers
# -----------------------------------------------------------------------------

fn make_bytes(n: usize, seed: u64) -> vec::Vec[u8]
  let mut v: vec::Vec[u8] = vec::Vec[u8]::with_capacity(n)
  v.resize(n, 0)

  let mut x: u64 = seed
  let mut i: usize = 0
  while i < n
    x = x * 6364136223846793005 + 1
    v[i] = ((x >> 32) & 0xFF) as u8
    i = i + 1
  .end
  ret v
.end

fn mem_copy(dst: &mut [u8], src: &[u8]) -> void
  let n = if dst.len() < src.len() then dst.len() else src.len()
  let mut i: usize = 0
  while i < n
    dst[i] = src[i]
    i = i + 1
  .end
.end

fn scan_newlines(buf: &[u8]) -> u64
  let mut cnt: u64 = 0
  let mut i: usize = 0
  while i < buf.len()
    if buf[i] == ('\n' as u8)
      cnt = cnt + 1
    .end
    i = i + 1
  .end
  ret cnt
.end

# -----------------------------------------------------------------------------
# Bench cases
# -----------------------------------------------------------------------------

fn bench_mem_copy_4k(b: &mut Bencher) -> void
  let src = make_bytes(4096, 1)
  let mut dst = make_bytes(4096, 2)

  b.iter(fn() -> void
    mem_copy(dst.as_mut_slice(), src.as_slice())
    do dst[0]
  .end)
.end

fn bench_mem_copy_64k(b: &mut Bencher) -> void
  let src = make_bytes(65536, 3)
  let mut dst = make_bytes(65536, 4)

  b.iter(fn() -> void
    mem_copy(dst.as_mut_slice(), src.as_slice())
    do dst[0]
  .end)
.end

fn bench_scan_newlines_4k(b: &mut Bencher) -> void
  let mut buf = make_bytes(4096, 5)
  # inject newlines
  let mut i: usize = 0
  while i < buf.len()
    if (i % 64) == 0
      buf[i] = ('\n' as u8)
    .end
    i = i + 1
  .end

  b.iter(fn() -> void
    let c = scan_newlines(buf.as_slice())
    do c
  .end)
.end

fn bench_scan_newlines_64k(b: &mut Bencher) -> void
  let mut buf = make_bytes(65536, 6)
  let mut i: usize = 0
  while i < buf.len()
    if (i % 128) == 0
      buf[i] = ('\n' as u8)
    .end
    i = i + 1
  .end

  b.iter(fn() -> void
    let c = scan_newlines(buf.as_slice())
    do c
  .end)
.end

fn bench_encode_u32_le_4k(b: &mut Bencher) -> void
  let mut out = make_bytes(4096, 7)
  let mut x: u32 = 0

  b.iter(fn() -> void
    let mut i: usize = 0
    while i + 4 <= out.len()
      # little-endian encoding
      out[i + 0] = (x & 0xFF) as u8
      out[i + 1] = ((x >> 8) & 0xFF) as u8
      out[i + 2] = ((x >> 16) & 0xFF) as u8
      out[i + 3] = ((x >> 24) & 0xFF) as u8
      x = x + 1
      i = i + 4
    .end
    do out[0]
  .end)
.end

# -----------------------------------------------------------------------------
# Register suite
# -----------------------------------------------------------------------------

fn register(r: &mut Runner) -> void
  r.bench("io/mem_copy_4k", bench_mem_copy_4k)
  r.bench("io/mem_copy_64k", bench_mem_copy_64k)
  r.bench("io/scan_newlines_4k", bench_scan_newlines_4k)
  r.bench("io/scan_newlines_64k", bench_scan_newlines_64k)
  r.bench("io/encode_u32_le_4k", bench_encode_u32_le_4k)
.end
