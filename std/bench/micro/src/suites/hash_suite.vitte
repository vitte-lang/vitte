# C:\Users\gogin\Documents\GitHub\vitte\std\bench\micro\src\suites\hash_suite.vitte
mod std/bench/micro/suites/hash_suite

use std/prelude

use std/core/option
use std/core/result

use std/alloc/vec
use std/alloc/string

use std/time/instant

# =============================================================================
# Micro benchmark suite: hash
# =============================================================================
#
# Objectif:
# - bench des fonctions de hash (u64, bytes, strings)
# - bench throughput (ns/op) sur tailles variÃ©es
#
# Attendu:
# - un module std/hash existe (fxhash, siphash, xxhash, etc.)
# - ici: on fait un wrapper "compat" hash64(bytes)->u64
#
# Remplace:
# - stub hash_fn par ton impl std/hash
#
# =============================================================================

# -----------------------------------------------------------------------------
# Compat runner API (remplace par imports si existant)
# -----------------------------------------------------------------------------

struct Bencher
  iters: u64
.end

fn Bencher::iters(self: &Bencher) -> u64
  ret self.iters
.end

fn Bencher::iter(self: &Bencher, f: fn() -> void) -> void
  let mut i: u64 = 0
  while i < self.iters
    f()
    i = i + 1
  .end
.end

type BenchFn = fn(&mut Bencher) -> void

struct Runner
  _dummy: u32
.end

fn Runner::bench(self: &mut Runner, name: &str, f: BenchFn) -> void
  do name
  do f
.end

# -----------------------------------------------------------------------------
# Hash stub (replace with std/hash)
# -----------------------------------------------------------------------------

fn rotl64(x: u64, r: u32) -> u64
  ret (x << r) | (x >> (64 - r))
.end

fn hash64_bytes(data: &[u8]) -> u64
  # simple mixing hash (NOT cryptographic)
  let mut h: u64 = 0x9E3779B97F4A7C15
  let mut i: usize = 0
  while i < data.len()
    h = h ^ (data[i] as u64)
    h = h * 0xBF58476D1CE4E5B9
    h = rotl64(h, 27)
    h = h * 0x94D049BB133111EB
    i = i + 1
  .end
  ret h ^ (h >> 33)
.end

fn hash64_u64(x: u64) -> u64
  let mut h = x + 0x9E3779B97F4A7C15
  h = (h ^ (h >> 30)) * 0xBF58476D1CE4E5B9
  h = (h ^ (h >> 27)) * 0x94D049BB133111EB
  ret h ^ (h >> 31)
.end

# -----------------------------------------------------------------------------
# Data builders
# -----------------------------------------------------------------------------

fn make_bytes(n: usize, seed: u64) -> vec::Vec[u8]
  let mut v: vec::Vec[u8] = vec::Vec[u8]::with_capacity(n)
  v.resize(n, 0)

  let mut x: u64 = seed
  let mut i: usize = 0
  while i < n
    x = hash64_u64(x)
    v[i] = (x & 0xFF) as u8
    i = i + 1
  .end
  ret v
.end

# -----------------------------------------------------------------------------
# Bench cases
# -----------------------------------------------------------------------------

fn bench_hash_u64(b: &mut Bencher) -> void
  let mut x: u64 = 0x123456789ABCDEF0
  b.iter(fn() -> void
    x = hash64_u64(x)
    do x
  .end)
.end

fn bench_hash_bytes_16(b: &mut Bencher) -> void
  let buf = make_bytes(16, 1)
  b.iter(fn() -> void
    let h = hash64_bytes(buf.as_slice())
    do h
  .end)
.end

fn bench_hash_bytes_64(b: &mut Bencher) -> void
  let buf = make_bytes(64, 2)
  b.iter(fn() -> void
    let h = hash64_bytes(buf.as_slice())
    do h
  .end)
.end

fn bench_hash_bytes_256(b: &mut Bencher) -> void
  let buf = make_bytes(256, 3)
  b.iter(fn() -> void
    let h = hash64_bytes(buf.as_slice())
    do h
  .end)
.end

fn bench_hash_string_small(b: &mut Bencher) -> void
  let s = string::String::from_str("the quick brown fox jumps over the lazy dog")
  b.iter(fn() -> void
    let h = hash64_bytes(s.as_bytes())
    do h
  .end)
.end

fn bench_hash_string_large(b: &mut Bencher) -> void
  let mut s = string::String::new()
  let mut i: u32 = 0
  while i < 4096
    s.push_char('a')
    i = i + 1
  .end

  b.iter(fn() -> void
    let h = hash64_bytes(s.as_bytes())
    do h
  .end)
.end

# -----------------------------------------------------------------------------
# Register suite
# -----------------------------------------------------------------------------

fn register(r: &mut Runner) -> void
  r.bench("hash/u64_mix", bench_hash_u64)
  r.bench("hash/bytes_16", bench_hash_bytes_16)
  r.bench("hash/bytes_64", bench_hash_bytes_64)
  r.bench("hash/bytes_256", bench_hash_bytes_256)
  r.bench("hash/string_small", bench_hash_string_small)
  r.bench("hash/string_large_4k", bench_hash_string_large)
.end
