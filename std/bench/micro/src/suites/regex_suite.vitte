# C:\Users\gogin\Documents\GitHub\vitte\std\bench\micro\src\suites\regex_suite.vitte
mod std/bench/micro/suites/regex_suite

use std/prelude

use std/core/option
use std/core/result

use std/alloc/vec
use std/alloc/string

# =============================================================================
# Micro benchmark suite: regex
# =============================================================================
#
# Objectif:
# - bench compilation + matching regex
# - patterns: literals, classes, alternation, simple groups
#
# Attendu:
# - std/regex existe (wrapper Rust ou impl maison)
# - API suggérée:
#     regex::Regex::new(pattern: &str) -> Result[Regex, RegexError]
#     regex::Regex::is_match(text: &str) -> bool
#     regex::Regex::find(text: &str) -> Option[(usize, usize)]
#     regex::Regex::find_all(text: &str) -> Vec[(usize, usize)]
#
# Ici:
# - on fournit des stubs compatibles si std/regex pas encore présent.
# - remplace les stubs par use std/regex.
#
# =============================================================================

# -----------------------------------------------------------------------------
# Compat runner API (remplace par imports si existant)
# -----------------------------------------------------------------------------

struct Bencher
  iters: u64
.end

fn Bencher::iters(self: &Bencher) -> u64
  ret self.iters
.end

fn Bencher::iter(self: &Bencher, f: fn() -> void) -> void
  let mut i: u64 = 0
  while i < self.iters
    f()
    i = i + 1
  .end
.end

type BenchFn = fn(&mut Bencher) -> void

struct Runner
  _dummy: u32
.end

fn Runner::bench(self: &mut Runner, name: &str, f: BenchFn) -> void
  do name
  do f
.end

# -----------------------------------------------------------------------------
# Regex stubs (replace with std/regex)
# -----------------------------------------------------------------------------

enum RegexError
  Invalid
.end

struct Regex
  pat: string::String
.end

fn Regex::new(pat: &str) -> result::Result[Regex, RegexError]
  if pat.len() == 0
    ret result::Err(RegexError::Invalid)
  .end
  ret result::Ok(Regex
    pat: string::String::from_str(pat)
  .end)
.end

fn Regex::is_match(self: &Regex, text: &str) -> bool
  # stub: substring search
  ret text.contains(self.pat.as_str())
.end

fn Regex::find(self: &Regex, text: &str) -> option::Option[(usize, usize)]
  let idx = text.find(self.pat.as_str())
  if idx.is_none()
    ret option::None
  .end
  let i = idx.unwrap()
  ret option::Some((i, i + self.pat.len()))
.end

fn Regex::find_all(self: &Regex, text: &str) -> vec::Vec[(usize, usize)]
  let mut out: vec::Vec[(usize, usize)] = vec::Vec[(usize, usize)]::new()
  let mut start: usize = 0

  while start < text.len()
    let sub = &text[start..]
    let idx = sub.find(self.pat.as_str())
    if idx.is_none()
      break
    .end
    let i = start + idx.unwrap()
    out.push((i, i + self.pat.len()))
    start = i + self.pat.len()
  .end

  ret out
.end

# -----------------------------------------------------------------------------
# Test data
# -----------------------------------------------------------------------------

fn make_text(size: usize) -> string::String
  let mut s = string::String::new()
  s.reserve(size)

  let mut i: usize = 0
  while i < size
    # deterministic text
    if (i % 97) == 0
      s.push_str("foobar-123 ")
      i = i + 10
      continue
    .end
    s.push_char('a')
    i = i + 1
  .end
  ret s
.end

# -----------------------------------------------------------------------------
# Bench cases: compile
# -----------------------------------------------------------------------------

fn bench_regex_compile_literal(b: &mut Bencher) -> void
  b.iter(fn() -> void
    let r = Regex::new("foobar").unwrap()
    do r.pat.len()
  .end)
.end

fn bench_regex_compile_class(b: &mut Bencher) -> void
  b.iter(fn() -> void
    let r = Regex::new("[a-z]+").unwrap()
    do r.pat.len()
  .end)
.end

fn bench_regex_compile_alt(b: &mut Bencher) -> void
  b.iter(fn() -> void
    let r = Regex::new("(foo|bar|baz)[0-9]+").unwrap()
    do r.pat.len()
  .end)
.end

# -----------------------------------------------------------------------------
# Bench cases: match
# -----------------------------------------------------------------------------

fn bench_regex_is_match_small(b: &mut Bencher) -> void
  let r = Regex::new("foobar").unwrap()
  let t = "zzzz foobar zzzz"

  b.iter(fn() -> void
    let ok = r.is_match(t)
    do ok
  .end)
.end

fn bench_regex_is_match_4k(b: &mut Bencher) -> void
  let r = Regex::new("foobar").unwrap()
  let t = make_text(4096)

  b.iter(fn() -> void
    let ok = r.is_match(t.as_str())
    do ok
  .end)
.end

fn bench_regex_find_4k(b: &mut Bencher) -> void
  let r = Regex::new("foobar").unwrap()
  let t = make_text(4096)

  b.iter(fn() -> void
    let o = r.find(t.as_str())
    do o.is_some()
  .end)
.end

fn bench_regex_find_all_64k(b: &mut Bencher) -> void
  let r = Regex::new("foobar").unwrap()
  let t = make_text(65536)

  b.iter(fn() -> void
    let v = r.find_all(t.as_str())
    do v.len()
  .end)
.end

# -----------------------------------------------------------------------------
# Register suite
# -----------------------------------------------------------------------------

fn register(r: &mut Runner) -> void
  r.bench("regex/compile_literal", bench_regex_compile_literal)
  r.bench("regex/compile_class", bench_regex_compile_class)
  r.bench("regex/compile_alt", bench_regex_compile_alt)

  r.bench("regex/is_match_small", bench_regex_is_match_small)
  r.bench("regex/is_match_4k", bench_regex_is_match_4k)
  r.bench("regex/find_4k", bench_regex_find_4k)
  r.bench("regex/find_all_64k", bench_regex_find_all_64k)
.end
