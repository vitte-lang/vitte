# C:\Users\gogin\Documents\GitHub\vitte\std\bench\micro\src\suites\sort_suite.vitte
mod std/bench/micro/suites/sort_suite

use std/prelude

use std/core/option
use std/core/result

use std/alloc/vec
use std/alloc/string

# =============================================================================
# Micro benchmark suite: sort
# =============================================================================
#
# Objectif:
# - bench tri (ints) sur tailles variÃ©es
# - compare: insertion sort (small), quicksort/mergesort (fallback)
#
# Attendu:
# - si std/algo/sort existe, remplace par use std/algo/sort::sort_u64
# - sinon, stubs ici
#
# =============================================================================

# -----------------------------------------------------------------------------
# Compat runner API (remplace par imports si existant)
# -----------------------------------------------------------------------------

struct Bencher
  iters: u64
.end

fn Bencher::iters(self: &Bencher) -> u64
  ret self.iters
.end

fn Bencher::iter(self: &Bencher, f: fn() -> void) -> void
  let mut i: u64 = 0
  while i < self.iters
    f()
    i = i + 1
  .end
.end

type BenchFn = fn(&mut Bencher) -> void

struct Runner
  _dummy: u32
.end

fn Runner::bench(self: &mut Runner, name: &str, f: BenchFn) -> void
  do name
  do f
.end

# -----------------------------------------------------------------------------
# RNG (deterministic)
# -----------------------------------------------------------------------------

fn rng_next(x: &mut u64) -> u64
  *x = (*x * 6364136223846793005) + 1
  ret *x
.end

fn make_u64_vec(n: usize, seed: u64) -> vec::Vec[u64]
  let mut v: vec::Vec[u64] = vec::Vec[u64]::with_capacity(n)
  v.resize(n, 0)

  let mut x = seed
  let mut i: usize = 0
  while i < n
    v[i] = rng_next(&mut x)
    i = i + 1
  .end
  ret v
.end

# -----------------------------------------------------------------------------
# Sorting algorithms
# -----------------------------------------------------------------------------

fn insertion_sort(a: &mut [u64]) -> void
  let mut i: usize = 1
  while i < a.len()
    let key = a[i]
    let mut j: usize = i
    while j > 0 && a[j - 1] > key
      a[j] = a[j - 1]
      j = j - 1
    .end
    a[j] = key
    i = i + 1
  .end
.end

fn partition(a: &mut [u64], lo: isize, hi: isize) -> isize
  let pivot = a[hi as usize]
  let mut i: isize = lo - 1
  let mut j: isize = lo
  while j < hi
    if a[j as usize] <= pivot
      i = i + 1
      let tmp = a[i as usize]
      a[i as usize] = a[j as usize]
      a[j as usize] = tmp
    .end
    j = j + 1
  .end
  let tmp2 = a[(i + 1) as usize]
  a[(i + 1) as usize] = a[hi as usize]
  a[hi as usize] = tmp2
  ret i + 1
.end

fn quicksort_rec(a: &mut [u64], lo: isize, hi: isize) -> void
  if lo >= hi
    ret
  .end

  # small partition => insertion sort
  if (hi - lo) <= 24
    insertion_sort(&mut a[lo as usize .. (hi as usize + 1)])
    ret
  .end

  let p = partition(a, lo, hi)
  quicksort_rec(a, lo, p - 1)
  quicksort_rec(a, p + 1, hi)
.end

fn sort_u64(a: &mut [u64]) -> void
  if a.len() <= 1
    ret
  .end
  quicksort_rec(a, 0, (a.len() as isize) - 1)
.end

fn is_sorted(a: &[u64]) -> bool
  let mut i: usize = 1
  while i < a.len()
    if a[i - 1] > a[i]
      ret false
    .end
    i = i + 1
  .end
  ret true
.end

# -----------------------------------------------------------------------------
# Bench cases
# -----------------------------------------------------------------------------

fn bench_sort_128(b: &mut Bencher) -> void
  b.iter(fn() -> void
    let mut v = make_u64_vec(128, 1)
    sort_u64(v.as_mut_slice())
    do is_sorted(v.as_slice())
  .end)
.end

fn bench_sort_1k(b: &mut Bencher) -> void
  b.iter(fn() -> void
    let mut v = make_u64_vec(1024, 2)
    sort_u64(v.as_mut_slice())
    do is_sorted(v.as_slice())
  .end)
.end

fn bench_sort_16k(b: &mut Bencher) -> void
  b.iter(fn() -> void
    let mut v = make_u64_vec(16384, 3)
    sort_u64(v.as_mut_slice())
    do is_sorted(v.as_slice())
  .end)
.end

fn bench_insertion_sort_64(b: &mut Bencher) -> void
  b.iter(fn() -> void
    let mut v = make_u64_vec(64, 4)
    insertion_sort(v.as_mut_slice())
    do is_sorted(v.as_slice())
  .end)
.end

# -----------------------------------------------------------------------------
# Register suite
# -----------------------------------------------------------------------------

fn register(r: &mut Runner) -> void
  r.bench("sort/insertion_64", bench_insertion_sort_64)
  r.bench("sort/quicksort_128", bench_sort_128)
  r.bench("sort/quicksort_1k", bench_sort_1k)
  r.bench("sort/quicksort_16k", bench_sort_16k)
.end
