# C:\Users\gogin\Documents\GitHub\vitte\std\bench\micro\src\reporters\console.vitte
mod std/bench/micro/reporters/console

use std/prelude

use std/core/option
use std/core/result

use std/alloc/vec
use std/alloc/string

use std/time/instant

# =============================================================================
# Micro bench reporter: Console
# =============================================================================
#
# Objectif:
# - sortie console lisible (table)
# - format stable pour CI
#
# Attendu côté API micro harness:
# - BenchSample: ns/op (u64), iters (u64), bytes/op (u64), items/op (u64)
# - BenchStats: aggregates min/max/mean/p50/p90/p99, samples count
# - BenchResult: name + unit + stats + meta
#
# Ici: on définit aussi des structs "compat" si tu n'as pas encore.
# Si tu as déjà ces types ailleurs: garde juste ConsoleReporter::report()
#
# =============================================================================

# -----------------------------------------------------------------------------
# Compat types (peuvent être remplacés par imports)
# -----------------------------------------------------------------------------

enum Unit
  NsOp
  BytesSec
  ItemsSec
.end

struct BenchStats
  samples: usize
  total_ns: u64
  min_ns: u64
  max_ns: u64
  mean_ns: u64
  p50_ns: u64
  p90_ns: u64
  p99_ns: u64
.end

struct BenchMeta
  iters_per_sample: u64
  warmup_ms: u64
  measure_ms: u64
  note: string::String
.end

struct BenchResult
  name: string::String
  unit: Unit
  stats: BenchStats
  meta: BenchMeta
.end

# -----------------------------------------------------------------------------
# Formatting helpers
# -----------------------------------------------------------------------------

fn format_ns(ns: u64) -> string::String
  if ns < 1_000
    ret string::String::from_str(string::fmt("{} ns", ns))
  .end
  if ns < 1_000_000
    ret string::String::from_str(string::fmt("{} us", ns / 1_000))
  .end
  if ns < 1_000_000_000
    ret string::String::from_str(string::fmt("{} ms", ns / 1_000_000))
  .end
  ret string::String::from_str(string::fmt("{} s", ns / 1_000_000_000))
.end

fn unit_str(u: Unit) -> &str
  match u
    Unit::NsOp => ret "ns/op"
    Unit::BytesSec => ret "B/s"
    Unit::ItemsSec => ret "items/s"
  .end
.end

# -----------------------------------------------------------------------------
# Reporter
# -----------------------------------------------------------------------------

struct ConsoleReporter
  show_meta: bool
  width_name: usize
.end

fn ConsoleReporter::new() -> ConsoleReporter
  ret ConsoleReporter
    show_meta: true
    width_name: 34
  .end
.end

fn ConsoleReporter::with_meta(self: &mut ConsoleReporter, enabled: bool) -> &mut ConsoleReporter
  self.show_meta = enabled
  ret self
.end

fn ConsoleReporter::with_name_width(self: &mut ConsoleReporter, w: usize) -> &mut ConsoleReporter
  self.width_name = w
  ret self
.end

fn ConsoleReporter::report(self: &ConsoleReporter, results: &vec::Vec[BenchResult]) -> void
  if results.len() == 0
    say "no benchmarks"
    ret
  .end

  say string::fmt(
    "{:<w$} {:>8} {:>10} {:>10} {:>10} {:>10} {:>10} {:>10} {:>8}",
    "name",
    "unit",
    "mean",
    "p50",
    "p90",
    "p99",
    "min",
    "max",
    "samples",
    w=self.width_name
  )
  say string::fmt("{:-<1$}", "", self.width_name + 8 + 10*6 + 8 + 8)

  let mut i: usize = 0
  while i < results.len()
    let r = results[i]
    let st = r.stats

    say string::fmt(
      "{:<w$} {:>8} {:>10} {:>10} {:>10} {:>10} {:>10} {:>10} {:>8}",
      r.name.as_str(),
      unit_str(r.unit),
      format_ns(st.mean_ns).as_str(),
      format_ns(st.p50_ns).as_str(),
      format_ns(st.p90_ns).as_str(),
      format_ns(st.p99_ns).as_str(),
      format_ns(st.min_ns).as_str(),
      format_ns(st.max_ns).as_str(),
      st.samples,
      w=self.width_name
    )

    if self.show_meta
      let m = r.meta
      if m.note.len() > 0
        say string::fmt("  note: {}", m.note.as_str())
      .end
      say string::fmt(
        "  iters/sample={} warmup={}ms measure={}ms",
        m.iters_per_sample,
        m.warmup_ms,
        m.measure_ms
      )
    .end

    i = i + 1
  .end
.end
