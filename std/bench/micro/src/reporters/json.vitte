# C:\Users\gogin\Documents\GitHub\vitte\std\bench\micro\src\reporters\json.vitte
mod std/bench/micro/reporters/json

use std/prelude

use std/core/option
use std/core/result

use std/alloc/vec
use std/alloc/string

# =============================================================================
# Micro bench reporter: JSON
# =============================================================================
#
# Objectif:
# - sortie JSON stable pour CI / tooling
# - pas d'escaping complet (contrôlé), mais structure correcte
#
# Types attendus (compat):
# - Unit, BenchStats, BenchMeta, BenchResult
#
# =============================================================================

# -----------------------------------------------------------------------------
# Compat types (peuvent être remplacés par imports)
# -----------------------------------------------------------------------------

enum Unit
  NsOp
  BytesSec
  ItemsSec
.end

struct BenchStats
  samples: usize
  total_ns: u64
  min_ns: u64
  max_ns: u64
  mean_ns: u64
  p50_ns: u64
  p90_ns: u64
  p99_ns: u64
.end

struct BenchMeta
  iters_per_sample: u64
  warmup_ms: u64
  measure_ms: u64
  note: string::String
.end

struct BenchResult
  name: string::String
  unit: Unit
  stats: BenchStats
  meta: BenchMeta
.end

# -----------------------------------------------------------------------------
# Helpers
# -----------------------------------------------------------------------------

fn unit_str(u: Unit) -> &str
  match u
    Unit::NsOp => ret "ns/op"
    Unit::BytesSec => ret "B/s"
    Unit::ItemsSec => ret "items/s"
  .end
.end

fn json_escape_stub(s: &str) -> string::String
  # minimal escape: backslash + quote
  let mut out = string::String::new()
  let bytes = s.as_bytes()

  let mut i: usize = 0
  while i < bytes.len()
    let c = bytes[i]
    if c == ('"' as u8)
      out.push_str("\\\"")
    elif c == ('\\' as u8)
      out.push_str("\\\\")
    elif c == ('\n' as u8)
      out.push_str("\\n")
    elif c == ('\r' as u8)
      out.push_str("\\r")
    elif c == ('\t' as u8)
      out.push_str("\\t")
    else
      out.push_char(c as char)
    .end
    i = i + 1
  .end

  ret out
.end

# -----------------------------------------------------------------------------
# Reporter
# -----------------------------------------------------------------------------

struct JsonReporter
  pretty: bool
.end

fn JsonReporter::new() -> JsonReporter
  ret JsonReporter
    pretty: true
  .end
.end

fn JsonReporter::compact() -> JsonReporter
  ret JsonReporter
    pretty: false
  .end
.end

fn JsonReporter::report(self: &JsonReporter, results: &vec::Vec[BenchResult]) -> void
  let nl = if self.pretty then "\n" else ""
  let ind1 = if self.pretty then "  " else ""
  let ind2 = if self.pretty then "    " else ""

  say string::fmt("{{{0}{1}\"bench\": [{0}", nl, ind1)

  let mut i: usize = 0
  while i < results.len()
    let r = results[i]
    let st = r.stats
    let m = r.meta
    let comma = if i + 1 < results.len() then "," else ""

    let name = json_escape_stub(r.name.as_str())
    let note = json_escape_stub(m.note.as_str())

    say string::fmt(
      "{0}{1}{{{2}{0}{1}{3}\"name\": \"{4}\",{2}{0}{1}{3}\"unit\": \"{5}\",{2}{0}{1}{3}\"stats\": {{\"samples\": {6}, \"mean_ns\": {7}, \"p50_ns\": {8}, \"p90_ns\": {9}, \"p99_ns\": {10}, \"min_ns\": {11}, \"max_ns\": {12}}},{2}{0}{1}{3}\"meta\": {{\"iters_per_sample\": {13}, \"warmup_ms\": {14}, \"measure_ms\": {15}, \"note\": \"{16}\"}}{17}}}{18}",
      nl, ind1, "", ind2,
      name.as_str(),
      unit_str(r.unit),
      st.samples,
      st.mean_ns,
      st.p50_ns,
      st.p90_ns,
      st.p99_ns,
      st.min_ns,
      st.max_ns,
      m.iters_per_sample,
      m.warmup_ms,
      m.measure_ms,
      note.as_str(),
      "",
      comma
    )

    i = i + 1
  .end

  say string::fmt("{0}{1}]{0}}}", nl, ind1)
.end
