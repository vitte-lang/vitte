# -----------------------------------------------------------------------------
# std/encoding
# -----------------------------------------------------------------------------
# Bootstrap-friendly encoding primitives.
#
# Provided:
# - Hex (encode/decode)
# - Base64 (RFC 4648) standard + URL-safe (no padding optional)
# - UTF-8 validation + decode to scalar values + encode
# - ASCII helpers
#
# Design constraints:
# - deterministic, no IO
# - no hidden allocations (uses std.collections Vec)
# - blocks use `.end` only
# -----------------------------------------------------------------------------

module std.encoding

use std.collections

# -----------------------------------------------------------------------------
# Local prelude (types)
# -----------------------------------------------------------------------------

type Bool = bool

type U8   = u8
type U16  = u16
type U32  = u32
type U64  = u64

type I32  = i32

type USize = usize

type Ptr[T] = ptr[T]

type Str = str

# -----------------------------------------------------------------------------
# Error model
# -----------------------------------------------------------------------------

type EncError enum
  Ok
  OutOfMemory
  Invalid
  Truncated
  Overflow
.end

# -----------------------------------------------------------------------------
# Runtime stubs (platform / stage0)
# -----------------------------------------------------------------------------

fn rt_memcpy(dst: Ptr[U8], src: Ptr[U8], bytes: USize)
  ret
.end

fn rt_memset(dst: Ptr[U8], v: U8, bytes: USize)
  ret
.end

fn panic(msg: Str)
  ret
.end

fn assert(cond: Bool, msg: Str)
  if !cond
    do panic(msg)
  .end
.end

# -----------------------------------------------------------------------------
# Vec helpers
# -----------------------------------------------------------------------------

fn vec_u8_reserve(v: &Vec[U8], add: USize) -> (Bool, EncError)
  let ok: Bool
  let err: ColError
  (ok, err) = vec_reserve_bytes[U8](v, 1, add)
  if ok
    ret (true, EncError::Ok)
  .end
  ret (false, EncError::OutOfMemory)
.end

fn vec_u8_push(v: &Vec[U8], b: U8) -> (Bool, EncError)
  let ok: Bool
  let err: ColError
  (ok, err) = vec_push[U8](v, 1, b)
  if ok
    ret (true, EncError::Ok)
  .end
  ret (false, EncError::OutOfMemory)
.end

fn vec_u32_push(v: &Vec[U32], x: U32) -> (Bool, EncError)
  let ok: Bool
  let err: ColError
  (ok, err) = vec_push[U32](v, 4, x)
  if ok
    ret (true, EncError::Ok)
  .end
  ret (false, EncError::OutOfMemory)
.end

fn min_usize(a: USize, b: USize) -> USize
  if a < b
    ret a
  .end
  ret b
.end

# -----------------------------------------------------------------------------
# ASCII helpers
# -----------------------------------------------------------------------------

fn is_ascii(b: U8) -> Bool
  ret b < 0x80
.end

fn is_ascii_digit(b: U8) -> Bool
  ret b >= (U8)'0' && b <= (U8)'9'
.end

fn is_ascii_hex(b: U8) -> Bool
  ret (b >= (U8)'0' && b <= (U8)'9') || (b >= (U8)'a' && b <= (U8)'f') || (b >= (U8)'A' && b <= (U8)'F')
.end

fn ascii_to_lower(b: U8) -> U8
  if b >= (U8)'A' && b <= (U8)'Z'
    ret b + 32
  .end
  ret b
.end

# -----------------------------------------------------------------------------
# Hex
# -----------------------------------------------------------------------------

fn hex_nibble(b: U8) -> (Bool, U8)
  # returns (ok, value)
  if b >= (U8)'0' && b <= (U8)'9'
    ret (true, b - (U8)'0')
  .end
  if b >= (U8)'a' && b <= (U8)'f'
    ret (true, (b - (U8)'a') + 10)
  .end
  if b >= (U8)'A' && b <= (U8)'F'
    ret (true, (b - (U8)'A') + 10)
  .end
  ret (false, 0)
.end

fn hex_encode(in: &Vec[U8], out: &Vec[U8], upper: Bool) -> (Bool, EncError)
  do vec_clear[U8](out)

  let need = in.len * 2
  let ok: Bool
  let err: EncError
  (ok, err) = vec_u8_reserve(out, need)
  if !ok
    ret (false, err)
  .end

  let alpha0: U8
  if upper
    set alpha0 = (U8)'A'
  else
    set alpha0 = (U8)'a'
  .end

  let i: USize
  set i = 0
  let ip = (Ptr[U8])in.data
  loop
    if i >= in.len
      break
    .end
    let x = *(ip + i)
    let hi = (x >> 4) & 0x0f
    let lo = x & 0x0f

    let c0: U8
    let c1: U8

    if hi < 10
      set c0 = (U8)'0' + hi
    else
      set c0 = alpha0 + (hi - 10)
    .end

    if lo < 10
      set c1 = (U8)'0' + lo
    else
      set c1 = alpha0 + (lo - 10)
    .end

    (ok, err) = vec_u8_push(out, c0)
    if !ok
      ret (false, err)
    .end
    (ok, err) = vec_u8_push(out, c1)
    if !ok
      ret (false, err)
    .end

    set i = i + 1
  .end

  ret (true, EncError::Ok)
.end

fn hex_decode(in: &Vec[U8], out: &Vec[U8]) -> (Bool, EncError)
  do vec_clear[U8](out)

  if (in.len % 2) != 0
    ret (false, EncError::Invalid)
  .end

  let need = in.len / 2
  let ok: Bool
  let err: EncError
  (ok, err) = vec_u8_reserve(out, need)
  if !ok
    ret (false, err)
  .end

  let i: USize
  set i = 0
  let ip = (Ptr[U8])in.data
  loop
    if i >= in.len
      break
    .end

    let ok0: Bool
    let ok1: Bool
    let n0: U8
    let n1: U8

    (ok0, n0) = hex_nibble(*(ip + i))
    (ok1, n1) = hex_nibble(*(ip + i + 1))
    if !ok0 || !ok1
      ret (false, EncError::Invalid)
    .end

    let b = (n0 << 4) | n1
    (ok, err) = vec_u8_push(out, b)
    if !ok
      ret (false, err)
    .end

    set i = i + 2
  .end

  ret (true, EncError::Ok)
.end

# -----------------------------------------------------------------------------
# Base64 (RFC 4648)
# -----------------------------------------------------------------------------

type Base64Variant enum
  Standard
  UrlSafe
.end

fn b64_table(v: Base64Variant, idx: U8) -> U8
  # idx 0..63
  if idx < 26
    ret (U8)'A' + idx
  .end
  if idx < 52
    ret (U8)'a' + (idx - 26)
  .end
  if idx < 62
    ret (U8)'0' + (idx - 52)
  .end

  if v == Base64Variant::Standard
    if idx == 62
      ret (U8)'+'
    .end
    ret (U8)'/'
  .end

  if idx == 62
    ret (U8)'-'
  .end
  ret (U8)'_'
.end

fn b64_rev(v: Base64Variant, c: U8) -> (Bool, U8)
  # returns (ok, 0..63)
  if c >= (U8)'A' && c <= (U8)'Z'
    ret (true, c - (U8)'A')
  .end
  if c >= (U8)'a' && c <= (U8)'z'
    ret (true, (c - (U8)'a') + 26)
  .end
  if c >= (U8)'0' && c <= (U8)'9'
    ret (true, (c - (U8)'0') + 52)
  .end

  if v == Base64Variant::Standard
    if c == (U8)'+'
      ret (true, 62)
    .end
    if c == (U8)'/'
      ret (true, 63)
    .end
  else
    if c == (U8)'-'
      ret (true, 62)
    .end
    if c == (U8)'_'
      ret (true, 63)
    .end
  .end

  ret (false, 0)
.end

fn base64_encoded_len(n: USize, padding: Bool) -> USize
  let full = (n / 3) * 4
  let rem = n % 3
  if rem == 0
    ret full
  .end

  if padding
    ret full + 4
  .end

  # no padding: rem=1 => +2, rem=2 => +3
  if rem == 1
    ret full + 2
  .end
  ret full + 3
.end

fn base64_encode(in: &Vec[U8], out: &Vec[U8], variant: Base64Variant, padding: Bool) -> (Bool, EncError)
  do vec_clear[U8](out)

  let need = base64_encoded_len(in.len, padding)
  let ok: Bool
  let err: EncError
  (ok, err) = vec_u8_reserve(out, need)
  if !ok
    ret (false, err)
  .end

  let ip = (Ptr[U8])in.data
  let i: USize
  set i = 0

  while i + 3 <= in.len
    let b0 = *(ip + i)
    let b1 = *(ip + i + 1)
    let b2 = *(ip + i + 2)

    let x0 = (b0 >> 2) & 0x3f
    let x1 = ((b0 & 0x03) << 4) | ((b1 >> 4) & 0x0f)
    let x2 = ((b1 & 0x0f) << 2) | ((b2 >> 6) & 0x03)
    let x3 = b2 & 0x3f

    (ok, err) = vec_u8_push(out, b64_table(variant, x0))
    if !ok
      ret (false, err)
    .end
    (ok, err) = vec_u8_push(out, b64_table(variant, x1))
    if !ok
      ret (false, err)
    .end
    (ok, err) = vec_u8_push(out, b64_table(variant, x2))
    if !ok
      ret (false, err)
    .end
    (ok, err) = vec_u8_push(out, b64_table(variant, x3))
    if !ok
      ret (false, err)
    .end

    set i = i + 3
  .end

  let rem = in.len - i
  if rem == 1
    let b0 = *(ip + i)
    let x0 = (b0 >> 2) & 0x3f
    let x1 = (b0 & 0x03) << 4

    (ok, err) = vec_u8_push(out, b64_table(variant, x0))
    if !ok
      ret (false, err)
    .end
    (ok, err) = vec_u8_push(out, b64_table(variant, x1))
    if !ok
      ret (false, err)
    .end

    if padding
      (ok, err) = vec_u8_push(out, (U8)'=')
      if !ok
        ret (false, err)
      .end
      (ok, err) = vec_u8_push(out, (U8)'=')
      if !ok
        ret (false, err)
      .end
    .end
  .end

  if rem == 2
    let b0 = *(ip + i)
    let b1 = *(ip + i + 1)

    let x0 = (b0 >> 2) & 0x3f
    let x1 = ((b0 & 0x03) << 4) | ((b1 >> 4) & 0x0f)
    let x2 = (b1 & 0x0f) << 2

    (ok, err) = vec_u8_push(out, b64_table(variant, x0))
    if !ok
      ret (false, err)
    .end
    (ok, err) = vec_u8_push(out, b64_table(variant, x1))
    if !ok
      ret (false, err)
    .end
    (ok, err) = vec_u8_push(out, b64_table(variant, x2))
    if !ok
      ret (false, err)
    .end

    if padding
      (ok, err) = vec_u8_push(out, (U8)'=')
      if !ok
        ret (false, err)
      .end
    .end
  .end

  ret (true, EncError::Ok)
.end

fn base64_decode(in: &Vec[U8], out: &Vec[U8], variant: Base64Variant, padding: Bool) -> (Bool, EncError)
  do vec_clear[U8](out)

  # We accept whitespace-free strict input.
  # If padding=false, accept non-multiple-of-4 lengths and infer.

  if in.len == 0
    ret (true, EncError::Ok)
  .end

  if padding
    if (in.len % 4) != 0
      ret (false, EncError::Invalid)
    .end
  .end

  # conservative reserve
  let est = (in.len / 4) * 3 + 3
  let ok: Bool
  let err: EncError
  (ok, err) = vec_u8_reserve(out, est)
  if !ok
    ret (false, err)
  .end

  let ip = (Ptr[U8])in.data
  let i: USize
  set i = 0

  loop
    if i >= in.len
      break
    .end

    let c0: U8
    let c1: U8
    let c2: U8
    let c3: U8

    set c0 = *(ip + i)
    set c1 = 0
    set c2 = 0
    set c3 = 0

    if i + 1 < in.len
      set c1 = *(ip + i + 1)
    else
      ret (false, EncError::Truncated)
    .end

    if i + 2 < in.len
      set c2 = *(ip + i + 2)
    else
      set c2 = (U8)'='
    .end

    if i + 3 < in.len
      set c3 = *(ip + i + 3)
    else
      set c3 = (U8)'='
    .end

    let p2: Bool
    let p3: Bool
    set p2 = (c2 == (U8)'=')
    set p3 = (c3 == (U8)'=')

    if padding
      # in padding mode, '=' only allowed in last block and implies full 4 chars
      if i + 3 >= in.len
        # ok
      .end
    .end

    let ok0: Bool
    let ok1: Bool
    let ok2: Bool
    let ok3: Bool

    let v0: U8
    let v1: U8
    let v2: U8
    let v3: U8

    (ok0, v0) = b64_rev(variant, c0)
    (ok1, v1) = b64_rev(variant, c1)
    if !ok0 || !ok1
      ret (false, EncError::Invalid)
    .end

    if p2
      set v2 = 0
      set ok2 = true
    else
      (ok2, v2) = b64_rev(variant, c2)
    .end

    if p3
      set v3 = 0
      set ok3 = true
    else
      (ok3, v3) = b64_rev(variant, c3)
    .end

    if !ok2 || !ok3
      ret (false, EncError::Invalid)
    .end

    let b0 = (v0 << 2) | (v1 >> 4)
    let b1 = ((v1 & 0x0f) << 4) | (v2 >> 2)
    let b2 = ((v2 & 0x03) << 6) | v3

    (ok, err) = vec_u8_push(out, b0)
    if !ok
      ret (false, err)
    .end

    if !p2
      (ok, err) = vec_u8_push(out, b1)
      if !ok
        ret (false, err)
      .end
    .end

    if !p3
      (ok, err) = vec_u8_push(out, b2)
      if !ok
        ret (false, err)
      .end
    .end

    # if padding and we saw '=', we must be at end
    if padding && (p2 || p3)
      if i + 4 != in.len
        ret (false, EncError::Invalid)
      .end
      break
    .end

    set i = i + 4

    # if padding disabled, allow trailing partial blocks; we still consume 4
    if !padding
      # if we were at end with inferred '=' we can break
      if i >= in.len
        break
      .end
    .end
  .end

  ret (true, EncError::Ok)
.end

# -----------------------------------------------------------------------------
# UTF-8
# -----------------------------------------------------------------------------

type Utf8Error enum
  Ok
  Invalid
  Truncated
  Overlong
  Surrogate
  OutOfRange
.end

fn utf8_decode_one(p: Ptr[U8], n: USize) -> (Bool, Utf8Error, U32, USize)
  # returns: (ok, err, codepoint, consumed)
  if n == 0
    ret (false, Utf8Error::Truncated, 0, 0)
  .end

  let b0 = *(p + 0)
  if b0 < 0x80
    ret (true, Utf8Error::Ok, (U32)b0, 1)
  .end

  # 2-byte
  if (b0 & 0xe0) == 0xc0
    if n < 2
      ret (false, Utf8Error::Truncated, 0, 0)
    .end
    let b1 = *(p + 1)
    if (b1 & 0xc0) != 0x80
      ret (false, Utf8Error::Invalid, 0, 0)
    .end
    let cp = ((U32)(b0 & 0x1f) << 6) | (U32)(b1 & 0x3f)
    if cp < 0x80
      ret (false, Utf8Error::Overlong, 0, 0)
    .end
    ret (true, Utf8Error::Ok, cp, 2)
  .end

  # 3-byte
  if (b0 & 0xf0) == 0xe0
    if n < 3
      ret (false, Utf8Error::Truncated, 0, 0)
    .end
    let b1 = *(p + 1)
    let b2 = *(p + 2)
    if (b1 & 0xc0) != 0x80 || (b2 & 0xc0) != 0x80
      ret (false, Utf8Error::Invalid, 0, 0)
    .end
    let cp = ((U32)(b0 & 0x0f) << 12) | ((U32)(b1 & 0x3f) << 6) | (U32)(b2 & 0x3f)
    if cp < 0x800
      ret (false, Utf8Error::Overlong, 0, 0)
    .end
    if cp >= 0xd800 && cp <= 0xdfff
      ret (false, Utf8Error::Surrogate, 0, 0)
    .end
    ret (true, Utf8Error::Ok, cp, 3)
  .end

  # 4-byte
  if (b0 & 0xf8) == 0xf0
    if n < 4
      ret (false, Utf8Error::Truncated, 0, 0)
    .end
    let b1 = *(p + 1)
    let b2 = *(p + 2)
    let b3 = *(p + 3)
    if (b1 & 0xc0) != 0x80 || (b2 & 0xc0) != 0x80 || (b3 & 0xc0) != 0x80
      ret (false, Utf8Error::Invalid, 0, 0)
    .end
    let cp = ((U32)(b0 & 0x07) << 18) | ((U32)(b1 & 0x3f) << 12) | ((U32)(b2 & 0x3f) << 6) | (U32)(b3 & 0x3f)
    if cp < 0x10000
      ret (false, Utf8Error::Overlong, 0, 0)
    .end
    if cp > 0x10ffff
      ret (false, Utf8Error::OutOfRange, 0, 0)
    .end
    ret (true, Utf8Error::Ok, cp, 4)
  .end

  ret (false, Utf8Error::Invalid, 0, 0)
.end

fn utf8_is_valid(bytes: &Vec[U8]) -> Bool
  let p = (Ptr[U8])bytes.data
  let i: USize
  set i = 0
  loop
    if i >= bytes.len
      break
    .end
    let ok: Bool
    let err: Utf8Error
    let cp: U32
    let used: USize
    (ok, err, cp, used) = utf8_decode_one(p + i, bytes.len - i)
    if !ok
      ret false
    .end
    set i = i + used
  .end
  ret true
.end

fn utf8_encode_one(cp: U32, out: &Vec[U8]) -> (Bool, Utf8Error)
  let ok: Bool
  let err: EncError

  if cp <= 0x7f
    (ok, err) = vec_u8_push(out, (U8)cp)
    if !ok
      ret (false, Utf8Error::Invalid)
    .end
    ret (true, Utf8Error::Ok)
  .end

  if cp <= 0x7ff
    (ok, err) = vec_u8_push(out, (U8)(0xc0 | ((cp >> 6) & 0x1f)))
    if !ok
      ret (false, Utf8Error::Invalid)
    .end
    (ok, err) = vec_u8_push(out, (U8)(0x80 | (cp & 0x3f)))
    if !ok
      ret (false, Utf8Error::Invalid)
    .end
    ret (true, Utf8Error::Ok)
  .end

  if cp <= 0xffff
    if cp >= 0xd800 && cp <= 0xdfff
      ret (false, Utf8Error::Surrogate)
    .end
    (ok, err) = vec_u8_push(out, (U8)(0xe0 | ((cp >> 12) & 0x0f)))
    if !ok
      ret (false, Utf8Error::Invalid)
    .end
    (ok, err) = vec_u8_push(out, (U8)(0x80 | ((cp >> 6) & 0x3f)))
    if !ok
      ret (false, Utf8Error::Invalid)
    .end
    (ok, err) = vec_u8_push(out, (U8)(0x80 | (cp & 0x3f)))
    if !ok
      ret (false, Utf8Error::Invalid)
    .end
    ret (true, Utf8Error::Ok)
  .end

  if cp <= 0x10ffff
    (ok, err) = vec_u8_push(out, (U8)(0xf0 | ((cp >> 18) & 0x07)))
    if !ok
      ret (false, Utf8Error::Invalid)
    .end
    (ok, err) = vec_u8_push(out, (U8)(0x80 | ((cp >> 12) & 0x3f)))
    if !ok
      ret (false, Utf8Error::Invalid)
    .end
    (ok, err) = vec_u8_push(out, (U8)(0x80 | ((cp >> 6) & 0x3f)))
    if !ok
      ret (false, Utf8Error::Invalid)
    .end
    (ok, err) = vec_u8_push(out, (U8)(0x80 | (cp & 0x3f)))
    if !ok
      ret (false, Utf8Error::Invalid)
    .end
    ret (true, Utf8Error::Ok)
  .end

  ret (false, Utf8Error::OutOfRange)
.end

fn utf8_decode_all(bytes: &Vec[U8], cps: &Vec[U32]) -> (Bool, Utf8Error)
  do vec_clear[U32](cps)

  # reserve worst-case: 1 codepoint per byte
  let ok: Bool
  let err: EncError
  (ok, err) = vec_reserve_bytes[U32](cps, 4, bytes.len)
  if !ok
    ret (false, Utf8Error::Invalid)
  .end

  let p = (Ptr[U8])bytes.data
  let i: USize
  set i = 0
  loop
    if i >= bytes.len
      break
    .end

    let ok2: Bool
    let e2: Utf8Error
    let cp: U32
    let used: USize
    (ok2, e2, cp, used) = utf8_decode_one(p + i, bytes.len - i)
    if !ok2
      ret (false, e2)
    .end

    let ok3: Bool
    let e3: EncError
    (ok3, e3) = vec_push[U32](cps, 4, cp)
    if !ok3
      ret (false, Utf8Error::Invalid)
    .end

    set i = i + used
  .end

  ret (true, Utf8Error::Ok)
.end

# -----------------------------------------------------------------------------
# Tests (scenarios)
# -----------------------------------------------------------------------------

fn assert_eq_u8_vec(a: &Vec[U8], b: &Vec[U8])
  do assert(a.len == b.len, "vec len mismatch")
  let i: USize
  set i = 0
  let ap = (Ptr[U8])a.data
  let bp = (Ptr[U8])b.data
  loop
    if i >= a.len
      break
    .end
    do assert(*(ap + i) == *(bp + i), "vec byte mismatch")
    set i = i + 1
  .end
.end

scn test_hex_roundtrip
  let x = vec_new[U8]()
  let ok: Bool
  let e: EncError

  (ok, e) = vec_u8_push(&x, 0x00)
  (ok, e) = vec_u8_push(&x, 0x12)
  (ok, e) = vec_u8_push(&x, 0xab)
  (ok, e) = vec_u8_push(&x, 0xff)

  let enc = vec_new[U8]()
  (ok, e) = hex_encode(&x, &enc, false)
  do assert(ok, "hex_encode")

  let dec = vec_new[U8]()
  (ok, e) = hex_decode(&enc, &dec)
  do assert(ok, "hex_decode")

  do assert_eq_u8_vec(&x, &dec)

  do vec_drop[U8](&x, 1)
  do vec_drop[U8](&enc, 1)
  do vec_drop[U8](&dec, 1)
.end

scn test_base64_roundtrip
  let x = vec_new[U8]()
  let ok: Bool
  let e: EncError

  (ok, e) = vec_u8_push(&x, (U8)'M')
  (ok, e) = vec_u8_push(&x, (U8)'a')
  (ok, e) = vec_u8_push(&x, (U8)'n')

  let enc = vec_new[U8]()
  (ok, e) = base64_encode(&x, &enc, Base64Variant::Standard, true)
  do assert(ok, "b64 enc")

  let dec = vec_new[U8]()
  (ok, e) = base64_decode(&enc, &dec, Base64Variant::Standard, true)
  do assert(ok, "b64 dec")

  do assert_eq_u8_vec(&x, &dec)

  do vec_drop[U8](&x, 1)
  do vec_drop[U8](&enc, 1)
  do vec_drop[U8](&dec, 1)
.end

scn test_utf8_validation
  let x = vec_new[U8]()
  let ok: Bool
  let e: EncError

  # "h√©" in UTF-8: 68 c3 a9
  (ok, e) = vec_u8_push(&x, (U8)'h')
  (ok, e) = vec_u8_push(&x, 0xc3)
  (ok, e) = vec_u8_push(&x, 0xa9)

  do assert(utf8_is_valid(&x), "utf8 valid")

  let cps = vec_new[U32]()
  let ok2: Bool
  let e2: Utf8Error
  (ok2, e2) = utf8_decode_all(&x, &cps)
  do assert(ok2, "utf8 decode")
  do assert(cps.len == 2, "cp len")

  do vec_drop[U8](&x, 1)
  do vec_drop[U32](&cps, 4)
.end

# End of std.encoding
