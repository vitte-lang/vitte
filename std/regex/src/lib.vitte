

# -----------------------------------------------------------------------------
# std/regex
# -----------------------------------------------------------------------------
# Regular expression utilities.
#
# Design goals:
# - bootstrap-friendly: no direct syscalls, runtime hooks optional
# - deterministic API surface across platforms
# - graceful fallback when runtime regex engine is unavailable
#
# Backends:
# - Runtime backend: delegates to rt_regex_* hooks
# - Literal backend: if runtime is unsupported, accepts ONLY literal patterns
#   (no metacharacters) and performs substring search.
#
# Notes:
# - Strings are treated as raw bytes (Vec[U8]). UTF-8 is not validated.
# - Blocks use `.end` only.
# -----------------------------------------------------------------------------

module std.regex

use std.collections

# -----------------------------------------------------------------------------
# Local prelude
# -----------------------------------------------------------------------------

type Bool  = bool

type U8    = u8
type U16   = u16
type U32   = u32
type U64   = u64

type I32   = i32
type I64   = i64

type USize = usize

type Ptr[T] = ptr[T]

type Str = str

# -----------------------------------------------------------------------------
# Panic / assert stubs (bootstrapped by runtime if desired)
# -----------------------------------------------------------------------------

fn panic(msg: Str)
  ret
.end

fn assert(cond: Bool, msg: Str)
  if !cond
    do panic(msg)
  .end
.end

# -----------------------------------------------------------------------------
# Errors / flags
# -----------------------------------------------------------------------------

type RegexError enum
  Ok
  Invalid
  OutOfMemory
  Unsupported
  CompileFail
  RuntimeFail
.end

# Flags: interpreted by runtime backend; literal backend ignores.
const REGEX_F_NONE:            U32 = 0
const REGEX_F_CASE_INSENSITIVE: U32 = 1
const REGEX_F_MULTILINE:        U32 = 2
const REGEX_F_DOTALL:           U32 = 4
const REGEX_F_UNICODE:          U32 = 8

# -----------------------------------------------------------------------------
# Match
# -----------------------------------------------------------------------------

type Match struct
  start: USize
  end: USize
.end

fn match_len(m: Match) -> USize
  if m.end < m.start
    ret 0
  .end
  ret m.end - m.start
.end

# -----------------------------------------------------------------------------
# Backends / Regex
# -----------------------------------------------------------------------------

type RegexBackend enum
  Runtime
  Literal
.end

type Regex struct
  backend: RegexBackend
  handle: I32
  flags: U32
  pat: Vec[U8]       # stored for Literal backend (and optionally for debug)
.end

fn regex_invalid() -> Regex
  let r: Regex
  set r.backend = RegexBackend::Runtime
  set r.handle = -1
  set r.flags = REGEX_F_NONE
  set r.pat = vec_new[U8]()
  ret r
.end

fn regex_is_valid(r: &Regex) -> Bool
  if r.backend == RegexBackend::Runtime
    ret r.handle >= 0
  .end
  # literal backend: valid if pattern exists (can be empty, but we treat empty as valid)
  ret true
.end

fn regex_drop(r: &Regex)
  if r.backend == RegexBackend::Runtime
    if r.handle >= 0
      do rt_regex_free(r.handle)
      set r.handle = -1
    .end
  .end
  do vec_drop[U8](&r.pat, 1)
.end

# -----------------------------------------------------------------------------
# Runtime syscall surface
# -----------------------------------------------------------------------------
# Conventions (recommended):
# - rc == 0: success
# - rc < 0: -N is an abstract error code mapped by map_rt_rc
# - for boolean operations: returns 1=true, 0=false, <0 error
# -----------------------------------------------------------------------------

fn rt_regex_compile(pat: Ptr[U8], pat_len: USize, flags: U32, out_handle: &I32) -> I32
  ret -9
.end

fn rt_regex_free(handle: I32) -> I32
  ret -9
.end

fn rt_regex_is_match(handle: I32, text: Ptr[U8], text_len: USize) -> I32
  ret -9
.end

# Finds first match at/after `from`.
# On success with match: returns 1 and sets out_start/out_end.
# If no match: returns 0.
# On error: returns <0.
fn rt_regex_find_from(handle: I32, text: Ptr[U8], text_len: USize, from: USize, out_start: &USize, out_end: &USize) -> I32
  ret -9
.end

# -----------------------------------------------------------------------------
# Error mapping
# -----------------------------------------------------------------------------

fn map_rt_rc(rc: I32) -> RegexError
  if rc == 0
    ret RegexError::Ok
  .end

  # -9 is used as Unsupported (consistent with other std modules in this repo)
  if rc == -9
    ret RegexError::Unsupported
  .end
  if rc == -12
    ret RegexError::OutOfMemory
  .end

  ret RegexError::RuntimeFail
.end

# -----------------------------------------------------------------------------
# Small Vec helpers (byte-level)
# -----------------------------------------------------------------------------

fn vec_push_byte(dst: &Vec[U8], b: U8) -> Bool
  let ok: Bool
  let e: ColError
  (ok, e) = vec_push[U8](dst, 1, b)
  ret ok
.end

fn vec_push_bytes(dst: &Vec[U8], p: Ptr[U8], n: USize) -> Bool
  let ok: Bool
  let e: ColError
  let i: USize
  set i = 0
  while i < n
    (ok, e) = vec_push[U8](dst, 1, *(p + i))
    if !ok
      ret false
    .end
    set i = i + 1
  .end
  ret true
.end

fn vec_assign_u8(dst: &Vec[U8], src: &Vec[U8]) -> Bool
  do vec_clear[U8](dst)
  let ok: Bool
  let e: ColError
  let i: USize
  set i = 0
  let p = (Ptr[U8])src.data
  while i < src.len
    (ok, e) = vec_push[U8](dst, 1, *(p + i))
    if !ok
      ret false
    .end
    set i = i + 1
  .end
  ret true
.end

fn vec_clone_u8(src: &Vec[U8]) -> (Bool, Vec[U8])
  let v = vec_new[U8]()
  if !vec_assign_u8(&v, src)
    do vec_drop[U8](&v, 1)
    ret (false, vec_new[U8]())
  .end
  ret (true, v)
.end

fn vec_eq_u8(a: &Vec[U8], b: &Vec[U8]) -> Bool
  if a.len != b.len
    ret false
  .end
  let ap = (Ptr[U8])a.data
  let bp = (Ptr[U8])b.data
  let i: USize
  set i = 0
  while i < a.len
    if *(ap + i) != *(bp + i)
      ret false
    .end
    set i = i + 1
  .end
  ret true
.end

fn vec_from_cstr(s: Str) -> Vec[U8]
  let v = vec_new[U8]()
  let p = (Ptr[U8])s
  let i: USize
  set i = 0
  loop
    let b = *(p + i)
    if b == 0
      break
    .end
    if !vec_push_byte(&v, b)
      do vec_drop[U8](&v, 1)
      ret vec_new[U8]()
    .end
    set i = i + 1
  .end
  ret v
.end

# -----------------------------------------------------------------------------
# Literal backend utilities
# -----------------------------------------------------------------------------

fn is_regex_meta(b: U8) -> Bool
  # metacharacters: . ^ $ * + ? ( ) [ ] { } | \
  if b == (U8)'.'  || b == (U8)'^' || b == (U8)'$'
    ret true
  .end
  if b == (U8)'*'  || b == (U8)'+' || b == (U8)'?'
    ret true
  .end
  if b == (U8)'('  || b == (U8)')' || b == (U8)'[' || b == (U8)']'
    ret true
  .end
  if b == (U8)'{'  || b == (U8)'}' || b == (U8)'|' || b == (U8)'\\'
    ret true
  .end
  ret false
.end

fn literal_is_supported(pat: &Vec[U8]) -> Bool
  let p = (Ptr[U8])pat.data
  let i: USize
  set i = 0
  while i < pat.len
    if is_regex_meta(*(p + i))
      ret false
    .end
    set i = i + 1
  .end
  ret true
.end

# Naive substring search.
# Returns (found, start, end). If pat is empty: found=true at from.
fn literal_find_from(pat: &Vec[U8], text: &Vec[U8], from: USize) -> (Bool, USize, USize)
  if from > text.len
    ret (false, 0, 0)
  .end

  if pat.len == 0
    ret (true, from, from)
  .end

  if pat.len > text.len
    ret (false, 0, 0)
  .end

  let tp = (Ptr[U8])text.data
  let pp = (Ptr[U8])pat.data

  let i: USize
  set i = from

  while i + pat.len <= text.len
    let j: USize
    set j = 0
    let ok: Bool
    set ok = true

    while j < pat.len
      if *(tp + i + j) != *(pp + j)
        set ok = false
        break
      .end
      set j = j + 1
    .end

    if ok
      ret (true, i, i + pat.len)
    .end

    set i = i + 1
  .end

  ret (false, 0, 0)
.end

# -----------------------------------------------------------------------------
# Compile
# -----------------------------------------------------------------------------

fn regex_new(pattern: &Vec[U8], flags: U32) -> (Bool, RegexError, Regex)
  let r = regex_invalid()
  set r.flags = flags

  # Keep a copy of pattern
  let ok: Bool
  let cp: Vec[U8]
  (ok, cp) = vec_clone_u8(pattern)
  if !ok
    ret (false, RegexError::OutOfMemory, r)
  .end
  do vec_drop[U8](&r.pat, 1)
  set r.pat = cp

  # Try runtime compile
  let h: I32
  set h = -1
  let rc = rt_regex_compile((Ptr[U8])pattern.data, pattern.len, flags, &h)
  let e = map_rt_rc(rc)

  if e == RegexError::Ok
    set r.backend = RegexBackend::Runtime
    set r.handle = h
    ret (true, RegexError::Ok, r)
  .end

  if e != RegexError::Unsupported
    # runtime present but compile failed
    ret (false, RegexError::CompileFail, r)
  .end

  # Fallback: literal-only patterns
  if !literal_is_supported(&r.pat)
    ret (false, RegexError::Unsupported, r)
  .end

  set r.backend = RegexBackend::Literal
  set r.handle = -1
  ret (true, RegexError::Ok, r)
.end

fn regex_new_cstr(pattern: Str, flags: U32) -> (Bool, RegexError, Regex)
  let v = vec_from_cstr(pattern)
  let ok: Bool
  let e: RegexError
  let r: Regex
  (ok, e, r) = regex_new(&v, flags)
  do vec_drop[U8](&v, 1)
  ret (ok, e, r)
.end

# -----------------------------------------------------------------------------
# Match operations
# -----------------------------------------------------------------------------

fn regex_is_match(r: &Regex, text: &Vec[U8]) -> (Bool, RegexError, Bool)
  if r.backend == RegexBackend::Runtime
    if r.handle < 0
      ret (false, RegexError::Invalid, false)
    .end
    let v = rt_regex_is_match(r.handle, (Ptr[U8])text.data, text.len)
    if v < 0
      ret (false, map_rt_rc((I32)v), false)
    .end
    ret (true, RegexError::Ok, v != 0)
  .end

  # literal backend
  let found: Bool
  let s: USize
  let e: USize
  (found, s, e) = literal_find_from(&r.pat, text, 0)
  ret (true, RegexError::Ok, found)
.end

fn regex_find_from(r: &Regex, text: &Vec[U8], from: USize) -> (Bool, RegexError, Bool, Match)
  let m: Match
  set m.start = 0
  set m.end = 0

  if from > text.len
    ret (true, RegexError::Ok, false, m)
  .end

  if r.backend == RegexBackend::Runtime
    if r.handle < 0
      ret (false, RegexError::Invalid, false, m)
    .end

    let s: USize
    let e2: USize
    let rc = rt_regex_find_from(r.handle, (Ptr[U8])text.data, text.len, from, &s, &e2)

    if rc < 0
      ret (false, map_rt_rc(rc), false, m)
    .end

    if rc == 0
      ret (true, RegexError::Ok, false, m)
    .end

    set m.start = s
    set m.end = e2
    ret (true, RegexError::Ok, true, m)
  .end

  # literal backend
  let found: Bool
  let s2: USize
  let e3: USize
  (found, s2, e3) = literal_find_from(&r.pat, text, from)
  if !found
    ret (true, RegexError::Ok, false, m)
  .end
  set m.start = s2
  set m.end = e3
  ret (true, RegexError::Ok, true, m)
.end

fn regex_find(r: &Regex, text: &Vec[U8]) -> (Bool, RegexError, Bool, Match)
  ret regex_find_from(r, text, 0)
.end

# Collect all matches up to `limit` (0 = no limit).
fn regex_find_all(r: &Regex, text: &Vec[U8], out: &Vec[Match], limit: USize) -> (Bool, RegexError)
  do vec_clear[Match](out)

  let from: USize
  set from = 0

  let count: USize
  set count = 0

  loop
    if limit != 0 && count >= limit
      break
    .end

    let ok: Bool
    let e: RegexError
    let has: Bool
    let m: Match
    (ok, e, has, m) = regex_find_from(r, text, from)
    if !ok
      ret (false, e)
    .end
    if !has
      break
    .end

    let ok2: Bool
    let ce: ColError
    (ok2, ce) = vec_push[Match](out, 0, m)
    if !ok2
      ret (false, RegexError::OutOfMemory)
    .end

    set count = count + 1

    # avoid infinite loop on empty matches
    if m.end == m.start
      set from = m.end + 1
    else
      set from = m.end
    .end

    if from > text.len
      break
    .end
  .end

  ret (true, RegexError::Ok)
.end

# -----------------------------------------------------------------------------
# Replace
# -----------------------------------------------------------------------------

# Replace all matches with replacement bytes.
# - For runtime backend: replacement is treated as literal replacement.
# - For literal backend: straightforward.
fn regex_replace_all(r: &Regex, text: &Vec[U8], repl: &Vec[U8], out: &Vec[U8]) -> (Bool, RegexError)
  do vec_clear[U8](out)

  let matches = vec_new[Match]()
  let ok: Bool
  let e: RegexError
  (ok, e) = regex_find_all(r, text, &matches, 0)
  if !ok
    do vec_drop[Match](&matches, 0)
    ret (false, e)
  .end

  let tp = (Ptr[U8])text.data
  let rp = (Ptr[U8])repl.data

  let cursor: USize
  set cursor = 0

  let i: USize
  set i = 0
  while i < matches.len
    let m = *((Ptr[Match])matches.data + i)

    if m.start > text.len || m.end > text.len || m.start < cursor || m.end < m.start
      do vec_drop[Match](&matches, 0)
      ret (false, RegexError::Invalid)
    .end

    # copy bytes [cursor, m.start)
    if m.start > cursor
      if !vec_push_bytes(out, tp + cursor, m.start - cursor)
        do vec_drop[Match](&matches, 0)
        ret (false, RegexError::OutOfMemory)
      .end
    .end

    # copy replacement
    if repl.len != 0
      if !vec_push_bytes(out, rp, repl.len)
        do vec_drop[Match](&matches, 0)
        ret (false, RegexError::OutOfMemory)
      .end
    .end

    set cursor = m.end
    set i = i + 1
  .end

  # tail
  if cursor < text.len
    if !vec_push_bytes(out, tp + cursor, text.len - cursor)
      do vec_drop[Match](&matches, 0)
      ret (false, RegexError::OutOfMemory)
    .end
  .end

  do vec_drop[Match](&matches, 0)
  ret (true, RegexError::Ok)
.end

fn regex_replace_all_cstr(r: &Regex, text: &Vec[U8], repl: Str, out: &Vec[U8]) -> (Bool, RegexError)
  let v = vec_from_cstr(repl)
  let ok: Bool
  let e: RegexError
  (ok, e) = regex_replace_all(r, text, &v, out)
  do vec_drop[U8](&v, 1)
  ret (ok, e)
.end

# -----------------------------------------------------------------------------
# Split
# -----------------------------------------------------------------------------

# Split text by pattern matches. Empty pattern is invalid.
fn regex_split(r: &Regex, text: &Vec[U8], out: &Vec[Vec[U8]], limit: USize) -> (Bool, RegexError)
  do vec_clear[Vec[U8]](out)

  if r.backend == RegexBackend::Literal && r.pat.len == 0
    ret (false, RegexError::Invalid)
  .end

  # Find matches
  let ms = vec_new[Match]()
  let ok: Bool
  let e: RegexError
  (ok, e) = regex_find_all(r, text, &ms, 0)
  if !ok
    do vec_drop[Match](&ms, 0)
    ret (false, e)
  .end

  let tp = (Ptr[U8])text.data
  let cursor: USize
  set cursor = 0

  let parts: USize
  set parts = 0

  let i: USize
  set i = 0
  while i < ms.len
    if limit != 0 && parts + 1 >= limit
      break
    .end

    let m = *((Ptr[Match])ms.data + i)

    # slice [cursor, m.start)
    let seg = vec_new[U8]()
    if m.start > cursor
      if !vec_push_bytes(&seg, tp + cursor, m.start - cursor)
        do vec_drop[U8](&seg, 1)
        do vec_drop[Match](&ms, 0)
        ret (false, RegexError::OutOfMemory)
      .end
    .end

    let ok2: Bool
    let ce: ColError
    (ok2, ce) = vec_push[Vec[U8]](out, 0, seg)
    if !ok2
      do vec_drop[U8](&seg, 1)
      do vec_drop[Match](&ms, 0)
      ret (false, RegexError::OutOfMemory)
    .end

    set parts = parts + 1
    set cursor = m.end
    set i = i + 1
  .end

  # tail
  let tail = vec_new[U8]()
  if cursor < text.len
    if !vec_push_bytes(&tail, tp + cursor, text.len - cursor)
      do vec_drop[U8](&tail, 1)
      do vec_drop[Match](&ms, 0)
      ret (false, RegexError::OutOfMemory)
    .end
  .end

  let ok3: Bool
  let ce3: ColError
  (ok3, ce3) = vec_push[Vec[U8]](out, 0, tail)
  if !ok3
    do vec_drop[U8](&tail, 1)
    do vec_drop[Match](&ms, 0)
    ret (false, RegexError::OutOfMemory)
  .end

  do vec_drop[Match](&ms, 0)
  ret (true, RegexError::Ok)
.end

# -----------------------------------------------------------------------------
# Tests (scenarios) - backend-independent via literal fallback
# -----------------------------------------------------------------------------

fn expect_eq_u8(a: &Vec[U8], b: &Vec[U8], msg: Str)
  do assert(vec_eq_u8(a, b), msg)
.end

scn test_literal_match_find_replace
  let pat = vec_from_cstr("abc")
  let ok: Bool
  let e: RegexError
  let r: Regex
  (ok, e, r) = regex_new(&pat, REGEX_F_NONE)
  do assert(ok, "compile")

  let text = vec_from_cstr("xxabcYYabczz")

  let isok: Bool
  let em: RegexError
  let yes: Bool
  (isok, em, yes) = regex_is_match(&r, &text)
  do assert(isok && yes, "is_match")

  let has: Bool
  let m: Match
  (isok, em, has, m) = regex_find(&r, &text)
  do assert(isok && has, "find")
  do assert(m.start == 2 && m.end == 5, "match range")

  let repl = vec_from_cstr("-")
  let out = vec_new[U8]()
  (isok, em) = regex_replace_all(&r, &text, &repl, &out)
  do assert(isok, "replace")

  let exp = vec_from_cstr("xx-YY-zz")
  do expect_eq_u8(&out, &exp, "replace eq")

  do vec_drop[U8](&pat, 1)
  do vec_drop[U8](&text, 1)
  do vec_drop[U8](&repl, 1)
  do vec_drop[U8](&out, 1)
  do vec_drop[U8](&exp, 1)
  do regex_drop(&r)
.end

scn test_split
  let ok: Bool
  let e: RegexError
  let r: Regex
  (ok, e, r) = regex_new_cstr(",", REGEX_F_NONE)
  do assert(ok, "compile split")

  let text = vec_from_cstr("a,b,c")
  let parts = vec_new[Vec[U8]]()

  let ok2: Bool
  let e2: RegexError
  (ok2, e2) = regex_split(&r, &text, &parts, 0)
  do assert(ok2, "split")
  do assert(parts.len == 3, "parts len")

  let p0 = *((Ptr[Vec[U8]])parts.data + 0)
  let p1 = *((Ptr[Vec[U8]])parts.data + 1)
  let p2 = *((Ptr[Vec[U8]])parts.data + 2)

  let a = vec_from_cstr("a")
  let b = vec_from_cstr("b")
  let c = vec_from_cstr("c")

  do expect_eq_u8(&p0, &a, "p0")
  do expect_eq_u8(&p1, &b, "p1")
  do expect_eq_u8(&p2, &c, "p2")

  # cleanup nested vecs
  let i: USize
  set i = 0
  while i < parts.len
    let v = *((Ptr[Vec[U8]])parts.data + i)
    do vec_drop[U8](&v, 1)
    set i = i + 1
  .end
  do vec_drop[Vec[U8]](&parts, 0)

  do vec_drop[U8](&text, 1)
  do vec_drop[U8](&a, 1)
  do vec_drop[U8](&b, 1)
  do vec_drop[U8](&c, 1)
  do regex_drop(&r)
.end

# End of std.regex