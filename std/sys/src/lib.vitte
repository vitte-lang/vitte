# -----------------------------------------------------------------------------
# std/sys
# -----------------------------------------------------------------------------
# System / process / environment utilities.
#
# This module provides a stable, bootstrap-friendly API surface for:
# - process arguments
# - environment variables
# - time / sleep
# - best-effort system metadata
# - path (byte-oriented) utilities
# - process control stubs (future runtime hooks)
#
# Notes:
# - Many functions are thin wrappers over `std.runtime` low-level hooks (rt_*).
# - Where a runtime hook is not available yet, functions return Unsupported.
# - This module is byte-oriented (Vec[U8]) to avoid UTF-8 policy decisions.
# - All blocks use `.end` only.
# -----------------------------------------------------------------------------

module std.sys

use std.collections
use std.runtime

# -----------------------------------------------------------------------------
# Types / errors
# -----------------------------------------------------------------------------

type Bool = bool

type U8    = u8
type U16   = u16
type U32   = u32
type U64   = u64

type I32   = i32
type I64   = i64

type USize = usize

type Ptr[T] = ptr[T]

type Str = str

# Common system error set.

type SysError enum
  Ok
  Invalid
  OutOfMemory
  Unsupported
  Io
  NotFound
  Busy
  Timeout
  Unexpected
.end

fn sys_error_ok(e: SysError) -> Bool
  ret e == SysError::Ok
.end

# Map std.runtime::RtError (if available) into SysError.
fn sys_error_from_rt(rc: I32) -> SysError
  let e = rt_err(rc)
  if e == RtError::Ok
    ret SysError::Ok
  .end
  if e == RtError::Invalid
    ret SysError::Invalid
  .end
  if e == RtError::OutOfMemory
    ret SysError::OutOfMemory
  .end
  if e == RtError::Io
    ret SysError::Io
  .end
  if e == RtError::Unsupported
    ret SysError::Unsupported
  .end
  ret SysError::Unexpected
.end

# -----------------------------------------------------------------------------
# Byte helpers
# -----------------------------------------------------------------------------

fn _vec_push_u8(v: &Vec[U8], b: U8) -> Bool
  let ok: Bool
  let e: ColError
  (ok, e) = vec_push[U8](v, 1, b)
  ret ok
.end

fn _vec_push_bytes(v: &Vec[U8], p: Ptr[U8], n: USize) -> Bool
  let i: USize
  set i = 0
  while i < n
    if !_vec_push_u8(v, *(p + i))
      ret false
    .end
    set i = i + 1
  .end
  ret true
.end

fn _vec_push_vec_u8(dst: &Vec[U8], src: &Vec[U8]) -> Bool
  ret _vec_push_bytes(dst, (Ptr[U8])src.data, src.len)
.end

fn bytes_from_cstr(s: Str) -> Vec[U8]
  let v = vec_new[U8]()
  let p = (Ptr[U8])s
  let i: USize
  set i = 0
  loop
    let b = *(p + i)
    if b == 0
      break
    .end
    if !_vec_push_u8(&v, b)
      do vec_drop[U8](&v, 1)
      ret vec_new[U8]()
    .end
    set i = i + 1
  .end
  ret v
.end

# Allocate a NUL-terminated byte buffer (Vec[U8]) from bytes.
fn bytes_to_cbytes(bytes: &Vec[U8]) -> (Bool, SysError, Vec[U8])
  let out = vec_new[U8]()
  if !_vec_push_vec_u8(&out, bytes)
    do vec_drop[U8](&out, 1)
    ret (false, SysError::OutOfMemory, vec_new[U8]())
  .end
  if !_vec_push_u8(&out, 0)
    do vec_drop[U8](&out, 1)
    ret (false, SysError::OutOfMemory, vec_new[U8]())
  .end
  ret (true, SysError::Ok, out)
.end

fn bytes_eq(a: &Vec[U8], b: &Vec[U8]) -> Bool
  if a.len != b.len
    ret false
  .end
  let ap = (Ptr[U8])a.data
  let bp = (Ptr[U8])b.data
  let i: USize
  set i = 0
  while i < a.len
    if *(ap + i) != *(bp + i)
      ret false
    .end
    set i = i + 1
  .end
  ret true
.end

fn bytes_starts_with(a: &Vec[U8], prefix: &Vec[U8]) -> Bool
  if prefix.len > a.len
    ret false
  .end
  let ap = (Ptr[U8])a.data
  let pp = (Ptr[U8])prefix.data
  let i: USize
  set i = 0
  while i < prefix.len
    if *(ap + i) != *(pp + i)
      ret false
    .end
    set i = i + 1
  .end
  ret true
.end

fn bytes_ends_with(a: &Vec[U8], suffix: &Vec[U8]) -> Bool
  if suffix.len > a.len
    ret false
  .end
  let off = a.len - suffix.len
  let ap = (Ptr[U8])a.data
  let sp = (Ptr[U8])suffix.data
  let i: USize
  set i = 0
  while i < suffix.len
    if *(ap + off + i) != *(sp + i)
      ret false
    .end
    set i = i + 1
  .end
  ret true
.end

fn bytes_clone(a: &Vec[U8]) -> (Bool, SysError, Vec[U8])
  let out = vec_new[U8]()
  if !_vec_push_bytes(&out, (Ptr[U8])a.data, a.len)
    do vec_drop[U8](&out, 1)
    ret (false, SysError::OutOfMemory, vec_new[U8]())
  .end
  ret (true, SysError::Ok, out)
.end

# -----------------------------------------------------------------------------
# Environment
# -----------------------------------------------------------------------------

# env_get returns:
# (ok, err, found, value_bytes)
# - found=false means the key is not present.
fn env_get(key: Str) -> (Bool, SysError, Bool, Vec[U8])
  let k = bytes_from_cstr(key)
  let out = vec_new[U8]()

  # Runtime contract:
  # - rc == 1 => found and out filled
  # - rc == 0 => not found
  # - rc < 0  => error
  let rc = rt_env_get((Ptr[U8])k.data, k.len, &out)
  do vec_drop[U8](&k, 1)

  if rc == 1
    ret (true, SysError::Ok, true, out)
  .end
  if rc == 0
    do vec_drop[U8](&out, 1)
    ret (true, SysError::Ok, false, vec_new[U8]())
  .end

  do vec_drop[U8](&out, 1)
  ret (false, sys_error_from_rt(rc), false, vec_new[U8]())
.end

fn env_set(key: Str, val: Str) -> (Bool, SysError)
  let k = bytes_from_cstr(key)
  let v = bytes_from_cstr(val)
  let rc = rt_env_set((Ptr[U8])k.data, k.len, (Ptr[U8])v.data, v.len)
  do vec_drop[U8](&k, 1)
  do vec_drop[U8](&v, 1)

  if rc != 0
    ret (false, sys_error_from_rt(rc))
  .end
  ret (true, SysError::Ok)
.end

fn env_unset(key: Str) -> (Bool, SysError)
  # Not all runtimes support unset; try setting empty string as convention.
  ret env_set(key, "")
.end

# -----------------------------------------------------------------------------
# Arguments
# -----------------------------------------------------------------------------

fn args_len() -> (Bool, SysError, USize)
  let n = rt_args_len()
  if n < 0
    ret (false, sys_error_from_rt(n), 0)
  .end
  ret (true, SysError::Ok, (USize)n)
.end

# args_get returns argument bytes (no trailing NUL)
fn args_get(i: USize) -> (Bool, SysError, Vec[U8])
  let out = vec_new[U8]()
  let rc = rt_args_get(i, &out)
  if rc < 0
    do vec_drop[U8](&out, 1)
    ret (false, sys_error_from_rt(rc), vec_new[U8]())
  .end
  ret (true, SysError::Ok, out)
.end

fn args_vec_drop(v: &Vec[Vec[U8]])
  let i: USize
  set i = 0
  while i < v.len
    let it = *((Ptr[Vec[U8]])v.data + i)
    do vec_drop[U8](&it, 1)
    set i = i + 1
  .end
  do vec_drop[Vec[U8]](v, 0)
.end

fn args_collect() -> (Bool, SysError, Vec[Vec[U8]])
  let ok: Bool
  let e: SysError
  let n: USize
  (ok, e, n) = args_len()
  if !ok
    ret (false, e, vec_new[Vec[U8]]())
  .end

  let out = vec_new[Vec[U8]]()
  let i: USize
  set i = 0
  while i < n
    let a: Vec[U8]
    (ok, e, a) = args_get(i)
    if !ok
      do args_vec_drop(&out)
      ret (false, e, vec_new[Vec[U8]]())
    .end

    let okp: Bool
    let ce: ColError
    (okp, ce) = vec_push[Vec[U8]](&out, 0, a)
    if !okp
      do vec_drop[U8](&a, 1)
      do args_vec_drop(&out)
      ret (false, SysError::OutOfMemory, vec_new[Vec[U8]]())
    .end

    set i = i + 1
  .end

  ret (true, SysError::Ok, out)
.end

fn arg0() -> (Bool, SysError, Vec[U8])
  let ok: Bool
  let e: SysError
  let n: USize
  (ok, e, n) = args_len()
  if !ok
    ret (false, e, vec_new[U8]())
  .end
  if n == 0
    ret (false, SysError::NotFound, vec_new[U8]())
  .end
  ret args_get(0)
.end

# -----------------------------------------------------------------------------
# Time / sleep
# -----------------------------------------------------------------------------

fn sleep_ms(ms: U32) -> (Bool, SysError)
  let rc = rt_sleep_ms(ms)
  if rc != 0
    ret (false, sys_error_from_rt(rc))
  .end
  ret (true, SysError::Ok)
.end

fn now_ms() -> (Bool, SysError, I64)
  let t = rt_time_now_ms()
  if t < 0
    ret (false, sys_error_from_rt((I32)t), 0)
  .end
  ret (true, SysError::Ok, t)
.end

# Placeholder for higher-resolution time.
fn now_ns() -> (Bool, SysError, I64)
  ret (false, SysError::Unsupported, 0)
.end

# -----------------------------------------------------------------------------
# Process I/O (best-effort)
# -----------------------------------------------------------------------------

fn stdout_write(p: Ptr[U8], len: USize) -> (Bool, SysError, USize)
  let n = rt_stdout_write(p, len)
  if n < 0
    ret (false, sys_error_from_rt((I32)n), 0)
  .end
  ret (true, SysError::Ok, (USize)n)
.end

fn stderr_write(p: Ptr[U8], len: USize) -> (Bool, SysError, USize)
  let n = rt_stderr_write(p, len)
  if n < 0
    ret (false, sys_error_from_rt((I32)n), 0)
  .end
  ret (true, SysError::Ok, (USize)n)
.end

fn print_cstr(s: Str) -> (Bool, SysError)
  let b = bytes_from_cstr(s)
  let ok: Bool
  let e: SysError
  let n: USize
  (ok, e, n) = stdout_write((Ptr[U8])b.data, b.len)
  do vec_drop[U8](&b, 1)
  ret (ok, e)
.end

fn eprint_cstr(s: Str) -> (Bool, SysError)
  let b = bytes_from_cstr(s)
  let ok: Bool
  let e: SysError
  let n: USize
  (ok, e, n) = stderr_write((Ptr[U8])b.data, b.len)
  do vec_drop[U8](&b, 1)
  ret (ok, e)
.end

fn println_cstr(s: Str) -> (Bool, SysError)
  let ok: Bool
  let e: SysError
  (ok, e) = print_cstr(s)
  if !ok
    ret (false, e)
  .end
  ret print_cstr("\n")
.end

# -----------------------------------------------------------------------------
# Best-effort system metadata (stubs + env heuristics)
# -----------------------------------------------------------------------------

fn pid() -> (Bool, SysError, U64)
  ret (false, SysError::Unsupported, 0)
.end

fn cwd() -> (Bool, SysError, Vec[U8])
  ret (false, SysError::Unsupported, vec_new[U8]())
.end

fn exe_path() -> (Bool, SysError, Vec[U8])
  ret (false, SysError::Unsupported, vec_new[U8]())
.end

fn arch_name() -> (Bool, SysError, Vec[U8])
  ret (false, SysError::Unsupported, vec_new[U8]())
.end

fn os_name() -> (Bool, SysError, Vec[U8])
  # In absence of a runtime hook, use env heuristics.
  let ok: Bool
  let e: SysError
  let found: Bool
  let v: Vec[U8]

  (ok, e, found, v) = env_get("OS")
  if ok && found
    ret (true, SysError::Ok, v)
  .end
  if ok
    do vec_drop[U8](&v, 1)
  .end

  ret (false, SysError::Unsupported, vec_new[U8]())
.end

fn home_dir() -> (Bool, SysError, Vec[U8])
  # Convention: HOME (Unix) / USERPROFILE (Windows). Best-effort.
  let ok: Bool
  let e: SysError
  let found: Bool
  let v: Vec[U8]

  (ok, e, found, v) = env_get("HOME")
  if ok && found
    ret (true, SysError::Ok, v)
  .end
  if ok
    do vec_drop[U8](&v, 1)
  .end

  (ok, e, found, v) = env_get("USERPROFILE")
  if ok && found
    ret (true, SysError::Ok, v)
  .end
  if ok
    do vec_drop[U8](&v, 1)
  .end

  ret (false, SysError::NotFound, vec_new[U8]())
.end

fn temp_dir() -> (Bool, SysError, Vec[U8])
  let ok: Bool
  let e: SysError
  let found: Bool
  let v: Vec[U8]

  (ok, e, found, v) = env_get("TMPDIR")
  if ok && found
    ret (true, SysError::Ok, v)
  .end
  if ok
    do vec_drop[U8](&v, 1)
  .end

  (ok, e, found, v) = env_get("TMP")
  if ok && found
    ret (true, SysError::Ok, v)
  .end
  if ok
    do vec_drop[U8](&v, 1)
  .end

  (ok, e, found, v) = env_get("TEMP")
  if ok && found
    ret (true, SysError::Ok, v)
  .end
  if ok
    do vec_drop[U8](&v, 1)
  .end

  ret (false, SysError::NotFound, vec_new[U8]())
.end

# Path separator (best-effort):
# - On Windows, prefer '\\'.
# - Otherwise '/'.
fn path_sep_byte() -> U8
  # Check for Windows-like env.
  let ok: Bool
  let e: SysError
  let found: Bool
  let v: Vec[U8]

  (ok, e, found, v) = env_get("WINDIR")
  if ok && found
    do vec_drop[U8](&v, 1)
    ret (U8)'\\'
  .end
  if ok
    do vec_drop[U8](&v, 1)
  .end
  ret (U8)'/'
.end

fn is_windows() -> Bool
  let sep = path_sep_byte()
  ret sep == (U8)'\\'
.end

# -----------------------------------------------------------------------------
# Path utilities (byte-oriented)
# -----------------------------------------------------------------------------

# Returns true if `b` is a path separator for the current platform.
fn _is_sep(b: U8) -> Bool
  let sep = path_sep_byte()
  if b == sep
    ret true
  .end
  # accept both separators on Windows
  if is_windows() && (b == (U8)'/' || b == (U8)'\\')
    ret true
  .end
  ret false
.end

fn path_is_abs(p: &Vec[U8]) -> Bool
  if p.len == 0
    ret false
  .end
  let b0 = *((Ptr[U8])p.data + 0)

  if _is_sep(b0)
    ret true
  .end

  # Windows drive prefix: "C:" + optional sep
  if is_windows() && p.len >= 2
    let b1 = *((Ptr[U8])p.data + 1)
    if b1 == (U8)':'
      ret true
    .end
  .end

  ret false
.end

# Join two paths with platform separator (no normalization).
fn path_join(a: &Vec[U8], b: &Vec[U8]) -> (Bool, SysError, Vec[U8])
  if a.len == 0
    ret bytes_clone(b)
  .end
  if b.len == 0
    ret bytes_clone(a)
  .end

  let out = vec_new[U8]()
  if !_vec_push_vec_u8(&out, a)
    do vec_drop[U8](&out, 1)
    ret (false, SysError::OutOfMemory, vec_new[U8]())
  .end

  let last = *((Ptr[U8])a.data + (a.len - 1))
  if !_is_sep(last)
    if !_vec_push_u8(&out, path_sep_byte())
      do vec_drop[U8](&out, 1)
      ret (false, SysError::OutOfMemory, vec_new[U8]())
    .end
  .end

  # If b starts with sep, avoid double sep.
  let first = *((Ptr[U8])b.data + 0)
  if _is_sep(first)
    if !_vec_push_bytes(&out, (Ptr[U8])b.data + 1, b.len - 1)
      do vec_drop[U8](&out, 1)
      ret (false, SysError::OutOfMemory, vec_new[U8]())
    .end
  else
    if !_vec_push_vec_u8(&out, b)
      do vec_drop[U8](&out, 1)
      ret (false, SysError::OutOfMemory, vec_new[U8]())
    .end
  .end

  ret (true, SysError::Ok, out)
.end

# Normalize: collapse repeated separators and remove trailing separator (except root).
fn path_normalize(p: &Vec[U8]) -> (Bool, SysError, Vec[U8])
  if p.len == 0
    ret (true, SysError::Ok, vec_new[U8]())
  .end

  let out = vec_new[U8]()
  let i: USize
  set i = 0

  # Copy, collapsing seps
  while i < p.len
    let b = *((Ptr[U8])p.data + i)

    if _is_sep(b)
      # emit one sep then skip others
      if out.len == 0 || !_is_sep(*((Ptr[U8])out.data + (out.len - 1)))
        if !_vec_push_u8(&out, path_sep_byte())
          do vec_drop[U8](&out, 1)
          ret (false, SysError::OutOfMemory, vec_new[U8]())
        .end
      .end

      set i = i + 1
      while i < p.len && _is_sep(*((Ptr[U8])p.data + i))
        set i = i + 1
      .end
      continue
    .end

    if !_vec_push_u8(&out, b)
      do vec_drop[U8](&out, 1)
      ret (false, SysError::OutOfMemory, vec_new[U8]())
    .end

    set i = i + 1
  .end

  # remove trailing sep except if the normalized is just root or "C:\\"
  if out.len > 1
    let last = *((Ptr[U8])out.data + (out.len - 1))
    if _is_sep(last)
      # keep "C:\\" (len 3) if windows
      if is_windows() && out.len == 3 && *((Ptr[U8])out.data + 1) == (U8)':'
        ret (true, SysError::Ok, out)
      .end

      # keep "//"? collapse already ensures single; keep only if root
      do vec_pop[U8](&out)
    .end
  .end

  ret (true, SysError::Ok, out)
.end

# Return (ok, err, dir, base)
fn path_split_dir_base(p: &Vec[U8]) -> (Bool, SysError, Vec[U8], Vec[U8])
  if p.len == 0
    ret (true, SysError::Ok, vec_new[U8](), vec_new[U8]())
  .end

  let i: I64
  set i = (I64)p.len - 1
  while i >= 0
    let b = *((Ptr[U8])p.data + (USize)i)
    if _is_sep(b)
      break
    .end
    set i = i - 1
  .end

  if i < 0
    # no separator => dir empty
    let ok: Bool
    let e: SysError
    let base: Vec[U8]
    (ok, e, base) = bytes_clone(p)
    if !ok
      ret (false, e, vec_new[U8](), vec_new[U8]())
    .end
    ret (true, SysError::Ok, vec_new[U8](), base)
  .end

  # dir = p[0..i] (keep sep if root)
  let dir = vec_new[U8]()
  let base = vec_new[U8]()

  # copy dir
  let di: USize
  set di = 0
  while di < (USize)i
    if !_vec_push_u8(&dir, *((Ptr[U8])p.data + di))
      do vec_drop[U8](&dir, 1)
      do vec_drop[U8](&base, 1)
      ret (false, SysError::OutOfMemory, vec_new[U8](), vec_new[U8]())
    .end
    set di = di + 1
  .end

  # If separator is at 0, keep root separator in dir
  if (USize)i == 0
    if !_vec_push_u8(&dir, path_sep_byte())
      do vec_drop[U8](&dir, 1)
      do vec_drop[U8](&base, 1)
      ret (false, SysError::OutOfMemory, vec_new[U8](), vec_new[U8]())
    .end
  .end

  # copy base (skip sep at i)
  let bi: USize
  set bi = (USize)i + 1
  while bi < p.len
    if !_vec_push_u8(&base, *((Ptr[U8])p.data + bi))
      do vec_drop[U8](&dir, 1)
      do vec_drop[U8](&base, 1)
      ret (false, SysError::OutOfMemory, vec_new[U8](), vec_new[U8]())
    .end
    set bi = bi + 1
  .end

  ret (true, SysError::Ok, dir, base)
.end

# Return (ok, err, stem, ext)
# - ext includes the dot (e.g. ".txt")
fn path_split_ext(p: &Vec[U8]) -> (Bool, SysError, Vec[U8], Vec[U8])
  let ok: Bool
  let e: SysError
  let dir: Vec[U8]
  let base: Vec[U8]
  (ok, e, dir, base) = path_split_dir_base(p)
  if !ok
    ret (false, e, vec_new[U8](), vec_new[U8]())
  .end

  # find last '.' in base
  let i: I64
  set i = (I64)base.len - 1
  while i >= 0
    let b = *((Ptr[U8])base.data + (USize)i)
    if b == (U8)'.'
      break
    .end
    set i = i - 1
  .end

  if i <= 0
    # no extension (or hidden file like .gitignore)
    do vec_drop[U8](&dir, 1)
    let stem: Vec[U8]
    (ok, e, stem) = bytes_clone(&base)
    do vec_drop[U8](&base, 1)
    if !ok
      ret (false, e, vec_new[U8](), vec_new[U8]())
    .end
    ret (true, SysError::Ok, stem, vec_new[U8]())
  .end

  let stem = vec_new[U8]()
  let ext = vec_new[U8]()

  let si: USize
  set si = 0
  while si < (USize)i
    if !_vec_push_u8(&stem, *((Ptr[U8])base.data + si))
      do vec_drop[U8](&dir, 1)
      do vec_drop[U8](&base, 1)
      do vec_drop[U8](&stem, 1)
      do vec_drop[U8](&ext, 1)
      ret (false, SysError::OutOfMemory, vec_new[U8](), vec_new[U8]())
    .end
    set si = si + 1
  .end

  let ei: USize
  set ei = (USize)i
  while ei < base.len
    if !_vec_push_u8(&ext, *((Ptr[U8])base.data + ei))
      do vec_drop[U8](&dir, 1)
      do vec_drop[U8](&base, 1)
      do vec_drop[U8](&stem, 1)
      do vec_drop[U8](&ext, 1)
      ret (false, SysError::OutOfMemory, vec_new[U8](), vec_new[U8]())
    .end
    set ei = ei + 1
  .end

  do vec_drop[U8](&dir, 1)
  do vec_drop[U8](&base, 1)

  ret (true, SysError::Ok, stem, ext)
.end

# -----------------------------------------------------------------------------
# Process control stubs (future runtime hooks)
# -----------------------------------------------------------------------------

type ExitStatus struct
  code: I32
.end

fn exit_status_new(code: I32) -> ExitStatus
  let s: ExitStatus
  set s.code = code
  ret s
.end

fn process_exit(code: I32) -> (Bool, SysError)
  # Future: rt_process_exit(code)
  ret (false, SysError::Unsupported)
.end

fn process_abort() -> (Bool, SysError)
  # Future: rt_process_abort()
  ret (false, SysError::Unsupported)
.end

# -----------------------------------------------------------------------------
# Smoke tests (scenarios)
# -----------------------------------------------------------------------------

scn test_sys_env_roundtrip
  let ok: Bool
  let e: SysError
  let found: Bool
  let v: Vec[U8]

  (ok, e) = env_set("VITTE_SYS_TEST_KEY", "123")
  do std.runtime::assert(ok, "env_set")

  (ok, e, found, v) = env_get("VITTE_SYS_TEST_KEY")
  do std.runtime::assert(ok && found, "env_get")

  let want = bytes_from_cstr("123")
  do std.runtime::assert(bytes_eq(&v, &want), "env_eq")

  do vec_drop[U8](&want, 1)
  do vec_drop[U8](&v, 1)
.end

scn test_sys_args_basic
  let ok: Bool
  let e: SysError
  let n: USize

  (ok, e, n) = args_len()
  do std.runtime::assert(ok, "args_len")

  if n > 0
    let a0: Vec[U8]
    (ok, e, a0) = args_get(0)
    do std.runtime::assert(ok, "args_get")
    do vec_drop[U8](&a0, 1)
  .end
.end

scn test_sys_time_sleep
  let ok: Bool
  let e: SysError
  let t0: I64
  let t1: I64

  (ok, e, t0) = now_ms()
  do std.runtime::assert(ok, "now_ms")

  (ok, e) = sleep_ms(0)
  do std.runtime::assert(ok, "sleep_ms")

  (ok, e, t1) = now_ms()
  do std.runtime::assert(ok, "now_ms 2")

  do std.runtime::assert(t1 >= t0, "time monotonic")
.end

scn test_sys_path_join_normalize_split
  let ok: Bool
  let e: SysError

  let a = bytes_from_cstr("a")
  let b = bytes_from_cstr("b")

  let j: Vec[U8]
  (ok, e, j) = path_join(&a, &b)
  do std.runtime::assert(ok, "path_join")

  let sep = path_sep_byte()
  do std.runtime::assert(j.len == 3, "path_join len")
  do std.runtime::assert(*((Ptr[U8])j.data + 0) == (U8)'a', "path_join a")
  do std.runtime::assert(*((Ptr[U8])j.data + 1) == sep, "path_join sep")
  do std.runtime::assert(*((Ptr[U8])j.data + 2) == (U8)'b', "path_join b")

  let nn: Vec[U8]
  (ok, e, nn) = path_normalize(&j)
  do std.runtime::assert(ok, "path_normalize")
  do std.runtime::assert(bytes_eq(&j, &nn), "path_normalize eq")

  let dir: Vec[U8]
  let base: Vec[U8]
  (ok, e, dir, base) = path_split_dir_base(&j)
  do std.runtime::assert(ok, "path_split")
  do std.runtime::assert(dir.len == 1 && *((Ptr[U8])dir.data + 0) == (U8)'a', "dir")
  do std.runtime::assert(base.len == 1 && *((Ptr[U8])base.data + 0) == (U8)'b', "base")

  do vec_drop[U8](&dir, 1)
  do vec_drop[U8](&base, 1)
  do vec_drop[U8](&nn, 1)
  do vec_drop[U8](&j, 1)
  do vec_drop[U8](&a, 1)
  do vec_drop[U8](&b, 1)
.end

scn test_sys_path_split_ext
  let ok: Bool
  let e: SysError

  let p = bytes_from_cstr("file.txt")

  let stem: Vec[U8]
  let ext: Vec[U8]
  (ok, e, stem, ext) = path_split_ext(&p)
  do std.runtime::assert(ok, "split_ext")

  let wstem = bytes_from_cstr("file")
  let wext  = bytes_from_cstr(".txt")

  do std.runtime::assert(bytes_eq(&stem, &wstem), "stem")
  do std.runtime::assert(bytes_eq(&ext, &wext), "ext")

  do vec_drop[U8](&wstem, 1)
  do vec_drop[U8](&wext, 1)
  do vec_drop[U8](&stem, 1)
  do vec_drop[U8](&ext, 1)
  do vec_drop[U8](&p, 1)
.end

# End of std.sys