# /Users/vincent/Documents/Github/vitte/std/collections/tests/t_vec.vitte
# -----------------------------------------------------------------------------
# std/collections/tests/t_vec
# -----------------------------------------------------------------------------
# MAX tests for std.collections.vec
#
# Coverage:
# - growth policy helper (_next_cap)
# - invalid allocator behavior
# - API surface compile/smoke: new/with_capacity/len/cap/push/pop/get/set/insert/remove/clear/shrink/drop/iter
#
# Notes:
# - std.collections.vec is allocator-abstract; Alloc/Buf functions are stubs
#   until wired to real storage, so runtime-functional tests are limited.
# - These tests validate deterministic helper logic and invalid-path returns.
# - All blocks use `.end` only.
# -----------------------------------------------------------------------------

module std.collections.tests.t_vec

use std.runtime
use std.collections.vec

type Bool = bool
type U32  = u32
type Str  = str

fn assert_true(b: Bool, msg: Str)
  do std.runtime::assert(b, msg)
.end

fn assert_false(b: Bool, msg: Str)
  do std.runtime::assert(!b, msg)
.end

fn assert_eq_u32(a: U32, b: U32, msg: Str)
  do std.runtime::assert(a == b, msg)
.end

fn assert_eq_str(a: Str, b: Str, msg: Str)
  do std.runtime::assert(a == b, msg)
.end

# -----------------------------------------------------------------------------
# Growth policy helper (pure)
# -----------------------------------------------------------------------------

scn test_vec_next_cap
  let c1 = std.collections.vec::_next_cap(0, 1)
  do std.runtime::assert(c1 >= 1, "0->1")
  do std.runtime::assert(c1 >= 4, "min 4")

  let c2 = std.collections.vec::_next_cap(4, 5)
  do std.runtime::assert(c2 >= 5, "4->5")

  let c3 = std.collections.vec::_next_cap(8, 9)
  do std.runtime::assert(c3 >= 9, "8->9")

  let c4 = std.collections.vec::_next_cap(16, 3)
  do std.runtime::assert(c4 >= 3, "need smaller ok")
.end

# -----------------------------------------------------------------------------
# Invalid allocator behavior
# -----------------------------------------------------------------------------

scn test_vec_invalid_alloc
  let a = std.collections.vec::alloc_invalid()
  let v = std.collections.vec::vec_new(a)

  do assert_false(std.collections.vec::vec_is_valid(&v), "vec invalid")

  do assert_eq_u32(std.collections.vec::vec_len(&v), 0, "len 0")
  do assert_eq_u32(std.collections.vec::vec_cap(&v), 0, "cap 0")

  let e = std.collections.vec::vec_push(&v, "x")
  do std.runtime::assert(e == std.collections.vec::VecError::Invalid, "push invalid")

  let e2: std.collections.vec::VecError
  let x: Str
  (e2, x) = std.collections.vec::vec_pop(&v)
  do std.runtime::assert(e2 == std.collections.vec::VecError::Invalid, "pop invalid")

  let e3: std.collections.vec::VecError
  let y: Str
  (e3, y) = std.collections.vec::vec_get(&v, 0)
  do std.runtime::assert(e3 == std.collections.vec::VecError::Invalid, "get invalid")

  let e4 = std.collections.vec::vec_set(&v, 0, "y")
  do std.runtime::assert(e4 == std.collections.vec::VecError::Invalid, "set invalid")

  let e5 = std.collections.vec::vec_clear(&v)
  do std.runtime::assert(e5 == std.collections.vec::VecError::Invalid, "clear invalid")
.end

# -----------------------------------------------------------------------------
# API compile/smoke paths (no storage)
# -----------------------------------------------------------------------------

scn test_vec_api_compile
  let a = std.collections.vec::alloc_invalid()
  let v = std.collections.vec::vec_with_capacity(a, 8)

  do std.runtime::assert(std.collections.vec::vec_is_valid(&v) == false, "with_capacity invalid")

  # iter surface
  let it = std.collections.vec::iter_new()
  let ok: Bool
  let s: Str
  (ok, s) = std.collections.vec::vec_iter_next(&v, &it)
  do assert_false(ok, "iter false invalid storage")
  do assert_eq_str(s, "", "iter empty")
.end

# -----------------------------------------------------------------------------
# Drop/shrink surface (invalid)
# -----------------------------------------------------------------------------

scn test_vec_drop_shrink_invalid
  let a = std.collections.vec::alloc_invalid()
  let v = std.collections.vec::vec_new(a)

  let e = std.collections.vec::vec_shrink_to_fit(&v)
  do std.runtime::assert(e == std.collections.vec::VecError::Invalid, "shrink invalid")

  let e2 = std.collections.vec::vec_drop(&v)
  do std.runtime::assert(e2 == std.collections.vec::VecError::Invalid, "drop invalid")
.end

# End of t_vec.vitte