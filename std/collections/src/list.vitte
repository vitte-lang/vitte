# std/collections/list.vitte
# -----------------------------------------------------------------------------
# std/collections/list
# -----------------------------------------------------------------------------
# Doubly-linked list with pool-backed nodes (bootstrap-friendly).
#
# MAX goals:
# - Practical API: push/pop front/back, insert/remove at iter, len, clear, iter.
# - No direct allocation: storage delegated to a NodePool abstraction.
# - Deterministic: node ids are stable; list stores head/tail + len.
#
# Design:
# - Concrete list of Str values (no generics yet).
# - Nodes are stored in a NodePool:
#     node.value: Str
#     node.prev: NodeId
#     node.next: NodeId
# - NodeId is I32; -1 means none.
#
# Notes:
# - NodePool functions are stubs and must be wired to real storage (arena/vec).
# - All blocks use `.end` only.
# -----------------------------------------------------------------------------

module std.collections.list

use std.runtime

type Bool = bool
type U32  = u32
type I32  = i32
type Str  = str

# -----------------------------------------------------------------------------
# Node pool abstraction (stubs)
# -----------------------------------------------------------------------------

type NodeId = I32

fn node_none() -> NodeId
  ret -1
.end

fn node_is_valid(id: NodeId) -> Bool
  ret id >= 0
.end

type NodePool struct
  id: I32
.end

fn pool_invalid() -> NodePool
  let p: NodePool
  set p.id = -1
  ret p
.end

fn pool_is_valid(p: &NodePool) -> Bool
  ret p.id >= 0
.end

fn pool_alloc(pool: &NodePool, value: Str) -> NodeId
  # TODO: allocate node and return id
  ret node_none()
.end

fn pool_free(pool: &NodePool, id: NodeId) -> Bool
  # TODO: free node
  ret false
.end

fn pool_clear(pool: &NodePool) -> Bool
  # TODO: free all nodes / reset arena
  ret false
.end

fn node_get_value(pool: &NodePool, id: NodeId) -> Str
  # TODO
  ret ""
.end

fn node_set_value(pool: &NodePool, id: NodeId, v: Str) -> Bool
  # TODO
  ret false
.end

fn node_get_prev(pool: &NodePool, id: NodeId) -> NodeId
  # TODO
  ret node_none()
.end

fn node_set_prev(pool: &NodePool, id: NodeId, prev: NodeId) -> Bool
  # TODO
  ret false
.end

fn node_get_next(pool: &NodePool, id: NodeId) -> NodeId
  # TODO
  ret node_none()
.end

fn node_set_next(pool: &NodePool, id: NodeId, next: NodeId) -> Bool
  # TODO
  ret false
.end

# -----------------------------------------------------------------------------
# List types
# -----------------------------------------------------------------------------

type ListError enum
  Ok
  Empty
  Invalid
  Failed
.end

type List struct
  pool: NodePool
  head: NodeId
  tail: NodeId
  len: U32
.end

fn list_new(pool: NodePool) -> List
  let l: List
  set l.pool = pool
  set l.head = node_none()
  set l.tail = node_none()
  set l.len = 0
  ret l
.end

fn list_is_valid(l: &List) -> Bool
  ret pool_is_valid(&l.pool)
.end

fn list_len(l: &List) -> U32
  ret l.len
.end

fn list_is_empty(l: &List) -> Bool
  ret l.len == 0
.end

fn list_clear(l: &List) -> ListError
  if !list_is_valid(l)
    ret ListError::Invalid
  .end
  set l.head = node_none()
  set l.tail = node_none()
  set l.len = 0
  if pool_clear(&l.pool)
    ret ListError::Ok
  .end
  ret ListError::Failed
.end

# -----------------------------------------------------------------------------
# Push / Pop
# -----------------------------------------------------------------------------

fn list_push_front(l: &List, v: Str) -> ListError
  if !list_is_valid(l)
    ret ListError::Invalid
  .end

  let n = pool_alloc(&l.pool, v)
  if !node_is_valid(n)
    ret ListError::Failed
  .end

  do node_set_prev(&l.pool, n, node_none())
  do node_set_next(&l.pool, n, l.head)

  if node_is_valid(l.head)
    do node_set_prev(&l.pool, l.head, n)
  else
    # was empty
    set l.tail = n
  .end

  set l.head = n
  set l.len = l.len + 1
  ret ListError::Ok
.end

fn list_push_back(l: &List, v: Str) -> ListError
  if !list_is_valid(l)
    ret ListError::Invalid
  .end

  let n = pool_alloc(&l.pool, v)
  if !node_is_valid(n)
    ret ListError::Failed
  .end

  do node_set_next(&l.pool, n, node_none())
  do node_set_prev(&l.pool, n, l.tail)

  if node_is_valid(l.tail)
    do node_set_next(&l.pool, l.tail, n)
  else
    # was empty
    set l.head = n
  .end

  set l.tail = n
  set l.len = l.len + 1
  ret ListError::Ok
.end

fn list_peek_front(l: &List) -> (ListError, Str)
  if !list_is_valid(l)
    ret (ListError::Invalid, "")
  .end
  if !node_is_valid(l.head)
    ret (ListError::Empty, "")
  .end
  ret (ListError::Ok, node_get_value(&l.pool, l.head))
.end

fn list_peek_back(l: &List) -> (ListError, Str)
  if !list_is_valid(l)
    ret (ListError::Invalid, "")
  .end
  if !node_is_valid(l.tail)
    ret (ListError::Empty, "")
  .end
  ret (ListError::Ok, node_get_value(&l.pool, l.tail))
.end

fn list_pop_front(l: &List) -> (ListError, Str)
  if !list_is_valid(l)
    ret (ListError::Invalid, "")
  .end
  let h = l.head
  if !node_is_valid(h)
    ret (ListError::Empty, "")
  .end

  let v = node_get_value(&l.pool, h)
  let n = node_get_next(&l.pool, h)

  if node_is_valid(n)
    do node_set_prev(&l.pool, n, node_none())
  else
    # list becomes empty
    set l.tail = node_none()
  .end

  set l.head = n

  do pool_free(&l.pool, h)
  set l.len = l.len - 1
  ret (ListError::Ok, v)
.end

fn list_pop_back(l: &List) -> (ListError, Str)
  if !list_is_valid(l)
    ret (ListError::Invalid, "")
  .end
  let t = l.tail
  if !node_is_valid(t)
    ret (ListError::Empty, "")
  .end

  let v = node_get_value(&l.pool, t)
  let p = node_get_prev(&l.pool, t)

  if node_is_valid(p)
    do node_set_next(&l.pool, p, node_none())
  else
    # list becomes empty
    set l.head = node_none()
  .end

  set l.tail = p

  do pool_free(&l.pool, t)
  set l.len = l.len - 1
  ret (ListError::Ok, v)
.end

# -----------------------------------------------------------------------------
# Iteration and splice ops
# -----------------------------------------------------------------------------

type Iter struct
  cur: NodeId
.end

fn iter_begin(l: &List) -> Iter
  let it: Iter
  set it.cur = l.head
  ret it
.end

fn iter_end() -> Iter
  let it: Iter
  set it.cur = node_none()
  ret it
.end

fn iter_is_end(it: &Iter) -> Bool
  ret !node_is_valid(it.cur)
.end

fn iter_next(l: &List, it: &Iter) -> (Bool, Str)
  if !list_is_valid(l)
    ret (false, "")
  .end
  if !node_is_valid(it.cur)
    ret (false, "")
  .end

  let id = it.cur
  let v = node_get_value(&l.pool, id)
  set it.cur = node_get_next(&l.pool, id)
  ret (true, v)
.end

# Insert BEFORE iterator position (it.cur). If it.cur is end, append.
fn list_insert_before(l: &List, it: &Iter, v: Str) -> ListError
  if !list_is_valid(l)
    ret ListError::Invalid
  .end

  if !node_is_valid(it.cur)
    ret list_push_back(l, v)
  .end

  let cur = it.cur
  let prev = node_get_prev(&l.pool, cur)

  let n = pool_alloc(&l.pool, v)
  if !node_is_valid(n)
    ret ListError::Failed
  .end

  do node_set_prev(&l.pool, n, prev)
  do node_set_next(&l.pool, n, cur)
  do node_set_prev(&l.pool, cur, n)

  if node_is_valid(prev)
    do node_set_next(&l.pool, prev, n)
  else
    set l.head = n
  .end

  set l.len = l.len + 1
  ret ListError::Ok
.end

# Remove node at iterator; iterator advances to next.
fn list_remove_at(l: &List, it: &Iter) -> (ListError, Str)
  if !list_is_valid(l)
    ret (ListError::Invalid, "")
  .end
  let cur = it.cur
  if !node_is_valid(cur)
    ret (ListError::Empty, "")
  .end

  let v = node_get_value(&l.pool, cur)
  let prev = node_get_prev(&l.pool, cur)
  let next = node_get_next(&l.pool, cur)

  if node_is_valid(prev)
    do node_set_next(&l.pool, prev, next)
  else
    set l.head = next
  .end

  if node_is_valid(next)
    do node_set_prev(&l.pool, next, prev)
  else
    set l.tail = prev
  .end

  set it.cur = next

  do pool_free(&l.pool, cur)
  set l.len = l.len - 1
  ret (ListError::Ok, v)
.end

# -----------------------------------------------------------------------------
# Smoke tests (scenarios)
# -----------------------------------------------------------------------------

scn test_list_api_smoke
  let p = pool_invalid()
  let l = list_new(p)
  do std.runtime::assert(list_is_valid(&l) == false, "invalid pool")
.end

# End of std.collections.list