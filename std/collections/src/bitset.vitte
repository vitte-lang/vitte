# /Users/vincent/Documents/Github/vitte/std/collections/src/bitset.vitte
# -----------------------------------------------------------------------------
# std/collections/bitset
# -----------------------------------------------------------------------------
# Fixed-size bitset with word storage + common operations.
#
# Goals:
# - Bootstrap-friendly: no dynamic allocation required for core operations.
# - Practical API: set/clear/test, range fill, bitwise ops, popcount, iter bits.
# - Deterministic: explicit size in bits.
#
# Design:
# - Storage = slice of U64 words supplied by caller (or owned by a wrapper type).
# - BitSet is a view: (bits, words_len, words_ptr) in higher layers.
#   Here we implement a simple owned-by-value representation using a Vec-like
#   abstraction is intentionally NOT included; you can wire to std.alloc later.
# - For now: BitSet stores `words: [U64]` as an abstract "buffer" via `BitBuf`.
#
# NOTE:
# Your current std layer may not have arrays/slices yet; this file uses a
# minimal `BitBuf` interface (len/get/set) that can be implemented by your
# runtime or replaced once slices are finalized.
#
# All blocks use `.end` only.
# -----------------------------------------------------------------------------

module std.collections.bitset

use std.runtime

type Bool = bool
type U8   = u8
type U32  = u32
type U64  = u64
type I32  = i32
type Str  = str

# -----------------------------------------------------------------------------
# Minimal word-buffer abstraction (to keep this module usable during bootstrap)
# -----------------------------------------------------------------------------
# Replace BitBuf with native slices/vec once available.
# -----------------------------------------------------------------------------

type BitBuf struct
  # opaque handle id (implementation-defined)
  id: I32
.end

fn bitbuf_invalid() -> BitBuf
  let b: BitBuf
  set b.id = -1
  ret b
.end

fn bitbuf_is_valid(b: &BitBuf) -> Bool
  ret b.id >= 0
.end

# These are expected to be provided by the platform/runtime layer eventually.
# For now, stubs return safe defaults.
fn bitbuf_len_words(b: &BitBuf) -> U32
  # TODO: wire to real buffer
  ret 0
.end

fn bitbuf_get_word(b: &BitBuf, i: U32) -> U64
  # TODO: wire to real buffer
  ret 0
.end

fn bitbuf_set_word(b: &BitBuf, i: U32, v: U64) -> Bool
  # TODO: wire to real buffer
  ret false
.end

fn bitbuf_fill_word(b: &BitBuf, v: U64) -> Bool
  let n = bitbuf_len_words(b)
  let i: U32
  set i = 0
  while i < n
    if !bitbuf_set_word(b, i, v)
      ret false
    .end
    set i = i + 1
  .end
  ret true
.end

# -----------------------------------------------------------------------------
# BitSet types
# -----------------------------------------------------------------------------

type BitSet struct
  bits: U32        # number of addressable bits
  buf: BitBuf      # word buffer
.end

fn word_bits() -> U32
  ret 64
.end

fn words_for_bits(bits: U32) -> U32
  if bits == 0
    ret 0
  .end
  # ceil(bits/64)
  ret (bits + 63) / 64
.end

fn bitset_new(bits: U32, buf: BitBuf) -> BitSet
  let s: BitSet
  set s.bits = bits
  set s.buf = buf
  ret s
.end

fn bitset_is_valid(s: &BitSet) -> Bool
  if !bitbuf_is_valid(&s.buf)
    ret false
  .end
  let need = words_for_bits(s.bits)
  ret bitbuf_len_words(&s.buf) >= need
.end

fn bitset_bits(s: &BitSet) -> U32
  ret s.bits
.end

fn bitset_words_len(s: &BitSet) -> U32
  ret words_for_bits(s.bits)
.end

# -----------------------------------------------------------------------------
# Indexing helpers
# -----------------------------------------------------------------------------

fn _check_index(s: &BitSet, bit: U32) -> Bool
  ret bit < s.bits
.end

fn _word_index(bit: U32) -> U32
  ret bit / 64
.end

fn _bit_mask(bit: U32) -> U64
  let shift: U32
  set shift = bit % 64
  ret (U64)1 << shift
.end

# -----------------------------------------------------------------------------
# Core ops
# -----------------------------------------------------------------------------

fn bitset_clear_all(s: &BitSet) -> Bool
  ret bitbuf_fill_word(&s.buf, 0)
.end

fn bitset_set_all(s: &BitSet) -> Bool
  let ok = bitbuf_fill_word(&s.buf, 0xffffffffffffffff)
  if !ok
    ret false
  .end

  # clear unused high bits in last word
  let nbits = s.bits
  if nbits == 0
    ret true
  .end

  let wlen = bitset_words_len(s)
  if wlen == 0
    ret true
  .end

  let used = nbits % 64
  if used == 0
    ret true
  .end

  let last = wlen - 1
  let w = bitbuf_get_word(&s.buf, last)
  let mask = ((U64)1 << used) - 1
  set w = w & mask
  ret bitbuf_set_word(&s.buf, last, w)
.end

fn bitset_test(s: &BitSet, bit: U32) -> Bool
  if !_check_index(s, bit)
    ret false
  .end
  let wi = _word_index(bit)
  let w = bitbuf_get_word(&s.buf, wi)
  ret (w & _bit_mask(bit)) != 0
.end

fn bitset_set(s: &BitSet, bit: U32) -> Bool
  if !_check_index(s, bit)
    ret false
  .end
  let wi = _word_index(bit)
  let w = bitbuf_get_word(&s.buf, wi)
  set w = w | _bit_mask(bit)
  ret bitbuf_set_word(&s.buf, wi, w)
.end

fn bitset_clear(s: &BitSet, bit: U32) -> Bool
  if !_check_index(s, bit)
    ret false
  .end
  let wi = _word_index(bit)
  let w = bitbuf_get_word(&s.buf, wi)
  set w = w & (~_bit_mask(bit))
  ret bitbuf_set_word(&s.buf, wi, w)
.end

fn bitset_flip(s: &BitSet, bit: U32) -> Bool
  if !_check_index(s, bit)
    ret false
  .end
  let wi = _word_index(bit)
  let w = bitbuf_get_word(&s.buf, wi)
  set w = w ^ _bit_mask(bit)
  ret bitbuf_set_word(&s.buf, wi, w)
.end

fn bitset_assign(s: &BitSet, bit: U32, on: Bool) -> Bool
  if on
    ret bitset_set(s, bit)
  .end
  ret bitset_clear(s, bit)
.end

# -----------------------------------------------------------------------------
# Range operations
# -----------------------------------------------------------------------------

fn bitset_fill_range(s: &BitSet, start: U32, len: U32, on: Bool) -> Bool
  if len == 0
    ret true
  .end
  if start >= s.bits
    ret false
  .end

  let end_excl: U32
  set end_excl = start + len
  if end_excl > s.bits
    set end_excl = s.bits
  .end

  let i: U32
  set i = start
  while i < end_excl
    if !bitset_assign(s, i, on)
      ret false
    .end
    set i = i + 1
  .end

  ret true
.end

# -----------------------------------------------------------------------------
# Bitwise ops (dst = a op b) word-wise
# -----------------------------------------------------------------------------

fn bitset_and(dst: &BitSet, a: &BitSet, b: &BitSet) -> Bool
  if dst.bits != a.bits || dst.bits != b.bits
    ret false
  .end

  let n = bitset_words_len(dst)
  let i: U32
  set i = 0
  while i < n
    let w = bitbuf_get_word(&a.buf, i) & bitbuf_get_word(&b.buf, i)
    if !bitbuf_set_word(&dst.buf, i, w)
      ret false
    .end
    set i = i + 1
  .end
  ret true
.end

fn bitset_or(dst: &BitSet, a: &BitSet, b: &BitSet) -> Bool
  if dst.bits != a.bits || dst.bits != b.bits
    ret false
  .end

  let n = bitset_words_len(dst)
  let i: U32
  set i = 0
  while i < n
    let w = bitbuf_get_word(&a.buf, i) | bitbuf_get_word(&b.buf, i)
    if !bitbuf_set_word(&dst.buf, i, w)
      ret false
    .end
    set i = i + 1
  .end
  ret true
.end

fn bitset_xor(dst: &BitSet, a: &BitSet, b: &BitSet) -> Bool
  if dst.bits != a.bits || dst.bits != b.bits
    ret false
  .end

  let n = bitset_words_len(dst)
  let i: U32
  set i = 0
  while i < n
    let w = bitbuf_get_word(&a.buf, i) ^ bitbuf_get_word(&b.buf, i)
    if !bitbuf_set_word(&dst.buf, i, w)
      ret false
    .end
    set i = i + 1
  .end
  ret true
.end

fn bitset_not(dst: &BitSet, a: &BitSet) -> Bool
  if dst.bits != a.bits
    ret false
  .end

  let n = bitset_words_len(dst)
  let i: U32
  set i = 0
  while i < n
    let w = ~bitbuf_get_word(&a.buf, i)
    if !bitbuf_set_word(&dst.buf, i, w)
      ret false
    .end
    set i = i + 1
  .end

  # clear unused high bits in last word
  do bitset_set_all(dst) # sets all then clears tail bits using dst.bits
  # overwrite with computed words again? (avoid). We'll do a targeted mask instead:
  if dst.bits == 0
    ret true
  .end
  let used = dst.bits % 64
  if used == 0
    ret true
  .end
  let last = bitset_words_len(dst) - 1
  let wlast = bitbuf_get_word(&dst.buf, last)
  let mask = ((U64)1 << used) - 1
  set wlast = wlast & mask
  ret bitbuf_set_word(&dst.buf, last, wlast)
.end

# -----------------------------------------------------------------------------
# Popcount / any / all
# -----------------------------------------------------------------------------

fn popcount_u64(x: U64) -> U32
  # SWAR popcount (portable)
  let v: U64
  set v = x
  set v = v - ((v >> 1) & 0x5555555555555555)
  set v = (v & 0x3333333333333333) + ((v >> 2) & 0x3333333333333333)
  set v = (v + (v >> 4)) & 0x0f0f0f0f0f0f0f0f
  set v = v + (v >> 8)
  set v = v + (v >> 16)
  set v = v + (v >> 32)
  ret (U32)(v & 0x7f)
.end

fn bitset_count_ones(s: &BitSet) -> U32
  let n = bitset_words_len(s)
  let i: U32
  set i = 0
  let acc: U32
  set acc = 0

  while i < n
    set acc = acc + popcount_u64(bitbuf_get_word(&s.buf, i))
    set i = i + 1
  .end

  # adjust for unused bits (if they might be set by external buffer)
  if s.bits == 0
    ret 0
  .end
  let used = s.bits % 64
  if used == 0
    ret acc
  .end
  # Mask last word
  let last = n - 1
  let w = bitbuf_get_word(&s.buf, last)
  let mask = ((U64)1 << used) - 1
  let adj = popcount_u64(w & (~mask))
  if adj > 0
    if acc >= adj
      set acc = acc - adj
    .end
  .end

  ret acc
.end

fn bitset_any(s: &BitSet) -> Bool
  let n = bitset_words_len(s)
  let i: U32
  set i = 0
  while i < n
    if bitbuf_get_word(&s.buf, i) != 0
      ret true
    .end
    set i = i + 1
  .end
  ret false
.end

fn bitset_none(s: &BitSet) -> Bool
  ret !bitset_any(s)
.end

fn bitset_all(s: &BitSet) -> Bool
  if s.bits == 0
    ret true
  .end

  let n = bitset_words_len(s)
  let i: U32
  set i = 0

  while i + 1 < n
    if bitbuf_get_word(&s.buf, i) != 0xffffffffffffffff
      ret false
    .end
    set i = i + 1
  .end

  # last word must be fully set only on used bits
  let used = s.bits % 64
  let last = n - 1
  let w = bitbuf_get_word(&s.buf, last)
  if used == 0
    ret w == 0xffffffffffffffff
  .end
  let mask = ((U64)1 << used) - 1
  ret (w & mask) == mask
.end

# -----------------------------------------------------------------------------
# Iteration: next set bit (linear word scan)
# -----------------------------------------------------------------------------

fn trailing_zeros_u64(x: U64) -> U32
  if x == 0
    ret 64
  .end

  let n: U32
  set n = 0
  let v: U64
  set v = x

  while (v & 1) == 0
    set n = n + 1
    set v = v >> 1
  .end
  ret n
.end

fn bitset_next_set(s: &BitSet, from_bit: U32) -> (Bool, U32)
  if s.bits == 0
    ret (false, 0)
  .end

  if from_bit >= s.bits
    ret (false, 0)
  .end

  let wi = _word_index(from_bit)
  let bi = from_bit % 64

  let nwords = bitset_words_len(s)
  let w = bitbuf_get_word(&s.buf, wi)

  # mask out bits below start
  let mask_low: U64
  if bi == 0
    set mask_low = 0xffffffffffffffff
  else
    set mask_low = ~(((U64)1 << bi) - 1)
  .end
  set w = w & mask_low

  let i: U32
  set i = wi

  while true
    if w != 0
      let tz = trailing_zeros_u64(w)
      let bit = i * 64 + tz
      if bit < s.bits
        ret (true, bit)
      .end
      ret (false, 0)
    .end

    set i = i + 1
    if i >= nwords
      ret (false, 0)
    .end
    set w = bitbuf_get_word(&s.buf, i)
  .end

  ret (false, 0)
.end

# -----------------------------------------------------------------------------
# Smoke tests (scenarios)
# -----------------------------------------------------------------------------
# These tests validate arithmetic helpers; buffer ops are stubs until wired.
# -----------------------------------------------------------------------------

scn test_bitset_helpers
  do std.runtime::assert(words_for_bits(0) == 0, "words 0")
  do std.runtime::assert(words_for_bits(1) == 1, "words 1")
  do std.runtime::assert(words_for_bits(64) == 1, "words 64")
  do std.runtime::assert(words_for_bits(65) == 2, "words 65")
.end

scn test_bitset_popcount
  do std.runtime::assert(popcount_u64(0) == 0, "pc 0")
  do std.runtime::assert(popcount_u64(1) == 1, "pc 1")
  do std.runtime::assert(popcount_u64(0xffffffffffffffff) == 64, "pc all")
.end

# End of std.collections.bitset