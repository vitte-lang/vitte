# /Users/vincent/Documents/Github/vitte/std/collections/src/vec.vitte
# -----------------------------------------------------------------------------
# std/collections/vec
# -----------------------------------------------------------------------------
# Growable vector with allocator-backed storage abstraction.
#
# MAX goals:
# - Practical Vec API (push/pop/get/set/insert/remove/clear/reserve/shrink).
# - Minimal dependencies: use allocator facade; no OS/IO.
# - Bootstrap-friendly: allocator functions are stubs; wire to std.alloc later.
#
# Design:
# - Concrete Vec of Str (no generics yet).
# - Backing storage = contiguous array of Str slots.
# - Memory management via Alloc interface:
#     alloc(n_slots) -> BufId
#     free(BufId)
#     realloc(BufId, new_n_slots) -> BufId
#     buf_len(BufId) -> U32 (capacity)
#     buf_get(BufId, i) -> Str
#     buf_set(BufId, i, Str) -> Bool
#
# Important:
# - This module is correct logically, but with stubbed allocator it wonâ€™t run.
# - Keep `.end` only.
# -----------------------------------------------------------------------------

module std.collections.vec

use std.runtime

type Bool = bool
type U32  = u32
type I32  = i32
type Str  = str

# -----------------------------------------------------------------------------
# Allocator / buffer abstraction (stubs)
# -----------------------------------------------------------------------------

type BufId = I32

fn buf_none() -> BufId
  ret -1
.end

fn buf_is_valid(id: BufId) -> Bool
  ret id >= 0
.end

type Alloc struct
  id: I32
.end

fn alloc_invalid() -> Alloc
  let a: Alloc
  set a.id = -1
  ret a
.end

fn alloc_is_valid(a: &Alloc) -> Bool
  ret a.id >= 0
.end

fn alloc_alloc(a: &Alloc, cap: U32) -> BufId
  # TODO: allocate buffer with `cap` Str slots
  ret buf_none()
.end

fn alloc_free(a: &Alloc, b: BufId) -> Bool
  # TODO
  ret false
.end

fn alloc_realloc(a: &Alloc, b: BufId, new_cap: U32) -> BufId
  # TODO
  ret buf_none()
.end

fn buf_cap(a: &Alloc, b: BufId) -> U32
  # TODO
  ret 0
.end

fn buf_get(a: &Alloc, b: BufId, i: U32) -> Str
  # TODO
  ret ""
.end

fn buf_set(a: &Alloc, b: BufId, i: U32, v: Str) -> Bool
  # TODO
  ret false
.end

fn buf_fill(a: &Alloc, b: BufId, from: U32, to_excl: U32, v: Str) -> Bool
  let i: U32
  set i = from
  while i < to_excl
    if !buf_set(a, b, i, v)
      ret false
    .end
    set i = i + 1
  .end
  ret true
.end

# -----------------------------------------------------------------------------
# Vec types
# -----------------------------------------------------------------------------

type VecError enum
  Ok
  OutOfBounds
  NoMem
  Invalid
.end

type Vec struct
  alloc: Alloc
  buf: BufId
  len: U32
.end

fn vec_new(alloc: Alloc) -> Vec
  let v: Vec
  set v.alloc = alloc
  set v.buf = buf_none()
  set v.len = 0
  ret v
.end

fn vec_with_capacity(alloc: Alloc, cap: U32) -> Vec
  let v = vec_new(alloc)
  if !alloc_is_valid(&v.alloc)
    ret v
  .end
  if cap == 0
    ret v
  .end
  let b = alloc_alloc(&v.alloc, cap)
  if buf_is_valid(b)
    set v.buf = b
  .end
  ret v
.end

fn vec_is_valid(v: &Vec) -> Bool
  ret alloc_is_valid(&v.alloc)
.end

fn vec_len(v: &Vec) -> U32
  ret v.len
.end

fn vec_is_empty(v: &Vec) -> Bool
  ret v.len == 0
.end

fn vec_cap(v: &Vec) -> U32
  if !vec_is_valid(v)
    ret 0
  .end
  if !buf_is_valid(v.buf)
    ret 0
  .end
  ret buf_cap(&v.alloc, v.buf)
.end

fn vec_clear(v: &Vec) -> VecError
  if !vec_is_valid(v)
    ret VecError::Invalid
  .end
  # optional: clear elements
  if buf_is_valid(v.buf)
    do buf_fill(&v.alloc, v.buf, 0, v.len, "")
  .end
  set v.len = 0
  ret VecError::Ok
.end

fn vec_drop(v: &Vec) -> VecError
  if !vec_is_valid(v)
    ret VecError::Invalid
  .end
  if buf_is_valid(v.buf)
    do buf_fill(&v.alloc, v.buf, 0, v.len, "")
    do alloc_free(&v.alloc, v.buf)
  .end
  set v.buf = buf_none()
  set v.len = 0
  ret VecError::Ok
.end

# -----------------------------------------------------------------------------
# Reserve / grow helpers
# -----------------------------------------------------------------------------

fn _grow_to(v: &Vec, new_cap: U32) -> Bool
  if !vec_is_valid(v)
    ret false
  .end

  if new_cap == 0
    ret true
  .end

  if !buf_is_valid(v.buf)
    let b = alloc_alloc(&v.alloc, new_cap)
    if !buf_is_valid(b)
      ret false
    .end
    set v.buf = b
    ret true
  .end

  let b2 = alloc_realloc(&v.alloc, v.buf, new_cap)
  if !buf_is_valid(b2)
    ret false
  .end
  set v.buf = b2
  ret true
.end

fn _next_cap(cur: U32, need: U32) -> U32
  # typical grow policy: max(need, max(4, cur*2))
  let c: U32
  if cur < 4
    set c = 4
  else
    set c = cur * 2
  .end
  if c < need
    set c = need
  .end
  ret c
.end

fn vec_reserve(v: &Vec, additional: U32) -> VecError
  if !vec_is_valid(v)
    ret VecError::Invalid
  .end

  let need = v.len + additional
  let cap = vec_cap(v)
  if cap >= need
    ret VecError::Ok
  .end

  let new_cap = _next_cap(cap, need)
  if !_grow_to(v, new_cap)
    ret VecError::NoMem
  .end
  ret VecError::Ok
.end

fn vec_shrink_to_fit(v: &Vec) -> VecError
  if !vec_is_valid(v)
    ret VecError::Invalid
  .end
  if !buf_is_valid(v.buf)
    ret VecError::Ok
  .end

  let cap = vec_cap(v)
  if v.len == cap
    ret VecError::Ok
  .end

  if v.len == 0
    do alloc_free(&v.alloc, v.buf)
    set v.buf = buf_none()
    ret VecError::Ok
  .end

  let b2 = alloc_realloc(&v.alloc, v.buf, v.len)
  if !buf_is_valid(b2)
    ret VecError::NoMem
  .end
  set v.buf = b2
  ret VecError::Ok
.end

# -----------------------------------------------------------------------------
# Element access
# -----------------------------------------------------------------------------

fn vec_get(v: &Vec, i: U32) -> (VecError, Str)
  if !vec_is_valid(v)
    ret (VecError::Invalid, "")
  .end
  if i >= v.len
    ret (VecError::OutOfBounds, "")
  .end
  ret (VecError::Ok, buf_get(&v.alloc, v.buf, i))
.end

fn vec_set(v: &Vec, i: U32, x: Str) -> VecError
  if !vec_is_valid(v)
    ret VecError::Invalid
  .end
  if i >= v.len
    ret VecError::OutOfBounds
  .end
  if !buf_set(&v.alloc, v.buf, i, x)
    ret VecError::Invalid
  .end
  ret VecError::Ok
.end

fn vec_front(v: &Vec) -> (VecError, Str)
  ret vec_get(v, 0)
.end

fn vec_back(v: &Vec) -> (VecError, Str)
  if v.len == 0
    ret (VecError::OutOfBounds, "")
  .end
  ret vec_get(v, v.len - 1)
.end

# -----------------------------------------------------------------------------
# Push / Pop
# -----------------------------------------------------------------------------

fn vec_push(v: &Vec, x: Str) -> VecError
  if !vec_is_valid(v)
    ret VecError::Invalid
  .end

  let cap = vec_cap(v)
  if v.len == cap
    let e = vec_reserve(v, 1)
    if e != VecError::Ok
      ret e
    .end
  .end

  if !buf_is_valid(v.buf)
    ret VecError::NoMem
  .end

  if !buf_set(&v.alloc, v.buf, v.len, x)
    ret VecError::Invalid
  .end
  set v.len = v.len + 1
  ret VecError::Ok
.end

fn vec_pop(v: &Vec) -> (VecError, Str)
  if !vec_is_valid(v)
    ret (VecError::Invalid, "")
  .end
  if v.len == 0
    ret (VecError::OutOfBounds, "")
  .end

  let i = v.len - 1
  let x = buf_get(&v.alloc, v.buf, i)
  do buf_set(&v.alloc, v.buf, i, "")
  set v.len = v.len - 1
  ret (VecError::Ok, x)
.end

# -----------------------------------------------------------------------------
# Insert / Remove (shift elements)
# -----------------------------------------------------------------------------

fn _shift_right(v: &Vec, from: U32, to_excl: U32)
  # shift [from..to_excl) one step to the right, backwards
  if to_excl <= from
    ret
  .end
  let i: U32
  set i = to_excl
  while i > from
    set i = i - 1
    let x = buf_get(&v.alloc, v.buf, i - 1)
    do buf_set(&v.alloc, v.buf, i, x)
  .end
.end

fn _shift_left(v: &Vec, from: U32, to_excl: U32)
  # shift [from..to_excl) one step to the left, forwards
  if to_excl <= from
    ret
  .end
  let i: U32
  set i = from
  while i + 1 < to_excl
    let x = buf_get(&v.alloc, v.buf, i + 1)
    do buf_set(&v.alloc, v.buf, i, x)
    set i = i + 1
  .end
.end

fn vec_insert(v: &Vec, index: U32, x: Str) -> VecError
  if !vec_is_valid(v)
    ret VecError::Invalid
  .end
  if index > v.len
    ret VecError::OutOfBounds
  .end

  let e = vec_reserve(v, 1)
  if e != VecError::Ok
    ret e
  .end

  let cap = vec_cap(v)
  if v.len >= cap
    ret VecError::NoMem
  .end

  # shift right to make room
  do _shift_right(v, index, v.len)
  do buf_set(&v.alloc, v.buf, index, x)
  set v.len = v.len + 1
  ret VecError::Ok
.end

fn vec_remove(v: &Vec, index: U32) -> (VecError, Str)
  if !vec_is_valid(v)
    ret (VecError::Invalid, "")
  .end
  if index >= v.len
    ret (VecError::OutOfBounds, "")
  .end

  let x = buf_get(&v.alloc, v.buf, index)
  # shift left to fill hole
  do _shift_left(v, index, v.len)
  # clear last
  do buf_set(&v.alloc, v.buf, v.len - 1, "")
  set v.len = v.len - 1
  ret (VecError::Ok, x)
.end

# -----------------------------------------------------------------------------
# Iteration
# -----------------------------------------------------------------------------

type Iter struct
  i: U32
.end

fn iter_new() -> Iter
  let it: Iter
  set it.i = 0
  ret it
.end

fn vec_iter_next(v: &Vec, it: &Iter) -> (Bool, Str)
  if it.i >= v.len
    ret (false, "")
  .end
  let x = buf_get(&v.alloc, v.buf, it.i)
  set it.i = it.i + 1
  ret (true, x)
.end

# -----------------------------------------------------------------------------
# Smoke tests (scenarios)
# -----------------------------------------------------------------------------

scn test_vec_grow_policy
  do std.runtime::assert(_next_cap(0, 1) >= 1, "grow 0->need")
  do std.runtime::assert(_next_cap(4, 5) >= 5, "grow 4->5")
  do std.runtime::assert(_next_cap(8, 9) >= 9, "grow 8->9")
.end

scn test_vec_api_smoke
  let a = alloc_invalid()
  let v = vec_new(a)
  do std.runtime::assert(vec_is_valid(&v) == false, "invalid alloc")
.end

# End of std.collections.vec