# std/collections/deque.vitte
# -----------------------------------------------------------------------------
# std/collections/deque
# -----------------------------------------------------------------------------
# Double-ended queue (ring buffer) with storage abstraction.
#
# MAX goals:
# - Provide an efficient deque API (push/pop front/back, peek, len, clear).
# - Ring-buffer indexing with power-of-two capacity when possible.
# - Bootstrap-friendly: storage delegated to a Buffer interface (no hard alloc).
#
# Design:
# - Deque is parameterized by a `DequeBuf` that stores elements in slots.
# - To avoid generics, this implementation is for Str elements (StrDeque).
# - Replace DequeBuf with real slices/vec + generics later.
#
# Storage contract:
# - Buffer provides: cap(), get(i), set(i, v), clear_slot(i)
# - Capacity must be > 0.
#
# Notes:
# - This file includes safe stub buffer functions. Wire to real storage.
# - All blocks use `.end` only.
# -----------------------------------------------------------------------------

module std.collections.deque

use std.runtime
use std.string

type Bool = bool
type U32  = u32
type I32  = i32
type Str  = str

# -----------------------------------------------------------------------------
# Minimal buffer abstraction (stubs)
# -----------------------------------------------------------------------------

type DequeBuf struct
  id: I32
.end

fn dequebuf_invalid() -> DequeBuf
  let b: DequeBuf
  set b.id = -1
  ret b
.end

fn dequebuf_is_valid(b: &DequeBuf) -> Bool
  ret b.id >= 0
.end

# Capacity in slots
fn dequebuf_cap(b: &DequeBuf) -> U32
  # TODO: wire to real buffer
  ret 0
.end

fn dequebuf_get(b: &DequeBuf, i: U32) -> Str
  # TODO: wire to real buffer
  ret ""
.end

fn dequebuf_set(b: &DequeBuf, i: U32, v: Str) -> Bool
  # TODO: wire to real buffer
  ret false
.end

fn dequebuf_clear_slot(b: &DequeBuf, i: U32) -> Bool
  # Optional: clear to default value
  ret dequebuf_set(b, i, "")
.end

# -----------------------------------------------------------------------------
# Helpers
# -----------------------------------------------------------------------------

fn is_pow2(x: U32) -> Bool
  if x == 0
    ret false
  .end
  ret (x & (x - 1)) == 0
.end

fn wrap_add(idx: U32, delta: U32, cap: U32) -> U32
  # idx = (idx + delta) % cap
  let x = idx + delta
  if cap == 0
    ret 0
  .end
  if is_pow2(cap)
    ret x & (cap - 1)
  .end
  ret x % cap
.end

fn wrap_sub(idx: U32, delta: U32, cap: U32) -> U32
  # idx = (idx - delta) mod cap
  if cap == 0
    ret 0
  .end
  if is_pow2(cap)
    ret (idx - delta) & (cap - 1)
  .end
  # generic
  let d: U32
  set d = delta % cap
  if idx >= d
    ret idx - d
  .end
  ret cap - (d - idx)
.end

# -----------------------------------------------------------------------------
# Public deque (Str)
# -----------------------------------------------------------------------------

type DequeError enum
  Ok
  Full
  Empty
  Invalid
.end

type StrDeque struct
  buf: DequeBuf
  head: U32   # index of front element
  len: U32
.end

fn deque_new(buf: DequeBuf) -> StrDeque
  let d: StrDeque
  set d.buf = buf
  set d.head = 0
  set d.len = 0
  ret d
.end

fn deque_is_valid(d: &StrDeque) -> Bool
  if !dequebuf_is_valid(&d.buf)
    ret false
  .end
  let cap = dequebuf_cap(&d.buf)
  ret cap > 0
.end

fn deque_cap(d: &StrDeque) -> U32
  if !deque_is_valid(d)
    ret 0
  .end
  ret dequebuf_cap(&d.buf)
.end

fn deque_len(d: &StrDeque) -> U32
  ret d.len
.end

fn deque_is_empty(d: &StrDeque) -> Bool
  ret d.len == 0
.end

fn deque_is_full(d: &StrDeque) -> Bool
  if !deque_is_valid(d)
    ret false
  .end
  ret d.len >= dequebuf_cap(&d.buf)
.end

fn deque_clear(d: &StrDeque) -> DequeError
  if !deque_is_valid(d)
    ret DequeError::Invalid
  .end

  # optional: clear underlying slots (O(cap))
  let cap = dequebuf_cap(&d.buf)
  let i: U32
  set i = 0
  while i < cap
    do dequebuf_clear_slot(&d.buf, i)
    set i = i + 1
  .end

  set d.head = 0
  set d.len = 0
  ret DequeError::Ok
.end

fn _idx_front(d: &StrDeque) -> U32
  ret d.head
.end

fn _idx_back(d: &StrDeque) -> U32
  # index of last element
  let cap = dequebuf_cap(&d.buf)
  ret wrap_add(d.head, d.len - 1, cap)
.end

fn _idx_push_back(d: &StrDeque) -> U32
  # insertion index at back = head + len
  let cap = dequebuf_cap(&d.buf)
  ret wrap_add(d.head, d.len, cap)
.end

fn _idx_push_front(d: &StrDeque) -> U32
  let cap = dequebuf_cap(&d.buf)
  ret wrap_sub(d.head, 1, cap)
.end

# -----------------------------------------------------------------------------
# Peek
# -----------------------------------------------------------------------------

fn deque_peek_front(d: &StrDeque) -> (DequeError, Str)
  if !deque_is_valid(d)
    ret (DequeError::Invalid, "")
  .end
  if d.len == 0
    ret (DequeError::Empty, "")
  .end
  ret (DequeError::Ok, dequebuf_get(&d.buf, _idx_front(d)))
.end

fn deque_peek_back(d: &StrDeque) -> (DequeError, Str)
  if !deque_is_valid(d)
    ret (DequeError::Invalid, "")
  .end
  if d.len == 0
    ret (DequeError::Empty, "")
  .end
  ret (DequeError::Ok, dequebuf_get(&d.buf, _idx_back(d)))
.end

# -----------------------------------------------------------------------------
# Push
# -----------------------------------------------------------------------------

fn deque_push_back(d: &StrDeque, v: Str) -> DequeError
  if !deque_is_valid(d)
    ret DequeError::Invalid
  .end
  if deque_is_full(d)
    ret DequeError::Full
  .end

  let i = _idx_push_back(d)
  if !dequebuf_set(&d.buf, i, v)
    ret DequeError::Invalid
  .end

  set d.len = d.len + 1
  ret DequeError::Ok
.end

fn deque_push_front(d: &StrDeque, v: Str) -> DequeError
  if !deque_is_valid(d)
    ret DequeError::Invalid
  .end
  if deque_is_full(d)
    ret DequeError::Full
  .end

  let i = _idx_push_front(d)
  if !dequebuf_set(&d.buf, i, v)
    ret DequeError::Invalid
  .end

  set d.head = i
  set d.len = d.len + 1
  ret DequeError::Ok
.end

# -----------------------------------------------------------------------------
# Pop
# -----------------------------------------------------------------------------

fn deque_pop_front(d: &StrDeque) -> (DequeError, Str)
  if !deque_is_valid(d)
    ret (DequeError::Invalid, "")
  .end
  if d.len == 0
    ret (DequeError::Empty, "")
  .end

  let i = _idx_front(d)
  let v = dequebuf_get(&d.buf, i)
  do dequebuf_clear_slot(&d.buf, i)

  let cap = dequebuf_cap(&d.buf)
  set d.head = wrap_add(d.head, 1, cap)
  set d.len = d.len - 1

  ret (DequeError::Ok, v)
.end

fn deque_pop_back(d: &StrDeque) -> (DequeError, Str)
  if !deque_is_valid(d)
    ret (DequeError::Invalid, "")
  .end
  if d.len == 0
    ret (DequeError::Empty, "")
  .end

  let i = _idx_back(d)
  let v = dequebuf_get(&d.buf, i)
  do dequebuf_clear_slot(&d.buf, i)

  set d.len = d.len - 1
  ret (DequeError::Ok, v)
.end

# -----------------------------------------------------------------------------
# Iteration (index-based)
# -----------------------------------------------------------------------------

fn deque_get(d: &StrDeque, index: U32) -> (DequeError, Str)
  if !deque_is_valid(d)
    ret (DequeError::Invalid, "")
  .end
  if index >= d.len
    ret (DequeError::Empty, "")
  .end
  let cap = dequebuf_cap(&d.buf)
  let i = wrap_add(d.head, index, cap)
  ret (DequeError::Ok, dequebuf_get(&d.buf, i))
.end

# -----------------------------------------------------------------------------
# Smoke tests (scenarios)
# -----------------------------------------------------------------------------
# These validate ring index helpers; buffer ops are stubbed until wired.
# -----------------------------------------------------------------------------

scn test_deque_helpers
  do std.runtime::assert(is_pow2(1), "pow2 1")
  do std.runtime::assert(is_pow2(8), "pow2 8")
  do std.runtime::assert(!is_pow2(0), "pow2 0 false")
  do std.runtime::assert(!is_pow2(6), "pow2 6 false")

  do std.runtime::assert(wrap_add(7, 1, 8) == 0, "wrap add pow2")
  do std.runtime::assert(wrap_sub(0, 1, 8) == 7, "wrap sub pow2")
.end

# End of std.collections.deque