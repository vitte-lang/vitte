

# -----------------------------------------------------------------------------
# std/path
# -----------------------------------------------------------------------------
# Pure path manipulation utilities (no filesystem access).
#
# Goals:
# - bootstrap-friendly (no syscalls)
# - portable parsing (POSIX + Windows forms)
# - safe helpers for joining, splitting, normalization
# - zero TLS/async assumptions
# - blocks use `.end` only
#
# Notes:
# - This module operates on UTF-8 byte sequences but does not validate UTF-8.
# - A "path" is represented as Vec[U8].
# - Windows support is best-effort (drive letters + UNC + backslash separators).
# -----------------------------------------------------------------------------

module std.path

use std.collections

# -----------------------------------------------------------------------------
# Local prelude
# -----------------------------------------------------------------------------

type Bool  = bool

type U8    = u8
type U16   = u16
type U32   = u32
type U64   = u64

type I32   = i32
type I64   = i64

type USize = usize

type Ptr[T] = ptr[T]

type Str = str

# -----------------------------------------------------------------------------
# Panic / assert stubs (bootstrapped by runtime if desired)
# -----------------------------------------------------------------------------

fn panic(msg: Str)
  ret
.end

fn assert(cond: Bool, msg: Str)
  if !cond
    do panic(msg)
  .end
.end

# -----------------------------------------------------------------------------
# Constants / separators
# -----------------------------------------------------------------------------

const SEP_POSIX: U8 = (U8)'/'
const SEP_WIN:   U8 = (U8)'\\'

# Preferred separator hook (bootstrap default: '/').
fn rt_path_preferred_sep() -> U8
  ret SEP_POSIX
.end

fn is_sep(b: U8) -> Bool
  ret b == SEP_POSIX || b == SEP_WIN
.end

fn is_alpha(b: U8) -> Bool
  ret (b >= (U8)'a' && b <= (U8)'z') || (b >= (U8)'A' && b <= (U8)'Z')
.end

fn is_digit(b: U8) -> Bool
  ret b >= (U8)'0' && b <= (U8)'9'
.end

# -----------------------------------------------------------------------------
# Path / PathBuf
# -----------------------------------------------------------------------------

# Path is a Vec[U8] by convention.

type PathBuf struct
  bytes: Vec[U8]
.end

fn pathbuf_new() -> PathBuf
  let p: PathBuf
  set p.bytes = vec_new[U8]()
  ret p
.end

fn pathbuf_from_vec(v: Vec[U8]) -> PathBuf
  let p: PathBuf
  set p.bytes = v
  ret p
.end

fn pathbuf_clear(p: &PathBuf)
  do vec_clear[U8](&p.bytes)
.end

fn pathbuf_drop(p: &PathBuf)
  do vec_drop[U8](&p.bytes, 1)
.end

fn pathbuf_as_vec(p: &PathBuf) -> &Vec[U8]
  ret &p.bytes
.end

# Minimal helper to build Vec[U8] from a NUL-terminated string literal.
fn vec_from_cstr(s: Str) -> Vec[U8]
  let v = vec_new[U8]()
  let p = (Ptr[U8])s
  let i: USize
  set i = 0
  loop
    let b = *(p + i)
    if b == 0
      break
    .end
    let ok: Bool
    let e: ColError
    (ok, e) = vec_push[U8](&v, 1, b)
    if !ok
      do vec_drop[U8](&v, 1)
      ret vec_new[U8]()
    .end
    set i = i + 1
  .end
  ret v
.end

fn pathbuf_from_cstr(s: Str) -> PathBuf
  ret pathbuf_from_vec(vec_from_cstr(s))
.end

# Copy bytes from src into dst (clears dst).
fn vec_assign_u8(dst: &Vec[U8], src: &Vec[U8]) -> Bool
  do vec_clear[U8](dst)
  let ok: Bool
  let e: ColError

  let i: USize
  set i = 0
  let p = (Ptr[U8])src.data
  while i < src.len
    (ok, e) = vec_push[U8](dst, 1, *(p + i))
    if !ok
      ret false
    .end
    set i = i + 1
  .end

  ret true
.end

fn vec_push_byte(dst: &Vec[U8], b: U8) -> Bool
  let ok: Bool
  let e: ColError
  (ok, e) = vec_push[U8](dst, 1, b)
  ret ok
.end

fn vec_push_bytes(dst: &Vec[U8], p: Ptr[U8], n: USize) -> Bool
  let ok: Bool
  let e: ColError
  let i: USize
  set i = 0
  while i < n
    (ok, e) = vec_push[U8](dst, 1, *(p + i))
    if !ok
      ret false
    .end
    set i = i + 1
  .end
  ret true
.end

fn vec_eq_u8(a: &Vec[U8], b: &Vec[U8]) -> Bool
  if a.len != b.len
    ret false
  .end
  let ap = (Ptr[U8])a.data
  let bp = (Ptr[U8])b.data
  let i: USize
  set i = 0
  while i < a.len
    if *(ap + i) != *(bp + i)
      ret false
    .end
    set i = i + 1
  .end
  ret true
.end

# -----------------------------------------------------------------------------
# Root / prefix parsing
# -----------------------------------------------------------------------------

# Drive prefix: "C:". Returns (has_drive, drive_letter, offset_after_prefix).
fn parse_drive_prefix(s: &Vec[U8]) -> (Bool, U8, USize)
  if s.len < 2
    ret (false, 0, 0)
  .end
  let p = (Ptr[U8])s.data
  let a = *(p + 0)
  let b = *(p + 1)
  if is_alpha(a) && b == (U8)':'
    ret (true, a, 2)
  .end
  ret (false, 0, 0)
.end

# UNC prefix: "\\\\server\\share". We only detect leading "\\\\".
fn has_unc_prefix(s: &Vec[U8]) -> Bool
  if s.len < 2
    ret false
  .end
  let p = (Ptr[U8])s.data
  ret *(p + 0) == SEP_WIN && *(p + 1) == SEP_WIN
.end

fn path_is_absolute(s: &Vec[U8]) -> Bool
  if s.len == 0
    ret false
  .end

  let p = (Ptr[U8])s.data

  # POSIX root
  if *(p + 0) == SEP_POSIX
    ret true
  .end

  # Windows UNC
  if has_unc_prefix(s)
    ret true
  .end

  # Windows drive absolute: C:\ or C:/
  let has: Bool
  let dl: U8
  let off: USize
  (has, dl, off) = parse_drive_prefix(s)
  if has && s.len > off && is_sep(*(p + off))
    ret true
  .end

  ret false
.end

# Returns (has_root, root_is_unc, has_drive, drive_letter, start_index_of_components)
fn parse_root(s: &Vec[U8]) -> (Bool, Bool, Bool, U8, USize)
  if s.len == 0
    ret (false, false, false, 0, 0)
  .end

  let p = (Ptr[U8])s.data

  # UNC
  if has_unc_prefix(s)
    ret (true, true, false, 0, 2)
  .end

  # POSIX root
  if *(p + 0) == SEP_POSIX
    ret (true, false, false, 0, 1)
  .end

  # Drive prefix
  let has: Bool
  let dl: U8
  let off: USize
  (has, dl, off) = parse_drive_prefix(s)
  if has
    # If followed by sep, treat as rooted
    if s.len > off && is_sep(*(p + off))
      ret (true, false, true, dl, off + 1)
    .end
    # "C:foo" is drive-relative (not absolute)
    ret (false, false, true, dl, off)
  .end

  ret (false, false, false, 0, 0)
.end

# -----------------------------------------------------------------------------
# Components
# -----------------------------------------------------------------------------

type PathCompKind enum
  Root
  Cur
  Parent
  Normal
.end

type PathComp struct
  kind: PathCompKind
  text: Vec[U8]   # only used for Normal
.end

fn comp_root() -> PathComp
  let c: PathComp
  set c.kind = PathCompKind::Root
  set c.text = vec_new[U8]()
  ret c
.end

fn comp_cur() -> PathComp
  let c: PathComp
  set c.kind = PathCompKind::Cur
  set c.text = vec_new[U8]()
  ret c
.end

fn comp_parent() -> PathComp
  let c: PathComp
  set c.kind = PathCompKind::Parent
  set c.text = vec_new[U8]()
  ret c
.end

fn comp_normal(v: Vec[U8]) -> PathComp
  let c: PathComp
  set c.kind = PathCompKind::Normal
  set c.text = v
  ret c
.end

fn comp_drop(c: &PathComp)
  if c.kind == PathCompKind::Normal
    do vec_drop[U8](&c.text, 1)
  .end
.end

# Split into raw segments (ignores empty segments). Does not interpret '.' or '..'.
fn path_split_segments(s: &Vec[U8], out: &Vec[Vec[U8]]) -> Bool
  do vec_clear[Vec[U8]](out)

  let has_root: Bool
  let is_unc: Bool
  let has_drive: Bool
  let dl: U8
  let start: USize
  (has_root, is_unc, has_drive, dl, start) = parse_root(s)

  let p = (Ptr[U8])s.data
  let i: USize
  set i = start

  let seg_start: USize
  set seg_start = i

  while i <= s.len
    let at_end: Bool
    set at_end = i == s.len

    let sep: Bool
    if at_end
      set sep = true
    else
      set sep = is_sep(*(p + i))
    .end

    if sep
      let seg_len = i - seg_start
      if seg_len != 0
        # build segment vec
        let seg = vec_new[U8]()
        if !vec_push_bytes(&seg, p + seg_start, seg_len)
          do vec_drop[U8](&seg, 1)
          ret false
        .end

        let ok: Bool
        let e: ColError
        (ok, e) = vec_push[Vec[U8]](out, 0, seg)
        if !ok
          do vec_drop[U8](&seg, 1)
          ret false
        .end
      .end

      set seg_start = i + 1
    .end

    set i = i + 1
  .end

  ret true
.end

# -----------------------------------------------------------------------------
# Join / normalize / split helpers
# -----------------------------------------------------------------------------

fn path_trim_trailing_seps(s: &Vec[U8]) -> USize
  if s.len == 0
    ret 0
  .end
  let p = (Ptr[U8])s.data
  let end: I32
  set end = (I32)s.len - 1

  # keep single leading root separator if that's all we have
  while end >= 0 && is_sep(*(p + (USize)end))
    # if the whole string is just separators, keep one
    if end == 0
      ret 1
    .end
    set end = end - 1
  .end

  ret (USize)(end + 1)
.end

fn path_has_trailing_sep(s: &Vec[U8]) -> Bool
  let n = path_trim_trailing_seps(s)
  ret n != s.len
.end

# Join: if rhs is absolute, result = rhs. Else base + sep + rhs.
fn path_join(base: &Vec[U8], rhs: &Vec[U8], out: &Vec[U8]) -> Bool
  if path_is_absolute(rhs)
    ret vec_assign_u8(out, rhs)
  .end

  do vec_clear[U8](out)

  # base without trailing seps
  let base_len = path_trim_trailing_seps(base)

  let bp = (Ptr[U8])base.data
  if !vec_push_bytes(out, bp, base_len)
    ret false
  .end

  if base_len != 0
    # add separator if rhs not empty
    if rhs.len != 0
      let sep = rt_path_preferred_sep()
      if !vec_push_byte(out, sep)
        ret false
      .end
    .end
  .end

  # rhs without leading seps
  let rp = (Ptr[U8])rhs.data
  let i: USize
  set i = 0
  while i < rhs.len && is_sep(*(rp + i))
    set i = i + 1
  .end
  if !vec_push_bytes(out, rp + i, rhs.len - i)
    ret false
  .end

  ret true
.end

# Compare segment to ASCII literal ("." or ".."), segment is Vec[U8].
fn seg_is_dot(seg: &Vec[U8]) -> Bool
  if seg.len != 1
    ret false
  .end
  ret *((Ptr[U8])seg.data + 0) == (U8)'.'
.end

fn seg_is_dotdot(seg: &Vec[U8]) -> Bool
  if seg.len != 2
    ret false
  .end
  let p = (Ptr[U8])seg.data
  ret *(p + 0) == (U8)'.' && *(p + 1) == (U8)'.'
.end

# Normalize:
# - collapse repeated separators
# - remove '.' segments
# - resolve '..' where possible
# - preserve root / drive / UNC prefix
# - does not access filesystem
fn path_normalize(src: &Vec[U8], out: &Vec[U8]) -> Bool
  do vec_clear[U8](out)

  let has_root: Bool
  let is_unc: Bool
  let has_drive: Bool
  let dl: U8
  let start: USize
  (has_root, is_unc, has_drive, dl, start) = parse_root(src)

  let sep = rt_path_preferred_sep()

  # write prefix
  if is_unc
    # keep leading \\ (normalize to preferred sep? keep backslashes for UNC)
    if !vec_push_byte(out, SEP_WIN)
      ret false
    .end
    if !vec_push_byte(out, SEP_WIN)
      ret false
    .end
  .end

  if has_drive
    if !vec_push_byte(out, dl)
      ret false
    .end
    if !vec_push_byte(out, (U8)':')
      ret false
    .end
    if has_root
      if !vec_push_byte(out, sep)
        ret false
      .end
    .end
  elif has_root && !is_unc
    if !vec_push_byte(out, sep)
      ret false
    .end
  .end

  # stack of segments (Vec[Vec[U8]])
  let segs = vec_new[Vec[U8]]()
  if !path_split_segments(src, &segs)
    do vec_drop[Vec[U8]](&segs, 0)
    ret false
  .end

  let stack = vec_new[Vec[U8]]()

  let i: USize
  set i = 0
  while i < segs.len
    let seg = *((Ptr[Vec[U8]])segs.data + i)

    if seg_is_dot(&seg)
      do vec_drop[U8](&seg, 1)
      set i = i + 1
      continue
    .end

    if seg_is_dotdot(&seg)
      # pop if possible
      if stack.len != 0
        let last = *((Ptr[Vec[U8]])stack.data + (stack.len - 1))
        do vec_drop[U8](&last, 1)
        do vec_pop[Vec[U8]](&stack, 0)
        do vec_drop[U8](&seg, 1)
        set i = i + 1
        continue
      .end

      # if rooted, ignore leading .., else keep ..
      if has_root
        do vec_drop[U8](&seg, 1)
        set i = i + 1
        continue
      .end

      # keep ..
      let ok: Bool
      let e: ColError
      (ok, e) = vec_push[Vec[U8]](&stack, 0, seg)
      if !ok
        do vec_drop[U8](&seg, 1)
        do vec_drop[Vec[U8]](&stack, 0)
        do vec_drop[Vec[U8]](&segs, 0)
        ret false
      .end

      set i = i + 1
      continue
    .end

    # normal segment
    let ok: Bool
    let e: ColError
    (ok, e) = vec_push[Vec[U8]](&stack, 0, seg)
    if !ok
      do vec_drop[U8](&seg, 1)
      do vec_drop[Vec[U8]](&stack, 0)
      do vec_drop[Vec[U8]](&segs, 0)
      ret false
    .end

    set i = i + 1
  .end

  # rebuild
  let j: USize
  set j = 0

  # out already has prefix/root
  while j < stack.len
    if out.len != 0
      let lastb = *((Ptr[U8])out.data + (out.len - 1))
      if !is_sep(lastb)
        if !vec_push_byte(out, sep)
          do vec_drop[Vec[U8]](&stack, 0)
          do vec_drop[Vec[U8]](&segs, 0)
          ret false
        .end
      .end
    .end

    let seg = *((Ptr[Vec[U8]])stack.data + j)
    if !vec_push_bytes(out, (Ptr[U8])seg.data, seg.len)
      do vec_drop[Vec[U8]](&stack, 0)
      do vec_drop[Vec[U8]](&segs, 0)
      ret false
    .end

    set j = j + 1
  .end

  # cleanup
  # drop nested segments
  set j = 0
  while j < stack.len
    let seg = *((Ptr[Vec[U8]])stack.data + j)
    do vec_drop[U8](&seg, 1)
    set j = j + 1
  .end
  do vec_drop[Vec[U8]](&stack, 0)

  # segs were moved into stack; segs vector elements are now invalid to drop individually.
  do vec_drop[Vec[U8]](&segs, 0)

  # If out ended up empty, normalize to "." for relative empty input
  if out.len == 0
    let ok: Bool
    let e: ColError
    (ok, e) = vec_push[U8](out, 1, (U8)'.')
    ret ok
  .end

  ret true
.end

# -----------------------------------------------------------------------------
# Basename / dirname
# -----------------------------------------------------------------------------

fn path_basename(src: &Vec[U8], out: &Vec[U8]) -> Bool
  do vec_clear[U8](out)

  let n = path_trim_trailing_seps(src)
  if n == 0
    # empty -> empty
    ret true
  .end

  let p = (Ptr[U8])src.data

  # find last separator before n
  let i: I32
  set i = (I32)n - 1
  while i >= 0 && !is_sep(*(p + (USize)i))
    set i = i - 1
  .end

  let start: USize
  set start = (USize)(i + 1)
  ret vec_push_bytes(out, p + start, n - start)
.end

fn path_dirname(src: &Vec[U8], out: &Vec[U8]) -> Bool
  do vec_clear[U8](out)

  let n = path_trim_trailing_seps(src)
  if n == 0
    # empty -> .
    ret vec_push_byte(out, (U8)'.')
  .end

  let p = (Ptr[U8])src.data

  # root-only cases
  if n == 1 && is_sep(*(p + 0))
    ret vec_push_byte(out, rt_path_preferred_sep())
  .end

  # drive root: "C:\"
  let has_root: Bool
  let is_unc: Bool
  let has_drive: Bool
  let dl: U8
  let start: USize
  (has_root, is_unc, has_drive, dl, start) = parse_root(src)

  # find last separator before n
  let i: I32
  set i = (I32)n - 1
  while i >= 0 && !is_sep(*(p + (USize)i))
    set i = i - 1
  .end

  if i < 0
    # no separator -> . or drive prefix
    if has_drive
      # "C:foo" -> "C:"
      if !vec_push_byte(out, dl)
        ret false
      .end
      if !vec_push_byte(out, (U8)':')
        ret false
      .end
      ret true
    .end
    ret vec_push_byte(out, (U8)'.')
  .end

  # if separator is at root boundary, return root
  let cut: USize
  set cut = (USize)i

  if has_drive && has_root
    # Keep "C:" + sep
    if cut < 2
      set cut = 2
    .end
    # ensure includes separator
    if cut < 3
      set cut = 3
    .end
  .end

  # trim trailing separators again for dirname
  while cut > 1 && is_sep(*(p + (cut - 1)))
    set cut = cut - 1
  .end

  if cut == 0
    ret vec_push_byte(out, (U8)'.')
  .end

  ret vec_push_bytes(out, p, cut)
.end

# -----------------------------------------------------------------------------
# Extension / stem
# -----------------------------------------------------------------------------

fn path_extension(src: &Vec[U8], out: &Vec[U8]) -> Bool
  do vec_clear[U8](out)

  let base = vec_new[U8]()
  if !path_basename(src, &base)
    do vec_drop[U8](&base, 1)
    ret false
  .end

  if base.len == 0
    do vec_drop[U8](&base, 1)
    ret true
  .end

  let p = (Ptr[U8])base.data
  let i: I32
  set i = (I32)base.len - 1
  while i >= 0 && *(p + (USize)i) != (U8)'.'
    set i = i - 1
  .end

  # no dot or dot is first char -> no extension
  if i <= 0
    do vec_drop[U8](&base, 1)
    ret true
  .end

  let start: USize
  set start = (USize)i + 1
  let ok = vec_push_bytes(out, p + start, base.len - start)
  do vec_drop[U8](&base, 1)
  ret ok
.end

fn path_stem(src: &Vec[U8], out: &Vec[U8]) -> Bool
  do vec_clear[U8](out)

  let base = vec_new[U8]()
  if !path_basename(src, &base)
    do vec_drop[U8](&base, 1)
    ret false
  .end

  if base.len == 0
    do vec_drop[U8](&base, 1)
    ret true
  .end

  let p = (Ptr[U8])base.data
  let i: I32
  set i = (I32)base.len - 1
  while i >= 0 && *(p + (USize)i) != (U8)'.'
    set i = i - 1
  .end

  if i <= 0
    # no extension
    let ok = vec_assign_u8(out, &base)
    do vec_drop[U8](&base, 1)
    ret ok
  .end

  let ok2 = vec_push_bytes(out, p, (USize)i)
  do vec_drop[U8](&base, 1)
  ret ok2
.end

# -----------------------------------------------------------------------------
# PathBuf mutators
# -----------------------------------------------------------------------------

fn pathbuf_set(p: &PathBuf, v: &Vec[U8]) -> Bool
  ret vec_assign_u8(&p.bytes, v)
.end

fn pathbuf_push(p: &PathBuf, seg: &Vec[U8]) -> Bool
  let tmp = vec_new[U8]()
  let ok = path_join(&p.bytes, seg, &tmp)
  if !ok
    do vec_drop[U8](&tmp, 1)
    ret false
  .end
  let ok2 = vec_assign_u8(&p.bytes, &tmp)
  do vec_drop[U8](&tmp, 1)
  ret ok2
.end

fn pathbuf_pop(p: &PathBuf) -> Bool
  let d = vec_new[U8]()
  if !path_dirname(&p.bytes, &d)
    do vec_drop[U8](&d, 1)
    ret false
  .end
  let ok = vec_assign_u8(&p.bytes, &d)
  do vec_drop[U8](&d, 1)
  ret ok
.end

fn pathbuf_normalize(p: &PathBuf) -> Bool
  let tmp = vec_new[U8]()
  let ok = path_normalize(&p.bytes, &tmp)
  if !ok
    do vec_drop[U8](&tmp, 1)
    ret false
  .end
  let ok2 = vec_assign_u8(&p.bytes, &tmp)
  do vec_drop[U8](&tmp, 1)
  ret ok2
.end

# -----------------------------------------------------------------------------
# SocketAddr-like parsing for path (split at last separator)
# -----------------------------------------------------------------------------

# Split at last separator. Returns (has_parent, parent, name).
fn path_split_parent(src: &Vec[U8], parent: &Vec[U8], name: &Vec[U8]) -> Bool
  let ok = path_dirname(src, parent)
  if !ok
    ret false
  .end
  ret path_basename(src, name)
.end

# -----------------------------------------------------------------------------
# Tests (scenarios)
# -----------------------------------------------------------------------------

fn expect_eq(a: &Vec[U8], b: &Vec[U8], msg: Str)
  do assert(vec_eq_u8(a, b), msg)
.end

scn test_is_absolute
  let a = vec_from_cstr("/usr/bin")
  let b = vec_from_cstr("usr/bin")
  let c = vec_from_cstr("C:\\Windows")
  let d = vec_from_cstr("C:Windows")
  let e = vec_from_cstr("\\\\server\\share")

  do assert(path_is_absolute(&a), "abs posix")
  do assert(!path_is_absolute(&b), "rel posix")
  do assert(path_is_absolute(&c), "abs drive")
  do assert(!path_is_absolute(&d), "rel drive")
  do assert(path_is_absolute(&e), "unc")

  do vec_drop[U8](&a, 1)
  do vec_drop[U8](&b, 1)
  do vec_drop[U8](&c, 1)
  do vec_drop[U8](&d, 1)
  do vec_drop[U8](&e, 1)
.end

scn test_join
  let base = vec_from_cstr("/a/b/")
  let rhs  = vec_from_cstr("c/d")
  let out = vec_new[U8]()

  let ok = path_join(&base, &rhs, &out)
  do assert(ok, "join")

  let exp = vec_from_cstr("/a/b/c/d")
  do expect_eq(&out, &exp, "join eq")

  do vec_drop[U8](&base, 1)
  do vec_drop[U8](&rhs, 1)
  do vec_drop[U8](&out, 1)
  do vec_drop[U8](&exp, 1)
.end

scn test_normalize
  let src = vec_from_cstr("/a//b/./c/../d")
  let out = vec_new[U8]()
  let ok = path_normalize(&src, &out)
  do assert(ok, "norm")

  let exp = vec_from_cstr("/a/b/d")
  do expect_eq(&out, &exp, "norm eq")

  do vec_drop[U8](&src, 1)
  do vec_drop[U8](&out, 1)
  do vec_drop[U8](&exp, 1)
.end

scn test_dir_base_ext
  let src = vec_from_cstr("/a/b/file.tar.gz")
  let dir = vec_new[U8]()
  let base = vec_new[U8]()
  let ext = vec_new[U8]()
  let stem = vec_new[U8]()

  let ok: Bool
  set ok = path_dirname(&src, &dir)
  do assert(ok, "dirname")
  set ok = path_basename(&src, &base)
  do assert(ok, "basename")
  set ok = path_extension(&src, &ext)
  do assert(ok, "ext")
  set ok = path_stem(&src, &stem)
  do assert(ok, "stem")

  let exp_dir = vec_from_cstr("/a/b")
  let exp_base = vec_from_cstr("file.tar.gz")
  let exp_ext = vec_from_cstr("gz")
  let exp_stem = vec_from_cstr("file.tar")

  do expect_eq(&dir, &exp_dir, "dir eq")
  do expect_eq(&base, &exp_base, "base eq")
  do expect_eq(&ext, &exp_ext, "ext eq")
  do expect_eq(&stem, &exp_stem, "stem eq")

  do vec_drop[U8](&src, 1)
  do vec_drop[U8](&dir, 1)
  do vec_drop[U8](&base, 1)
  do vec_drop[U8](&ext, 1)
  do vec_drop[U8](&stem, 1)
  do vec_drop[U8](&exp_dir, 1)
  do vec_drop[U8](&exp_base, 1)
  do vec_drop[U8](&exp_ext, 1)
  do vec_drop[U8](&exp_stem, 1)
.end

scn test_pathbuf_ops
  let p = pathbuf_from_cstr("/a")
  let seg = vec_from_cstr("b")

  let ok = pathbuf_push(&p, &seg)
  do assert(ok, "push")

  let exp1 = vec_from_cstr("/a/b")
  do expect_eq(&p.bytes, &exp1, "push eq")

  do assert(pathbuf_pop(&p), "pop")
  let exp2 = vec_from_cstr("/a")
  do expect_eq(&p.bytes, &exp2, "pop eq")

  do vec_drop[U8](&seg, 1)
  do vec_drop[U8](&exp1, 1)
  do vec_drop[U8](&exp2, 1)
  do pathbuf_drop(&p)
.end

# End of std.path