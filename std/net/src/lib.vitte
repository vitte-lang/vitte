# -----------------------------------------------------------------------------
# std/net
# -----------------------------------------------------------------------------
# Bootstrap-friendly networking primitives.
#
# Scope:
# - data types: IpAddr, SocketAddr, DnsRecord
# - byte-order helpers (htons/ntohs/htonl/ntohl)
# - sockets API via runtime hooks (tcp/udp):
#   - socket/open/close/connect/bind/listen/accept
#   - send/recv with flags
#   - set_nonblocking, set_timeout
# - DNS resolve hook (runtime) + convenience connect helper
# - parsing/formatting helpers:
#   - IPv4 parse/format
#   - IPv6 parse/format (supports :: compression in parse; format is full)
#   - SocketAddr parse/format (IPv4: a.b.c.d:port, IPv6: [..]:port)
# - send_all / recv_exact helpers
#
# Constraints:
# - no direct syscalls here; runtime provides hooks
# - no TLS
# - no async
# - blocks use `.end` only
# - allocations are limited to Vec for buffers/results
# -----------------------------------------------------------------------------

module std.net

use std.collections

# -----------------------------------------------------------------------------
# Local prelude
# -----------------------------------------------------------------------------

type Bool = bool

type U8   = u8
type U16  = u16
type U32  = u32
type U64  = u64

type I32  = i32
type I64  = i64

type USize = usize

type Ptr[T] = ptr[T]

type Str = str

# -----------------------------------------------------------------------------
# Panic / assert stubs (bootstrapped by runtime if desired)
# -----------------------------------------------------------------------------

fn panic(msg: Str)
  ret
.end

fn assert(cond: Bool, msg: Str)
  if !cond
    do panic(msg)
  .end
.end

# -----------------------------------------------------------------------------
# Errors
# -----------------------------------------------------------------------------

type NetError enum
  Ok
  Invalid
  Unsupported
  OutOfMemory
  WouldBlock
  TimedOut
  Refused
  Reset
  NotConnected
  AddrInUse
  AddrNotAvail
  DnsFail
  Io
.end

# -----------------------------------------------------------------------------
# Protocol / socket kinds
# -----------------------------------------------------------------------------

type IpFamily enum
  V4
  V6
.end

type SockType enum
  Stream
  Datagram
.end

type SockProto enum
  Tcp
  Udp
.end

# -----------------------------------------------------------------------------
# Flags (best-effort; runtime may interpret differently)
# -----------------------------------------------------------------------------

const NET_FLAG_NONE:     U32 = 0
const NET_FLAG_PEEK:     U32 = 1
const NET_FLAG_DONTWAIT: U32 = 2

# -----------------------------------------------------------------------------
# Endianness helpers
# -----------------------------------------------------------------------------

fn bswap_u16(x: U16) -> U16
  ret (U16)(((x & 0x00ff) << 8) | ((x & 0xff00) >> 8))
.end

fn bswap_u32(x: U32) -> U32
  let v = x
  ret ((v & 0x000000ff) << 24) |
      ((v & 0x0000ff00) << 8) |
      ((v & 0x00ff0000) >> 8) |
      ((v & 0xff000000) >> 24)
.end

# Host endianness hook (bootstrap default: little endian)
fn rt_net_host_is_little_endian() -> Bool
  ret true
.end

fn htons(x: U16) -> U16
  if rt_net_host_is_little_endian()
    ret bswap_u16(x)
  .end
  ret x
.end

fn ntohs(x: U16) -> U16
  if rt_net_host_is_little_endian()
    ret bswap_u16(x)
  .end
  ret x
.end

fn htonl(x: U32) -> U32
  if rt_net_host_is_little_endian()
    ret bswap_u32(x)
  .end
  ret x
.end

fn ntohl(x: U32) -> U32
  if rt_net_host_is_little_endian()
    ret bswap_u32(x)
  .end
  ret x
.end

# -----------------------------------------------------------------------------
# Address types
# -----------------------------------------------------------------------------

type Ipv4Addr struct
  a: U8
  b: U8
  c: U8
  d: U8
.end

fn ipv4(a: U8, b: U8, c: U8, d: U8) -> Ipv4Addr
  let ip: Ipv4Addr
  set ip.a = a
  set ip.b = b
  set ip.c = c
  set ip.d = d
  ret ip
.end

fn ipv4_loopback() -> Ipv4Addr
  ret ipv4(127, 0, 0, 1)
.end

fn ipv4_any() -> Ipv4Addr
  ret ipv4(0, 0, 0, 0)
.end

# IPv6 is 16 raw bytes.

type Ipv6Addr struct
  bytes: [16]U8
.end

fn ipv6_zero() -> Ipv6Addr
  let ip: Ipv6Addr
  let i: USize
  set i = 0
  while i < 16
    set ip.bytes[i] = 0
    set i = i + 1
  .end
  ret ip
.end

# Tagged union style

type IpAddr struct
  family: IpFamily
  v4: Ipv4Addr
  v6: Ipv6Addr
.end

fn ipaddr_v4(v: Ipv4Addr) -> IpAddr
  let ip: IpAddr
  set ip.family = IpFamily::V4
  set ip.v4 = v
  ret ip
.end

fn ipaddr_v6(v: Ipv6Addr) -> IpAddr
  let ip: IpAddr
  set ip.family = IpFamily::V6
  set ip.v6 = v
  ret ip
.end

# Socket address

type SocketAddr struct
  ip: IpAddr
  port: U16
.end

fn sockaddr(ip: IpAddr, port: U16) -> SocketAddr
  let sa: SocketAddr
  set sa.ip = ip
  set sa.port = port
  ret sa
.end

fn sockaddr_v4(ip: Ipv4Addr, port: U16) -> SocketAddr
  ret sockaddr(ipaddr_v4(ip), port)
.end

fn sockaddr_v6(ip: Ipv6Addr, port: U16) -> SocketAddr
  ret sockaddr(ipaddr_v6(ip), port)
.end

# -----------------------------------------------------------------------------
# DNS record (minimal)
# -----------------------------------------------------------------------------

type DnsRecord struct
  addr: SocketAddr
  ttl_sec: U32
.end

# -----------------------------------------------------------------------------
# Socket handle
# -----------------------------------------------------------------------------

type Socket struct
  fd: I32
  kind: SockType
  proto: SockProto
  family: IpFamily
.end

fn socket_invalid() -> Socket
  let s: Socket
  set s.fd = -1
  set s.kind = SockType::Stream
  set s.proto = SockProto::Tcp
  set s.family = IpFamily::V4
  ret s
.end

fn socket_is_valid(s: Socket) -> Bool
  ret s.fd >= 0
.end

# -----------------------------------------------------------------------------
# Runtime syscall surface
# -----------------------------------------------------------------------------

# Conventions (recommended):
# - rc == 0: success
# - rc < 0: -N is an abstract error code mapped by map_rt_rc
# - send/recv return >=0 byte count on success, <0 on error

fn rt_net_socket(family: IpFamily, kind: SockType, proto: SockProto) -> I32
  ret -1
.end

fn rt_net_close(fd: I32) -> I32
  ret -1
.end

fn rt_net_connect(fd: I32, addr: &SocketAddr) -> I32
  ret -1
.end

fn rt_net_bind(fd: I32, addr: &SocketAddr) -> I32
  ret -1
.end

fn rt_net_listen(fd: I32, backlog: I32) -> I32
  ret -1
.end

fn rt_net_accept(fd: I32, out_addr: &SocketAddr) -> I32
  ret -1
.end

fn rt_net_send(fd: I32, data: Ptr[U8], len: USize, flags: U32) -> I64
  ret -1
.end

fn rt_net_recv(fd: I32, dst: Ptr[U8], len: USize, flags: U32) -> I64
  ret -1
.end

fn rt_net_set_nonblocking(fd: I32, on: Bool) -> I32
  ret -1
.end

fn rt_net_set_timeout_ms(fd: I32, read_ms: I32, write_ms: I32) -> I32
  ret -1
.end

# DNS resolve: returns count, writes up to max records into out array.
fn rt_net_dns_resolve(host: Str, port: U16, out: Ptr[DnsRecord], max: USize) -> I32
  ret -1
.end

# -----------------------------------------------------------------------------
# Error mapping
# -----------------------------------------------------------------------------

# Default mapping for abstract negative rc values.
# Runtime should standardize codes if it wants richer behavior.
fn map_rt_rc(rc: I32) -> NetError
  if rc == 0
    ret NetError::Ok
  .end
  if rc == -2
    ret NetError::WouldBlock
  .end
  if rc == -3
    ret NetError::TimedOut
  .end
  if rc == -4
    ret NetError::Refused
  .end
  if rc == -5
    ret NetError::Reset
  .end
  if rc == -6
    ret NetError::NotConnected
  .end
  if rc == -7
    ret NetError::AddrInUse
  .end
  if rc == -8
    ret NetError::AddrNotAvail
  .end
  if rc == -9
    ret NetError::Unsupported
  .end
  if rc == -12
    ret NetError::OutOfMemory
  .end
  ret NetError::Io
.end

fn map_rt_i64(n: I64) -> (Bool, NetError, USize)
  if n >= 0
    ret (true, NetError::Ok, (USize)n)
  .end
  ret (false, map_rt_rc((I32)n), 0)
.end

# -----------------------------------------------------------------------------
# High-level socket API
# -----------------------------------------------------------------------------

fn net_socket(family: IpFamily, kind: SockType, proto: SockProto) -> (Bool, NetError, Socket)
  let s = socket_invalid()

  let fd = rt_net_socket(family, kind, proto)
  if fd < 0
    ret (false, map_rt_rc(fd), s)
  .end

  set s.fd = fd
  set s.family = family
  set s.kind = kind
  set s.proto = proto

  ret (true, NetError::Ok, s)
.end

fn net_close(s: &Socket) -> (Bool, NetError)
  if s.fd < 0
    ret (true, NetError::Ok)
  .end

  let rc = rt_net_close(s.fd)
  let e = map_rt_rc(rc)
  if e != NetError::Ok
    ret (false, e)
  .end

  set s.fd = -1
  ret (true, NetError::Ok)
.end

fn net_connect(s: &Socket, addr: &SocketAddr) -> (Bool, NetError)
  if s.fd < 0
    ret (false, NetError::Invalid)
  .end
  let rc = rt_net_connect(s.fd, addr)
  let e = map_rt_rc(rc)
  if e != NetError::Ok
    ret (false, e)
  .end
  ret (true, NetError::Ok)
.end

fn net_bind(s: &Socket, addr: &SocketAddr) -> (Bool, NetError)
  if s.fd < 0
    ret (false, NetError::Invalid)
  .end
  let rc = rt_net_bind(s.fd, addr)
  let e = map_rt_rc(rc)
  if e != NetError::Ok
    ret (false, e)
  .end
  ret (true, NetError::Ok)
.end

fn net_listen(s: &Socket, backlog: I32) -> (Bool, NetError)
  if s.fd < 0
    ret (false, NetError::Invalid)
  .end
  let rc = rt_net_listen(s.fd, backlog)
  let e = map_rt_rc(rc)
  if e != NetError::Ok
    ret (false, e)
  .end
  ret (true, NetError::Ok)
.end

fn net_accept(s: &Socket) -> (Bool, NetError, Socket, SocketAddr)
  let child = socket_invalid()
  let addr: SocketAddr

  if s.fd < 0
    ret (false, NetError::Invalid, child, addr)
  .end

  let fd2 = rt_net_accept(s.fd, &addr)
  if fd2 < 0
    ret (false, map_rt_rc(fd2), child, addr)
  .end

  set child.fd = fd2
  set child.family = s.family
  set child.kind = s.kind
  set child.proto = s.proto

  ret (true, NetError::Ok, child, addr)
.end

fn net_send(s: &Socket, data: &Vec[U8], flags: U32) -> (Bool, NetError, USize)
  if s.fd < 0
    ret (false, NetError::Invalid, 0)
  .end

  if data.len == 0
    ret (true, NetError::Ok, 0)
  .end

  let ok: Bool
  let e: NetError
  let n: USize
  (ok, e, n) = map_rt_i64(rt_net_send(s.fd, (Ptr[U8])data.data, data.len, flags))
  if !ok
    ret (false, e, 0)
  .end
  ret (true, NetError::Ok, n)
.end

# Receive into out (cleared). Returns number of bytes appended.
fn net_recv(s: &Socket, out: &Vec[U8], max_bytes: USize, flags: U32) -> (Bool, NetError, USize)
  do vec_clear[U8](out)

  if s.fd < 0
    ret (false, NetError::Invalid, 0)
  .end

  if max_bytes == 0
    ret (true, NetError::Ok, 0)
  .end

  # Allocate temp buffer; copy only n bytes into out.
  let tmp = vec_new[U8]()
  let ok: Bool
  let e: ColError
  (ok, e) = vec_reserve_bytes[U8](&tmp, 1, max_bytes)
  if !ok
    ret (false, NetError::OutOfMemory, 0)
  .end

  let i: USize
  set i = 0
  while i < max_bytes
    (ok, e) = vec_push[U8](&tmp, 1, 0)
    if !ok
      do vec_drop[U8](&tmp, 1)
      ret (false, NetError::OutOfMemory, 0)
    .end
    set i = i + 1
  .end

  let ok2: Bool
  let e2: NetError
  let n: USize
  (ok2, e2, n) = map_rt_i64(rt_net_recv(s.fd, (Ptr[U8])tmp.data, max_bytes, flags))
  if !ok2
    do vec_drop[U8](&tmp, 1)
    ret (false, e2, 0)
  .end

  let j: USize
  set j = 0
  while j < n
    (ok, e) = vec_push[U8](out, 1, *((Ptr[U8])tmp.data + j))
    if !ok
      do vec_drop[U8](&tmp, 1)
      ret (false, NetError::OutOfMemory, 0)
    .end
    set j = j + 1
  .end

  do vec_drop[U8](&tmp, 1)
  ret (true, NetError::Ok, n)
.end

fn net_set_nonblocking(s: &Socket, on: Bool) -> (Bool, NetError)
  if s.fd < 0
    ret (false, NetError::Invalid)
  .end
  let rc = rt_net_set_nonblocking(s.fd, on)
  let e = map_rt_rc(rc)
  if e != NetError::Ok
    ret (false, e)
  .end
  ret (true, NetError::Ok)
.end

fn net_set_timeout_ms(s: &Socket, read_ms: I32, write_ms: I32) -> (Bool, NetError)
  if s.fd < 0
    ret (false, NetError::Invalid)
  .end
  let rc = rt_net_set_timeout_ms(s.fd, read_ms, write_ms)
  let e = map_rt_rc(rc)
  if e != NetError::Ok
    ret (false, e)
  .end
  ret (true, NetError::Ok)
.end

# Send entire buffer (loops until fully sent or error).
fn net_send_all(s: &Socket, data: &Vec[U8], flags: U32) -> (Bool, NetError)
  if data.len == 0
    ret (true, NetError::Ok)
  .end

  let off: USize
  set off = 0
  let p = (Ptr[U8])data.data

  loop
    if off >= data.len
      break
    .end

    let ok: Bool
    let e: NetError
    let n: USize
    (ok, e, n) = map_rt_i64(rt_net_send(s.fd, p + off, data.len - off, flags))
    if !ok
      ret (false, e)
    .end
    if n == 0
      ret (false, NetError::Io)
    .end

    set off = off + n
  .end

  ret (true, NetError::Ok)
.end

# Receive exactly n bytes (appends into out). Uses internal chunk size.
fn net_recv_exact(s: &Socket, out: &Vec[U8], need: USize, flags: U32) -> (Bool, NetError)
  do vec_clear[U8](out)

  if need == 0
    ret (true, NetError::Ok)
  .end

  let chunk: USize
  set chunk = 4096

  let got: USize
  set got = 0

  loop
    if got >= need
      break
    .end

    let want = need - got
    let step: USize
    if want < chunk
      set step = want
    else
      set step = chunk
    .end

    let tmp = vec_new[U8]()
    let ok: Bool
    let e: ColError
    (ok, e) = vec_reserve_bytes[U8](&tmp, 1, step)
    if !ok
      ret (false, NetError::OutOfMemory)
    .end

    let i: USize
    set i = 0
    while i < step
      (ok, e) = vec_push[U8](&tmp, 1, 0)
      if !ok
        do vec_drop[U8](&tmp, 1)
        ret (false, NetError::OutOfMemory)
      .end
      set i = i + 1
    .end

    let ok2: Bool
    let e2: NetError
    let n: USize
    (ok2, e2, n) = map_rt_i64(rt_net_recv(s.fd, (Ptr[U8])tmp.data, step, flags))
    if !ok2
      do vec_drop[U8](&tmp, 1)
      ret (false, e2)
    .end

    if n == 0
      do vec_drop[U8](&tmp, 1)
      ret (false, NetError::Io)
    .end

    let j: USize
    set j = 0
    while j < n
      (ok, e) = vec_push[U8](out, 1, *((Ptr[U8])tmp.data + j))
      if !ok
        do vec_drop[U8](&tmp, 1)
        ret (false, NetError::OutOfMemory)
      .end
      set j = j + 1
    .end

    do vec_drop[U8](&tmp, 1)
    set got = got + n
  .end

  ret (true, NetError::Ok)
.end

# -----------------------------------------------------------------------------
# DNS
# -----------------------------------------------------------------------------

fn dns_resolve(host: Str, port: U16, out: &Vec[DnsRecord], max: USize) -> (Bool, NetError, USize)
  do vec_clear[DnsRecord](out)

  if max == 0
    ret (false, NetError::Invalid, 0)
  .end

  # allocate temp array of records by pushing defaults
  let tmp = vec_new[DnsRecord]()

  let i: USize
  set i = 0
  while i < max
    let r: DnsRecord
    set r.ttl_sec = 0
    set r.addr = sockaddr_v4(ipv4_any(), port)

    let ok: Bool
    let e: ColError
    (ok, e) = vec_push[DnsRecord](&tmp, 0, r)
    if !ok
      do vec_drop[DnsRecord](&tmp, 0)
      ret (false, NetError::OutOfMemory, 0)
    .end

    set i = i + 1
  .end

  let n = rt_net_dns_resolve(host, port, (Ptr[DnsRecord])tmp.data, max)
  if n < 0
    do vec_drop[DnsRecord](&tmp, 0)
    ret (false, NetError::DnsFail, 0)
  .end

  # copy first n records into out
  let k: USize
  set k = 0
  while k < (USize)n
    let ok: Bool
    let e: ColError
    (ok, e) = vec_push[DnsRecord](out, 0, *((Ptr[DnsRecord])tmp.data + k))
    if !ok
      do vec_drop[DnsRecord](&tmp, 0)
      ret (false, NetError::OutOfMemory, 0)
    .end
    set k = k + 1
  .end

  do vec_drop[DnsRecord](&tmp, 0)
  ret (true, NetError::Ok, (USize)n)
.end

# Convenience: resolve first record then connect TCP.
fn tcp_connect_host(host: Str, port: U16) -> (Bool, NetError, Socket)
  let s = socket_invalid()

  let addrs = vec_new[DnsRecord]()
  let ok: Bool
  let e: NetError
  let n: USize
  (ok, e, n) = dns_resolve(host, port, &addrs, 8)
  if !ok
    do vec_drop[DnsRecord](&addrs, 0)
    ret (false, e, s)
  .end
  if n == 0
    do vec_drop[DnsRecord](&addrs, 0)
    ret (false, NetError::DnsFail, s)
  .end

  let first = *((Ptr[DnsRecord])addrs.data + 0)

  let ok2: Bool
  let e2: NetError
  (ok2, e2, s) = net_socket(first.addr.ip.family, SockType::Stream, SockProto::Tcp)
  if !ok2
    do vec_drop[DnsRecord](&addrs, 0)
    ret (false, e2, s)
  .end

  (ok2, e2) = net_connect(&s, &first.addr)
  do vec_drop[DnsRecord](&addrs, 0)
  if !ok2
    do net_close(&s)
    ret (false, e2, s)
  .end

  ret (true, NetError::Ok, s)
.end

# -----------------------------------------------------------------------------
# ASCII parsing helpers
# -----------------------------------------------------------------------------

fn is_digit(b: U8) -> Bool
  ret b >= (U8)'0' && b <= (U8)'9'
.end

fn hex_val(b: U8) -> (Bool, U8)
  if b >= (U8)'0' && b <= (U8)'9'
    ret (true, b - (U8)'0')
  .end
  if b >= (U8)'a' && b <= (U8)'f'
    ret (true, (U8)10 + (b - (U8)'a'))
  .end
  if b >= (U8)'A' && b <= (U8)'F'
    ret (true, (U8)10 + (b - (U8)'A'))
  .end
  ret (false, 0)
.end

fn parse_u16_dec(p: Ptr[U8], len: USize) -> (Bool, U16)
  if len == 0
    ret (false, 0)
  .end
  let i: USize
  set i = 0
  let acc: U32
  set acc = 0
  while i < len
    let ch = *(p + i)
    if !is_digit(ch)
      ret (false, 0)
    .end
    set acc = acc * 10 + (U32)(ch - (U8)'0')
    if acc > 65535
      ret (false, 0)
    .end
    set i = i + 1
  .end
  ret (true, (U16)acc)
.end

fn parse_u8_dec(p: Ptr[U8], len: USize) -> (Bool, U8)
  let ok: Bool
  let v16: U16
  (ok, v16) = parse_u16_dec(p, len)
  if !ok || v16 > 255
    ret (false, 0)
  .end
  ret (true, (U8)v16)
.end

fn parse_u16_hex(p: Ptr[U8], len: USize) -> (Bool, U16)
  if len == 0 || len > 4
    ret (false, 0)
  .end

  let i: USize
  set i = 0
  let acc: U32
  set acc = 0

  while i < len
    let ch = *(p + i)
    let ok: Bool
    let hv: U8
    (ok, hv) = hex_val(ch)
    if !ok
      ret (false, 0)
    .end
    set acc = (acc << 4) | (U32)hv
    set i = i + 1
  .end

  ret (true, (U16)acc)
.end

# Minimal helper to build Vec[U8] from a NUL-terminated string literal.
fn vec_from_cstr(s: Str) -> Vec[U8]
  let v = vec_new[U8]()
  let p = (Ptr[U8])s
  let i: USize
  set i = 0
  loop
    let b = *(p + i)
    if b == 0
      break
    .end
    let ok: Bool
    let e: ColError
    (ok, e) = vec_push[U8](&v, 1, b)
    if !ok
      do vec_drop[U8](&v, 1)
      ret vec_new[U8]()
    .end
    set i = i + 1
  .end
  ret v
.end

# -----------------------------------------------------------------------------
# IPv4 parsing/formatting
# -----------------------------------------------------------------------------

fn ipv4_parse_ascii(s: &Vec[U8]) -> (Bool, NetError, Ipv4Addr)
  let ip = ipv4(0,0,0,0)

  if s.len < 7
    ret (false, NetError::Invalid, ip)
  .end

  let p = (Ptr[U8])s.data
  let i: USize
  set i = 0

  let vals: [4]U8
  let count: USize
  set count = 0

  let start: USize
  set start = 0

  while i <= s.len
    if i == s.len || *(p + i) == (U8)'.'
      let seg_len = i - start
      let ok: Bool
      let v: U8
      (ok, v) = parse_u8_dec(p + start, seg_len)
      if !ok
        ret (false, NetError::Invalid, ip)
      .end
      if count >= 4
        ret (false, NetError::Invalid, ip)
      .end
      set vals[count] = v
      set count = count + 1
      set start = i + 1
    .end
    set i = i + 1
  .end

  if count != 4
    ret (false, NetError::Invalid, ip)
  .end

  set ip.a = vals[0]
  set ip.b = vals[1]
  set ip.c = vals[2]
  set ip.d = vals[3]

  ret (true, NetError::Ok, ip)
.end

fn push_dec_u8(out: &Vec[U8], x: U8) -> (Bool, NetError)
  let v: U32
  set v = (U32)x

  let d0: U8
  let d1: U8
  let d2: U8

  set d0 = (U8)'0' + (U8)(v % 10)
  set v = v / 10
  set d1 = (U8)'0' + (U8)(v % 10)
  set v = v / 10
  set d2 = (U8)'0' + (U8)(v % 10)

  let ok: Bool
  let e: ColError

  if x >= 100
    (ok, e) = vec_push[U8](out, 1, d2)
    if !ok
      ret (false, NetError::OutOfMemory)
    .end
    (ok, e) = vec_push[U8](out, 1, d1)
    if !ok
      ret (false, NetError::OutOfMemory)
    .end
    (ok, e) = vec_push[U8](out, 1, d0)
    if !ok
      ret (false, NetError::OutOfMemory)
    .end
  elif x >= 10
    (ok, e) = vec_push[U8](out, 1, d1)
    if !ok
      ret (false, NetError::OutOfMemory)
    .end
    (ok, e) = vec_push[U8](out, 1, d0)
    if !ok
      ret (false, NetError::OutOfMemory)
    .end
  else
    (ok, e) = vec_push[U8](out, 1, d0)
    if !ok
      ret (false, NetError::OutOfMemory)
    .end
  .end

  ret (true, NetError::Ok)
.end

fn ipv4_format_ascii(ip: Ipv4Addr, out: &Vec[U8]) -> (Bool, NetError)
  do vec_clear[U8](out)

  let ok: Bool
  let e: NetError

  (ok, e) = push_dec_u8(out, ip.a)
  if !ok
    ret (false, e)
  .end

  let ok2: Bool
  let ce: ColError
  (ok2, ce) = vec_push[U8](out, 1, (U8)'.')
  if !ok2
    ret (false, NetError::OutOfMemory)
  .end

  (ok, e) = push_dec_u8(out, ip.b)
  if !ok
    ret (false, e)
  .end

  (ok2, ce) = vec_push[U8](out, 1, (U8)'.')
  if !ok2
    ret (false, NetError::OutOfMemory)
  .end

  (ok, e) = push_dec_u8(out, ip.c)
  if !ok
    ret (false, e)
  .end

  (ok2, ce) = vec_push[U8](out, 1, (U8)'.')
  if !ok2
    ret (false, NetError::OutOfMemory)
  .end

  (ok, e) = push_dec_u8(out, ip.d)
  if !ok
    ret (false, e)
  .end

  ret (true, NetError::Ok)
.end

# -----------------------------------------------------------------------------
# IPv6 parsing/formatting
# -----------------------------------------------------------------------------

fn ipv6_parse_ascii(s: &Vec[U8]) -> (Bool, NetError, Ipv6Addr)
  let ip = ipv6_zero()

  if s.len == 0
    ret (false, NetError::Invalid, ip)
  .end

  let p = (Ptr[U8])s.data
  let i: USize
  set i = 0

  let parts: [8]U16
  let count: USize
  set count = 0

  let compress_at: I32
  set compress_at = -1

  # special case: leading ::
  if s.len >= 2 && *(p + 0) == (U8)':' && *(p + 1) == (U8)':'
    set compress_at = 0
    set i = 2
    if i == s.len
      ret (true, NetError::Ok, ip)
    .end
  .end

  let start: USize
  set start = i

  while i <= s.len
    if i == s.len || *(p + i) == (U8)':'
      let seg_len = i - start
      if seg_len == 0
        # must be ::
        if i + 1 < s.len && *(p + i) == (U8)':' && *(p + i + 1) == (U8)':'
          if compress_at != -1
            ret (false, NetError::Invalid, ip)
          .end
          set compress_at = (I32)count
          set i = i + 2
          set start = i
          if i == s.len
            break
          .end
          continue
        .end
        ret (false, NetError::Invalid, ip)
      .end

      if count >= 8
        ret (false, NetError::Invalid, ip)
      .end

      let ok: Bool
      let v: U16
      (ok, v) = parse_u16_hex(p + start, seg_len)
      if !ok
        ret (false, NetError::Invalid, ip)
      .end

      set parts[count] = v
      set count = count + 1

      if i == s.len
        break
      .end

      # handle ::
      if i + 1 < s.len && *(p + i) == (U8)':' && *(p + i + 1) == (U8)':'
        if compress_at != -1
          ret (false, NetError::Invalid, ip)
        .end
        set compress_at = (I32)count
        set i = i + 2
        set start = i
        if i == s.len
          break
        .end
        continue
      .end

      set i = i + 1
      set start = i
      continue
    .end

    set i = i + 1
  .end

  # expand ::
  if compress_at != -1
    let missing: I32
    set missing = (I32)(8 - count)
    if missing < 0
      ret (false, NetError::Invalid, ip)
    .end

    let t: I32
    set t = (I32)count - 1
    while t >= compress_at
      set parts[(USize)(t + missing)] = parts[(USize)t]
      set t = t - 1
    .end

    let z: I32
    set z = 0
    while z < missing
      set parts[(USize)(compress_at + z)] = 0
      set z = z + 1
    .end

    set count = 8
  .end

  if count != 8
    ret (false, NetError::Invalid, ip)
  .end

  let j: USize
  set j = 0
  while j < 8
    let w = parts[j]
    set ip.bytes[j * 2 + 0] = (U8)((w >> 8) & 0xff)
    set ip.bytes[j * 2 + 1] = (U8)(w & 0xff)
    set j = j + 1
  .end

  ret (true, NetError::Ok, ip)
.end

fn push_hex_u16(out: &Vec[U8], x: U16) -> (Bool, NetError)
  let ok: Bool
  let e: ColError

  if x == 0
    (ok, e) = vec_push[U8](out, 1, (U8)'0')
    if !ok
      ret (false, NetError::OutOfMemory)
    .end
    ret (true, NetError::Ok)
  .end

  let started: Bool
  set started = false

  let shift: I32
  set shift = 12

  while shift >= 0
    let nib = (U8)((x >> (U16)shift) & 0x0f)
    if nib != 0 || started
      set started = true
      let ch: U8
      if nib < 10
        set ch = (U8)'0' + nib
      else
        set ch = (U8)'a' + (nib - (U8)10)
      .end
      (ok, e) = vec_push[U8](out, 1, ch)
      if !ok
        ret (false, NetError::OutOfMemory)
      .end
    .end
    set shift = shift - 4
  .end

  ret (true, NetError::Ok)
.end

fn ipv6_format_ascii(ip: Ipv6Addr, out: &Vec[U8]) -> (Bool, NetError)
  do vec_clear[U8](out)

  let i: USize
  set i = 0
  while i < 8
    let hi = (U16)ip.bytes[i * 2 + 0]
    let lo = (U16)ip.bytes[i * 2 + 1]
    let w = (hi << 8) | lo

    let ok: Bool
    let e: NetError
    (ok, e) = push_hex_u16(out, w)
    if !ok
      ret (false, e)
    .end

    if i != 7
      let ok2: Bool
      let ce: ColError
      (ok2, ce) = vec_push[U8](out, 1, (U8)':')
      if !ok2
        ret (false, NetError::OutOfMemory)
      .end
    .end

    set i = i + 1
  .end

  ret (true, NetError::Ok)
.end

# -----------------------------------------------------------------------------
# SocketAddr parse/format
# -----------------------------------------------------------------------------

fn sockaddr_parse_ascii(s: &Vec[U8]) -> (Bool, NetError, SocketAddr)
  let sa: SocketAddr
  set sa.port = 0
  set sa.ip.family = IpFamily::V4
  set sa.ip.v4 = ipv4_any()

  if s.len == 0
    ret (false, NetError::Invalid, sa)
  .end

  let p = (Ptr[U8])s.data

  # IPv6 form: [addr]:port
  if *(p + 0) == (U8)'['
    let i: USize
    set i = 1
    while i < s.len && *(p + i) != (U8)']'
      set i = i + 1
    .end
    if i >= s.len
      ret (false, NetError::Invalid, sa)
    .end

    let inner = vec_new[U8]()
    let ok: Bool
    let e: ColError
    let j: USize
    set j = 1
    while j < i
      (ok, e) = vec_push[U8](&inner, 1, *(p + j))
      if !ok
        do vec_drop[U8](&inner, 1)
        ret (false, NetError::OutOfMemory, sa)
      .end
      set j = j + 1
    .end

    if i + 1 >= s.len || *(p + i + 1) != (U8)':'
      do vec_drop[U8](&inner, 1)
      ret (false, NetError::Invalid, sa)
    .end

    let ok2: Bool
    let ne: NetError
    let ip6: Ipv6Addr
    (ok2, ne, ip6) = ipv6_parse_ascii(&inner)
    do vec_drop[U8](&inner, 1)
    if !ok2
      ret (false, ne, sa)
    .end

    let ok3: Bool
    let port: U16
    (ok3, port) = parse_u16_dec(p + (i + 2), s.len - (i + 2))
    if !ok3
      ret (false, NetError::Invalid, sa)
    .end

    set sa.ip = ipaddr_v6(ip6)
    set sa.port = port
    ret (true, NetError::Ok, sa)
  .end

  # IPv4 form: find last ':'
  let k: I32
  set k = (I32)s.len - 1
  let sep: I32
  set sep = -1
  while k >= 0
    if *(p + (USize)k) == (U8)':'
      set sep = k
      break
    .end
    set k = k - 1
  .end
  if sep == -1
    ret (false, NetError::Invalid, sa)
  .end

  let ipbuf = vec_new[U8]()
  let ok: Bool
  let e: ColError
  let i: USize
  set i = 0
  while i < (USize)sep
    (ok, e) = vec_push[U8](&ipbuf, 1, *(p + i))
    if !ok
      do vec_drop[U8](&ipbuf, 1)
      ret (false, NetError::OutOfMemory, sa)
    .end
    set i = i + 1
  .end

  let ok2: Bool
  let ne: NetError
  let ip4: Ipv4Addr
  (ok2, ne, ip4) = ipv4_parse_ascii(&ipbuf)
  do vec_drop[U8](&ipbuf, 1)
  if !ok2
    ret (false, ne, sa)
  .end

  let ok3: Bool
  let port: U16
  (ok3, port) = parse_u16_dec(p + (USize)sep + 1, s.len - ((USize)sep + 1))
  if !ok3
    ret (false, NetError::Invalid, sa)
  .end

  set sa.ip = ipaddr_v4(ip4)
  set sa.port = port
  ret (true, NetError::Ok, sa)
.end

fn sockaddr_format_ascii(sa: SocketAddr, out: &Vec[U8]) -> (Bool, NetError)
  do vec_clear[U8](out)

  let ok: Bool
  let e: NetError

  if sa.ip.family == IpFamily::V4
    (ok, e) = ipv4_format_ascii(sa.ip.v4, out)
    if !ok
      ret (false, e)
    .end

    let ok2: Bool
    let ce: ColError
    (ok2, ce) = vec_push[U8](out, 1, (U8)':')
    if !ok2
      ret (false, NetError::OutOfMemory)
    .end

    let portv = sa.port

    let ptmp: [5]U8
    let n: USize
    set n = 0

    let v: U32
    set v = (U32)portv

    if v == 0
      (ok2, ce) = vec_push[U8](out, 1, (U8)'0')
      if !ok2
        ret (false, NetError::OutOfMemory)
      .end
      ret (true, NetError::Ok)
    .end

    while v != 0 && n < 5
      set ptmp[n] = (U8)'0' + (U8)(v % 10)
      set v = v / 10
      set n = n + 1
    .end

    let i: I32
    set i = (I32)n - 1
    while i >= 0
      (ok2, ce) = vec_push[U8](out, 1, ptmp[(USize)i])
      if !ok2
        ret (false, NetError::OutOfMemory)
      .end
      set i = i - 1
    .end

    ret (true, NetError::Ok)
  .end

  # IPv6: [addr]:port
  let ok2: Bool
  let ce: ColError
  (ok2, ce) = vec_push[U8](out, 1, (U8)'[')
  if !ok2
    ret (false, NetError::OutOfMemory)
  .end

  let tmp = vec_new[U8]()
  (ok, e) = ipv6_format_ascii(sa.ip.v6, &tmp)
  if !ok
    do vec_drop[U8](&tmp, 1)
    ret (false, e)
  .end

  let i: USize
  set i = 0
  while i < tmp.len
    (ok2, ce) = vec_push[U8](out, 1, *((Ptr[U8])tmp.data + i))
    if !ok2
      do vec_drop[U8](&tmp, 1)
      ret (false, NetError::OutOfMemory)
    .end
    set i = i + 1
  .end
  do vec_drop[U8](&tmp, 1)

  (ok2, ce) = vec_push[U8](out, 1, (U8)']')
  if !ok2
    ret (false, NetError::OutOfMemory)
  .end
  (ok2, ce) = vec_push[U8](out, 1, (U8)':')
  if !ok2
    ret (false, NetError::OutOfMemory)
  .end

  let portv = sa.port

  let ptmp: [5]U8
  let n: USize
  set n = 0

  let v: U32
  set v = (U32)portv

  if v == 0
    (ok2, ce) = vec_push[U8](out, 1, (U8)'0')
    if !ok2
      ret (false, NetError::OutOfMemory)
    .end
    ret (true, NetError::Ok)
  .end

  while v != 0 && n < 5
    set ptmp[n] = (U8)'0' + (U8)(v % 10)
    set v = v / 10
    set n = n + 1
  .end

  let j: I32
  set j = (I32)n - 1
  while j >= 0
    (ok2, ce) = vec_push[U8](out, 1, ptmp[(USize)j])
    if !ok2
      ret (false, NetError::OutOfMemory)
    .end
    set j = j - 1
  .end

  ret (true, NetError::Ok)
.end

# -----------------------------------------------------------------------------
# Tests (scenarios)
# -----------------------------------------------------------------------------

scn test_ipv4_parse_format
  let s = vec_from_cstr("192.168.0.1")

  let ok: Bool
  let ne: NetError
  let ip: Ipv4Addr
  (ok, ne, ip) = ipv4_parse_ascii(&s)
  do assert(ok, "parse")

  let out = vec_new[U8]()
  (ok, ne) = ipv4_format_ascii(ip, &out)
  do assert(ok, "format")

  do assert(out.len == s.len, "len")

  let i: USize
  set i = 0
  let sp = (Ptr[U8])s.data
  let op = (Ptr[U8])out.data
  while i < s.len
    do assert(*(sp + i) == *(op + i), "byte")
    set i = i + 1
  .end

  do vec_drop[U8](&s, 1)
  do vec_drop[U8](&out, 1)
.end

scn test_ipv6_parse_format
  let s = vec_from_cstr("2001:db8:0:0:0:0:0:1")

  let ok: Bool
  let ne: NetError
  let ip: Ipv6Addr
  (ok, ne, ip) = ipv6_parse_ascii(&s)
  do assert(ok, "ipv6 parse")

  let out = vec_new[U8]()
  (ok, ne) = ipv6_format_ascii(ip, &out)
  do assert(ok, "ipv6 format")

  let ip2: Ipv6Addr
  (ok, ne, ip2) = ipv6_parse_ascii(&out)
  do assert(ok, "ipv6 parse2")

  let i: USize
  set i = 0
  while i < 16
    do assert(ip.bytes[i] == ip2.bytes[i], "ipv6 byte")
    set i = i + 1
  .end

  do vec_drop[U8](&s, 1)
  do vec_drop[U8](&out, 1)
.end

scn test_ipv6_parse_compressed
  let s = vec_from_cstr("2001:db8::1")

  let ok: Bool
  let ne: NetError
  let ip: Ipv6Addr
  (ok, ne, ip) = ipv6_parse_ascii(&s)
  do assert(ok, "ipv6 :: parse")

  do vec_drop[U8](&s, 1)
.end

scn test_sockaddr_parse_format_v4
  let s = vec_from_cstr("127.0.0.1:8080")

  let ok: Bool
  let ne: NetError
  let sa: SocketAddr
  (ok, ne, sa) = sockaddr_parse_ascii(&s)
  do assert(ok, "sa parse v4")

  let out = vec_new[U8]()
  (ok, ne) = sockaddr_format_ascii(sa, &out)
  do assert(ok, "sa format v4")

  let sa2: SocketAddr
  (ok, ne, sa2) = sockaddr_parse_ascii(&out)
  do assert(ok, "sa parse2 v4")

  do assert(sa2.ip.family == IpFamily::V4, "family")
  do assert(sa2.port == 8080, "port")

  do vec_drop[U8](&s, 1)
  do vec_drop[U8](&out, 1)
.end

scn test_sockaddr_parse_format_v6
  let s = vec_from_cstr("[2001:db8::1]:443")

  let ok: Bool
  let ne: NetError
  let sa: SocketAddr
  (ok, ne, sa) = sockaddr_parse_ascii(&s)
  do assert(ok, "sa parse v6")

  let out = vec_new[U8]()
  (ok, ne) = sockaddr_format_ascii(sa, &out)
  do assert(ok, "sa format v6")

  let sa2: SocketAddr
  (ok, ne, sa2) = sockaddr_parse_ascii(&out)
  do assert(ok, "sa parse2 v6")

  do assert(sa2.ip.family == IpFamily::V6, "family6")
  do assert(sa2.port == 443, "port6")

  do vec_drop[U8](&s, 1)
  do vec_drop[U8](&out, 1)
.end

scn test_endianness_helpers
  do assert(bswap_u16(0x1234) == 0x3412, "bswap16")
  do assert(bswap_u32(0x11223344) == 0x44332211, "bswap32")
.end

# End of std.net