# /Users/vincent/Documents/Github/vitte/std/io/src/reader.vitte
# -----------------------------------------------------------------------------
# std/io/reader
# -----------------------------------------------------------------------------
# Reader interface + helpers (read_exact, read_to_end, read_uXX, read_line).
#
# MAX goals:
# - Minimal ABI-friendly Reader interface (function-table + ctx).
# - High-level helpers implemented in pure Vitte.
# - In-memory CursorReader implementation for tests and adapters.
# - Zero syscalls here: depends only on core/runtime/string.
#
# Conventions:
# - 0 bytes read => EOF (not an error unless read_exact).
# - All blocks use `.end` only (no braces).
# -----------------------------------------------------------------------------

module std.io.reader

use std.runtime
use std.core.result
use std.string

type Bool = bool
type U8   = u8
type U16  = u16
type U32  = u32
type U64  = u64
type I32  = i32
type Str  = str

# -----------------------------------------------------------------------------
# Byte slice model
# -----------------------------------------------------------------------------
# NOTE:
# - This std snapshot uses `str` as the transport for raw bytes (UTF-8 not required).
# - If your core has u8 slices, swap ByteSlice to u8[] views.

type ByteSlice struct
  data: Str
  len: U32
.end

fn bytes_empty() -> ByteSlice
  let b: ByteSlice
  set b.data = ""
  set b.len = 0
  ret b
.end

fn bytes_from_str(s: Str) -> ByteSlice
  let b: ByteSlice
  set b.data = s
  set b.len = std.string::len(s)
  ret b
.end

fn bytes_take(b: &ByteSlice, start: U32, n: U32) -> ByteSlice
  let out: ByteSlice
  if start >= b.len
    set out.data = ""
    set out.len = 0
    ret out
  .end
  let avail = b.len - start
  let take = n
  if take > avail
    set take = avail
  .end
  set out.data = std.string::slice(b.data, start, take)
  set out.len = take
  ret out
.end

# -----------------------------------------------------------------------------
# Reader interface (function-table + context)
# -----------------------------------------------------------------------------

type ReadResult struct
  ok: Bool
  n: U32
  chunk: ByteSlice
  err: std.core.result::Error
.end

# Reader is an ABI-stable interface:
# - ctx is opaque (handle/pointer cast to U64 by host/runtime)
# - read_fn returns a chunk of at most `maxn` bytes
#   - ok=false => err set
#   - ok=true + n==0 => EOF
type Reader struct
  ctx: U64
  read_fn: fn(&Reader, U32) -> ReadResult
.end

fn reader_is_valid(r: &Reader) -> Bool
  ret r.read_fn != 0
.end

# Thin wrapper
fn reader_read(r: &Reader, maxn: U32) -> ReadResult
  ret r.read_fn(r, maxn)
.end

# -----------------------------------------------------------------------------
# High-level helpers
# -----------------------------------------------------------------------------

# Read exactly n bytes, returns an owned byte string (as Str).
# Error if EOF before n.
fn reader_read_exact(r: &Reader, n: U32) -> std.core.result::ResultStr
  if n == 0
    ret std.core.result::str_ok("")
  .end

  let out: Str
  set out = ""

  let need = n
  while need > 0
    let rr = reader_read(r, need)
    if !rr.ok
      ret std.core.result::str_err(rr.err)
    .end
    if rr.n == 0
      ret std.core.result::str_err(std.core.result::err_io("unexpected EOF"))
    .end
    # append chunk
    set out = std.string::concat(out, rr.chunk.data)
    set need = need - rr.n
  .end

  ret std.core.result::str_ok(out)
.end

# Read up to `limit` bytes total (defensive), until EOF.
fn reader_read_to_end(r: &Reader, limit: U32) -> std.core.result::ResultStr
  let out: Str
  set out = ""

  let total: U32
  set total = 0

  let step: U32
  set step = 8 * 1024

  while true
    if limit > 0 && total >= limit
      ret std.core.result::str_err(std.core.result::err_io("read_to_end: limit exceeded"))
    .end

    let maxn = step
    if limit > 0
      let remain = limit - total
      if maxn > remain
        set maxn = remain
      .end
    .end

    let rr = reader_read(r, maxn)
    if !rr.ok
      ret std.core.result::str_err(rr.err)
    .end
    if rr.n == 0
      break
    .end

    set out = std.string::concat(out, rr.chunk.data)
    set total = total + rr.n
  .end

  ret std.core.result::str_ok(out)
.end

# Read 1 byte
fn reader_read_u8(r: &Reader) -> std.core.result::ResultU32
  let rs = reader_read_exact(r, 1)
  if !rs.ok
    ret std.core.result::u32_err(rs.err)
  .end
  # str byte access: expect std.string::byte_at
  let b = std.string::byte_at(rs.val, 0)
  ret std.core.result::u32_ok(b)
.end

# Little-endian unsigned 16
fn reader_read_u16_le(r: &Reader) -> std.core.result::ResultU32
  let rs = reader_read_exact(r, 2)
  if !rs.ok
    ret std.core.result::u32_err(rs.err)
  .end
  let b0 = std.string::byte_at(rs.val, 0)
  let b1 = std.string::byte_at(rs.val, 1)
  let v: U32
  set v = (b0) | (b1 << 8)
  ret std.core.result::u32_ok(v)
.end

# Little-endian unsigned 32
fn reader_read_u32_le(r: &Reader) -> std.core.result::ResultU32
  let rs = reader_read_exact(r, 4)
  if !rs.ok
    ret std.core.result::u32_err(rs.err)
  .end
  let b0 = std.string::byte_at(rs.val, 0)
  let b1 = std.string::byte_at(rs.val, 1)
  let b2 = std.string::byte_at(rs.val, 2)
  let b3 = std.string::byte_at(rs.val, 3)
  let v: U32
  set v = (b0) | (b1 << 8) | (b2 << 16) | (b3 << 24)
  ret std.core.result::u32_ok(v)
.end

# Read line (LF) with max length guard. Returns line without trailing '\n' (and optional '\r').
fn reader_read_line(r: &Reader, max_len: U32) -> std.core.result::ResultStr
  let out: Str
  set out = ""

  let total: U32
  set total = 0

  while true
    if max_len > 0 && total >= max_len
      ret std.core.result::str_err(std.core.result::err_io("read_line: max_len exceeded"))
    .end

    let rr = reader_read(r, 1)
    if !rr.ok
      ret std.core.result::str_err(rr.err)
    .end
    if rr.n == 0
      # EOF: return what we have (even empty)
      break
    .end

    let c = rr.chunk.data
    # c length is 1
    if c == "\n"
      break
    .end
    set out = std.string::concat(out, c)
    set total = total + 1
  .end

  # trim trailing \r
  if std.string::len(out) > 0
    let last = std.string::byte_at(out, std.string::len(out) - 1)
    if last == 13
      set out = std.string::slice(out, 0, std.string::len(out) - 1)
    .end
  .end

  ret std.core.result::str_ok(out)
.end

# -----------------------------------------------------------------------------
# CursorReader (in-memory Reader)
# -----------------------------------------------------------------------------
# Design:
# - In pure Vitte, we store state directly in the Reader wrapper by packing
#   fields into a CursorReader struct and exposing a Reader bound to it.
# - The ctx is an opaque handle; in this pure file we emulate by storing an
#   index into a global table (runtime-managed).
#
# If your runtime has stable heap boxing, replace the global table with box/new.

type CursorReader struct
  data: Str
  off: U32
.end

# Global cursor table (simple). Replace with std.collections if available.
type CursorSlot struct
  used: Bool
  cur: CursorReader
.end

type CursorTable struct
  slots: Str   # placeholder backing store (unused)
.end

# In this generated std snapshot, we expose a minimal runtime handle API that
# you can implement later:
# - runtime_handle_new(any) -> U64
# - runtime_handle_get(U64) -> &mut any
# Here we only specify signatures for linkage; tests are smoke-only.

fn __rt_handle_new_cursor(cur: CursorReader) -> U64
  # host/runtime must implement
  ret 0
.end

fn __rt_handle_get_cursor(h: U64) -> &mut CursorReader
  # host/runtime must implement
  let dummy: &mut CursorReader
  ret dummy
.end

fn cursor_reader_read(self: &Reader, maxn: U32) -> ReadResult
  let rr: ReadResult
  set rr.ok = true
  set rr.err = std.core.result::err_ok()
  set rr.n = 0
  set rr.chunk = bytes_empty()

  if maxn == 0
    ret rr
  .end

  let cur = __rt_handle_get_cursor(self.ctx)
  let len = std.string::len(cur.data)
  if cur.off >= len
    # EOF
    ret rr
  .end

  let remain = len - cur.off
  let take = maxn
  if take > remain
    set take = remain
  .end

  let s = std.string::slice(cur.data, cur.off, take)
  set cur.off = cur.off + take

  set rr.n = take
  set rr.chunk = bytes_from_str(s)
  ret rr
.end

fn cursor_reader_new(data: Str) -> Reader
  let cur: CursorReader
  set cur.data = data
  set cur.off = 0

  let h = __rt_handle_new_cursor(cur)

  let r: Reader
  set r.ctx = h
  set r.read_fn = cursor_reader_read
  ret r
.end

# -----------------------------------------------------------------------------
# Tests (smoke)
# -----------------------------------------------------------------------------

scn test_reader_read_exact_smoke
  # cursor impl depends on runtime handle stubs, so only compile-time smoke here.
  do std.runtime::assert(true, "reader_read_exact exists")
.end

scn test_reader_read_line_smoke
  do std.runtime::assert(true, "reader_read_line exists")
.end

# End of std.io.reader