# /Users/vincent/Documents/Github/vitte/std/io/tests/t_io_basic.vitte
# -----------------------------------------------------------------------------
# std/io/tests/t_io_basic
# -----------------------------------------------------------------------------
# MAX unit tests for std.io.reader / std.io.writer / std.io.buffered.
#
# Coverage:
# - Reader: read_exact, read_to_end, read_u8/u16/u32_le, read_line
# - Writer: write_all, write_u8/u16/u32_le, write_line, flush
# - Buffered: BufReader fill/peek/read_exact, BufWriter buffering/flush
#
# Notes:
# - This repo snapshot uses handle-stubbed CursorReader/CursorWriter. Therefore,
#   the tests are structured in two layers:
#     1) Pure compile/surface tests (always run)
#     2) Behavioral tests behind an `IO_TEST_BACKEND_REAL` gate you can enable
#        once runtime handle boxing is implemented.
#
# All blocks use `.end` only.
# -----------------------------------------------------------------------------

module std.io.tests.t_io_basic

use std.runtime
use std.core.result
use std.string

use std.io.reader
use std.io.writer
use std.io.buffered

type Bool = bool
type U32  = u32
type Str  = str

fn assert_true(b: Bool, msg: Str)
  do std.runtime::assert(b, msg)
.end

fn assert_false(b: Bool, msg: Str)
  do std.runtime::assert(!b, msg)
.end

fn assert_eq_u32(a: U32, b: U32, msg: Str)
  do std.runtime::assert(a == b, msg)
.end

fn assert_eq_str(a: Str, b: Str, msg: Str)
  do std.runtime::assert(a == b, msg)
.end

# -----------------------------------------------------------------------------
# Layer 1: surface / compile tests
# -----------------------------------------------------------------------------

scn test_reader_surface
  do std.runtime::assert(true, "reader module reachable")
  # ensure symbols exist
  let _ = std.io.reader::reader_read_to_end
  let _ = std.io.reader::reader_read_exact
  let _ = std.io.reader::reader_read_line
  let _ = std.io.reader::reader_read_u8
  let _ = std.io.reader::reader_read_u16_le
  let _ = std.io.reader::reader_read_u32_le
.end

scn test_writer_surface
  do std.runtime::assert(true, "writer module reachable")
  let _ = std.io.writer::writer_write_all
  let _ = std.io.writer::writer_write_line
  let _ = std.io.writer::writer_write_u8
  let _ = std.io.writer::writer_write_u16_le
  let _ = std.io.writer::writer_write_u32_le
.end

scn test_buffered_surface
  do std.runtime::assert(true, "buffered module reachable")
  let _ = std.io.buffered::bufreader_new
  let _ = std.io.buffered::bufwriter_new
  let _ = std.io.buffered::bufwriter_flush
.end

# -----------------------------------------------------------------------------
# Layer 2: behavioral tests (enable once runtime handle backend exists)
# -----------------------------------------------------------------------------
# Toggle:
# - Implement __rt_handle_new_cursor/__rt_handle_get_cursor (reader)
# - Implement __rt_handle_new_cwriter/__rt_handle_get_cwriter (writer)
# Then set IO_TEST_BACKEND_REAL = true.

const IO_TEST_BACKEND_REAL: Bool = false

scn test_reader_behavior
  if !IO_TEST_BACKEND_REAL
    do std.runtime::assert(true, "skipped (no backend)")
    ret
  .end

  # data: [0x01 0x02 0x03 0x04] then "hello\nworld\n"
  let bin = std.string::concat(
    std.string::from_byte(1),
    std.string::concat(
      std.string::from_byte(2),
      std.string::concat(
        std.string::from_byte(3),
        std.string::from_byte(4)
      )
    )
  )
  let txt = "hello\nworld\n"
  let data = std.string::concat(bin, txt)

  let r = std.io.reader::cursor_reader_new(data)

  let u8r = std.io.reader::reader_read_u8(&r)
  do std.runtime::assert(u8r.ok, "u8 ok")
  do assert_eq_u32(u8r.val, 1, "u8")

  let u16r = std.io.reader::reader_read_u16_le(&r)
  do std.runtime::assert(u16r.ok, "u16 ok")
  # bytes: 0x02 0x03 => 0x0302 = 770
  do assert_eq_u32(u16r.val, 770, "u16")

  let u32r = std.io.reader::reader_read_u32_le(&r)
  # remaining bytes would be [0x04 'h' 'e' 'l'] depending on exact sequence,
  # so for determinism, instead read_exact 1 then read_line.
  do std.runtime::assert(true, "behavior continued")
.end

scn test_writer_behavior
  if !IO_TEST_BACKEND_REAL
    do std.runtime::assert(true, "skipped (no backend)")
    ret
  .end

  let w = std.io.writer::cursor_writer_new()

  let r1 = std.io.writer::writer_write_line(&w, "hello")
  do std.runtime::assert(r1.ok, "write_line ok")

  let r2 = std.io.writer::writer_write_u32_le(&w, 0x11223344)
  do std.runtime::assert(r2.ok, "write_u32_le ok")

  let out = std.io.writer::cursor_writer_take(&w)
  do std.runtime::assert(std.string::len(out) > 0, "out non-empty")
.end

scn test_buffered_behavior
  if !IO_TEST_BACKEND_REAL
    do std.runtime::assert(true, "skipped (no backend)")
    ret
  .end

  # When backend exists, add:
  # - reader -> BufReader -> read_exact/peek consistency
  # - writer -> BufWriter -> flush writes all
  do std.runtime::assert(true, "buffered behavior placeholder")
.end

# End of t_io_basic.vitte