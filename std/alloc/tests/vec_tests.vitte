mod std/alloc/tests/vec_tests

use std/prelude
use std/testing/test
use std/collections/vec
use std/core/option
use std/core/result

fn t_vec_new_empty() -> void
  let v: Vec[i32] = Vec::new()
  test::assert_true(v.len() == 0, "Vec::new len == 0")
  test::assert_true(v.is_empty(), "Vec::new is_empty")
.end

fn t_vec_with_capacity() -> void
  let v: Vec[u8] = Vec::with_capacity(32)
  test::assert_true(v.len() == 0, "with_capacity len == 0")
  test::assert_true(v.capacity() >= 32, "capacity >= requested")
.end

fn t_vec_push_pop() -> void
  let v: Vec[i32] = Vec::new()
  v.push(1)
  v.push(2)
  v.push(3)
  test::assert_true(v.len() == 3, "push len")
  test::assert_true(v[0] == 1, "index 0")
  test::assert_true(v[2] == 3, "index 2")

  let a = v.pop()
  test::assert_true(a.is_some(), "pop some")
  test::assert_true(a.unwrap() == 3, "pop value")
  test::assert_true(v.len() == 2, "len after pop")
.end

fn t_vec_clear() -> void
  let v: Vec[i32] = Vec::new()
  v.push(1)
  v.push(2)
  v.clear()
  test::assert_true(v.is_empty(), "clear -> empty")
  test::assert_true(v.len() == 0, "clear len == 0")
.end

fn t_vec_reserve_capacity_monotonic() -> void
  let v: Vec[i32] = Vec::new()
  let c0 = v.capacity()
  v.reserve(64)
  let c1 = v.capacity()
  test::assert_true(c1 >= c0, "capacity monotonic after reserve")
  test::assert_true(c1 >= 64, "capacity >= reserved")
.end

fn t_vec_extend_from_slice() -> void
  let v: Vec[i32] = Vec::new()
  v.extend_from_slice([1, 2, 3, 4])
  test::assert_true(v.len() == 4, "extend_from_slice len")
  test::assert_true(v[0] == 1, "extend[0]")
  test::assert_true(v[3] == 4, "extend[3]")
.end

fn t_vec_insert_remove() -> void
  let v: Vec[i32] = Vec::new()
  v.push(1)
  v.push(3)
  v.insert(1, 2)
  test::assert_true(v.len() == 3, "insert len")
  test::assert_true(v[0] == 1, "insert idx0")
  test::assert_true(v[1] == 2, "insert idx1")
  test::assert_true(v[2] == 3, "insert idx2")

  let x = v.remove(1)
  test::assert_true(x == 2, "remove returns removed")
  test::assert_true(v.len() == 2, "remove len")
  test::assert_true(v[0] == 1, "remove idx0")
  test::assert_true(v[1] == 3, "remove idx1")
.end

fn t_vec_swap_remove() -> void
  let v: Vec[i32] = Vec::new()
  v.extend_from_slice([10, 20, 30, 40])
  let x = v.swap_remove(1)     # removes 20, swaps last in
  test::assert_true(x == 20, "swap_remove returns removed")
  test::assert_true(v.len() == 3, "swap_remove len")
  test::assert_true(v.contains(10), "contains 10")
  test::assert_true(v.contains(30), "contains 30")
  test::assert_true(v.contains(40), "contains 40")
.end

fn t_vec_front_back() -> void
  let v: Vec[i32] = Vec::new()
  v.push(7)
  v.push(9)
  test::assert_true(v.first().unwrap() == 7, "first")
  test::assert_true(v.last().unwrap() == 9, "last")
.end

fn t_vec_iter_sum() -> void
  let v: Vec[i32] = Vec::new()
  v.extend_from_slice([1, 2, 3, 4, 5])
  let mut s = 0
  for x in v.iter()
    s = s + x
  .end
  test::assert_true(s == 15, "iter sum")
.end

fn t_vec_map_collect() -> void
  let v: Vec[i32] = Vec::new()
  v.extend_from_slice([1, 2, 3])

  let w: Vec[i32] = Vec::new()
  for x in v.iter()
    w.push(x * 2)
  .end

  test::assert_true(w.len() == 3, "map len")
  test::assert_true(w[0] == 2, "map[0]")
  test::assert_true(w[1] == 4, "map[1]")
  test::assert_true(w[2] == 6, "map[2]")
.end

fn t_vec_slice_views() -> void
  let v: Vec[i32] = Vec::new()
  v.extend_from_slice([1, 2, 3, 4, 5])
  let s = v.as_slice()
  test::assert_true(s.len() == 5, "as_slice len")
  test::assert_true(s[0] == 1, "slice[0]")
  test::assert_true(s[4] == 5, "slice[4]")
.end

fn t_vec_sort_basic() -> void
  let v: Vec[i32] = Vec::new()
  v.extend_from_slice([4, 1, 3, 2])
  v.sort()
  test::assert_true(v[0] == 1, "sort[0]")
  test::assert_true(v[1] == 2, "sort[1]")
  test::assert_true(v[2] == 3, "sort[2]")
  test::assert_true(v[3] == 4, "sort[3]")
.end

fn run_all() -> void
  test::case("vec_new_empty", t_vec_new_empty)
  test::case("vec_with_capacity", t_vec_with_capacity)
  test::case("vec_push_pop", t_vec_push_pop)
  test::case("vec_clear", t_vec_clear)
  test::case("vec_reserve_capacity", t_vec_reserve_capacity_monotonic)
  test::case("vec_extend_from_slice", t_vec_extend_from_slice)
  test::case("vec_insert_remove", t_vec_insert_remove)
  test::case("vec_swap_remove", t_vec_swap_remove)
  test::case("vec_front_back", t_vec_front_back)
  test::case("vec_iter_sum", t_vec_iter_sum)
  test::case("vec_map_collect", t_vec_map_collect)
  test::case("vec_slice_views", t_vec_slice_views)
  test::case("vec_sort_basic", t_vec_sort_basic)
.end

fn main() -> i32
  test::run("std::alloc::vec_tests", run_all)
  ret 0
.end
