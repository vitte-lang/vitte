mod std/alloc/tests/string_tests

use std/prelude
use std/testing/test
use std/core/string
use std/core/compare

fn t_string_empty_new() -> void
  let s = String::new()
  test::assert_true(s.len() == 0, "String::new() len == 0")
  test::assert_true(s.is_empty(), "String::new() is_empty")
.end

fn t_string_from_str() -> void
  let s = String::from_str("abc")
  test::assert_true(s.len() == 3, "from_str len")
  test::assert_true(s.as_str() == "abc", "from_str content")
.end

fn t_string_clone_eq() -> void
  let a = String::from_str("hello")
  let b = a.clone()
  test::assert_true(a.as_str() == b.as_str(), "clone content")
  test::assert_true(a.len() == b.len(), "clone len")
.end

fn t_string_push_char() -> void
  let s = String::from_str("ab")
  s.push_char('c')
  test::assert_true(s.as_str() == "abc", "push_char")
  test::assert_true(s.len() == 3, "push_char len")
.end

fn t_string_push_str() -> void
  let s = String::from_str("ab")
  s.push_str("cd")
  test::assert_true(s.as_str() == "abcd", "push_str")
  test::assert_true(s.len() == 4, "push_str len")
.end

fn t_string_pop_char() -> void
  let s = String::from_str("abc")
  let c = s.pop_char()
  test::assert_true(c.is_some(), "pop_char some")
  test::assert_true(c.unwrap() == 'c', "pop_char value")
  test::assert_true(s.as_str() == "ab", "pop_char remaining")
  test::assert_true(s.len() == 2, "pop_char len")
.end

fn t_string_clear() -> void
  let s = String::from_str("abc")
  s.clear()
  test::assert_true(s.is_empty(), "clear is_empty")
  test::assert_true(s.len() == 0, "clear len")
  test::assert_true(s.as_str() == "", "clear content")
.end

fn t_string_reserve_and_capacity_monotonic() -> void
  let s = String::new()
  let c0 = s.capacity()
  s.reserve(64)
  let c1 = s.capacity()
  test::assert_true(c1 >= c0, "capacity monotonic after reserve")
  test::assert_true(c1 >= 64, "capacity >= reserved")
.end

fn t_string_insert_remove() -> void
  let s = String::from_str("ace")
  s.insert(1, 'b')
  s.insert(3, 'd')
  test::assert_true(s.as_str() == "abcde", "insert")
  let r = s.remove(2)
  test::assert_true(r == 'c', "remove returns removed char")
  test::assert_true(s.as_str() == "abde", "remove content")
.end

fn t_string_split_and_join() -> void
  let s = String::from_str("a,b,c")
  let parts = s.as_str().split(",")
  test::assert_true(parts.len() == 3, "split len")
  test::assert_true(parts[0] == "a", "split[0]")
  test::assert_true(parts[1] == "b", "split[1]")
  test::assert_true(parts[2] == "c", "split[2]")

  let joined = String::join(parts, ",")
  test::assert_true(joined.as_str() == "a,b,c", "join")
.end

fn t_string_trim() -> void
  let s = String::from_str("  hello \n")
  let t = s.as_str().trim()
  test::assert_true(t == "hello", "trim")
.end

fn t_string_find_contains() -> void
  let s = String::from_str("hello world")
  test::assert_true(s.as_str().contains("world"), "contains true")
  test::assert_true(!s.as_str().contains("WORLD"), "contains case sensitive")
  test::assert_true(s.as_str().find("lo").is_some(), "find some")
  test::assert_true(s.as_str().find("zz").is_none(), "find none")
.end

fn t_string_utf8_len_vs_chars() -> void
  let s = String::from_str("Ã©")         # UTF-8: 2 bytes
  test::assert_true(s.len() >= 1, "len bytes >= 1")
  let n = s.as_str().chars().count()
  test::assert_true(n == 1, "chars count == 1")
.end

fn run_all() -> void
  test::case("string_empty_new", t_string_empty_new)
  test::case("string_from_str", t_string_from_str)
  test::case("string_clone_eq", t_string_clone_eq)
  test::case("string_push_char", t_string_push_char)
  test::case("string_push_str", t_string_push_str)
  test::case("string_pop_char", t_string_pop_char)
  test::case("string_clear", t_string_clear)
  test::case("string_reserve_capacity", t_string_reserve_and_capacity_monotonic)
  test::case("string_insert_remove", t_string_insert_remove)
  test::case("string_split_join", t_string_split_and_join)
  test::case("string_trim", t_string_trim)
  test::case("string_find_contains", t_string_find_contains)
  test::case("string_utf8_len_chars", t_string_utf8_len_vs_chars)
.end

fn main() -> i32
  test::run("std::alloc::string_tests", run_all)
  ret 0
.end
