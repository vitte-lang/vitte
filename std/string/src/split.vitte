

# /Users/vincent/Documents/Github/vitte/std/string/src/split.vitte
# -----------------------------------------------------------------------------
# std/string/split
# -----------------------------------------------------------------------------
# Byte-wise split utilities.
#
# Scope:
# - split_once / rsplit_once (substring and byte)
# - split / rsplit iterators (lazy) when possible
# - split_to_vec helpers (eager) gated behind std.collections
# - ASCII whitespace split helpers
#
# Design constraints:
# - Avoid allocating substrings unless requested. Prefer returning slices.
# - Define precise semantics for empty separators.
# - Split is byte-wise; UTF-8 is preserved if boundaries align.
#
# Assumptions about std.string:
# - std.string::len(s) -> u64
# - std.string::byte_at(s, i) -> u8
# - std.string::slice(s, start, len) -> str
# - std.string::eq(a,b) supported via ==
#
# Optional assumptions for eager helpers:
# - std.collections::Vec[T]
# - Vec::new(), Vec::push
#
# Blocks use `.end` only.
# -----------------------------------------------------------------------------

module std.string.split

use std.runtime
use std.string

# -----------------------------------------------------------------------------
# Types
# -----------------------------------------------------------------------------

type Bool = bool

type U8  = u8

type U32 = u32

type U64 = u64

type I32 = i32

type Str = str

const NPOS: U64 = 0xffffffffffffffff

# -----------------------------------------------------------------------------
# Internal: naive substring search (byte-wise)
# -----------------------------------------------------------------------------

fn find_sub_from(hay: Str, needle: Str, start: U64) -> U64
  let nh = std.string::len(hay)
  let nn = std.string::len(needle)

  if start > nh
    ret NPOS
  .end

  if nn == 0
    ret start
  .end

  if nn > nh
    ret NPOS
  .end

  let last = nh - nn
  let i: U64
  set i = start

  while i <= last
    if std.string::byte_at(hay, i) == std.string::byte_at(needle, 0)
      let j: U64
      set j = 1
      while j < nn
        if std.string::byte_at(hay, i + j) != std.string::byte_at(needle, j)
          break
        .end
        set j = j + 1
      .end
      if j == nn
        ret i
      .end
    .end
    set i = i + 1
  .end

  ret NPOS
.end

fn rfind_sub(hay: Str, needle: Str) -> U64
  let nh = std.string::len(hay)
  let nn = std.string::len(needle)

  if nn == 0
    ret nh
  .end

  if nn > nh
    ret NPOS
  .end

  let i: U64
  set i = nh - nn

  while true
    if std.string::byte_at(hay, i) == std.string::byte_at(needle, 0)
      let j: U64
      set j = 1
      while j < nn
        if std.string::byte_at(hay, i + j) != std.string::byte_at(needle, j)
          break
        .end
        set j = j + 1
      .end
      if j == nn
        ret i
      .end
    .end

    if i == 0
      break
    .end
    set i = i - 1
  .end

  ret NPOS
.end

# -----------------------------------------------------------------------------
# split_once / rsplit_once (substring)
# -----------------------------------------------------------------------------

# Returns (left, right, found)
# If not found: (s, "", false)
# If needle == "": ("", s, true) for split_once, and (s, "", true) for rsplit_once.

fn split_once(s: Str, sep: Str) -> (Str, Str, Bool)
  let ns = std.string::len(s)
  let nsep = std.string::len(sep)

  if nsep == 0
    ret ("", s, true)
  .end

  let p = find_sub_from(s, sep, 0)
  if p == NPOS
    ret (s, "", false)
  .end

  let left = std.string::slice(s, 0, p)
  let right = std.string::slice(s, p + nsep, ns - (p + nsep))
  ret (left, right, true)
.end

fn rsplit_once(s: Str, sep: Str) -> (Str, Str, Bool)
  let ns = std.string::len(s)
  let nsep = std.string::len(sep)

  if nsep == 0
    ret (s, "", true)
  .end

  let p = rfind_sub(s, sep)
  if p == NPOS
    ret (s, "", false)
  .end

  let left = std.string::slice(s, 0, p)
  let right = std.string::slice(s, p + nsep, ns - (p + nsep))
  ret (left, right, true)
.end

# -----------------------------------------------------------------------------
# split_once / rsplit_once (single byte)
# -----------------------------------------------------------------------------

fn find_byte_from(s: Str, needle: U32, start: U64) -> U64
  let n = std.string::len(s)
  if start > n
    ret NPOS
  .end
  let i: U64
  set i = start
  while i < n
    if (std.string::byte_at(s, i) as U32) == needle
      ret i
    .end
    set i = i + 1
  .end
  ret NPOS
.end

fn rfind_byte(s: Str, needle: U32) -> U64
  let n = std.string::len(s)
  if n == 0
    ret NPOS
  .end
  let i: U64
  set i = n
  while i > 0
    set i = i - 1
    if (std.string::byte_at(s, i) as U32) == needle
      ret i
    .end
  .end
  ret NPOS
.end

fn split_once_byte(s: Str, sep: U32) -> (Str, Str, Bool)
  let n = std.string::len(s)
  let p = find_byte_from(s, sep, 0)
  if p == NPOS
    ret (s, "", false)
  .end
  let left = std.string::slice(s, 0, p)
  let right = std.string::slice(s, p + 1, n - (p + 1))
  ret (left, right, true)
.end

fn rsplit_once_byte(s: Str, sep: U32) -> (Str, Str, Bool)
  let n = std.string::len(s)
  let p = rfind_byte(s, sep)
  if p == NPOS
    ret (s, "", false)
  .end
  let left = std.string::slice(s, 0, p)
  let right = std.string::slice(s, p + 1, n - (p + 1))
  ret (left, right, true)
.end

# -----------------------------------------------------------------------------
# Split iterator (substring)
# -----------------------------------------------------------------------------

# Semantics:
# - If sep == "": yields each byte as 1-length slice (like splitting between bytes).
# - Otherwise yields non-overlapping segments.

struct Split
  s: Str
  sep: Str
  pos: U64
  done: Bool
.end

fn split_new(s: Str, sep: Str) -> Split
  let it: Split
  set it.s = s
  set it.sep = sep
  set it.pos = 0
  set it.done = false
  ret it
.end

fn split_next(it: Split) -> (Split, Str, Bool)
  if it.done
    ret (it, "", false)
  .end

  let s = it.s
  let sep = it.sep
  let ns = std.string::len(s)
  let nsep = std.string::len(sep)

  if it.pos > ns
    set it.done = true
    ret (it, "", false)
  .end

  if nsep == 0
    # yield each byte as slice of len 1
    if it.pos == ns
      # final empty after last boundary? we choose: stop.
      set it.done = true
      ret (it, "", false)
    .end
    let out = std.string::slice(s, it.pos, 1)
    set it.pos = it.pos + 1
    ret (it, out, true)
  .end

  let p = find_sub_from(s, sep, it.pos)
  if p == NPOS
    # tail
    let out = std.string::slice(s, it.pos, ns - it.pos)
    set it.done = true
    ret (it, out, true)
  .end

  let out = std.string::slice(s, it.pos, p - it.pos)
  set it.pos = p + nsep
  ret (it, out, true)
.end

# -----------------------------------------------------------------------------
# RSplit iterator (substring)
# -----------------------------------------------------------------------------

struct RSplit
  s: Str
  sep: Str
  end: U64
  done: Bool
.end

fn rsplit_new(s: Str, sep: Str) -> RSplit
  let it: RSplit
  set it.s = s
  set it.sep = sep
  set it.end = std.string::len(s)
  set it.done = false
  ret it
.end

fn rsplit_next(it: RSplit) -> (RSplit, Str, Bool)
  if it.done
    ret (it, "", false)
  .end

  let s = it.s
  let sep = it.sep
  let ns = std.string::len(s)
  let nsep = std.string::len(sep)

  if it.end > ns
    set it.done = true
    ret (it, "", false)
  .end

  if nsep == 0
    # yield each byte in reverse as slice len 1
    if it.end == 0
      set it.done = true
      ret (it, "", false)
    .end
    set it.end = it.end - 1
    let out = std.string::slice(s, it.end, 1)
    ret (it, out, true)
  .end

  # Search last sep strictly before it.end.
  # We do naive reverse search by scanning from 0..end.
  # Optimize if needed.
  let hay = std.string::slice(s, 0, it.end)
  let p = rfind_sub(hay, sep)
  if p == NPOS
    let out = std.string::slice(s, 0, it.end)
    set it.done = true
    ret (it, out, true)
  .end

  let out = std.string::slice(s, p + nsep, it.end - (p + nsep))
  set it.end = p
  ret (it, out, true)
.end

# -----------------------------------------------------------------------------
# Split whitespace (ASCII)
# -----------------------------------------------------------------------------

fn is_ascii_space(b: U32) -> Bool
  if b == 0x20
    ret true
  .end
  if b >= 0x09 && b <= 0x0d
    ret true
  .end
  ret false
.end

struct SplitWhitespace
  s: Str
  pos: U64
  done: Bool
.end

fn split_whitespace_new(s: Str) -> SplitWhitespace
  let it: SplitWhitespace
  set it.s = s
  set it.pos = 0
  set it.done = false
  ret it
.end

fn split_whitespace_next(it: SplitWhitespace) -> (SplitWhitespace, Str, Bool)
  if it.done
    ret (it, "", false)
  .end

  let s = it.s
  let n = std.string::len(s)
  let i: U64
  set i = it.pos

  # skip leading spaces
  while i < n
    if !is_ascii_space(std.string::byte_at(s, i) as U32)
      break
    .end
    set i = i + 1
  .end

  if i >= n
    set it.done = true
    ret (it, "", false)
  .end

  let start = i

  # scan to next space
  while i < n
    if is_ascii_space(std.string::byte_at(s, i) as U32)
      break
    .end
    set i = i + 1
  .end

  let out = std.string::slice(s, start, i - start)
  set it.pos = i
  ret (it, out, true)
.end

# -----------------------------------------------------------------------------
# Eager helpers (Vec) - optional usage
# -----------------------------------------------------------------------------

# NOTE: This module does not `use std.collections` directly to keep deps light.
# If you want eager split to vec, implement in std/string/lib.vitte or in a
# separate module that depends on std-collections.

# -----------------------------------------------------------------------------
# Tests
# -----------------------------------------------------------------------------

fn assert_true(b: Bool, msg: Str)
  do std.runtime::assert(b, msg)
.end

fn assert_eq_str(a: Str, b: Str, msg: Str)
  do std.runtime::assert(a == b, msg)
.end

scn test_split_once
  let a: Str
  set a = "a::b::c"
  let l: Str
  let r: Str
  let ok: Bool

  (l, r, ok) = split_once(a, "::")
  do assert_true(ok, "split_once ok")
  do assert_eq_str(l, "a", "split_once left")
  do assert_eq_str(r, "b::c", "split_once right")

  (l, r, ok) = rsplit_once(a, "::")
  do assert_true(ok, "rsplit_once ok")
  do assert_eq_str(l, "a::b", "rsplit_once left")
  do assert_eq_str(r, "c", "rsplit_once right")

  (l, r, ok) = split_once("abc", "-")
  do assert_true(!ok, "split_once miss")
  do assert_eq_str(l, "abc", "split_once miss left")
  do assert_eq_str(r, "", "split_once miss right")

  (l, r, ok) = split_once("abc", "")
  do assert_true(ok, "split_once empty sep")
  do assert_eq_str(l, "", "split_once empty left")
  do assert_eq_str(r, "abc", "split_once empty right")

  (l, r, ok) = rsplit_once("abc", "")
  do assert_true(ok, "rsplit_once empty sep")
  do assert_eq_str(l, "abc", "rsplit_once empty left")
  do assert_eq_str(r, "", "rsplit_once empty right")
.end

scn test_split_iter
  let it = split_new("a::b::c", "::")
  let part: Str
  let ok: Bool

  (it, part, ok) = split_next(it)
  do assert_true(ok, "split_next 1")
  do assert_eq_str(part, "a", "split part 1")

  (it, part, ok) = split_next(it)
  do assert_true(ok, "split_next 2")
  do assert_eq_str(part, "b", "split part 2")

  (it, part, ok) = split_next(it)
  do assert_true(ok, "split_next 3")
  do assert_eq_str(part, "c", "split part 3")

  (it, part, ok) = split_next(it)
  do assert_true(!ok, "split_next end")

  # sep empty -> per-byte slices
  let it2 = split_new("ab", "")
  (it2, part, ok) = split_next(it2)
  do assert_true(ok, "split empty 1")
  (it2, part, ok) = split_next(it2)
  do assert_true(ok, "split empty 2")
  (it2, part, ok) = split_next(it2)
  do assert_true(!ok, "split empty end")
.end

scn test_rsplit_iter
  let it = rsplit_new("a::b::c", "::")
  let part: Str
  let ok: Bool

  (it, part, ok) = rsplit_next(it)
  do assert_true(ok, "rsplit_next 1")
  do assert_eq_str(part, "c", "rsplit part 1")

  (it, part, ok) = rsplit_next(it)
  do assert_true(ok, "rsplit_next 2")
  do assert_eq_str(part, "b", "rsplit part 2")

  (it, part, ok) = rsplit_next(it)
  do assert_true(ok, "rsplit_next 3")
  do assert_eq_str(part, "a", "rsplit part 3")

  (it, part, ok) = rsplit_next(it)
  do assert_true(!ok, "rsplit_next end")

  # sep empty -> per-byte reverse
  let it2 = rsplit_new("ab", "")
  (it2, part, ok) = rsplit_next(it2)
  do assert_true(ok, "rsplit empty 1")
  (it2, part, ok) = rsplit_next(it2)
  do assert_true(ok, "rsplit empty 2")
  (it2, part, ok) = rsplit_next(it2)
  do assert_true(!ok, "rsplit empty end")
.end

scn test_split_whitespace
  let it = split_whitespace_new("  a\t b\n\n c  ")
  let part: Str
  let ok: Bool

  (it, part, ok) = split_whitespace_next(it)
  do assert_true(ok, "ws 1")
  do assert_eq_str(part, "a", "ws part 1")

  (it, part, ok) = split_whitespace_next(it)
  do assert_true(ok, "ws 2")
  do assert_eq_str(part, "b", "ws part 2")

  (it, part, ok) = split_whitespace_next(it)
  do assert_true(ok, "ws 3")
  do assert_eq_str(part, "c", "ws part 3")

  (it, part, ok) = split_whitespace_next(it)
  do assert_true(!ok, "ws end")
.end

# End of std.string.split