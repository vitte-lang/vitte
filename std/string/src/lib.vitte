

# -----------------------------------------------------------------------------
# std/string
# -----------------------------------------------------------------------------
# Owned string + byte-oriented string utilities.
#
# Design goals (bootstrap-friendly):
# - Minimal dependencies: builds on std.collections::Vec.
# - Deterministic, allocation-explicit API.
# - ASCII-first utilities; UTF-8 is treated as opaque bytes by default.
# - Interop with C-style strings via `Str` (NUL-terminated).
#
# Conventions:
# - Owned strings are `String` = Vec[U8] bytes WITHOUT a trailing NUL.
# - Functions returning cstr-compatible buffers append a trailing NUL.
# - All blocks use `.end` only.
# -----------------------------------------------------------------------------

module std.string

use std.collections
use std.runtime

# -----------------------------------------------------------------------------
# Types / errors
# -----------------------------------------------------------------------------

type Bool  = bool

type U8    = u8
type U32   = u32
type U64   = u64

type I64   = i64

type USize = usize

type Ptr[T] = ptr[T]

type Str = str

# Errors are intentionally small and stable.

type StrError enum
  Ok
  Invalid
  OutOfMemory
  Unsupported
.end

# Owned string (bytes without NUL terminator).

type String struct
  data: Vec[U8]
.end

# -----------------------------------------------------------------------------
# Small internal helpers
# -----------------------------------------------------------------------------

fn _vec_push_u8(v: &Vec[U8], b: U8) -> Bool
  let ok: Bool
  let e: ColError
  (ok, e) = vec_push[U8](v, 1, b)
  ret ok
.end

fn _vec_push_bytes(v: &Vec[U8], p: Ptr[U8], n: USize) -> Bool
  let i: USize
  set i = 0
  while i < n
    if !_vec_push_u8(v, *(p + i))
      ret false
    .end
    set i = i + 1
  .end
  ret true
.end

fn _bytes_eq(a: &Vec[U8], b: &Vec[U8]) -> Bool
  if a.len != b.len
    ret false
  .end
  let ap = (Ptr[U8])a.data
  let bp = (Ptr[U8])b.data
  let i: USize
  set i = 0
  while i < a.len
    if *(ap + i) != *(bp + i)
      ret false
    .end
    set i = i + 1
  .end
  ret true
.end

fn _is_ascii_space(b: U8) -> Bool
  if b == (U8)' ' || b == (U8)'\n' || b == (U8)'\r' || b == (U8)'\t' || b == (U8)'\v' || b == (U8)'\f'
    ret true
  .end
  ret false
.end

fn _is_ascii_digit(b: U8) -> Bool
  ret b >= (U8)'0' && b <= (U8)'9'
.end

fn _ascii_lower(b: U8) -> U8
  if b >= (U8)'A' && b <= (U8)'Z'
    ret (U8)(b + ((U8)'a' - (U8)'A'))
  .end
  ret b
.end

fn _ascii_upper(b: U8) -> U8
  if b >= (U8)'a' && b <= (U8)'z'
    ret (U8)(b - ((U8)'a' - (U8)'A'))
  .end
  ret b
.end

# -----------------------------------------------------------------------------
# Constructors / lifecycle
# -----------------------------------------------------------------------------

fn string_new() -> String
  let s: String
  set s.data = vec_new[U8]()
  ret s
.end

fn string_with_capacity(cap: USize) -> (Bool, StrError, String)
  # Vec reserve API may not exist; we emulate by pushing then clearing.
  let s = string_new()
  let tmp: USize
  set tmp = 0
  while tmp < cap
    if !_vec_push_u8(&s.data, 0)
      do vec_drop[U8](&s.data, 1)
      ret (false, StrError::OutOfMemory, string_new())
    .end
    set tmp = tmp + 1
  .end
  do vec_clear[U8](&s.data)
  ret (true, StrError::Ok, s)
.end

fn string_drop(s: &String)
  do vec_drop[U8](&s.data, 1)
.end

fn string_clear(s: &String)
  do vec_clear[U8](&s.data)
.end

fn string_len(s: &String) -> USize
  ret s.data.len
.end

fn string_is_empty(s: &String) -> Bool
  ret s.data.len == 0
.end

fn string_bytes(s: &String) -> &Vec[U8]
  ret &s.data
.end

# Clone (deep copy bytes)
fn string_clone(src: &String) -> (Bool, StrError, String)
  let out = string_new()
  if !_vec_push_bytes(&out.data, (Ptr[U8])src.data.data, src.data.len)
    do string_drop(&out)
    ret (false, StrError::OutOfMemory, string_new())
  .end
  ret (true, StrError::Ok, out)
.end

# From bytes (copies)
fn string_from_bytes(bytes: &Vec[U8]) -> (Bool, StrError, String)
  let out = string_new()
  if !_vec_push_bytes(&out.data, (Ptr[U8])bytes.data, bytes.len)
    do string_drop(&out)
    ret (false, StrError::OutOfMemory, string_new())
  .end
  ret (true, StrError::Ok, out)
.end

# From C string (copies until NUL)
fn string_from_cstr(s: Str) -> (Bool, StrError, String)
  let out = string_new()
  let p = (Ptr[U8])s
  let i: USize
  set i = 0
  loop
    let b = *(p + i)
    if b == 0
      break
    .end
    if !_vec_push_u8(&out.data, b)
      do string_drop(&out)
      ret (false, StrError::OutOfMemory, string_new())
    .end
    set i = i + 1
  .end
  ret (true, StrError::Ok, out)
.end

# Convert to a NUL-terminated byte buffer (returns new Vec[U8])
fn string_to_cbytes(s: &String) -> (Bool, StrError, Vec[U8])
  let out = vec_new[U8]()
  if !_vec_push_bytes(&out, (Ptr[U8])s.data.data, s.data.len)
    do vec_drop[U8](&out, 1)
    ret (false, StrError::OutOfMemory, vec_new[U8]())
  .end
  if !_vec_push_u8(&out, 0)
    do vec_drop[U8](&out, 1)
    ret (false, StrError::OutOfMemory, vec_new[U8]())
  .end
  ret (true, StrError::Ok, out)
.end

# -----------------------------------------------------------------------------
# Mutation
# -----------------------------------------------------------------------------

fn string_push_byte(s: &String, b: U8) -> (Bool, StrError)
  if !_vec_push_u8(&s.data, b)
    ret (false, StrError::OutOfMemory)
  .end
  ret (true, StrError::Ok)
.end

fn string_push_bytes(s: &String, p: Ptr[U8], n: USize) -> (Bool, StrError)
  if !_vec_push_bytes(&s.data, p, n)
    ret (false, StrError::OutOfMemory)
  .end
  ret (true, StrError::Ok)
.end

fn string_push_string(dst: &String, src: &String) -> (Bool, StrError)
  ret string_push_bytes(dst, (Ptr[U8])src.data.data, src.data.len)
.end

fn string_push_cstr(dst: &String, src: Str) -> (Bool, StrError)
  let p = (Ptr[U8])src
  let i: USize
  set i = 0
  loop
    let b = *(p + i)
    if b == 0
      break
    .end
    if !_vec_push_u8(&dst.data, b)
      ret (false, StrError::OutOfMemory)
    .end
    set i = i + 1
  .end
  ret (true, StrError::Ok)
.end

fn string_pop(s: &String) -> (Bool, StrError, Bool, U8)
  if s.data.len == 0
    ret (true, StrError::Ok, false, 0)
  .end
  let last = *((Ptr[U8])s.data.data + (s.data.len - 1))
  do vec_pop[U8](&s.data)
  ret (true, StrError::Ok, true, last)
.end

# Truncate to length `n` (bytes)
fn string_truncate(s: &String, n: USize) -> (Bool, StrError)
  if n > s.data.len
    ret (false, StrError::Invalid)
  .end
  while s.data.len > n
    do vec_pop[U8](&s.data)
  .end
  ret (true, StrError::Ok)
.end

# -----------------------------------------------------------------------------
# Comparison
# -----------------------------------------------------------------------------

fn string_eq(a: &String, b: &String) -> Bool
  ret _bytes_eq(&a.data, &b.data)
.end

# Lexicographic compare: -1, 0, +1
fn string_cmp(a: &String, b: &String) -> I64
  let ap = (Ptr[U8])a.data.data
  let bp = (Ptr[U8])b.data.data
  let i: USize
  set i = 0
  let n: USize
  set n = a.data.len
  if b.data.len < n
    set n = b.data.len
  .end

  while i < n
    let x = *(ap + i)
    let y = *(bp + i)
    if x < y
      ret -1
    .end
    if x > y
      ret 1
    .end
    set i = i + 1
  .end

  if a.data.len < b.data.len
    ret -1
  .end
  if a.data.len > b.data.len
    ret 1
  .end
  ret 0
.end

# -----------------------------------------------------------------------------
# Slicing / building
# -----------------------------------------------------------------------------

fn string_slice(s: &String, start: USize, end: USize) -> (Bool, StrError, String)
  if start > end
    ret (false, StrError::Invalid, string_new())
  .end
  if end > s.data.len
    ret (false, StrError::Invalid, string_new())
  .end
  let out = string_new()
  let p = (Ptr[U8])s.data.data
  if !_vec_push_bytes(&out.data, p + start, end - start)
    do string_drop(&out)
    ret (false, StrError::OutOfMemory, string_new())
  .end
  ret (true, StrError::Ok, out)
.end

fn string_concat(a: &String, b: &String) -> (Bool, StrError, String)
  let out = string_new()
  if !_vec_push_bytes(&out.data, (Ptr[U8])a.data.data, a.data.len)
    do string_drop(&out)
    ret (false, StrError::OutOfMemory, string_new())
  .end
  if !_vec_push_bytes(&out.data, (Ptr[U8])b.data.data, b.data.len)
    do string_drop(&out)
    ret (false, StrError::OutOfMemory, string_new())
  .end
  ret (true, StrError::Ok, out)
.end

fn string_repeat(s: &String, count: USize) -> (Bool, StrError, String)
  let out = string_new()
  let i: USize
  set i = 0
  while i < count
    if !_vec_push_bytes(&out.data, (Ptr[U8])s.data.data, s.data.len)
      do string_drop(&out)
      ret (false, StrError::OutOfMemory, string_new())
    .end
    set i = i + 1
  .end
  ret (true, StrError::Ok, out)
.end

# -----------------------------------------------------------------------------
# Search
# -----------------------------------------------------------------------------

# Find first occurrence of `needle` in `hay` (byte-oriented)
# returns (found, index)
fn string_find(hay: &String, needle: &String) -> (Bool, StrError, Bool, USize)
  if needle.data.len == 0
    ret (true, StrError::Ok, true, 0)
  .end
  if needle.data.len > hay.data.len
    ret (true, StrError::Ok, false, 0)
  .end

  let hp = (Ptr[U8])hay.data.data
  let np = (Ptr[U8])needle.data.data

  let i: USize
  set i = 0
  while i + needle.data.len <= hay.data.len
    let j: USize
    set j = 0
    let ok: Bool
    set ok = true
    while j < needle.data.len
      if *(hp + i + j) != *(np + j)
        set ok = false
        break
      .end
      set j = j + 1
    .end

    if ok
      ret (true, StrError::Ok, true, i)
    .end

    set i = i + 1
  .end

  ret (true, StrError::Ok, false, 0)
.end

fn string_starts_with(s: &String, prefix: &String) -> Bool
  if prefix.data.len > s.data.len
    ret false
  .end
  let sp = (Ptr[U8])s.data.data
  let pp = (Ptr[U8])prefix.data.data
  let i: USize
  set i = 0
  while i < prefix.data.len
    if *(sp + i) != *(pp + i)
      ret false
    .end
    set i = i + 1
  .end
  ret true
.end

fn string_ends_with(s: &String, suffix: &String) -> Bool
  if suffix.data.len > s.data.len
    ret false
  .end
  let off = s.data.len - suffix.data.len
  let sp = (Ptr[U8])s.data.data
  let pp = (Ptr[U8])suffix.data.data
  let i: USize
  set i = 0
  while i < suffix.data.len
    if *(sp + off + i) != *(pp + i)
      ret false
    .end
    set i = i + 1
  .end
  ret true
.end

# -----------------------------------------------------------------------------
# Trim / case (ASCII)
# -----------------------------------------------------------------------------

fn string_trim_ascii(s: &String) -> (Bool, StrError, String)
  let n = s.data.len
  if n == 0
    ret (true, StrError::Ok, string_new())
  .end

  let p = (Ptr[U8])s.data.data
  let a: USize
  let b: USize
  set a = 0
  set b = n

  while a < b && _is_ascii_space(*(p + a))
    set a = a + 1
  .end
  while b > a && _is_ascii_space(*(p + (b - 1)))
    set b = b - 1
  .end

  ret string_slice(s, a, b)
.end

fn string_to_lower_ascii(s: &String) -> (Bool, StrError, String)
  let out = string_new()
  let p = (Ptr[U8])s.data.data
  let i: USize
  set i = 0
  while i < s.data.len
    if !_vec_push_u8(&out.data, _ascii_lower(*(p + i)))
      do string_drop(&out)
      ret (false, StrError::OutOfMemory, string_new())
    .end
    set i = i + 1
  .end
  ret (true, StrError::Ok, out)
.end

fn string_to_upper_ascii(s: &String) -> (Bool, StrError, String)
  let out = string_new()
  let p = (Ptr[U8])s.data.data
  let i: USize
  set i = 0
  while i < s.data.len
    if !_vec_push_u8(&out.data, _ascii_upper(*(p + i)))
      do string_drop(&out)
      ret (false, StrError::OutOfMemory, string_new())
    .end
    set i = i + 1
  .end
  ret (true, StrError::Ok, out)
.end

# Replace all occurrences of a single byte (ASCII-oriented)
fn string_replace_byte(s: &String, from: U8, to: U8) -> (Bool, StrError, String)
  let out = string_new()
  let p = (Ptr[U8])s.data.data
  let i: USize
  set i = 0
  while i < s.data.len
    let b = *(p + i)
    if b == from
      set b = to
    .end
    if !_vec_push_u8(&out.data, b)
      do string_drop(&out)
      ret (false, StrError::OutOfMemory, string_new())
    .end
    set i = i + 1
  .end
  ret (true, StrError::Ok, out)
.end

# -----------------------------------------------------------------------------
# Split / join
# -----------------------------------------------------------------------------

# Split by a delimiter byte. Empty segments are kept.
fn string_split_byte(s: &String, delim: U8) -> (Bool, StrError, Vec[String])
  let out = vec_new[String]()

  let start: USize
  set start = 0

  let p = (Ptr[U8])s.data.data
  let i: USize
  set i = 0
  while i < s.data.len
    if *(p + i) == delim
      let seg: String
      let ok: Bool
      let e: StrError
      (ok, e, seg) = string_slice(s, start, i)
      if !ok
        do vec_drop[String](&out, 0)
        ret (false, e, vec_new[String]())
      .end

      let okp: Bool
      let ce: ColError
      (okp, ce) = vec_push[String](&out, 0, seg)
      if !okp
        do string_drop(&seg)
        do vec_drop[String](&out, 0)
        ret (false, StrError::OutOfMemory, vec_new[String]())
      .end

      set start = i + 1
    .end
    set i = i + 1
  .end

  # final segment
  let last: String
  let ok2: Bool
  let e2: StrError
  (ok2, e2, last) = string_slice(s, start, s.data.len)
  if !ok2
    do vec_drop[String](&out, 0)
    ret (false, e2, vec_new[String]())
  .end
  let okp2: Bool
  let ce2: ColError
  (okp2, ce2) = vec_push[String](&out, 0, last)
  if !okp2
    do string_drop(&last)
    do vec_drop[String](&out, 0)
    ret (false, StrError::OutOfMemory, vec_new[String]())
  .end

  ret (true, StrError::Ok, out)
.end

fn strings_drop(v: &Vec[String])
  let i: USize
  set i = 0
  while i < v.len
    let it = *((Ptr[String])v.data + i)
    do string_drop(&it)
    set i = i + 1
  .end
  do vec_drop[String](v, 0)
.end

fn string_join(parts: &Vec[String], sep: &String) -> (Bool, StrError, String)
  let out = string_new()

  let i: USize
  set i = 0
  while i < parts.len
    if i != 0
      if !_vec_push_bytes(&out.data, (Ptr[U8])sep.data.data, sep.data.len)
        do string_drop(&out)
        ret (false, StrError::OutOfMemory, string_new())
      .end
    .end

    let it = *((Ptr[String])parts.data + i)
    if !_vec_push_bytes(&out.data, (Ptr[U8])it.data.data, it.data.len)
      do string_drop(&out)
      ret (false, StrError::OutOfMemory, string_new())
    .end

    set i = i + 1
  .end

  ret (true, StrError::Ok, out)
.end

# Split ASCII whitespace (one or more). Empty segments are skipped.
fn string_split_ascii_ws(s: &String) -> (Bool, StrError, Vec[String])
  let out = vec_new[String]()
  let p = (Ptr[U8])s.data.data

  let i: USize
  set i = 0
  while i < s.data.len
    while i < s.data.len && _is_ascii_space(*(p + i))
      set i = i + 1
    .end
    if i >= s.data.len
      break
    .end

    let start = i
    while i < s.data.len && !_is_ascii_space(*(p + i))
      set i = i + 1
    .end

    let seg: String
    let ok: Bool
    let e: StrError
    (ok, e, seg) = string_slice(s, start, i)
    if !ok
      do vec_drop[String](&out, 0)
      ret (false, e, vec_new[String]())
    .end

    let okp: Bool
    let ce: ColError
    (okp, ce) = vec_push[String](&out, 0, seg)
    if !okp
      do string_drop(&seg)
      do vec_drop[String](&out, 0)
      ret (false, StrError::OutOfMemory, vec_new[String]())
    .end
  .end

  ret (true, StrError::Ok, out)
.end

# -----------------------------------------------------------------------------
# Parsing (ASCII) - integers
# -----------------------------------------------------------------------------

fn string_parse_i64(s: &String) -> (Bool, StrError, Bool, I64)
  let p = (Ptr[U8])s.data.data
  let n = s.data.len
  if n == 0
    ret (true, StrError::Ok, false, 0)
  .end

  let i: USize
  set i = 0
  let neg: Bool
  set neg = false

  if *(p + 0) == (U8)'-'
    set neg = true
    set i = 1
    if i >= n
      ret (true, StrError::Ok, false, 0)
    .end
  .end

  let acc: I64
  set acc = 0

  while i < n
    let b = *(p + i)
    if !_is_ascii_digit(b)
      ret (true, StrError::Ok, false, 0)
    .end
    set acc = acc * (I64)10 + (I64)(b - (U8)'0')
    set i = i + 1
  .end

  if neg
    set acc = -acc
  .end

  ret (true, StrError::Ok, true, acc)
.end

fn string_parse_u64(s: &String) -> (Bool, StrError, Bool, U64)
  let p = (Ptr[U8])s.data.data
  let n = s.data.len
  if n == 0
    ret (true, StrError::Ok, false, 0)
  .end

  let i: USize
  set i = 0
  let acc: U64
  set acc = 0

  while i < n
    let b = *(p + i)
    if !_is_ascii_digit(b)
      ret (true, StrError::Ok, false, 0)
    .end
    set acc = acc * (U64)10 + (U64)(b - (U8)'0')
    set i = i + 1
  .end

  ret (true, StrError::Ok, true, acc)
.end

# -----------------------------------------------------------------------------
# Formatting - integers
# -----------------------------------------------------------------------------

fn string_from_i64(n: I64) -> (Bool, StrError, String)
  let out = string_new()

  if n == 0
    if !_vec_push_u8(&out.data, (U8)'0')
      do string_drop(&out)
      ret (false, StrError::OutOfMemory, string_new())
    .end
    ret (true, StrError::Ok, out)
  .end

  let x: I64
  set x = n
  let neg: Bool
  set neg = x < 0
  if neg
    set x = -x
  .end

  let tmp = vec_new[U8]()
  loop
    let d = (U8)(x % 10)
    if !_vec_push_u8(&tmp, (U8)'0' + d)
      do vec_drop[U8](&tmp, 1)
      do string_drop(&out)
      ret (false, StrError::OutOfMemory, string_new())
    .end
    set x = x / 10
    if x == 0
      break
    .end
  .end

  if neg
    if !_vec_push_u8(&out.data, (U8)'-')
      do vec_drop[U8](&tmp, 1)
      do string_drop(&out)
      ret (false, StrError::OutOfMemory, string_new())
    .end
  .end

  let i: USize
  set i = tmp.len
  while i > 0
    set i = i - 1
    if !_vec_push_u8(&out.data, *((Ptr[U8])tmp.data + i))
      do vec_drop[U8](&tmp, 1)
      do string_drop(&out)
      ret (false, StrError::OutOfMemory, string_new())
    .end
  .end

  do vec_drop[U8](&tmp, 1)
  ret (true, StrError::Ok, out)
.end

fn string_from_u64(n: U64) -> (Bool, StrError, String)
  let out = string_new()

  if n == 0
    if !_vec_push_u8(&out.data, (U8)'0')
      do string_drop(&out)
      ret (false, StrError::OutOfMemory, string_new())
    .end
    ret (true, StrError::Ok, out)
  .end

  let x: U64
  set x = n

  let tmp = vec_new[U8]()
  loop
    let d = (U8)(x % (U64)10)
    if !_vec_push_u8(&tmp, (U8)'0' + d)
      do vec_drop[U8](&tmp, 1)
      do string_drop(&out)
      ret (false, StrError::OutOfMemory, string_new())
    .end
    set x = x / (U64)10
    if x == 0
      break
    .end
  .end

  let i: USize
  set i = tmp.len
  while i > 0
    set i = i - 1
    if !_vec_push_u8(&out.data, *((Ptr[U8])tmp.data + i))
      do vec_drop[U8](&tmp, 1)
      do string_drop(&out)
      ret (false, StrError::OutOfMemory, string_new())
    .end
  .end

  do vec_drop[U8](&tmp, 1)
  ret (true, StrError::Ok, out)
.end

# -----------------------------------------------------------------------------
# Smoke tests (scenarios)
# -----------------------------------------------------------------------------

scn test_string_from_cstr_and_to_cbytes
  let ok: Bool
  let e: StrError
  let s: String

  (ok, e, s) = string_from_cstr("hello")
  do std.runtime::assert(ok, "from_cstr")

  let cb: Vec[U8]
  (ok, e, cb) = string_to_cbytes(&s)
  do std.runtime::assert(ok, "to_cbytes")

  do std.runtime::assert(cb.len == 6, "cbytes len")
  do std.runtime::assert(*((Ptr[U8])cb.data + 5) == 0, "cbytes nul")

  do vec_drop[U8](&cb, 1)
  do string_drop(&s)
.end

scn test_string_find_and_slice
  let ok: Bool
  let e: StrError
  let s: String
  let n: String

  (ok, e, s) = string_from_cstr("xxabcxx")
  (ok, e, n) = string_from_cstr("abc")

  let found: Bool
  let idx: USize
  (ok, e, found, idx) = string_find(&s, &n)
  do std.runtime::assert(ok && found && idx == 2, "find")

  let sub: String
  (ok, e, sub) = string_slice(&s, 2, 5)
  do std.runtime::assert(ok && string_eq(&sub, &n), "slice")

  do string_drop(&sub)
  do string_drop(&n)
  do string_drop(&s)
.end

scn test_string_split_join
  let ok: Bool
  let e: StrError

  let s: String
  (ok, e, s) = string_from_cstr("a,b,,c")

  let parts: Vec[String]
  (ok, e, parts) = string_split_byte(&s, (U8)',')
  do std.runtime::assert(ok, "split")
  do std.runtime::assert(parts.len == 4, "split len")

  let sep: String
  (ok, e, sep) = string_from_cstr("|")

  let joined: String
  (ok, e, joined) = string_join(&parts, &sep)
  do std.runtime::assert(ok, "join")

  let want: String
  (ok, e, want) = string_from_cstr("a|b||c")
  do std.runtime::assert(string_eq(&joined, &want), "join eq")

  do string_drop(&want)
  do string_drop(&joined)
  do string_drop(&sep)
  do strings_drop(&parts)
  do string_drop(&s)
.end

scn test_string_parse_and_format
  let ok: Bool
  let e: StrError

  let s: String
  (ok, e, s) = string_from_cstr("-42")

  let has: Bool
  let v: I64
  (ok, e, has, v) = string_parse_i64(&s)
  do std.runtime::assert(ok && has && v == -42, "parse i64")

  let t: String
  (ok, e, t) = string_from_i64(v)
  do std.runtime::assert(ok && string_eq(&s, &t), "format i64")

  do string_drop(&t)
  do string_drop(&s)
.end

# End of std.string