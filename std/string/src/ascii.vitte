

# /Users/vincent/Documents/Github/vitte/std/string/src/ascii.vitte
# -----------------------------------------------------------------------------
# std/string/ascii
# -----------------------------------------------------------------------------
# ASCII utilities: classification, case folding, and byte-wise string helpers.
#
# Design notes:
# - ASCII is defined over bytes 0x00..0x7F.
# - All classification/case APIs operate on U32 values representing bytes.
# - String helpers assume `std.string::len(s)` and `std.string::byte_at(s, i)`.
# - Slicing helpers assume `std.string::slice(s, start, len)`.
#   If your std.string uses a different API, adjust the wrappers only.
#
# Blocks use `.end` only.
# -----------------------------------------------------------------------------

module std.string.ascii

use std.runtime
use std.string

# -----------------------------------------------------------------------------
# Types
# -----------------------------------------------------------------------------

type Bool = bool

type U8  = u8

type U32 = u32

type U64 = u64

type I32 = i32

type Str = str

# Sentinel for "not found" indices.
const NPOS: U64 = 0xffffffffffffffff

# -----------------------------------------------------------------------------
# Core predicates (byte-oriented)
# -----------------------------------------------------------------------------

fn is_ascii(b: U32) -> Bool
  ret b <= 0x7f
.end

fn is_ascii_lower(b: U32) -> Bool
  ret b >= 0x61 && b <= 0x7a
.end

fn is_ascii_upper(b: U32) -> Bool
  ret b >= 0x41 && b <= 0x5a
.end

fn is_ascii_alpha(b: U32) -> Bool
  ret is_ascii_lower(b) || is_ascii_upper(b)
.end

fn is_ascii_digit(b: U32) -> Bool
  ret b >= 0x30 && b <= 0x39
.end

fn is_ascii_alnum(b: U32) -> Bool
  ret is_ascii_alpha(b) || is_ascii_digit(b)
.end

fn is_ascii_bin_digit(b: U32) -> Bool
  ret b == 0x30 || b == 0x31
.end

fn is_ascii_oct_digit(b: U32) -> Bool
  ret b >= 0x30 && b <= 0x37
.end

fn is_ascii_hex_lower(b: U32) -> Bool
  ret b >= 0x61 && b <= 0x66
.end

fn is_ascii_hex_upper(b: U32) -> Bool
  ret b >= 0x41 && b <= 0x46
.end

fn is_ascii_hex_digit(b: U32) -> Bool
  ret is_ascii_digit(b) || is_ascii_hex_lower(b) || is_ascii_hex_upper(b)
.end

fn is_ascii_control(b: U32) -> Bool
  # C0 controls + DEL
  ret b <= 0x1f || b == 0x7f
.end

fn is_ascii_space(b: U32) -> Bool
  # ASCII whitespace: space + \t\n\v\f\r
  if b == 0x20
    ret true
  .end
  if b >= 0x09 && b <= 0x0d
    ret true
  .end
  ret false
.end

fn is_ascii_blank(b: U32) -> Bool
  # space or tab
  ret b == 0x20 || b == 0x09
.end

fn is_ascii_print(b: U32) -> Bool
  # printable incl space
  ret b >= 0x20 && b <= 0x7e
.end

fn is_ascii_graph(b: U32) -> Bool
  # printable excluding space
  ret b >= 0x21 && b <= 0x7e
.end

fn is_ascii_punct(b: U32) -> Bool
  # punctuation ranges: !"#$%&'()*+,-./  :;<=>?  [\]^_`  {|}~
  if b >= 0x21 && b <= 0x2f
    ret true
  .end
  if b >= 0x3a && b <= 0x40
    ret true
  .end
  if b >= 0x5b && b <= 0x60
    ret true
  .end
  if b >= 0x7b && b <= 0x7e
    ret true
  .end
  ret false
.end

# -----------------------------------------------------------------------------
# Case conversion (byte-oriented)
# -----------------------------------------------------------------------------

fn to_ascii_lower(b: U32) -> U32
  if is_ascii_upper(b)
    ret b + 0x20
  .end
  ret b
.end

fn to_ascii_upper(b: U32) -> U32
  if is_ascii_lower(b)
    ret b - 0x20
  .end
  ret b
.end

fn fold_ascii_case(b: U32) -> U32
  # simple ASCII case fold
  ret to_ascii_lower(b)
.end

fn ascii_eq_ignore_case_byte(a: U32, b: U32) -> Bool
  ret fold_ascii_case(a) == fold_ascii_case(b)
.end

# -----------------------------------------------------------------------------
# Digit value helpers
# -----------------------------------------------------------------------------

fn dec_value(b: U32) -> I32
  if is_ascii_digit(b)
    ret (b - 0x30) as I32
  .end
  ret -1
.end

fn hex_value(b: U32) -> I32
  if is_ascii_digit(b)
    ret (b - 0x30) as I32
  .end
  if is_ascii_hex_lower(b)
    ret (10 + (b - 0x61)) as I32
  .end
  if is_ascii_hex_upper(b)
    ret (10 + (b - 0x41)) as I32
  .end
  ret -1
.end

fn oct_value(b: U32) -> I32
  if is_ascii_oct_digit(b)
    ret (b - 0x30) as I32
  .end
  ret -1
.end

fn bin_value(b: U32) -> I32
  if is_ascii_bin_digit(b)
    ret (b - 0x30) as I32
  .end
  ret -1
.end

# -----------------------------------------------------------------------------
# String helpers (byte-wise)
# -----------------------------------------------------------------------------

fn is_ascii_str(s: Str) -> Bool
  let n = std.string::len(s)
  let i: U64
  set i = 0
  while i < n
    let b = std.string::byte_at(s, i) as U32
    if !is_ascii(b)
      ret false
    .end
    set i = i + 1
  .end
  ret true
.end

fn is_ascii_str_printable(s: Str) -> Bool
  let n = std.string::len(s)
  let i: U64
  set i = 0
  while i < n
    let b = std.string::byte_at(s, i) as U32
    if !is_ascii_print(b)
      ret false
    .end
    set i = i + 1
  .end
  ret true
.end

fn find_byte(s: Str, needle: U32) -> U64
  let n = std.string::len(s)
  let i: U64
  set i = 0
  while i < n
    if (std.string::byte_at(s, i) as U32) == needle
      ret i
    .end
    set i = i + 1
  .end
  ret NPOS
.end

fn rfind_byte(s: Str, needle: U32) -> U64
  let n = std.string::len(s)
  if n == 0
    ret NPOS
  .end
  let i: U64
  set i = n
  while i > 0
    set i = i - 1
    if (std.string::byte_at(s, i) as U32) == needle
      ret i
    .end
  .end
  ret NPOS
.end

fn starts_with_byte(s: Str, b0: U32) -> Bool
  if std.string::len(s) == 0
    ret false
  .end
  ret (std.string::byte_at(s, 0) as U32) == b0
.end

fn ends_with_byte(s: Str, b0: U32) -> Bool
  let n = std.string::len(s)
  if n == 0
    ret false
  .end
  ret (std.string::byte_at(s, n - 1) as U32) == b0
.end

fn eq_ignore_case(a: Str, b: Str) -> Bool
  let na = std.string::len(a)
  let nb = std.string::len(b)
  if na != nb
    ret false
  .end

  let i: U64
  set i = 0
  while i < na
    let ba = std.string::byte_at(a, i) as U32
    let bb = std.string::byte_at(b, i) as U32

    # If either is non-ASCII, fall back to strict byte equality.
    if !is_ascii(ba) || !is_ascii(bb)
      if ba != bb
        ret false
      .end
    else
      if !ascii_eq_ignore_case_byte(ba, bb)
        ret false
      .end
    .end

    set i = i + 1
  .end

  ret true
.end

fn cmp_ignore_case(a: Str, b: Str) -> I32
  # Lexicographic compare with ASCII case fold.
  let na = std.string::len(a)
  let nb = std.string::len(b)
  let nmin: U64
  if na < nb
    set nmin = na
  else
    set nmin = nb
  .end

  let i: U64
  set i = 0
  while i < nmin
    let ba = std.string::byte_at(a, i) as U32
    let bb = std.string::byte_at(b, i) as U32

    let ca: U32
    let cb: U32

    if is_ascii(ba)
      set ca = fold_ascii_case(ba)
    else
      set ca = ba
    .end

    if is_ascii(bb)
      set cb = fold_ascii_case(bb)
    else
      set cb = bb
    .end

    if ca < cb
      ret -1
    .end
    if ca > cb
      ret 1
    .end

    set i = i + 1
  .end

  if na < nb
    ret -1
  .end
  if na > nb
    ret 1
  .end
  ret 0
.end

fn starts_with_ignore_case(hay: Str, pref: Str) -> Bool
  let nh = std.string::len(hay)
  let np = std.string::len(pref)
  if np == 0
    ret true
  .end
  if np > nh
    ret false
  .end

  let i: U64
  set i = 0
  while i < np
    let a = std.string::byte_at(hay, i) as U32
    let b = std.string::byte_at(pref, i) as U32

    if is_ascii(a) && is_ascii(b)
      if !ascii_eq_ignore_case_byte(a, b)
        ret false
      .end
    else
      if a != b
        ret false
      .end
    .end

    set i = i + 1
  .end

  ret true
.end

fn ends_with_ignore_case(hay: Str, suf: Str) -> Bool
  let nh = std.string::len(hay)
  let ns = std.string::len(suf)
  if ns == 0
    ret true
  .end
  if ns > nh
    ret false
  .end

  let base = nh - ns
  let i: U64
  set i = 0
  while i < ns
    let a = std.string::byte_at(hay, base + i) as U32
    let b = std.string::byte_at(suf, i) as U32

    if is_ascii(a) && is_ascii(b)
      if !ascii_eq_ignore_case_byte(a, b)
        ret false
      .end
    else
      if a != b
        ret false
      .end
    .end

    set i = i + 1
  .end

  ret true
.end

fn trim_ascii_whitespace(s: Str) -> Str
  # Requires std.string::slice(s, start, len).
  let n = std.string::len(s)
  if n == 0
    ret s
  .end

  let start: U64
  let end: U64
  set start = 0
  set end = n

  while start < end
    let b = std.string::byte_at(s, start) as U32
    if !is_ascii_space(b)
      break
    .end
    set start = start + 1
  .end

  while end > start
    let b = std.string::byte_at(s, end - 1) as U32
    if !is_ascii_space(b)
      break
    .end
    set end = end - 1
  .end

  ret std.string::slice(s, start, end - start)
.end

fn trim_ascii_whitespace_left(s: Str) -> Str
  let n = std.string::len(s)
  let start: U64
  set start = 0
  while start < n
    let b = std.string::byte_at(s, start) as U32
    if !is_ascii_space(b)
      break
    .end
    set start = start + 1
  .end
  ret std.string::slice(s, start, n - start)
.end

fn trim_ascii_whitespace_right(s: Str) -> Str
  let n = std.string::len(s)
  let end: U64
  set end = n
  while end > 0
    let b = std.string::byte_at(s, end - 1) as U32
    if !is_ascii_space(b)
      break
    .end
    set end = end - 1
  .end
  ret std.string::slice(s, 0, end)
.end

fn count_ascii_spaces(s: Str) -> U64
  let n = std.string::len(s)
  let i: U64
  let c: U64
  set i = 0
  set c = 0
  while i < n
    if is_ascii_space(std.string::byte_at(s, i) as U32)
      set c = c + 1
    .end
    set i = i + 1
  .end
  ret c
.end

# -----------------------------------------------------------------------------
# Parsing helpers (best-effort, ASCII only)
# -----------------------------------------------------------------------------
# Returns default_value on failure.

fn parse_u64_dec_or(s: Str, default_value: U64) -> U64
  let n = std.string::len(s)
  if n == 0
    ret default_value
  .end

  let i: U64
  set i = 0

  # optional + sign
  if (std.string::byte_at(s, 0) as U32) == 0x2b
    set i = 1
    if i == n
      ret default_value
    .end
  .end

  let acc: U64
  set acc = 0

  while i < n
    let b = std.string::byte_at(s, i) as U32
    let d = dec_value(b)
    if d < 0
      ret default_value
    .end

    # overflow check: acc*10 + d
    if acc > (0xffffffffffffffff / 10)
      ret default_value
    .end
    set acc = acc * 10

    let du = d as U64
    if acc > (0xffffffffffffffff - du)
      ret default_value
    .end
    set acc = acc + du

    set i = i + 1
  .end

  ret acc
.end

fn parse_u64_hex_or(s: Str, default_value: U64) -> U64
  let n = std.string::len(s)
  if n == 0
    ret default_value
  .end

  let i: U64
  set i = 0

  # optional 0x/0X
  if n >= 2
    let b0 = std.string::byte_at(s, 0) as U32
    let b1 = std.string::byte_at(s, 1) as U32
    if b0 == 0x30 && (b1 == 0x78 || b1 == 0x58)
      set i = 2
      if i == n
        ret default_value
      .end
    .end
  .end

  let acc: U64
  set acc = 0

  while i < n
    let b = std.string::byte_at(s, i) as U32
    let hv = hex_value(b)
    if hv < 0
      ret default_value
    .end

    # overflow check: acc<<4 + hv
    if acc > (0xffffffffffffffff >> 4)
      ret default_value
    .end
    set acc = acc << 4

    let hu = hv as U64
    if acc > (0xffffffffffffffff - hu)
      ret default_value
    .end
    set acc = acc + hu

    set i = i + 1
  .end

  ret acc
.end

# -----------------------------------------------------------------------------
# Internal assertion helpers for tests
# -----------------------------------------------------------------------------

fn assert_true(b: Bool, msg: Str)
  do std.runtime::assert(b, msg)
.end

fn assert_false(b: Bool, msg: Str)
  do std.runtime::assert(!b, msg)
.end

fn assert_eq_u64(a: U64, b: U64, msg: Str)
  do std.runtime::assert(a == b, msg)
.end

fn assert_eq_i32(a: I32, b: I32, msg: Str)
  do std.runtime::assert(a == b, msg)
.end

# -----------------------------------------------------------------------------
# Tests
# -----------------------------------------------------------------------------

scn test_ascii_predicates
  do assert_true(is_ascii(0), "ascii 0")
  do assert_true(is_ascii(0x7f), "ascii 0x7f")
  do assert_false(is_ascii(0x80), "non-ascii 0x80")

  do assert_true(is_ascii_lower(0x61), "a lower")
  do assert_true(is_ascii_upper(0x5a), "Z upper")
  do assert_false(is_ascii_alpha(0x40), "@ not alpha")

  do assert_true(is_ascii_digit(0x30), "0 digit")
  do assert_true(is_ascii_alnum(0x39), "9 alnum")
  do assert_true(is_ascii_alnum(0x41), "A alnum")
  do assert_false(is_ascii_alnum(0x2f), "/ not alnum")

  do assert_true(is_ascii_hex_digit(0x66), "f hex")
  do assert_true(is_ascii_hex_digit(0x46), "F hex")
  do assert_true(is_ascii_hex_digit(0x39), "9 hex")
  do assert_false(is_ascii_hex_digit(0x47), "G not hex")

  do assert_true(is_ascii_space(0x20), "space")
  do assert_true(is_ascii_space(0x0a), "\\n")
  do assert_false(is_ascii_space(0x2d), "- not space")

  do assert_true(is_ascii_control(0x1f), "c0 control")
  do assert_true(is_ascii_control(0x7f), "DEL")
  do assert_false(is_ascii_control(0x20), "space not control")

  do assert_true(is_ascii_print(0x20), "print space")
  do assert_true(is_ascii_print(0x7e), "print ~")
  do assert_false(is_ascii_print(0x7f), "DEL not print")

  do assert_true(is_ascii_punct(0x21), "!")
  do assert_true(is_ascii_punct(0x2f), "/")
  do assert_true(is_ascii_punct(0x3a), ":")
  do assert_true(is_ascii_punct(0x60), "`")
  do assert_true(is_ascii_punct(0x7e), "~")
  do assert_false(is_ascii_punct(0x30), "0 not punct")
.end

scn test_ascii_case
  do assert_eq_u64(to_ascii_lower(0x41) as U64, 0x61, "A->a")
  do assert_eq_u64(to_ascii_upper(0x7a) as U64, 0x5a, "z->Z")
  do assert_eq_u64(to_ascii_lower(0x5f) as U64, 0x5f, "_ stays")

  do assert_true(ascii_eq_ignore_case_byte(0x41, 0x61), "A == a")
  do assert_true(ascii_eq_ignore_case_byte(0x5a, 0x7a), "Z == z")
  do assert_false(ascii_eq_ignore_case_byte(0x41, 0x62), "A != b")
.end

scn test_ascii_digit_values
  do assert_eq_i32(dec_value(0x30), 0, "dec 0")
  do assert_eq_i32(dec_value(0x39), 9, "dec 9")
  do assert_eq_i32(dec_value(0x2f), -1, "dec invalid")

  do assert_eq_i32(hex_value(0x30), 0, "hex 0")
  do assert_eq_i32(hex_value(0x39), 9, "hex 9")
  do assert_eq_i32(hex_value(0x41), 10, "hex A")
  do assert_eq_i32(hex_value(0x46), 15, "hex F")
  do assert_eq_i32(hex_value(0x61), 10, "hex a")
  do assert_eq_i32(hex_value(0x66), 15, "hex f")
  do assert_eq_i32(hex_value(0x67), -1, "hex g invalid")

  do assert_eq_i32(oct_value(0x30), 0, "oct 0")
  do assert_eq_i32(oct_value(0x37), 7, "oct 7")
  do assert_eq_i32(oct_value(0x38), -1, "oct invalid")

  do assert_eq_i32(bin_value(0x30), 0, "bin 0")
  do assert_eq_i32(bin_value(0x31), 1, "bin 1")
  do assert_eq_i32(bin_value(0x32), -1, "bin invalid")
.end

scn test_ascii_string_helpers
  # These tests assume std.string literal support.
  let a: Str
  let b: Str
  let c: Str
  set a = "Hello"
  set b = "heLLo"
  set c = "Hello!"

  do assert_true(eq_ignore_case(a, b), "eq_ignore_case")
  do assert_false(eq_ignore_case(a, c), "len differs")

  do assert_true(starts_with_ignore_case(c, "he"), "starts")
  do assert_true(ends_with_ignore_case(c, "LO!"), "ends")

  do assert_eq_i32(cmp_ignore_case("abc", "AbC"), 0, "cmp eq")
  do assert_true(cmp_ignore_case("abc", "abd") < 0, "cmp lt")
  do assert_true(cmp_ignore_case("abe", "abd") > 0, "cmp gt")

  do assert_true(is_ascii_str("ABCxyz09_"), "ascii str")
.end

scn test_ascii_parse
  do assert_eq_u64(parse_u64_dec_or("0", 9), 0, "dec 0")
  do assert_eq_u64(parse_u64_dec_or("+42", 9), 42, "dec +42")
  do assert_eq_u64(parse_u64_dec_or("0042", 9), 42, "dec 0042")
  do assert_eq_u64(parse_u64_dec_or("42x", 9), 9, "dec invalid")

  do assert_eq_u64(parse_u64_hex_or("0", 9), 0, "hex 0")
  do assert_eq_u64(parse_u64_hex_or("ff", 9), 255, "hex ff")
  do assert_eq_u64(parse_u64_hex_or("0x10", 9), 16, "hex 0x10")
  do assert_eq_u64(parse_u64_hex_or("0X10", 9), 16, "hex 0X10")
  do assert_eq_u64(parse_u64_hex_or("0x", 9), 9, "hex invalid")
  do assert_eq_u64(parse_u64_hex_or("gg", 9), 9, "hex invalid")
.end

# End of std.string.ascii