# /Users/vincent/Documents/Github/vitte/std/fs/src/path.vitte
# -----------------------------------------------------------------------------
# std/fs/path
# -----------------------------------------------------------------------------
# Path utilities (pure string-based) for Vitte stdlib.
#
# MAX MAX goals:
# - Pure path manipulation (no syscalls): join/normalize/split/dirname/basename/ext.
# - Cross-platform semantics (POSIX + Windows drive/UNC best-effort).
# - Deterministic behavior: never touch filesystem.
# - Bootstrap-friendly: use only std.runtime + std.string (+ std.core optional).
#
# Design decisions:
# - Path is represented as Str (UTF-8 string). No owned/buffered path type yet.
# - Separators accepted: '/' and '\\'. Normalization chooses '/' by default.
# - Windows drive detection: "C:" prefix and UNC prefix "\\\\".
# - Normalization:
#     - collapses repeated separators
#     - resolves '.' segments
#     - resolves '..' segments when possible (not past root/prefix)
#     - preserves leading prefix/root
#
# Notes:
# - This module assumes std.string provides:
#     len(s), slice(s,start,len), find(s,sub), rfind(s,sub), starts_with(s,p),
#     ends_with(s,p), contains(s,sub) [optional], trim(s), etc.
#   Where a helper may not exist, the code uses local fallbacks.
# - All blocks use `.end` only.
# -----------------------------------------------------------------------------

module std.fs.path

use std.runtime
use std.string
use std.core.cmp

type Bool = bool
type U32  = u32
type I32  = i32
type Str  = str

# -----------------------------------------------------------------------------
# Basic string helpers
# -----------------------------------------------------------------------------

fn s_len(s: Str) -> U32
  ret std.string::len(s)
.end

fn s_slice(s: Str, start: U32, len: U32) -> Str
  ret std.string::slice(s, start, len)
.end

fn s_starts_with(s: Str, p: Str) -> Bool
  ret std.string::starts_with(s, p)
.end

fn s_ends_with(s: Str, p: Str) -> Bool
  ret std.string::ends_with(s, p)
.end

fn s_find(s: Str, sub: Str) -> I32
  ret std.string::find(s, sub)
.end

fn s_rfind(s: Str, sub: Str) -> I32
  ret std.string::rfind(s, sub)
.end

fn s_concat(a: Str, b: Str) -> Str
  ret std.string::concat(a, b)
.end

fn s_eq(a: Str, b: Str) -> Bool
  ret a == b
.end

fn s_is_empty(s: Str) -> Bool
  ret s_len(s) == 0
.end

# -----------------------------------------------------------------------------
# Separator predicates
# -----------------------------------------------------------------------------

fn is_sep_ch(ch: Str) -> Bool
  ret (ch == "/") || (ch == "\\")
.end

fn is_sep_at(p: Str, i: U32) -> Bool
  if i >= s_len(p)
    ret false
  .end
  ret is_sep_ch(s_slice(p, i, 1))
.end

fn canonical_sep() -> Str
  ret "/"
.end

# Convert backslashes to slashes (best-effort)
fn to_slashes(p: Str) -> Str
  # If std.string has replace, use it; else do a manual pass.
  if std.string::has_replace()
    ret std.string::replace(p, "\\", "/")
  .end

  let out: Str
  set out = ""
  let i: U32
  set i = 0
  while i < s_len(p)
    let ch = s_slice(p, i, 1)
    if ch == "\\"
      set out = s_concat(out, "/")
    else
      set out = s_concat(out, ch)
    .end
    set i = i + 1
  .end
  ret out
.end

# -----------------------------------------------------------------------------
# Prefix / root detection (Windows + POSIX)
# -----------------------------------------------------------------------------
# Returns (prefix, rest, is_abs)
# - prefix: "", "/", "C:", "//server/share" (UNC) etc.
# - rest: remaining after prefix (no leading separators in most cases)
# - is_abs: absolute path (rooted) after considering prefix
# -----------------------------------------------------------------------------

type PrefixInfo struct
  prefix: Str
  rest: Str
  is_abs: Bool
.end

fn prefixinfo_new(prefix: Str, rest: Str, is_abs: Bool) -> PrefixInfo
  let x: PrefixInfo
  set x.prefix = prefix
  set x.rest = rest
  set x.is_abs = is_abs
  ret x
.end

fn is_alpha(ch: Str) -> Bool
  # ASCII alpha (best-effort)
  if ch == "a" ret true .end
  if ch == "b" ret true .end
  if ch == "c" ret true .end
  if ch == "d" ret true .end
  if ch == "e" ret true .end
  if ch == "f" ret true .end
  if ch == "g" ret true .end
  if ch == "h" ret true .end
  if ch == "i" ret true .end
  if ch == "j" ret true .end
  if ch == "k" ret true .end
  if ch == "l" ret true .end
  if ch == "m" ret true .end
  if ch == "n" ret true .end
  if ch == "o" ret true .end
  if ch == "p" ret true .end
  if ch == "q" ret true .end
  if ch == "r" ret true .end
  if ch == "s" ret true .end
  if ch == "t" ret true .end
  if ch == "u" ret true .end
  if ch == "v" ret true .end
  if ch == "w" ret true .end
  if ch == "x" ret true .end
  if ch == "y" ret true .end
  if ch == "z" ret true .end
  if ch == "A" ret true .end
  if ch == "B" ret true .end
  if ch == "C" ret true .end
  if ch == "D" ret true .end
  if ch == "E" ret true .end
  if ch == "F" ret true .end
  if ch == "G" ret true .end
  if ch == "H" ret true .end
  if ch == "I" ret true .end
  if ch == "J" ret true .end
  if ch == "K" ret true .end
  if ch == "L" ret true .end
  if ch == "M" ret true .end
  if ch == "N" ret true .end
  if ch == "O" ret true .end
  if ch == "P" ret true .end
  if ch == "Q" ret true .end
  if ch == "R" ret true .end
  if ch == "S" ret true .end
  if ch == "T" ret true .end
  if ch == "U" ret true .end
  if ch == "V" ret true .end
  if ch == "W" ret true .end
  if ch == "X" ret true .end
  if ch == "Y" ret true .end
  if ch == "Z" ret true .end
  ret false
.end

fn parse_prefix(p0: Str) -> PrefixInfo
  let p = to_slashes(p0)

  if s_is_empty(p)
    ret prefixinfo_new("", "", false)
  .end

  # UNC: starts with "//"
  if s_starts_with(p, "//")
    # Find server/share: //server/share/...
    # Keep prefix as //server/share and rest after that.
    let tmp = s_slice(p, 2, s_len(p) - 2)
    let first = s_find(tmp, "/")
    if first < 0
      ret prefixinfo_new(p, "", true)
    .end
    let server = s_slice(tmp, 0, (U32)first)
    let tmp2 = s_slice(tmp, (U32)first + 1, s_len(tmp) - ((U32)first + 1))
    let second = s_find(tmp2, "/")
    if second < 0
      let pref = s_concat("//", s_concat(server, s_concat("/", tmp2)))
      ret prefixinfo_new(pref, "", true)
    .end
    let share = s_slice(tmp2, 0, (U32)second)
    let pref = s_concat("//", s_concat(server, s_concat("/", share)))
    let rest = s_slice(tmp2, (U32)second + 1, s_len(tmp2) - ((U32)second + 1))
    ret prefixinfo_new(pref, rest, true)
  .end

  # Drive: "C:" (optionally followed by "/")
  if s_len(p) >= 2
    let c0 = s_slice(p, 0, 1)
    let c1 = s_slice(p, 1, 1)
    if is_alpha(c0) && (c1 == ":")
      let pref = s_slice(p, 0, 2) # "C:"
      if s_len(p) == 2
        ret prefixinfo_new(pref, "", false) # "C:" relative to cwd on drive
      .end
      if is_sep_at(p, 2)
        let rest = s_slice(p, 3, s_len(p) - 3)
        ret prefixinfo_new(pref, rest, true) # "C:/..." absolute on drive
      .end
      let rest = s_slice(p, 2, s_len(p) - 2)
      ret prefixinfo_new(pref, rest, false)
    .end
  .end

  # POSIX absolute: starts with "/"
  if s_starts_with(p, "/")
    let rest = p
    # strip leading slashes but remember rooted
    while s_starts_with(rest, "/")
      if s_len(rest) == 1
        ret prefixinfo_new("/", "", true)
      .end
      set rest = s_slice(rest, 1, s_len(rest) - 1)
    .end
    ret prefixinfo_new("/", rest, true)
  .end

  ret prefixinfo_new("", p, false)
.end

fn is_absolute(p: Str) -> Bool
  let info = parse_prefix(p)
  ret info.is_abs
.end

# -----------------------------------------------------------------------------
# Split into segments by '/'
# -----------------------------------------------------------------------------

type SegList struct
  # simple string builder of segments separated by '\n' (bootstrap)
  data: Str
  count: U32
.end

fn seglist_new() -> SegList
  let s: SegList
  set s.data = ""
  set s.count = 0
  ret s
.end

fn seglist_push(sl: &SegList, seg: Str)
  if sl.count == 0
    set sl.data = seg
  else
    set sl.data = s_concat(sl.data, s_concat("\n", seg))
  .end
  set sl.count = sl.count + 1
.end

fn seglist_get(sl: &SegList, idx: U32) -> Str
  # naive: iterate lines
  let i: U32
  set i = 0
  let start: U32
  set start = 0
  let cur: U32
  set cur = 0
  while cur < s_len(sl.data)
    if i == idx
      # find end
      let j: U32
      set j = start
      while j < s_len(sl.data) && s_slice(sl.data, j, 1) != "\n"
        set j = j + 1
      .end
      ret s_slice(sl.data, start, j - start)
    .end

    if s_slice(sl.data, cur, 1) == "\n"
      set i = i + 1
      set start = cur + 1
    .end
    set cur = cur + 1
  .end

  # last segment
  if i == idx
    ret s_slice(sl.data, start, s_len(sl.data) - start)
  .end
  ret ""
.end

fn split_segments(p: Str) -> SegList
  let sl = seglist_new()

  let i: U32
  set i = 0
  let start: U32
  set start = 0

  while i <= s_len(p)
    if i == s_len(p) || s_slice(p, i, 1) == "/"
      let seg_len = i - start
      if seg_len > 0
        let seg = s_slice(p, start, seg_len)
        do seglist_push(&sl, seg)
      .end
      set start = i + 1
    .end
    set i = i + 1
  .end

  ret sl
.end

# -----------------------------------------------------------------------------
# Normalize (collapse ., .., separators)
# -----------------------------------------------------------------------------

fn normalize(p0: Str) -> Str
  let info = parse_prefix(p0)
  let rest = info.rest

  # canonicalize seps in rest (already slashes)
  let rest2 = to_slashes(rest)

  # split segments
  let segs = split_segments(rest2)

  # stack as SegList (use same structure)
  let stack = seglist_new()

  let i: U32
  set i = 0
  while i < segs.count
    let seg = seglist_get(&segs, i)

    if seg == "."
      # skip
      set i = i + 1
      continue
    .end

    if seg == ".."
      if stack.count > 0
        # pop
        # remove last by rebuilding (bootstrap)
        let new_stack = seglist_new()
        let j: U32
        set j = 0
        while j + 1 < stack.count
          do seglist_push(&new_stack, seglist_get(&stack, j))
          set j = j + 1
        .end
        set stack = new_stack
      else
        # if not absolute, keep leading ..
        if !info.is_abs
          do seglist_push(&stack, "..")
        .end
      .end
      set i = i + 1
      continue
    .end

    do seglist_push(&stack, seg)
    set i = i + 1
  .end

  # join stack
  let out: Str
  set out = ""

  # prefix
  if info.prefix == "/"
    set out = "/"
  else
    set out = info.prefix
    if !s_is_empty(out) && info.is_abs
      set out = s_concat(out, "/")
    .end
  .end

  let k: U32
  set k = 0
  while k < stack.count
    if k > 0
      set out = s_concat(out, "/")
    .end
    set out = s_concat(out, seglist_get(&stack, k))
    set k = k + 1
  .end

  # special-case empty
  if s_is_empty(out)
    if info.is_abs
      if s_is_empty(info.prefix)
        ret "/"
      .end
      ret info.prefix
    .end
    ret "."
  .end

  ret out
.end

# -----------------------------------------------------------------------------
# Join
# -----------------------------------------------------------------------------

fn join(a: Str, b: Str) -> Str
  if s_is_empty(a)
    ret b
  .end
  if s_is_empty(b)
    ret a
  .end

  # if b is absolute, return normalized b
  if is_absolute(b)
    ret normalize(b)
  .end

  let aa = to_slashes(a)
  let bb = to_slashes(b)

  if s_ends_with(aa, "/")
    ret normalize(s_concat(aa, bb))
  .end
  ret normalize(s_concat(aa, s_concat("/", bb)))
.end

fn join3(a: Str, b: Str, c: Str) -> Str
  ret join(join(a, b), c)
.end

# -----------------------------------------------------------------------------
# Dirname / Basename
# -----------------------------------------------------------------------------

fn basename(p0: Str) -> Str
  let p = normalize(p0)
  if p == "/" ret "/" .end
  if s_ends_with(p, "/")
    # trim trailing slash (except root)
    let q = s_slice(p, 0, s_len(p) - 1)
    ret basename(q)
  .end
  let i = s_rfind(p, "/")
  if i < 0
    ret p
  .end
  ret s_slice(p, (U32)i + 1, s_len(p) - ((U32)i + 1))
.end

fn dirname(p0: Str) -> Str
  let p = normalize(p0)
  if p == "/" ret "/" .end

  if s_ends_with(p, "/")
    let q = s_slice(p, 0, s_len(p) - 1)
    ret dirname(q)
  .end

  let i = s_rfind(p, "/")
  if i < 0
    ret "."
  .end
  if i == 0
    ret "/"
  .end
  ret s_slice(p, 0, (U32)i)
.end

# -----------------------------------------------------------------------------
# Extension helpers
# -----------------------------------------------------------------------------

fn extname(p0: Str) -> Str
  let base = basename(p0)
  if base == "." ret "" .end
  if base == ".." ret "" .end
  let i = s_rfind(base, ".")
  if i < 0
    ret ""
  .end
  if i == 0
    # ".bashrc" => ext "", treat leading dot as no ext
    ret ""
  .end
  ret s_slice(base, (U32)i + 1, s_len(base) - ((U32)i + 1))
.end

fn has_ext(p0: Str) -> Bool
  ret !s_is_empty(extname(p0))
.end

fn stem(p0: Str) -> Str
  let base = basename(p0)
  let i = s_rfind(base, ".")
  if i <= 0
    ret base
  .end
  ret s_slice(base, 0, (U32)i)
.end

# -----------------------------------------------------------------------------
# Split (dirname, basename)
# -----------------------------------------------------------------------------

type SplitPath struct
  dir: Str
  base: Str
.end

fn split(p: Str) -> SplitPath
  let s: SplitPath
  set s.dir = dirname(p)
  set s.base = basename(p)
  ret s
.end

# -----------------------------------------------------------------------------
# Relativize (best-effort)
# -----------------------------------------------------------------------------

fn relpath(from0: Str, to0: Str) -> Str
  let from = normalize(from0)
  let to = normalize(to0)

  # if prefixes differ (drive/UNC/root), return to
  let pf = parse_prefix(from)
  let pt = parse_prefix(to)
  if pf.prefix != pt.prefix || pf.is_abs != pt.is_abs
    ret to
  .end

  let a = split_segments(pf.rest)
  let b = split_segments(pt.rest)

  # find common prefix length
  let i: U32
  set i = 0
  while i < a.count && i < b.count
    if seglist_get(&a, i) != seglist_get(&b, i)
      break
    .end
    set i = i + 1
  .end

  # up moves
  let out: Str
  set out = ""

  let up: U32
  set up = i
  while up < a.count
    if s_is_empty(out)
      set out = ".."
    else
      set out = s_concat(out, s_concat("/", ".."))
    .end
    set up = up + 1
  .end

  # down moves
  let j: U32
  set j = i
  while j < b.count
    let seg = seglist_get(&b, j)
    if s_is_empty(out)
      set out = seg
    else
      set out = s_concat(out, s_concat("/", seg))
    .end
    set j = j + 1
  .end

  if s_is_empty(out)
    ret "."
  .end
  ret out
.end

# -----------------------------------------------------------------------------
# Smoke tests (scenarios)
# -----------------------------------------------------------------------------

scn test_path_normalize_posix
  do std.runtime::assert(normalize("/a//b/./c") == "/a/b/c", "norm posix")
  do std.runtime::assert(normalize("/a/b/../c") == "/a/c", "norm ..")
  do std.runtime::assert(dirname("/a/b") == "/a", "dirname")
  do std.runtime::assert(basename("/a/b") == "b", "basename")
.end

scn test_path_ext
  do std.runtime::assert(extname("/a/b.txt") == "txt", "ext txt")
  do std.runtime::assert(stem("/a/b.txt") == "b", "stem b")
  do std.runtime::assert(extname(".bashrc") == "", "dotfile ext empty")
.end

scn test_path_join_rel
  do std.runtime::assert(join("/a/b", "c") == "/a/b/c", "join")
  do std.runtime::assert(relpath("/a/b", "/a/b/c/d") == "c/d", "rel down")
  do std.runtime::assert(relpath("/a/b/c", "/a/b/d") == "../d", "rel up")
.end

# End of std.fs.path