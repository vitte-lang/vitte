# /Users/vincent/Documents/Github/vitte/std/fs/src/walk.vitte
# -----------------------------------------------------------------------------
# std/fs/walk
# -----------------------------------------------------------------------------
# Directory tree walking utilities (filesystem traversal).
#
# MAX MAX goals:
# - Provide a robust directory walker abstraction usable by tools/build systems.
# - Support recursion, depth limits, filters, and error handling strategies.
# - Keep OS-specific syscalls behind a small Dir API surface (stubbed here).
#
# Design:
# - Public API:
#     WalkOptions, WalkEntry, WalkError, WalkEvent
#     walk_dir(root, opts, cb) -> WalkError
#     iter-style: WalkIter (state machine) for pull-based traversal
# - Underlying IO delegated to std.fs.dir facade:
#     dir_open(path) -> DirHandle
#     dir_read_next(handle) -> (ok, Dirent)
#     dir_close(handle)
#     stat(path) -> FileInfo
#   These are stubs until wired.
#
# Traversal model:
# - Preorder (DirEnter -> entries -> DirExit)
# - Emits events for directories and files.
# - Options:
#     follow_symlinks, include_hidden, max_depth, sort, on_error policy
#
# All blocks use `.end` only.
# -----------------------------------------------------------------------------

module std.fs.walk

use std.runtime
use std.string
use std.core.result
use std.fs.path

type Bool = bool
type U32  = u32
type I32  = i32
type Str  = str

# -----------------------------------------------------------------------------
# FS facade (stubs)
# -----------------------------------------------------------------------------

type DirHandle struct
  id: I32
.end

fn dir_invalid() -> DirHandle
  let h: DirHandle
  set h.id = -1
  ret h
.end

fn dir_is_valid(h: &DirHandle) -> Bool
  ret h.id >= 0
.end

type FileType enum
  Unknown
  File
  Dir
  Symlink
.end

type Dirent struct
  name: Str
  typ: FileType
.end

type FileInfo struct
  typ: FileType
  size: U32
.end

fn fs_dir_open(path: Str) -> DirHandle
  # TODO: syscall wrapper
  ret dir_invalid()
.end

fn fs_dir_read_next(h: &DirHandle) -> (Bool, Dirent)
  # TODO
  let d: Dirent
  set d.name = ""
  set d.typ = FileType::Unknown
  ret (false, d)
.end

fn fs_dir_close(h: &DirHandle) -> Bool
  # TODO
  ret false
.end

fn fs_stat(path: Str, follow_symlink: Bool) -> std.core.result::ResultU32
  # TODO: return ok(size) or err(...)
  ret std.core.result::u32_err(std.core.result::err_io("stat not implemented"))
.end

fn fs_is_hidden_name(name: Str) -> Bool
  # Unix: leading dot
  if std.string::starts_with(name, ".")
    ret true
  .end
  ret false
.end

# -----------------------------------------------------------------------------
# Walk error / policies
# -----------------------------------------------------------------------------

type OnError enum
  Stop        # first error stops traversal
  Skip        # skip that entry and continue
  Report      # call callback with Error event and continue
.end

type WalkError struct
  ok: Bool
  err: std.core.result::Error
.end

fn walk_ok() -> WalkError
  let w: WalkError
  set w.ok = true
  set w.err = std.core.result::err_ok()
  ret w
.end

fn walk_err(e: std.core.result::Error) -> WalkError
  let w: WalkError
  set w.ok = false
  set w.err = e
  ret w
.end

fn walk_is_ok(w: &WalkError) -> Bool
  ret w.ok
.end

# -----------------------------------------------------------------------------
# Options / Entry / Events
# -----------------------------------------------------------------------------

type WalkOptions struct
  follow_symlinks: Bool
  include_hidden: Bool
  max_depth: U32        # 0 => only root event(s); 1 => root children; ...
  sort: Bool            # sort entries by name (requires buffering)
  on_error: OnError
.end

fn walk_options_default() -> WalkOptions
  let o: WalkOptions
  set o.follow_symlinks = false
  set o.include_hidden = false
  set o.max_depth = 0xffffffff
  set o.sort = false
  set o.on_error = OnError::Stop
  ret o
.end

type WalkEntry struct
  path: Str
  name: Str
  depth: U32
  typ: FileType
  size: U32
.end

fn entry_new(path: Str, name: Str, depth: U32, typ: FileType, size: U32) -> WalkEntry
  let e: WalkEntry
  set e.path = path
  set e.name = name
  set e.depth = depth
  set e.typ = typ
  set e.size = size
  ret e
.end

type WalkEventKind enum
  DirEnter
  DirExit
  File
  Error
.end

type WalkEvent struct
  kind: WalkEventKind
  entry: WalkEntry
  err: std.core.result::Error
.end

fn event_dir_enter(e: WalkEntry) -> WalkEvent
  let w: WalkEvent
  set w.kind = WalkEventKind::DirEnter
  set w.entry = e
  set w.err = std.core.result::err_ok()
  ret w
.end

fn event_dir_exit(e: WalkEntry) -> WalkEvent
  let w: WalkEvent
  set w.kind = WalkEventKind::DirExit
  set w.entry = e
  set w.err = std.core.result::err_ok()
  ret w
.end

fn event_file(e: WalkEntry) -> WalkEvent
  let w: WalkEvent
  set w.kind = WalkEventKind::File
  set w.entry = e
  set w.err = std.core.result::err_ok()
  ret w
.end

fn event_error(path: Str, depth: U32, err: std.core.result::Error) -> WalkEvent
  let e = entry_new(path, std.fs.path::basename(path), depth, FileType::Unknown, 0)
  let w: WalkEvent
  set w.kind = WalkEventKind::Error
  set w.entry = e
  set w.err = err
  ret w
.end

# Callback signature (conceptual):
#   fn cb(ev: &WalkEvent) -> Bool
# Return false to stop traversal early.

# -----------------------------------------------------------------------------
# Internal stack (bootstrap stack: newline-separated frames)
# -----------------------------------------------------------------------------

type Frame struct
  path: Str
  depth: U32
  state: I32   # 0 = entering, 1 = iterating, 2 = exiting
  handle: DirHandle
.end

type FrameStack struct
  data: Str
  count: U32
.end

fn stack_new() -> FrameStack
  let s: FrameStack
  set s.data = ""
  set s.count = 0
  ret s
.end

fn frame_encode(f: &Frame) -> Str
  # path|depth|state|handle_id
  let a = f.path
  let b = std.string::itoa_u32(f.depth)
  let c = std.string::itoa_i32(f.state)
  let d = std.string::itoa_i32(f.handle.id)
  ret std.string::concat(a, std.string::concat("|", std.string::concat(b, std.string::concat("|", std.string::concat(c, std.string::concat("|", d))))))
.end

fn frame_decode(s: Str) -> Frame
  # very small parser split by '|'
  let f: Frame
  set f.path = ""
  set f.depth = 0
  set f.state = 0
  set f.handle = dir_invalid()

  let p0 = std.string::find(s, "|")
  if p0 < 0
    set f.path = s
    ret f
  .end

  let path = std.string::slice(s, 0, (U32)p0)
  let rest = std.string::slice(s, (U32)p0 + 1, std.string::len(s) - ((U32)p0 + 1))

  let p1 = std.string::find(rest, "|")
  if p1 < 0
    set f.path = path
    ret f
  .end

  let depth_s = std.string::slice(rest, 0, (U32)p1)
  let rest2 = std.string::slice(rest, (U32)p1 + 1, std.string::len(rest) - ((U32)p1 + 1))

  let p2 = std.string::find(rest2, "|")
  if p2 < 0
    set f.path = path
    set f.depth = std.string::atoi_u32(depth_s)
    ret f
  .end

  let state_s = std.string::slice(rest2, 0, (U32)p2)
  let hid_s = std.string::slice(rest2, (U32)p2 + 1, std.string::len(rest2) - ((U32)p2 + 1))

  set f.path = path
  set f.depth = std.string::atoi_u32(depth_s)
  set f.state = std.string::atoi_i32(state_s)
  set f.handle.id = std.string::atoi_i32(hid_s)
  ret f
.end

fn stack_push(st: &FrameStack, f: &Frame)
  let line = frame_encode(f)
  if st.count == 0
    set st.data = line
  else
    set st.data = std.string::concat(st.data, std.string::concat("\n", line))
  .end
  set st.count = st.count + 1
.end

fn stack_pop(st: &FrameStack) -> Frame
  # pop last line (rebuild)
  let f: Frame
  set f.path = ""
  set f.depth = 0
  set f.state = 0
  set f.handle = dir_invalid()

  if st.count == 0
    ret f
  .end

  # find last '\n'
  let idx = std.string::rfind(st.data, "\n")
  if idx < 0
    let line = st.data
    set st.data = ""
    set st.count = 0
    ret frame_decode(line)
  .end

  let cut = (U32)idx
  let line = std.string::slice(st.data, cut + 1, std.string::len(st.data) - (cut + 1))
  set st.data = std.string::slice(st.data, 0, cut)
  set st.count = st.count - 1
  ret frame_decode(line)
.end

fn stack_is_empty(st: &FrameStack) -> Bool
  ret st.count == 0
.end

# -----------------------------------------------------------------------------
# Core walker (push-based via callback)
# -----------------------------------------------------------------------------

fn walk_dir(root0: Str, opts: &WalkOptions, cb: fn(&WalkEvent)->Bool) -> WalkError
  let root = std.fs.path::normalize(root0)

  # root stat (typ inference)
  let st = fs_stat(root, opts.follow_symlinks)
  let root_typ: FileType
  set root_typ = FileType::Unknown
  if st.ok
    # size available; typ unknown in stub => treat as Dir by default
    set root_typ = FileType::Dir
  else
    # error: decide policy
    let ev = event_error(root, 0, st.err)
    if opts.on_error == OnError::Report
      if !cb(&ev)
        ret walk_err(std.core.result::err_invalid("walk stopped by callback"))
      .end
      ret walk_ok()
    .end
    if opts.on_error == OnError::Skip
      ret walk_ok()
    .end
    ret walk_err(st.err)
  .end

  # init stack with root frame
  let stck = stack_new()
  let fr: Frame
  set fr.path = root
  set fr.depth = 0
  set fr.state = 0
  set fr.handle = dir_invalid()
  do stack_push(&stck, &fr)

  while !stack_is_empty(&stck)
    let f = stack_pop(&stck)

    if f.state == 0
      # emit enter
      let ent = entry_new(f.path, std.fs.path::basename(f.path), f.depth, FileType::Dir, 0)
      let ev = event_dir_enter(ent)
      if !cb(&ev)
        ret walk_ok()
      .end

      # depth limit
      if f.depth >= opts.max_depth
        # schedule exit only
        set f.state = 2
        do stack_push(&stck, &f)
        continue
      .end

      # open dir
      let h = fs_dir_open(f.path)
      if !dir_is_valid(&h)
        let e = std.core.result::err_io("dir_open failed")
        if opts.on_error == OnError::Report
          let er = event_error(f.path, f.depth, e)
          if !cb(&er)
            ret walk_ok()
          .end
          # still exit
          set f.state = 2
          do stack_push(&stck, &f)
          continue
        .end
        if opts.on_error == OnError::Skip
          set f.state = 2
          do stack_push(&stck, &f)
          continue
        .end
        ret walk_err(e)
      .end

      set f.handle = h
      set f.state = 1
      # push frame back for iteration
      do stack_push(&stck, &f)
      continue
    .end

    if f.state == 1
      # read one entry per loop, re-push frame until exhausted
      let ok: Bool
      let d: Dirent
      (ok, d) = fs_dir_read_next(&f.handle)

      if !ok
        # exhausted
        do fs_dir_close(&f.handle)
        set f.state = 2
        do stack_push(&stck, &f)
        continue
      .end

      # skip "." and ".."
      if d.name == "." || d.name == ".."
        do stack_push(&stck, &f)
        continue
      .end

      # hidden filter
      if !opts.include_hidden && fs_is_hidden_name(d.name)
        do stack_push(&stck, &f)
        continue
      .end

      let child_path = std.fs.path::join(f.path, d.name)

      # stat to determine file/dir; in stub we rely on dirent typ
      let typ = d.typ
      if typ == FileType::Unknown
        let st2 = fs_stat(child_path, opts.follow_symlinks)
        if st2.ok
          # cannot know typ in stub; assume File
          set typ = FileType::File
        else
          if opts.on_error == OnError::Report
            let er = event_error(child_path, f.depth + 1, st2.err)
            if !cb(&er)
              ret walk_ok()
            .end
            do stack_push(&stck, &f)
            continue
          .end
          if opts.on_error == OnError::Skip
            do stack_push(&stck, &f)
            continue
          .end
          ret walk_err(st2.err)
        .end
      .end

      if typ == FileType::Dir
        # Push current frame back, then push child enter frame (preorder)
        do stack_push(&stck, &f)

        let child: Frame
        set child.path = child_path
        set child.depth = f.depth + 1
        set child.state = 0
        set child.handle = dir_invalid()
        do stack_push(&stck, &child)
        continue
      .end

      # file (or symlink treated as file unless follow)
      let ent = entry_new(child_path, d.name, f.depth + 1, typ, 0)
      let ev = event_file(ent)
      if !cb(&ev)
        ret walk_ok()
      .end

      do stack_push(&stck, &f)
      continue
    .end

    # state == 2 => exit
    let ent = entry_new(f.path, std.fs.path::basename(f.path), f.depth, FileType::Dir, 0)
    let ev = event_dir_exit(ent)
    if !cb(&ev)
      ret walk_ok()
    .end
  .end

  ret walk_ok()
.end

# -----------------------------------------------------------------------------
# Pull-based iterator (state machine)
# -----------------------------------------------------------------------------

type WalkIter struct
  opts: WalkOptions
  stack: FrameStack
  started: Bool
  done: Bool
.end

fn walkiter_new(root: Str, opts: WalkOptions) -> WalkIter
  let it: WalkIter
  set it.opts = opts
  set it.stack = stack_new()
  set it.started = false
  set it.done = false

  let fr: Frame
  set fr.path = std.fs.path::normalize(root)
  set fr.depth = 0
  set fr.state = 0
  set fr.handle = dir_invalid()
  do stack_push(&it.stack, &fr)

  ret it
.end

fn walkiter_next(it: &WalkIter) -> (Bool, WalkEvent)
  let ev: WalkEvent
  set ev.kind = WalkEventKind::Error
  set ev.entry = entry_new("", "", 0, FileType::Unknown, 0)
  set ev.err = std.core.result::err_ok()

  if it.done
    ret (false, ev)
  .end

  while !stack_is_empty(&it.stack)
    let f = stack_pop(&it.stack)

    if f.state == 0
      let ent = entry_new(f.path, std.fs.path::basename(f.path), f.depth, FileType::Dir, 0)
      set f.state = 1
      # push for iteration/open
      do stack_push(&it.stack, &f)
      ret (true, event_dir_enter(ent))
    .end

    if f.state == 1
      # open if needed
      if !dir_is_valid(&f.handle)
        if f.depth >= it.opts.max_depth
          set f.state = 2
          do stack_push(&it.stack, &f)
          continue
        .end
        let h = fs_dir_open(f.path)
        if !dir_is_valid(&h)
          set f.state = 2
          do stack_push(&it.stack, &f)
          ret (true, event_error(f.path, f.depth, std.core.result::err_io("dir_open failed")))
        .end
        set f.handle = h
      .end

      let ok: Bool
      let d: Dirent
      (ok, d) = fs_dir_read_next(&f.handle)

      if !ok
        do fs_dir_close(&f.handle)
        set f.state = 2
        do stack_push(&it.stack, &f)
        continue
      .end

      if d.name == "." || d.name == ".."
        do stack_push(&it.stack, &f)
        continue
      .end

      if !it.opts.include_hidden && fs_is_hidden_name(d.name)
        do stack_push(&it.stack, &f)
        continue
      .end

      let child_path = std.fs.path::join(f.path, d.name)
      let typ = d.typ
      if typ == FileType::Dir
        do stack_push(&it.stack, &f)
        let child: Frame
        set child.path = child_path
        set child.depth = f.depth + 1
        set child.state = 0
        set child.handle = dir_invalid()
        do stack_push(&it.stack, &child)
        continue
      .end

      let ent = entry_new(child_path, d.name, f.depth + 1, typ, 0)
      do stack_push(&it.stack, &f)
      ret (true, event_file(ent))
    .end

    # exit
    let ent = entry_new(f.path, std.fs.path::basename(f.path), f.depth, FileType::Dir, 0)
    ret (true, event_dir_exit(ent))
  .end

  set it.done = true
  ret (false, ev)
.end

# -----------------------------------------------------------------------------
# Smoke tests (scenarios)
# -----------------------------------------------------------------------------

scn test_walk_options_default
  let o = walk_options_default()
  do std.runtime::assert(o.max_depth > 0, "default max_depth")
.end

# End of std.fs.walk