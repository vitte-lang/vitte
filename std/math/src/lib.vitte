# -----------------------------------------------------------------------------
# std/math
# -----------------------------------------------------------------------------
# Bootstrap-friendly math primitives.
#
# Scope (portable core):
# - integer utilities: min/max/clamp, abs, gcd/lcm, pow, mul_add
# - integer safety: checked/saturating add/sub, div_ceil, align_up/down
# - bit utilities: popcount, clz/ctz, rotations, next_pow2, bit_reverse, bswap
# - floating utilities: min/max/clamp, abs, is_nan/is_inf (best-effort),
#   floor/ceil/round/trunc/fract, lerp/remap, hypot
# - random: xorshift64* PRNG (deterministic) + helpers (u32/u64/f64/range)
# - constants: PI, TAU, E, LN2, LN10, SQRT2, PHI (as f64)
#
# Constraints:
# - no platform-specific intrinsics required; runtime may override hooks
# - blocks use `.end` only
# - minimal deps (no Vec)
# -----------------------------------------------------------------------------

module std.math

# -----------------------------------------------------------------------------
# Local prelude
# -----------------------------------------------------------------------------

type Bool = bool

type U8   = u8
type U16  = u16
type U32  = u32
type U64  = u64

type I8   = i8
type I16  = i16
type I32  = i32
type I64  = i64

type USize = usize
type ISize = isize

type F32  = f32
type F64  = f64

type Str = str

# -----------------------------------------------------------------------------
# Panic / assert stubs
# -----------------------------------------------------------------------------

fn panic(msg: Str)
  ret
.end

fn assert(cond: Bool, msg: Str)
  if !cond
    do panic(msg)
  .end
.end

# -----------------------------------------------------------------------------
# Constants (double precision)
# -----------------------------------------------------------------------------

const PI:   F64 = 3.14159265358979323846264338327950288
const TAU:  F64 = 6.28318530717958647692528676655900576
const E:    F64 = 2.71828182845904523536028747135266250
const LN2:  F64 = 0.69314718055994530941723212145817657
const LN10: F64 = 2.30258509299404568401799145468436421

const SQRT2: F64 = 1.41421356237309504880168872420969808
const PHI:   F64 = 1.61803398874989484820458683436563812

# -----------------------------------------------------------------------------
# Integer utilities
# -----------------------------------------------------------------------------

fn min_u32(a: U32, b: U32) -> U32
  if a < b
    ret a
  .end
  ret b
.end

fn max_u32(a: U32, b: U32) -> U32
  if a > b
    ret a
  .end
  ret b
.end

fn clamp_u32(x: U32, lo: U32, hi: U32) -> U32
  if x < lo
    ret lo
  .end
  if x > hi
    ret hi
  .end
  ret x
.end

fn min_u64(a: U64, b: U64) -> U64
  if a < b
    ret a
  .end
  ret b
.end

fn max_u64(a: U64, b: U64) -> U64
  if a > b
    ret a
  .end
  ret b
.end

fn clamp_u64(x: U64, lo: U64, hi: U64) -> U64
  if x < lo
    ret lo
  .end
  if x > hi
    ret hi
  .end
  ret x
.end

fn min_i32(a: I32, b: I32) -> I32
  if a < b
    ret a
  .end
  ret b
.end

fn max_i32(a: I32, b: I32) -> I32
  if a > b
    ret a
  .end
  ret b
.end

fn clamp_i32(x: I32, lo: I32, hi: I32) -> I32
  if x < lo
    ret lo
  .end
  if x > hi
    ret hi
  .end
  ret x
.end

fn min_i64(a: I64, b: I64) -> I64
  if a < b
    ret a
  .end
  ret b
.end

fn max_i64(a: I64, b: I64) -> I64
  if a > b
    ret a
  .end
  ret b
.end

fn clamp_i64(x: I64, lo: I64, hi: I64) -> I64
  if x < lo
    ret lo
  .end
  if x > hi
    ret hi
  .end
  ret x
.end

fn abs_i32(x: I32) -> I32
  if x < 0
    ret 0 - x
  .end
  ret x
.end

fn abs_i64(x: I64) -> I64
  if x < 0
    ret 0 - x
  .end
  ret x
.end

fn abs_isize(x: ISize) -> ISize
  if x < 0
    ret 0 - x
  .end
  ret x
.end

fn gcd_u64(a: U64, b: U64) -> U64
  if a == 0
    ret b
  .end
  if b == 0
    ret a
  .end
  let x = a
  let y = b
  while y != 0
    let r = x % y
    set x = y
    set y = r
  .end
  ret x
.end

fn gcd_u32(a: U32, b: U32) -> U32
  ret (U32)gcd_u64((U64)a, (U64)b)
.end

fn lcm_u64(a: U64, b: U64) -> U64
  if a == 0 || b == 0
    ret 0
  .end
  let g = gcd_u64(a, b)
  ret (a / g) * b
.end

fn lcm_u32(a: U32, b: U32) -> U32
  ret (U32)lcm_u64((U64)a, (U64)b)
.end

fn mul_add_u64(a: U64, b: U64, c: U64) -> U64
  ret (a * b) + c
.end

# Fast exponentiation (wraps on overflow).
fn pow_u64(base: U64, exp: U32) -> U64
  let b = base
  let e = exp
  let acc: U64
  set acc = 1
  while e != 0
    if (e & 1) == 1
      set acc = acc * b
    .end
    set b = b * b
    set e = e >> 1
  .end
  ret acc
.end

# -----------------------------------------------------------------------------
# Integer safety helpers
# -----------------------------------------------------------------------------

fn checked_add_u64(a: U64, b: U64) -> (Bool, U64)
  let s = a + b
  if s < a
    ret (false, 0)
  .end
  ret (true, s)
.end

fn checked_sub_u64(a: U64, b: U64) -> (Bool, U64)
  if b > a
    ret (false, 0)
  .end
  ret (true, a - b)
.end

fn saturating_add_u64(a: U64, b: U64) -> U64
  let s = a + b
  if s < a
    ret 0xffffffffffffffff
  .end
  ret s
.end

fn saturating_sub_u64(a: U64, b: U64) -> U64
  if b > a
    ret 0
  .end
  ret a - b
.end

fn div_ceil_u64(a: U64, b: U64) -> U64
  if b == 0
    ret 0
  .end
  ret (a + (b - 1)) / b
.end

fn align_down_u64(x: U64, align_pow2: U64) -> U64
  if align_pow2 == 0
    ret x
  .end
  ret x & ~(align_pow2 - 1)
.end

fn align_up_u64(x: U64, align_pow2: U64) -> U64
  if align_pow2 == 0
    ret x
  .end
  ret (x + (align_pow2 - 1)) & ~(align_pow2 - 1)
.end

# -----------------------------------------------------------------------------
# Bit utilities (portable)
# -----------------------------------------------------------------------------

fn popcount_u64(x: U64) -> U32
  let c: U32
  set c = 0
  let y = x
  while y != 0
    set y = y & (y - 1)
    set c = c + 1
  .end
  ret c
.end

fn clz_u64(x: U64) -> U32
  if x == 0
    ret 64
  .end
  let n: U32
  set n = 0
  let i: I32
  set i = 63
  while i >= 0
    if ((x >> (U32)i) & 1) == 1
      break
    .end
    set n = n + 1
    set i = i - 1
  .end
  ret n
.end

fn ctz_u64(x: U64) -> U32
  if x == 0
    ret 64
  .end
  let n: U32
  set n = 0
  let i: U32
  set i = 0
  while i < 64
    if ((x >> i) & 1) == 1
      break
    .end
    set n = n + 1
    set i = i + 1
  .end
  ret n
.end

fn rotl_u64(x: U64, r: U32) -> U64
  let k = r & 63
  if k == 0
    ret x
  .end
  ret (x << k) | (x >> (64 - k))
.end

fn rotr_u64(x: U64, r: U32) -> U64
  let k = r & 63
  if k == 0
    ret x
  .end
  ret (x >> k) | (x << (64 - k))
.end

fn is_pow2_u64(x: U64) -> Bool
  if x == 0
    ret false
  .end
  ret (x & (x - 1)) == 0
.end

fn next_pow2_u64(x: U64) -> U64
  if x <= 1
    ret 1
  .end
  let v = x - 1
  set v = v | (v >> 1)
  set v = v | (v >> 2)
  set v = v | (v >> 4)
  set v = v | (v >> 8)
  set v = v | (v >> 16)
  set v = v | (v >> 32)
  ret v + 1
.end

fn bswap_u64(x: U64) -> U64
  let v = x
  let y: U64
  set y = 0
  let i: U32
  set i = 0
  while i < 8
    set y = (y << 8) | (v & 0xff)
    set v = v >> 8
    set i = i + 1
  .end
  ret y
.end

fn bit_reverse_u64(x: U64) -> U64
  let v = x
  let y: U64
  set y = 0
  let i: U32
  set i = 0
  while i < 64
    set y = (y << 1) | (v & 1)
    set v = v >> 1
    set i = i + 1
  .end
  ret y
.end

# -----------------------------------------------------------------------------
# Floating utilities (best-effort)
# -----------------------------------------------------------------------------

fn min_f64(a: F64, b: F64) -> F64
  if a < b
    ret a
  .end
  ret b
.end

fn max_f64(a: F64, b: F64) -> F64
  if a > b
    ret a
  .end
  ret b
.end

fn clamp_f64(x: F64, lo: F64, hi: F64) -> F64
  if x < lo
    ret lo
  .end
  if x > hi
    ret hi
  .end
  ret x
.end

fn abs_f64(x: F64) -> F64
  if x < 0.0
    ret 0.0 - x
  .end
  ret x
.end

# Robust NaN test (IEEE-friendly): NaN is never equal to itself.
fn is_nan_f64(x: F64) -> Bool
  ret x != x
.end

# Best-effort Inf test without bitcasts.
fn is_inf_f64(x: F64) -> Bool
  if is_nan_f64(x)
    ret false
  .end
  let ax = abs_f64(x)
  # threshold well below max finite for safety
  ret ax > 1.0e308
.end

fn trunc_f64(x: F64) -> F64
  let t: I64
  set t = (I64)x
  ret (F64)t
.end

fn floor_f64(x: F64) -> F64
  let t: I64
  set t = (I64)x
  let f = (F64)t
  if f > x
    ret f - 1.0
  .end
  ret f
.end

fn ceil_f64(x: F64) -> F64
  let t: I64
  set t = (I64)x
  let f = (F64)t
  if f < x
    ret f + 1.0
  .end
  ret f
.end

fn round_f64(x: F64) -> F64
  if x >= 0.0
    ret floor_f64(x + 0.5)
  .end
  ret ceil_f64(x - 0.5)
.end

fn fract_f64(x: F64) -> F64
  ret x - floor_f64(x)
.end

fn mod_f64(x: F64, y: F64) -> F64
  if y == 0.0
    ret 0.0
  .end
  # x - floor(x/y)*y
  let q = floor_f64(x / y)
  ret x - (q * y)
.end

fn lerp_f64(a: F64, b: F64, t: F64) -> F64
  ret a + (b - a) * t
.end

fn inv_lerp_f64(a: F64, b: F64, x: F64) -> F64
  if a == b
    ret 0.0
  .end
  ret (x - a) / (b - a)
.end

fn remap_f64(in_a: F64, in_b: F64, out_a: F64, out_b: F64, x: F64) -> F64
  let t = inv_lerp_f64(in_a, in_b, x)
  ret lerp_f64(out_a, out_b, t)
.end

fn hypot_f64(x: F64, y: F64) -> F64
  ret sqrt_f64(x * x + y * y)
.end

fn deg2rad_f64(deg: F64) -> F64
  ret deg * (PI / 180.0)
.end

fn rad2deg_f64(rad: F64) -> F64
  ret rad * (180.0 / PI)
.end

# -----------------------------------------------------------------------------
# PRNG: xorshift64*
# -----------------------------------------------------------------------------

type XorShift64Star struct
  state: U64
.end

fn xorshift64star_new(seed: U64) -> XorShift64Star
  let r: XorShift64Star
  if seed == 0
    set r.state = 0x9e3779b97f4a7c15
  else
    set r.state = seed
  .end
  ret r
.end

fn xorshift64star_next_u64(r: &XorShift64Star) -> U64
  let x = r.state
  set x = x ^ (x >> 12)
  set x = x ^ (x << 25)
  set x = x ^ (x >> 27)
  set r.state = x
  ret x * 0x2545f4914f6cdd1d
.end

fn xorshift64star_next_u32(r: &XorShift64Star) -> U32
  ret (U32)(xorshift64star_next_u64(r) >> 32)
.end

fn xorshift64star_next_bool(r: &XorShift64Star) -> Bool
  ret (xorshift64star_next_u64(r) & 1) == 1
.end

# Uniform in [0, 1). Uses top 53 bits.
fn xorshift64star_next_f64(r: &XorShift64Star) -> F64
  let x = xorshift64star_next_u64(r)
  let mant = (x >> 11) & 0x1fffffffffffff
  ret (F64)mant / 9007199254740992.0
.end

fn xorshift64star_next_range_u32(r: &XorShift64Star, lo: U32, hi: U32) -> U32
  if hi <= lo
    ret lo
  .end
  let span = hi - lo
  let x = xorshift64star_next_u32(r)
  ret lo + (x % span)
.end

fn xorshift64star_next_range_u64(r: &XorShift64Star, lo: U64, hi: U64) -> U64
  if hi <= lo
    ret lo
  .end
  let span = hi - lo
  let x = xorshift64star_next_u64(r)
  ret lo + (x % span)
.end

# -----------------------------------------------------------------------------
# Simple numeric approximations
# -----------------------------------------------------------------------------

# Newton-Raphson sqrt for positive values; returns 0 for x<=0.
fn sqrt_f64(x: F64) -> F64
  if x <= 0.0
    ret 0.0
  .end

  let g: F64
  set g = x

  let i: U32
  set i = 0
  while i < 32
    set g = 0.5 * (g + (x / g))
    set i = i + 1
  .end

  ret g
.end

# sin/cos via small-angle polynomial (very rough; for bootstrap only)
fn sin_f64(x: F64) -> F64
  # range reduce to [-pi, pi]
  let t = x
  while t > PI
    set t = t - TAU
  .end
  while t < (0.0 - PI)
    set t = t + TAU
  .end

  let x2 = t * t
  # x - x^3/6 + x^5/120
  ret t - (t * x2) / 6.0 + (t * x2 * x2) / 120.0
.end

fn cos_f64(x: F64) -> F64
  # range reduce to [-pi, pi]
  let t = x
  while t > PI
    set t = t - TAU
  .end
  while t < (0.0 - PI)
    set t = t + TAU
  .end

  let x2 = t * t
  # 1 - x^2/2 + x^4/24
  ret 1.0 - x2 / 2.0 + (x2 * x2) / 24.0
.end

# -----------------------------------------------------------------------------
# Tests (scenarios)
# -----------------------------------------------------------------------------

scn test_gcd_lcm
  do assert(gcd_u64(0, 10) == 10, "gcd 0")
  do assert(gcd_u64(54, 24) == 6, "gcd")
  do assert(lcm_u64(6, 10) == 30, "lcm")
  do assert(gcd_u32(54, 24) == 6, "gcd32")
  do assert(lcm_u32(6, 10) == 30, "lcm32")
.end

scn test_int_safety
  let ok: Bool
  let v: U64

  (ok, v) = checked_add_u64(1, 2)
  do assert(ok && v == 3, "checked_add")

  (ok, v) = checked_sub_u64(5, 3)
  do assert(ok && v == 2, "checked_sub")

  (ok, v) = checked_sub_u64(3, 5)
  do assert(!ok, "checked_sub under")

  do assert(saturating_add_u64(0xffffffffffffffff, 1) == 0xffffffffffffffff, "sat_add")
  do assert(saturating_sub_u64(0, 1) == 0, "sat_sub")

  do assert(div_ceil_u64(10, 3) == 4, "div_ceil")
  do assert(align_down_u64(15, 8) == 8, "align_down")
  do assert(align_up_u64(9, 8) == 16, "align_up")
.end

scn test_bits
  do assert(popcount_u64(0) == 0, "popcount 0")
  do assert(popcount_u64(0xff) == 8, "popcount")
  do assert(clz_u64(1) == 63, "clz")
  do assert(ctz_u64(8) == 3, "ctz")
  do assert(rotl_u64(1, 1) == 2, "rotl")
  do assert(rotr_u64(2, 1) == 1, "rotr")
  do assert(is_pow2_u64(8), "is_pow2")
  do assert(!is_pow2_u64(12), "is_pow2 false")
  do assert(next_pow2_u64(9) == 16, "next_pow2")
  do assert(bswap_u64(0x0102030405060708) == 0x0807060504030201, "bswap")
  do assert(bit_reverse_u64(1) == (1 << 63), "bit_reverse")
.end

scn test_pow
  do assert(pow_u64(2, 10) == 1024, "pow")
.end

scn test_prng_deterministic
  let r = xorshift64star_new(123)
  let a = xorshift64star_next_u64(&r)
  let b = xorshift64star_next_u64(&r)
  do assert(a != b, "prng")
.end

scn test_float_rounding
  do assert(floor_f64(1.9) == 1.0, "floor")
  do assert(ceil_f64(1.1) == 2.0, "ceil")
  do assert(trunc_f64(-1.9) == -1.0, "trunc")
  do assert(floor_f64(-1.1) == -2.0, "floor neg")
  do assert(ceil_f64(-1.9) == -1.0, "ceil neg")
  do assert(round_f64(2.49) == 2.0, "round")
  do assert(round_f64(2.50) == 3.0, "round half")
.end

scn test_sqrt_hypot
  let x = sqrt_f64(9.0)
  do assert(x > 2.9 && x < 3.1, "sqrt")
  let h = hypot_f64(3.0, 4.0)
  do assert(h > 4.9 && h < 5.1, "hypot")
.end

scn test_lerp_remap
  do assert(lerp_f64(0.0, 10.0, 0.5) == 5.0, "lerp")
  do assert(remap_f64(0.0, 10.0, 0.0, 1.0, 5.0) == 0.5, "remap")
.end

# End of std.math