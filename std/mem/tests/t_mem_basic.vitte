# /Users/vincent/Documents/Github/vitte/std/mem/tests/t_mem_basic.vitte
# -----------------------------------------------------------------------------
# std/mem/tests/t_mem_basic
# -----------------------------------------------------------------------------
# MAX unit tests for std.mem (+ ptr/slice helpers if present).
#
# Layers:
# 1) Surface tests: symbol reachability / compilation probes
# 2) Pure semantics tests: pow2/alignment math, Buffer and Slice pointer math
# 3) Backend-dependent smoke tests (guarded): alloc/memcpy/memset/memcmp
#
# All blocks use `.end` only.
# -----------------------------------------------------------------------------

module std.mem.tests.t_mem_basic

use std.runtime
use std.mem
use std.string

# Optional submodules (if present in your layout)
use std.mem.ptr
use std.mem.slice

type Bool = bool
type U32  = u32
type U64  = u64
type I64  = i64
type Str  = str

fn assert_true(b: Bool, msg: Str)
  do std.runtime::assert(b, msg)
.end

fn assert_false(b: Bool, msg: Str)
  do std.runtime::assert(!b, msg)
.end

fn assert_eq_u64(a: U64, b: U64, msg: Str)
  do std.runtime::assert(a == b, msg)
.end

fn assert_eq_i64(a: I64, b: I64, msg: Str)
  do std.runtime::assert(a == b, msg)
.end

# -----------------------------------------------------------------------------
# Feature gates for backend-dependent tests
# -----------------------------------------------------------------------------
const MEM_TEST_BACKEND_REAL: Bool = false

# -----------------------------------------------------------------------------
# 1) Surface tests
# -----------------------------------------------------------------------------

scn test_mem_surface
  # Ensure core symbols exist
  let _ = std.mem::is_pow2
  let _ = std.mem::align_up
  let _ = std.mem::align_down
  let _ = std.mem::next_multiple

  let _ = std.mem::memcpy
  let _ = std.mem::memmove
  let _ = std.mem::memset
  let _ = std.mem::memcmp
  let _ = std.mem::memeq

  let _ = std.mem::buf_new
  let _ = std.mem::buf_slice
  let _ = std.mem::buf_prefix
  let _ = std.mem::buf_suffix
  let _ = std.mem::buf_cmp
  let _ = std.mem::buf_eq
.end

scn test_ptr_surface
  let _ = std.mem.ptr::null
  let _ = std.mem.ptr::add
  let _ = std.mem.ptr::sub
  let _ = std.mem.ptr::offset
  let _ = std.mem.ptr::diff
  let _ = std.mem.ptr::align_up
  let _ = std.mem.ptr::align_down
  let _ = std.mem.ptr::is_aligned
.end

scn test_slice_surface
  let _ = std.mem.slice::slice_new
  let _ = std.mem.slice::slice_sub
  let _ = std.mem.slice::slice_prefix
  let _ = std.mem.slice::slice_suffix
  let _ = std.mem.slice::slice_addr_of
  let _ = std.mem.slice::slice_byte_len
.end

# -----------------------------------------------------------------------------
# 2) Pure semantics tests (no backend required)
# -----------------------------------------------------------------------------

scn test_pow2_and_align_math
  do assert_true(std.mem::is_pow2(1), "pow2(1)")
  do assert_true(std.mem::is_pow2(2), "pow2(2)")
  do assert_true(std.mem::is_pow2(8), "pow2(8)")
  do assert_false(std.mem::is_pow2(0), "pow2(0)=false")
  do assert_false(std.mem::is_pow2(3), "pow2(3)=false")

  do assert_eq_u64(std.mem::align_down(15, 8), 8, "align_down(15,8)=8")
  do assert_eq_u64(std.mem::align_up(15, 8), 16, "align_up(15,8)=16")

  do assert_eq_u64(std.mem::next_multiple(16, 8), 16, "next_multiple exact")
  do assert_eq_u64(std.mem::next_multiple(17, 8), 24, "next_multiple bump")
.end

scn test_buffer_math_and_slices
  # Pure pointer math (Ptr is U64 in current std.mem fa√ßade)
  let b = std.mem::buf_new(0x2000, 64)

  do assert_eq_u64(b.ptr, 0x2000, "buf ptr")
  do assert_eq_u64(b.len, 64, "buf len")
  do assert_eq_u64(std.mem::buf_end(&b), 0x2000 + 64, "buf_end")

  let p10 = std.mem::buf_at(&b, 10)
  do assert_eq_u64(p10, 0x200a, "buf_at")

  let s = std.mem::buf_slice(&b, 8, 16)
  do assert_eq_u64(s.ptr, 0x2008, "buf_slice ptr")
  do assert_eq_u64(s.len, 16, "buf_slice len")

  let pre = std.mem::buf_prefix(&b, 12)
  do assert_eq_u64(pre.ptr, 0x2000, "buf_prefix ptr")
  do assert_eq_u64(pre.len, 12, "buf_prefix len")

  let suf = std.mem::buf_suffix(&b, 12)
  do assert_eq_u64(suf.ptr, 0x2000 + (64 - 12), "buf_suffix ptr")
  do assert_eq_u64(suf.len, 12, "buf_suffix len")
.end

scn test_ptr_math_and_align
  let p = std.mem.ptr::from_addr(0x1000)

  do assert_true(std.mem.ptr::is_null(std.mem.ptr::null()), "ptr null")
  do assert_eq_u64(std.mem.ptr::addr(p), 0x1000, "ptr addr")
  do assert_eq_u64(std.mem.ptr::add(p, 4), 0x1004, "ptr add")
  do assert_eq_u64(std.mem.ptr::sub(p, 4), 0x0ffc, "ptr sub")

  do assert_eq_u64(std.mem.ptr::offset(p, 8), 0x1008, "ptr offset +")
  do assert_eq_u64(std.mem.ptr::offset(p, -8), 0x0ff8, "ptr offset -")

  do assert_eq_i64(std.mem.ptr::diff(0x1010, 0x1000), 16, "ptr diff +")
  do assert_eq_i64(std.mem.ptr::diff(0x1000, 0x1010), -16, "ptr diff -")

  let q = std.mem.ptr::from_addr(0x1013)
  do assert_eq_u64(std.mem.ptr::align_down(q, 8), 0x1010, "ptr align_down")
  do assert_eq_u64(std.mem.ptr::align_up(q, 8), 0x1018, "ptr align_up")
  do assert_true(std.mem.ptr::is_aligned(0x1010, 8), "ptr aligned true")
  do assert_false(std.mem.ptr::is_aligned(0x1013, 8), "ptr aligned false")
.end

scn test_slice_math
  let base = std.mem.ptr::from_addr(0x3000)
  let s = std.mem.slice::slice_new(base, 10, 4, 4)

  do assert_eq_u64(std.mem.slice::slice_byte_len(&s), 40, "slice byte_len")
  do assert_eq_u64(std.mem.slice::slice_end_ptr(&s), 0x3000 + 40, "slice end_ptr")

  let p3 = std.mem.slice::slice_addr_of(&s, 3)
  do assert_eq_u64(p3, 0x3000 + 12, "slice addr_of")

  let sub = std.mem.slice::slice_sub(&s, 2, 4)
  do assert_eq_u64(sub.base, 0x3000 + 8, "slice sub base")
  do assert_eq_u64(sub.len, 4, "slice sub len")

  let pre = std.mem.slice::slice_prefix(&s, 3)
  do assert_eq_u64(pre.base, 0x3000, "slice prefix base")
  do assert_eq_u64(pre.len, 3, "slice prefix len")

  let suf = std.mem.slice::slice_suffix(&s, 3)
  do assert_eq_u64(suf.base, 0x3000 + (10 - 3) * 4, "slice suffix base")
  do assert_eq_u64(suf.len, 3, "slice suffix len")
.end

# -----------------------------------------------------------------------------
# 3) Backend-dependent smoke tests
# -----------------------------------------------------------------------------

scn test_mem_backend_smoke
  if !MEM_TEST_BACKEND_REAL
    do std.runtime::assert(true, "skipped (no backend)")
    ret
  .end

  # Allocate two buffers, write patterns, compare, copy, verify.
  let a = std.mem::mem_alloc(64, 16)
  let b = std.mem::mem_alloc(64, 16)

  do std.runtime::assert(a != 0, "alloc a")
  do std.runtime::assert(b != 0, "alloc b")

  let ba = std.mem::buf_new(a, 64)
  let bb = std.mem::buf_new(b, 64)

  do std.mem::buf_fill(&ba, 0x11)
  do std.mem::buf_fill(&bb, 0x22)

  do std.runtime::assert(!std.mem::buf_eq(&ba, &bb), "buffers differ")

  let copied = std.mem::buf_copy_from(&bb, &ba)
  do assert_eq_u64(copied, 64, "copied bytes")
  do std.runtime::assert(std.mem::buf_eq(&ba, &bb), "buffers equal after copy")

  # Change one byte and ensure compare detects difference
  let one = std.mem::buf_slice(&bb, 10, 1)
  do std.mem::buf_fill(&one, 0x33)
  do std.runtime::assert(!std.mem::buf_eq(&ba, &bb), "buffers differ after byte tweak")

  do std.mem::mem_free(a, 64, 16)
  do std.mem::mem_free(b, 64, 16)
.end