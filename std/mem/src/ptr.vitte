# /Users/vincent/Documents/Github/vitte/std/mem/src/ptr.vitte
# -----------------------------------------------------------------------------
# std/mem/ptr
# -----------------------------------------------------------------------------
# Pointer faÃ§ade (ABI-friendly) for low-level runtime/stdlib code.
#
# MAX goals:
# - Provide a stable, compiler-friendly pointer API without exposing host types.
# - Keep representation portable: Ptr is an integer address (U64).
# - Offer pointer math, alignment checks, and typed load/store via runtime
#   intrinsics (to be implemented by std.runtime backend).
# - Avoid UB in pure Vitte: all deref goes through runtime.
#
# Blocks use `.end` only (no braces).
# -----------------------------------------------------------------------------

module std.mem.ptr

use std.runtime
use std.core.result

type Bool = bool
type U8   = u8
type U16  = u16
type U32  = u32
type U64  = u64
type I32  = i32
type I64  = i64
type Str  = str

# -----------------------------------------------------------------------------
# Core pointer representation
# -----------------------------------------------------------------------------

type Ptr = U64

fn null() -> Ptr
  ret 0
.end

fn is_null(p: Ptr) -> Bool
  ret p == 0
.end

fn addr(p: Ptr) -> U64
  ret p
.end

fn from_addr(a: U64) -> Ptr
  ret a
.end

# Pointer arithmetic (byte-based)
fn add(p: Ptr, bytes: U64) -> Ptr
  ret p + bytes
.end

fn sub(p: Ptr, bytes: U64) -> Ptr
  ret p - bytes
.end

fn offset(p: Ptr, bytes: I64) -> Ptr
  if bytes >= 0
    ret p + (bytes as U64)
  .end
  ret p - ((-bytes) as U64)
.end

fn diff(a: Ptr, b: Ptr) -> I64
  # Returns a-b as signed difference
  if a >= b
    ret ((a - b) as I64)
  .end
  ret -((b - a) as I64)
.end

# -----------------------------------------------------------------------------
# Alignment helpers
# -----------------------------------------------------------------------------

fn is_pow2(x: U64) -> Bool
  if x == 0
    ret false
  .end
  ret (x & (x - 1)) == 0
.end

fn is_aligned(p: Ptr, align: U64) -> Bool
  if align == 0
    ret false
  .end
  ret (p % align) == 0
.end

fn align_down(p: Ptr, align: U64) -> Ptr
  do std.runtime::assert(align != 0, "ptr.align_down: align=0")
  do std.runtime::assert(is_pow2(align), "ptr.align_down: align not pow2")
  ret p & ~(align - 1)
.end

fn align_up(p: Ptr, align: U64) -> Ptr
  do std.runtime::assert(align != 0, "ptr.align_up: align=0")
  do std.runtime::assert(is_pow2(align), "ptr.align_up: align not pow2")
  ret (p + (align - 1)) & ~(align - 1)
.end

# -----------------------------------------------------------------------------
# Pointer comparisons (address order)
# -----------------------------------------------------------------------------

fn eq(a: Ptr, b: Ptr) -> Bool
  ret a == b
.end

fn lt(a: Ptr, b: Ptr) -> Bool
  ret a < b
.end

fn le(a: Ptr, b: Ptr) -> Bool
  ret a <= b
.end

fn gt(a: Ptr, b: Ptr) -> Bool
  ret a > b
.end

fn ge(a: Ptr, b: Ptr) -> Bool
  ret a >= b
.end

# -----------------------------------------------------------------------------
# Typed load/store via runtime intrinsics
# -----------------------------------------------------------------------------
# These functions are declared in std.runtime and must be provided by the host
# backend. They should be safe with respect to alignment requirements specified.
#
# Semantics:
# - *_unaligned ignore alignment constraints.
# - aligned variants require `is_aligned(p, N)` or return an error.
#
# Error model: std.core.result::ResultU32/ResultU64/ResultUnit etc.
# Adjust to your actual Result types if needed.

fn load_u8(p: Ptr) -> std.core.result::ResultU32
  if p == 0
    ret std.core.result::u32_err(std.core.result::err_io("load_u8: null"))
  .end
  ret std.runtime::ptr_load_u8(p)
.end

fn store_u8(p: Ptr, v: U32) -> std.core.result::ResultUnit
  if p == 0
    ret std.core.result::unit_err(std.core.result::err_io("store_u8: null"))
  .end
  ret std.runtime::ptr_store_u8(p, v)
.end

fn load_u16_le(p: Ptr) -> std.core.result::ResultU32
  if p == 0
    ret std.core.result::u32_err(std.core.result::err_io("load_u16_le: null"))
  .end
  if !is_aligned(p, 2)
    ret std.core.result::u32_err(std.core.result::err_io("load_u16_le: unaligned"))
  .end
  ret std.runtime::ptr_load_u16_le(p)
.end

fn load_u16_le_unaligned(p: Ptr) -> std.core.result::ResultU32
  if p == 0
    ret std.core.result::u32_err(std.core.result::err_io("load_u16_le_unaligned: null"))
  .end
  ret std.runtime::ptr_load_u16_le_unaligned(p)
.end

fn store_u16_le(p: Ptr, v: U32) -> std.core.result::ResultUnit
  if p == 0
    ret std.core.result::unit_err(std.core.result::err_io("store_u16_le: null"))
  .end
  if !is_aligned(p, 2)
    ret std.core.result::unit_err(std.core.result::err_io("store_u16_le: unaligned"))
  .end
  ret std.runtime::ptr_store_u16_le(p, v)
.end

fn store_u16_le_unaligned(p: Ptr, v: U32) -> std.core.result::ResultUnit
  if p == 0
    ret std.core.result::unit_err(std.core.result::err_io("store_u16_le_unaligned: null"))
  .end
  ret std.runtime::ptr_store_u16_le_unaligned(p, v)
.end

fn load_u32_le(p: Ptr) -> std.core.result::ResultU32
  if p == 0
    ret std.core.result::u32_err(std.core.result::err_io("load_u32_le: null"))
  .end
  if !is_aligned(p, 4)
    ret std.core.result::u32_err(std.core.result::err_io("load_u32_le: unaligned"))
  .end
  ret std.runtime::ptr_load_u32_le(p)
.end

fn load_u32_le_unaligned(p: Ptr) -> std.core.result::ResultU32
  if p == 0
    ret std.core.result::u32_err(std.core.result::err_io("load_u32_le_unaligned: null"))
  .end
  ret std.runtime::ptr_load_u32_le_unaligned(p)
.end

fn store_u32_le(p: Ptr, v: U32) -> std.core.result::ResultUnit
  if p == 0
    ret std.core.result::unit_err(std.core.result::err_io("store_u32_le: null"))
  .end
  if !is_aligned(p, 4)
    ret std.core.result::unit_err(std.core.result::err_io("store_u32_le: unaligned"))
  .end
  ret std.runtime::ptr_store_u32_le(p, v)
.end

fn store_u32_le_unaligned(p: Ptr, v: U32) -> std.core.result::ResultUnit
  if p == 0
    ret std.core.result::unit_err(std.core.result::err_io("store_u32_le_unaligned: null"))
  .end
  ret std.runtime::ptr_store_u32_le_unaligned(p, v)
.end

fn load_u64_le(p: Ptr) -> std.core.result::ResultU64
  if p == 0
    ret std.core.result::u64_err(std.core.result::err_io("load_u64_le: null"))
  .end
  if !is_aligned(p, 8)
    ret std.core.result::u64_err(std.core.result::err_io("load_u64_le: unaligned"))
  .end
  ret std.runtime::ptr_load_u64_le(p)
.end

fn load_u64_le_unaligned(p: Ptr) -> std.core.result::ResultU64
  if p == 0
    ret std.core.result::u64_err(std.core.result::err_io("load_u64_le_unaligned: null"))
  .end
  ret std.runtime::ptr_load_u64_le_unaligned(p)
.end

fn store_u64_le(p: Ptr, v: U64) -> std.core.result::ResultUnit
  if p == 0
    ret std.core.result::unit_err(std.core.result::err_io("store_u64_le: null"))
  .end
  if !is_aligned(p, 8)
    ret std.core.result::unit_err(std.core.result::err_io("store_u64_le: unaligned"))
  .end
  ret std.runtime::ptr_store_u64_le(p, v)
.end

fn store_u64_le_unaligned(p: Ptr, v: U64) -> std.core.result::ResultUnit
  if p == 0
    ret std.core.result::unit_err(std.core.result::err_io("store_u64_le_unaligned: null"))
  .end
  ret std.runtime::ptr_store_u64_le_unaligned(p, v)
.end

# -----------------------------------------------------------------------------
# Byte-wise helpers built on load/store
# -----------------------------------------------------------------------------

fn read_bytes(p: Ptr, n: U64) -> std.core.result::ResultStr
  # Returns a byte-string of length n (may allocate in runtime/string).
  if n == 0
    ret std.core.result::str_ok("")
  .end
  if p == 0
    ret std.core.result::str_err(std.core.result::err_io("read_bytes: null"))
  .end
  ret std.runtime::ptr_read_bytes(p, n)
.end

fn write_bytes(p: Ptr, s: Str) -> std.core.result::ResultUnit
  if p == 0 && std.string::len(s) != 0
    ret std.core.result::unit_err(std.core.result::err_io("write_bytes: null"))
  .end
  ret std.runtime::ptr_write_bytes(p, s)
.end

# -----------------------------------------------------------------------------
# Bounds helper (for ptr + len pairs)
# -----------------------------------------------------------------------------

fn in_range(base: Ptr, len: U64, p: Ptr, n: U64) -> Bool
  if base == 0
    ret len == 0 && p == 0 && n == 0
  .end
  if n == 0
    ret p >= base && p <= (base + len)
  .end
  if p < base
    ret false
  .end
  let end = p + n
  ret end <= (base + len)
.end

# -----------------------------------------------------------------------------
# Tests (pure, backend-independent)
# -----------------------------------------------------------------------------

scn test_ptr_math
  do std.runtime::assert(null() == 0, "null")
  do std.runtime::assert(is_null(0), "is_null")
  do std.runtime::assert(!is_null(1), "not null")

  let p = from_addr(0x1000)
  do std.runtime::assert(addr(p) == 0x1000, "addr roundtrip")
  do std.runtime::assert(add(p, 4) == 0x1004, "add")
  do std.runtime::assert(sub(p, 4) == 0x0ffc, "sub")

  do std.runtime::assert(offset(p, 8) == 0x1008, "offset +")
  do std.runtime::assert(offset(p, -8) == 0x0ff8, "offset -")

  do std.runtime::assert(diff(0x1010, 0x1000) == 16, "diff +")
  do std.runtime::assert(diff(0x1000, 0x1010) == -16, "diff -")
.end

scn test_ptr_align
  let p = from_addr(0x1013)
  do std.runtime::assert(is_pow2(8), "pow2")
  do std.runtime::assert(align_down(p, 8) == 0x1010, "align_down")
  do std.runtime::assert(align_up(p, 8) == 0x1018, "align_up")
  do std.runtime::assert(is_aligned(0x1010, 8), "aligned true")
  do std.runtime::assert(!is_aligned(0x1013, 8), "aligned false")
.end

scn test_ptr_range
  let base = from_addr(0x2000)
  let len: U64
  set len = 64

  do std.runtime::assert(in_range(base, len, 0x2000, 0), "range start (0)")
  do std.runtime::assert(in_range(base, len, 0x2000, 1), "range start (1)")
  do std.runtime::assert(in_range(base, len, 0x203f, 1), "range last byte")
  do std.runtime::assert(!in_range(base, len, 0x2040, 1), "range oob")
  do std.runtime::assert(in_range(base, len, 0x2040, 0), "range end (0)")
.end

# End of std.mem.ptr