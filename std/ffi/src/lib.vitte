

# -----------------------------------------------------------------------------
# std/ffi
# -----------------------------------------------------------------------------
# Bootstrap-friendly Foreign Function Interface primitives.
#
# Goals:
# - provide stable ABI-facing integer aliases and pointer/slice helpers
# - define a C-string type (NUL-terminated) and conversions to/from Vec[U8]
# - define a C buffer/byte span type for passing byte arrays across FFI
# - provide safe-ish wrappers around common patterns: out-params, length pairs
# - declare runtime hooks for allocation (optional) and for string formatting
#
# Non-goals:
# - dynamic library loading (belongs to std.os / std.dl)
# - reflection
# - full ABI description for structs across targets (handled in spec/abi_ffi.md)
#
# Constraints:
# - no IO
# - blocks use `.end` only
# - minimal dependencies: only std.core + std.collections
# -----------------------------------------------------------------------------

module std.ffi

use std.core
use std.collections

# -----------------------------------------------------------------------------
# Local aliases (re-export style)
# -----------------------------------------------------------------------------

type Bool  = std.core::Bool

type U8    = std.core::U8
type U16   = std.core::U16
type U32   = std.core::U32
type U64   = std.core::U64

type I8    = std.core::I8
type I16   = std.core::I16
type I32   = std.core::I32
type I64   = std.core::I64

type USize = std.core::USize
type ISize = std.core::ISize

type Ptr[T] = std.core::Ptr[T]

type Str   = std.core::Str

type Option[T] = std.core::Option[T]

type Result[T, E] = std.core::Result[T, E]

type Ordering = std.core::Ordering

# -----------------------------------------------------------------------------
# Errors
# -----------------------------------------------------------------------------

type FfiError enum
  Ok
  Null
  Invalid
  OutOfMemory
  Truncated
  Unsupported
.end

# -----------------------------------------------------------------------------
# ABI primitives
# -----------------------------------------------------------------------------

# Opaque pointer

type Opaque struct
  _unused: U8
.end

# C ABI char is byte in this layer.

type CChar = U8

# NUL-terminated C string (const)

type CStr struct
  ptr: Ptr[CChar]
.end

# Mutable C string pointer (rare; for APIs that mutate in place)

type CStrMut struct
  ptr: Ptr[CChar]
.end

# Raw byte span (ptr,len) for FFI

type ByteSpan struct
  ptr: Ptr[U8]
  len: USize
.end

# Mutable byte span (ptr,len)

type ByteSpanMut struct
  ptr: Ptr[U8]
  len: USize
.end

# -----------------------------------------------------------------------------
# Runtime hooks (platform / stage0)
# -----------------------------------------------------------------------------

fn rt_memcpy(dst: Ptr[U8], src: Ptr[U8], bytes: USize) -> Void
  ret
.end

fn rt_memmove(dst: Ptr[U8], src: Ptr[U8], bytes: USize) -> Void
  ret
.end

fn rt_memset(dst: Ptr[U8], v: U8, bytes: USize) -> Void
  ret
.end

# Optional allocator hooks. If runtime does not support, leave as stubs.
# ABI contract:
# - rt_alloc returns pointer aligned for max_align and writable
# - rt_free accepts null

fn rt_alloc(bytes: USize) -> Ptr[U8]
  ret (Ptr[U8])0
.end

fn rt_free(p: Ptr[U8], bytes: USize) -> Void
  ret
.end

fn panic(msg: Str) -> Void
  ret
.end

fn assert(cond: Bool, msg: Str) -> Void
  if !cond
    do panic(msg)
  .end
.end

# -----------------------------------------------------------------------------
# Basic constructors
# -----------------------------------------------------------------------------

fn cstr_null() -> CStr
  let s: CStr
  set s.ptr = (Ptr[CChar])0
  ret s
.end

fn cstr_is_null(s: CStr) -> Bool
  ret s.ptr == (Ptr[CChar])0
.end

fn bytespan_null() -> ByteSpan
  let b: ByteSpan
  set b.ptr = (Ptr[U8])0
  set b.len = 0
  ret b
.end

fn bytespan_mut_null() -> ByteSpanMut
  let b: ByteSpanMut
  set b.ptr = (Ptr[U8])0
  set b.len = 0
  ret b
.end

fn bytespan_from_ptr(ptr: Ptr[U8], len: USize) -> ByteSpan
  let b: ByteSpan
  set b.ptr = ptr
  set b.len = len
  ret b
.end

fn bytespan_mut_from_ptr(ptr: Ptr[U8], len: USize) -> ByteSpanMut
  let b: ByteSpanMut
  set b.ptr = ptr
  set b.len = len
  ret b
.end

# -----------------------------------------------------------------------------
# CStr utilities
# -----------------------------------------------------------------------------

fn cstr_len(s: CStr) -> (Bool, FfiError, USize)
  if s.ptr == (Ptr[CChar])0
    ret (false, FfiError::Null, 0)
  .end
  let i: USize
  set i = 0
  loop
    let b = *(s.ptr + i)
    if b == 0
      break
    .end
    set i = i + 1
  .end
  ret (true, FfiError::Ok, i)
.end

fn cstr_eq(a: CStr, b: CStr) -> (Bool, FfiError, Bool)
  if a.ptr == (Ptr[CChar])0 || b.ptr == (Ptr[CChar])0
    ret (false, FfiError::Null, false)
  .end

  let i: USize
  set i = 0
  loop
    let x = *(a.ptr + i)
    let y = *(b.ptr + i)
    if x != y
      ret (true, FfiError::Ok, false)
    .end
    if x == 0
      break
    .end
    set i = i + 1
  .end
  ret (true, FfiError::Ok, true)
.end

fn cstr_to_vec_bytes(s: CStr, out: &Vec[U8], include_nul: Bool) -> (Bool, FfiError)
  do vec_clear[U8](out)

  let ok: Bool
  let err: FfiError
  let n: USize

  (ok, err, n) = cstr_len(s)
  if !ok
    ret (false, err)
  .end

  let need: USize
  set need = n
  if include_nul
    set need = need + 1
  .end

  let ok2: Bool
  let e2: ColError
  (ok2, e2) = vec_reserve_bytes[U8](out, 1, need)
  if !ok2
    ret (false, FfiError::OutOfMemory)
  .end

  # copy bytes
  let i: USize
  set i = 0
  loop
    if i >= need
      break
    .end
    let b = *(s.ptr + i)
    let ok3: Bool
    let e3: ColError
    (ok3, e3) = vec_push[U8](out, 1, b)
    if !ok3
      ret (false, FfiError::OutOfMemory)
    .end
    set i = i + 1
  .end

  ret (true, FfiError::Ok)
.end

# Copies bytes from a Vec into a new NUL-terminated allocation.
# Returns a CStr pointing to owned memory.
# Contract: caller must free with cstr_free_owned.

fn cstr_from_vec_owned(bytes: &Vec[U8]) -> (Bool, FfiError, CStr)
  let s: CStr
  set s.ptr = (Ptr[CChar])0

  let n: USize
  set n = bytes.len

  let p = rt_alloc(n + 1)
  if p == (Ptr[U8])0
    ret (false, FfiError::OutOfMemory, s)
  .end

  if n > 0
    do rt_memcpy(p, (Ptr[U8])bytes.data, n)
  .end
  *(p + n) = 0

  set s.ptr = (Ptr[CChar])p
  ret (true, FfiError::Ok, s)
.end

fn cstr_free_owned(s: CStr) -> (Bool, FfiError)
  if s.ptr == (Ptr[CChar])0
    ret (true, FfiError::Ok)
  .end

  # best effort: compute length to free exact; some allocators ignore bytes
  let ok: Bool
  let err: FfiError
  let n: USize
  (ok, err, n) = cstr_len(s)
  if !ok
    # if corrupt, still attempt free with 0
    do rt_free((Ptr[U8])s.ptr, 0)
    ret (false, err)
  .end

  do rt_free((Ptr[U8])s.ptr, n + 1)
  ret (true, FfiError::Ok)
.end

# -----------------------------------------------------------------------------
# ByteSpan utilities
# -----------------------------------------------------------------------------

fn bytespan_is_null(b: ByteSpan) -> Bool
  ret b.ptr == (Ptr[U8])0
.end

fn bytespan_copy_to_vec(b: ByteSpan, out: &Vec[U8]) -> (Bool, FfiError)
  do vec_clear[U8](out)

  if b.ptr == (Ptr[U8])0
    if b.len == 0
      ret (true, FfiError::Ok)
    .end
    ret (false, FfiError::Null)
  .end

  let ok: Bool
  let e: ColError
  (ok, e) = vec_reserve_bytes[U8](out, 1, b.len)
  if !ok
    ret (false, FfiError::OutOfMemory)
  .end

  let i: USize
  set i = 0
  loop
    if i >= b.len
      break
    .end
    let v = *(b.ptr + i)
    let ok2: Bool
    let e2: ColError
    (ok2, e2) = vec_push[U8](out, 1, v)
    if !ok2
      ret (false, FfiError::OutOfMemory)
    .end
    set i = i + 1
  .end

  ret (true, FfiError::Ok)
.end

fn bytespan_write_from_vec(dst: ByteSpanMut, src: &Vec[U8]) -> (Bool, FfiError, USize)
  if dst.ptr == (Ptr[U8])0
    if dst.len == 0
      ret (true, FfiError::Ok, 0)
    .end
    ret (false, FfiError::Null, 0)
  .end

  let n = std.core::min_usize(dst.len, src.len)
  if n > 0
    do rt_memcpy(dst.ptr, (Ptr[U8])src.data, n)
  .end
  ret (true, FfiError::Ok, n)
.end

# -----------------------------------------------------------------------------
# Out-param pattern helpers
# -----------------------------------------------------------------------------

# Many C APIs return an error code and fill out parameters.
# This helper writes a value into *out if out != NULL.

fn write_out_u32(out: Ptr[U32], v: U32) -> (Bool, FfiError)
  if out == (Ptr[U32])0
    ret (false, FfiError::Null)
  .end
  *out = v
  ret (true, FfiError::Ok)
.end

fn write_out_usize(out: Ptr[USize], v: USize) -> (Bool, FfiError)
  if out == (Ptr[USize])0
    ret (false, FfiError::Null)
  .end
  *out = v
  ret (true, FfiError::Ok)
.end

fn write_out_ptr_u8(out: Ptr[Ptr[U8]], v: Ptr[U8]) -> (Bool, FfiError)
  if out == (Ptr[Ptr[U8]])0
    ret (false, FfiError::Null)
  .end
  *out = v
  ret (true, FfiError::Ok)
.end

# -----------------------------------------------------------------------------
# Common ABI utilities
# -----------------------------------------------------------------------------

fn check_nonnull(ptr: Ptr[U8]) -> (Bool, FfiError)
  if ptr == (Ptr[U8])0
    ret (false, FfiError::Null)
  .end
  ret (true, FfiError::Ok)
.end

fn check_len_pair(ptr: Ptr[U8], len: USize) -> (Bool, FfiError)
  if ptr == (Ptr[U8])0
    if len == 0
      ret (true, FfiError::Ok)
    .end
    ret (false, FfiError::Null)
  .end
  ret (true, FfiError::Ok)
.end

# -----------------------------------------------------------------------------
# Tests (scenarios)
# -----------------------------------------------------------------------------

fn assert_eq_u8_vec(a: &Vec[U8], b: &Vec[U8])
  do assert(a.len == b.len, "vec len mismatch")
  let ap = (Ptr[U8])a.data
  let bp = (Ptr[U8])b.data
  let i: USize
  set i = 0
  loop
    if i >= a.len
      break
    .end
    do assert(*(ap + i) == *(bp + i), "vec byte mismatch")
    set i = i + 1
  .end
.end

scn test_bytespan_copy
  let v = vec_new[U8]()
  let ok: Bool
  let e: ColError

  (ok, e) = vec_push[U8](&v, 1, 1)
  (ok, e) = vec_push[U8](&v, 1, 2)
  (ok, e) = vec_push[U8](&v, 1, 3)

  let span = bytespan_from_ptr((Ptr[U8])v.data, v.len)

  let out = vec_new[U8]()
  let ok2: Bool
  let fe: FfiError
  (ok2, fe) = bytespan_copy_to_vec(span, &out)
  do assert(ok2, "bytespan_copy_to_vec")

  do assert_eq_u8_vec(&v, &out)

  do vec_drop[U8](&v, 1)
  do vec_drop[U8](&out, 1)
.end

scn test_cstr_len_eq
  # build "hi\0" on stack
  let b0: U8
  let b1: U8
  let b2: U8
  set b0 = (U8)'h'
  set b1 = (U8)'i'
  set b2 = 0

  let s = cstr_null()
  set s.ptr = (Ptr[CChar])&b0

  let ok: Bool
  let fe: FfiError
  let n: USize
  (ok, fe, n) = cstr_len(s)
  do assert(ok, "cstr_len")
  do assert(n == 2, "cstr_len == 2")

  # compare with itself
  let eq: Bool
  (ok, fe, eq) = cstr_eq(s, s)
  do assert(ok, "cstr_eq")
  do assert(eq, "cstr_eq true")
.end

# End of std.ffi