# -----------------------------------------------------------------------------
# std/process
# -----------------------------------------------------------------------------
# Bootstrap-friendly process management.
#
# Scope:
# - Command builder (program/args/env/cwd + stdio config)
# - spawn/wait/try_wait/kill
# - piped stdio handles + read/write helpers
# - convenience helpers: status(), output()
#
# Constraints:
# - no direct syscalls; runtime provides hooks
# - no async
# - blocks use `.end` only
# - buffers/results use Vec
# -----------------------------------------------------------------------------

module std.process

use std.collections

# -----------------------------------------------------------------------------
# Local prelude
# -----------------------------------------------------------------------------

type Bool  = bool

type U8    = u8
type U16   = u16
type U32   = u32
type U64   = u64

type I32   = i32
type I64   = i64

type USize = usize

type Ptr[T] = ptr[T]

type Str = str

# -----------------------------------------------------------------------------
# Panic / assert stubs (bootstrapped by runtime if desired)
# -----------------------------------------------------------------------------

fn panic(msg: Str)
  ret
.end

fn assert(cond: Bool, msg: Str)
  if !cond
    do panic(msg)
  .end
.end

# -----------------------------------------------------------------------------
# Errors / signals / stdio
# -----------------------------------------------------------------------------

type ProcessError enum
  Ok
  Invalid
  OutOfMemory
  NotFound
  Permission
  WouldBlock
  TimedOut
  Unsupported
  Io
.end

# Portable-ish signal enum (runtime may map)

type Signal enum
  Term
  Kill
  Int
.end

# Stdio configuration for spawned child

type Stdio enum
  Inherit
  Null
  Piped
.end

# -----------------------------------------------------------------------------
# Core data types
# -----------------------------------------------------------------------------

type ExitStatus struct
  # If exited normally, code >= 0
  code: I32
  # If terminated by signal, signal >= 0
  signal: I32
  success: Bool
.end

fn exitstatus_from_code(code: I32) -> ExitStatus
  let st: ExitStatus
  set st.code = code
  set st.signal = -1
  set st.success = code == 0
  ret st
.end

fn exitstatus_from_signal(sig: I32) -> ExitStatus
  let st: ExitStatus
  set st.code = -1
  set st.signal = sig
  set st.success = false
  ret st
.end

fn exitstatus_unknown() -> ExitStatus
  let st: ExitStatus
  set st.code = -1
  set st.signal = -1
  set st.success = false
  ret st
.end

# Piped IO handle (abstract file descriptor)

type Pipe struct
  fd: I32
.end

fn pipe_invalid() -> Pipe
  let p: Pipe
  set p.fd = -1
  ret p
.end

fn pipe_is_valid(p: &Pipe) -> Bool
  ret p.fd >= 0
.end

# Env var entry

type EnvVar struct
  key: Vec[U8]
  val: Vec[U8]
.end

fn envvar_new() -> EnvVar
  let e: EnvVar
  set e.key = vec_new[U8]()
  set e.val = vec_new[U8]()
  ret e
.end

fn envvar_drop(e: &EnvVar)
  do vec_drop[U8](&e.key, 1)
  do vec_drop[U8](&e.val, 1)
.end

# Command builder

type Command struct
  program: Vec[U8]
  args: Vec[Vec[U8]]
  env: Vec[EnvVar]
  cwd: Vec[U8]

  stdin: Stdio
  stdout: Stdio
  stderr: Stdio
.end

# Spawned child

type Child struct
  pid: I32
  stdin: Pipe
  stdout: Pipe
  stderr: Pipe
.end

fn child_invalid() -> Child
  let c: Child
  set c.pid = -1
  set c.stdin = pipe_invalid()
  set c.stdout = pipe_invalid()
  set c.stderr = pipe_invalid()
  ret c
.end

fn child_is_valid(c: &Child) -> Bool
  ret c.pid > 0
.end

# Output capture

type Output struct
  status: ExitStatus
  stdout: Vec[U8]
  stderr: Vec[U8]
.end

fn output_new() -> Output
  let o: Output
  set o.status = exitstatus_unknown()
  set o.stdout = vec_new[U8]()
  set o.stderr = vec_new[U8]()
  ret o
.end

fn output_drop(o: &Output)
  do vec_drop[U8](&o.stdout, 1)
  do vec_drop[U8](&o.stderr, 1)
.end

# -----------------------------------------------------------------------------
# Runtime syscall surface
# -----------------------------------------------------------------------------
# Conventions (recommended):
# - rc == 0: success
# - rc < 0: -N is an abstract error code mapped by map_rt_rc
#
# Spawn contract:
# - runtime reads Command (program/args/env/cwd + stdio settings)
# - runtime fills Child {pid, stdin/stdout/stderr fds} for piped config
# - if stdio is not Piped, corresponding fd should remain -1
# -----------------------------------------------------------------------------

fn rt_proc_spawn(cmd: &Command, out_child: &Child) -> I32
  ret -1
.end

fn rt_proc_wait(pid: I32, out_exited: &Bool, out_code: &I32, out_signal: &I32) -> I32
  ret -1
.end

fn rt_proc_try_wait(pid: I32, out_done: &Bool, out_exited: &Bool, out_code: &I32, out_signal: &I32) -> I32
  ret -1
.end

fn rt_proc_kill(pid: I32, sig: Signal) -> I32
  ret -1
.end

fn rt_proc_close(fd: I32) -> I32
  ret -1
.end

fn rt_proc_read(fd: I32, dst: Ptr[U8], len: USize) -> I64
  ret -1
.end

fn rt_proc_write(fd: I32, src: Ptr[U8], len: USize) -> I64
  ret -1
.end

fn rt_proc_getpid() -> I32
  ret -1
.end

fn rt_proc_sleep_ms(ms: U32) -> I32
  ret -1
.end

# -----------------------------------------------------------------------------
# Error mapping
# -----------------------------------------------------------------------------

fn map_rt_rc(rc: I32) -> ProcessError
  if rc == 0
    ret ProcessError::Ok
  .end

  if rc == -2
    ret ProcessError::WouldBlock
  .end
  if rc == -3
    ret ProcessError::TimedOut
  .end
  if rc == -9
    ret ProcessError::Unsupported
  .end
  if rc == -10
    ret ProcessError::NotFound
  .end
  if rc == -11
    ret ProcessError::Permission
  .end
  if rc == -12
    ret ProcessError::OutOfMemory
  .end

  ret ProcessError::Io
.end

fn map_rt_i64(n: I64) -> (Bool, ProcessError, USize)
  if n >= 0
    ret (true, ProcessError::Ok, (USize)n)
  .end
  ret (false, map_rt_rc((I32)n), 0)
.end

# -----------------------------------------------------------------------------
# Small Vec helpers (byte-level)
# -----------------------------------------------------------------------------

fn vec_push_byte(dst: &Vec[U8], b: U8) -> Bool
  let ok: Bool
  let e: ColError
  (ok, e) = vec_push[U8](dst, 1, b)
  ret ok
.end

fn vec_push_bytes(dst: &Vec[U8], p: Ptr[U8], n: USize) -> Bool
  let ok: Bool
  let e: ColError
  let i: USize
  set i = 0
  while i < n
    (ok, e) = vec_push[U8](dst, 1, *(p + i))
    if !ok
      ret false
    .end
    set i = i + 1
  .end
  ret true
.end

fn vec_assign_u8(dst: &Vec[U8], src: &Vec[U8]) -> Bool
  do vec_clear[U8](dst)
  let ok: Bool
  let e: ColError
  let i: USize
  set i = 0
  let p = (Ptr[U8])src.data
  while i < src.len
    (ok, e) = vec_push[U8](dst, 1, *(p + i))
    if !ok
      ret false
    .end
    set i = i + 1
  .end
  ret true
.end

fn vec_clone_u8(src: &Vec[U8]) -> (Bool, Vec[U8])
  let v = vec_new[U8]()
  if !vec_assign_u8(&v, src)
    do vec_drop[U8](&v, 1)
    ret (false, vec_new[U8]())
  .end
  ret (true, v)
.end

fn vec_from_cstr(s: Str) -> Vec[U8]
  let v = vec_new[U8]()
  let p = (Ptr[U8])s
  let i: USize
  set i = 0
  loop
    let b = *(p + i)
    if b == 0
      break
    .end
    if !vec_push_byte(&v, b)
      do vec_drop[U8](&v, 1)
      ret vec_new[U8]()
    .end
    set i = i + 1
  .end
  ret v
.end

# Make Vec[U8] with length len filled with zeros (stable .data pointer)
fn vec_make_zeros(len: USize) -> (Bool, Vec[U8])
  let v = vec_new[U8]()
  let ok: Bool
  let e: ColError
  (ok, e) = vec_reserve_bytes[U8](&v, 1, len)
  if !ok
    do vec_drop[U8](&v, 1)
    ret (false, vec_new[U8]())
  .end

  let i: USize
  set i = 0
  while i < len
    (ok, e) = vec_push[U8](&v, 1, 0)
    if !ok
      do vec_drop[U8](&v, 1)
      ret (false, vec_new[U8]())
    .end
    set i = i + 1
  .end

  ret (true, v)
.end

# -----------------------------------------------------------------------------
# Command builder API
# -----------------------------------------------------------------------------

fn command_new() -> Command
  let c: Command
  set c.program = vec_new[U8]()
  set c.args = vec_new[Vec[U8]]()
  set c.env = vec_new[EnvVar]()
  set c.cwd = vec_new[U8]()
  set c.stdin = Stdio::Inherit
  set c.stdout = Stdio::Inherit
  set c.stderr = Stdio::Inherit
  ret c
.end

fn command_drop(c: &Command)
  do vec_drop[U8](&c.program, 1)
  do vec_drop[U8](&c.cwd, 1)

  # drop args (each Vec[U8])
  let i: USize
  set i = 0
  while i < c.args.len
    let a = *((Ptr[Vec[U8]])c.args.data + i)
    do vec_drop[U8](&a, 1)
    set i = i + 1
  .end
  do vec_drop[Vec[U8]](&c.args, 0)

  # drop env (each EnvVar)
  set i = 0
  while i < c.env.len
    let ev = *((Ptr[EnvVar])c.env.data + i)
    do envvar_drop(&ev)
    set i = i + 1
  .end
  do vec_drop[EnvVar](&c.env, 0)
.end

fn command_set_program(c: &Command, program: &Vec[U8]) -> Bool
  ret vec_assign_u8(&c.program, program)
.end

fn command_set_program_cstr(c: &Command, program: Str) -> Bool
  let v = vec_from_cstr(program)
  let ok = vec_assign_u8(&c.program, &v)
  do vec_drop[U8](&v, 1)
  ret ok
.end

fn command_arg(c: &Command, arg: &Vec[U8]) -> Bool
  let ok: Bool
  let e: ColError
  let ok2: Bool
  let copy: Vec[U8]

  (ok2, copy) = vec_clone_u8(arg)
  if !ok2
    ret false
  .end

  (ok, e) = vec_push[Vec[U8]](&c.args, 0, copy)
  if !ok
    do vec_drop[U8](&copy, 1)
    ret false
  .end

  ret true
.end

fn command_arg_cstr(c: &Command, arg: Str) -> Bool
  let v = vec_from_cstr(arg)
  let ok = command_arg(c, &v)
  do vec_drop[U8](&v, 1)
  ret ok
.end

fn command_env(c: &Command, key: &Vec[U8], val: &Vec[U8]) -> Bool
  let ev = envvar_new()

  if !vec_assign_u8(&ev.key, key)
    do envvar_drop(&ev)
    ret false
  .end
  if !vec_assign_u8(&ev.val, val)
    do envvar_drop(&ev)
    ret false
  .end

  let ok: Bool
  let e: ColError
  (ok, e) = vec_push[EnvVar](&c.env, 0, ev)
  if !ok
    do envvar_drop(&ev)
    ret false
  .end

  ret true
.end

fn command_env_cstr(c: &Command, key: Str, val: Str) -> Bool
  let k = vec_from_cstr(key)
  let v = vec_from_cstr(val)
  let ok = command_env(c, &k, &v)
  do vec_drop[U8](&k, 1)
  do vec_drop[U8](&v, 1)
  ret ok
.end

fn command_cwd(c: &Command, cwd: &Vec[U8]) -> Bool
  ret vec_assign_u8(&c.cwd, cwd)
.end

fn command_cwd_cstr(c: &Command, cwd: Str) -> Bool
  let v = vec_from_cstr(cwd)
  let ok = vec_assign_u8(&c.cwd, &v)
  do vec_drop[U8](&v, 1)
  ret ok
.end

fn command_stdin(c: &Command, s: Stdio)
  set c.stdin = s
.end

fn command_stdout(c: &Command, s: Stdio)
  set c.stdout = s
.end

fn command_stderr(c: &Command, s: Stdio)
  set c.stderr = s
.end

fn command_pipe_output(c: &Command)
  set c.stdout = Stdio::Piped
  set c.stderr = Stdio::Piped
.end

# -----------------------------------------------------------------------------
# Child lifecycle
# -----------------------------------------------------------------------------

fn child_close_pipe(p: &Pipe) -> (Bool, ProcessError)
  if p.fd < 0
    ret (true, ProcessError::Ok)
  .end
  let rc = rt_proc_close(p.fd)
  let e = map_rt_rc(rc)
  if e != ProcessError::Ok
    ret (false, e)
  .end
  set p.fd = -1
  ret (true, ProcessError::Ok)
.end

fn child_drop(c: &Child)
  do child_close_pipe(&c.stdin)
  do child_close_pipe(&c.stdout)
  do child_close_pipe(&c.stderr)
  set c.pid = -1
.end

fn child_kill(c: &Child, sig: Signal) -> (Bool, ProcessError)
  if c.pid <= 0
    ret (false, ProcessError::Invalid)
  .end
  let rc = rt_proc_kill(c.pid, sig)
  let e = map_rt_rc(rc)
  if e != ProcessError::Ok
    ret (false, e)
  .end
  ret (true, ProcessError::Ok)
.end

fn child_wait(c: &Child) -> (Bool, ProcessError, ExitStatus)
  if c.pid <= 0
    ret (false, ProcessError::Invalid, exitstatus_unknown())
  .end

  let exited: Bool
  let code: I32
  let sig: I32

  let rc = rt_proc_wait(c.pid, &exited, &code, &sig)
  let e = map_rt_rc(rc)
  if e != ProcessError::Ok
    ret (false, e, exitstatus_unknown())
  .end

  # close pipes after process exits
  do child_close_pipe(&c.stdin)
  do child_close_pipe(&c.stdout)
  do child_close_pipe(&c.stderr)

  if exited
    let st = exitstatus_from_code(code)
    set c.pid = -1
    ret (true, ProcessError::Ok, st)
  .end

  let st2 = exitstatus_from_signal(sig)
  set c.pid = -1
  ret (true, ProcessError::Ok, st2)
.end

fn child_try_wait(c: &Child) -> (Bool, ProcessError, Bool, ExitStatus)
  if c.pid <= 0
    ret (false, ProcessError::Invalid, false, exitstatus_unknown())
  .end

  let done: Bool
  let exited: Bool
  let code: I32
  let sig: I32

  let rc = rt_proc_try_wait(c.pid, &done, &exited, &code, &sig)
  let e = map_rt_rc(rc)
  if e != ProcessError::Ok
    ret (false, e, false, exitstatus_unknown())
  .end

  if !done
    ret (true, ProcessError::Ok, false, exitstatus_unknown())
  .end

  # done: same semantics as wait
  do child_close_pipe(&c.stdin)
  do child_close_pipe(&c.stdout)
  do child_close_pipe(&c.stderr)

  if exited
    let st = exitstatus_from_code(code)
    set c.pid = -1
    ret (true, ProcessError::Ok, true, st)
  .end

  let st2 = exitstatus_from_signal(sig)
  set c.pid = -1
  ret (true, ProcessError::Ok, true, st2)
.end

# -----------------------------------------------------------------------------
# Spawn
# -----------------------------------------------------------------------------

fn spawn(cmd: &Command) -> (Bool, ProcessError, Child)
  let ch = child_invalid()

  # minimal validation
  if cmd.program.len == 0
    ret (false, ProcessError::Invalid, ch)
  .end

  let rc = rt_proc_spawn(cmd, &ch)
  let e = map_rt_rc(rc)
  if e != ProcessError::Ok
    ret (false, e, child_invalid())
  .end

  ret (true, ProcessError::Ok, ch)
.end

# -----------------------------------------------------------------------------
# Pipe I/O
# -----------------------------------------------------------------------------

fn pipe_read_some(p: &Pipe, out: &Vec[U8], max_bytes: USize) -> (Bool, ProcessError, USize)
  do vec_clear[U8](out)

  if p.fd < 0
    ret (false, ProcessError::Invalid, 0)
  .end

  if max_bytes == 0
    ret (true, ProcessError::Ok, 0)
  .end

  let okm: Bool
  let tmp: Vec[U8]
  (okm, tmp) = vec_make_zeros(max_bytes)
  if !okm
    ret (false, ProcessError::OutOfMemory, 0)
  .end

  let ok: Bool
  let e: ProcessError
  let n: USize
  (ok, e, n) = map_rt_i64(rt_proc_read(p.fd, (Ptr[U8])tmp.data, max_bytes))
  if !ok
    do vec_drop[U8](&tmp, 1)
    ret (false, e, 0)
  .end

  let i: USize
  set i = 0
  while i < n
    if !vec_push_byte(out, *((Ptr[U8])tmp.data + i))
      do vec_drop[U8](&tmp, 1)
      ret (false, ProcessError::OutOfMemory, 0)
    .end
    set i = i + 1
  .end

  do vec_drop[U8](&tmp, 1)
  ret (true, ProcessError::Ok, n)
.end

fn pipe_read_to_end(p: &Pipe, out: &Vec[U8]) -> (Bool, ProcessError)
  do vec_clear[U8](out)

  if p.fd < 0
    ret (false, ProcessError::Invalid)
  .end

  let chunk: USize
  set chunk = 4096

  loop
    let buf = vec_new[U8]()
    let ok: Bool
    let e: ProcessError
    let n: USize
    (ok, e, n) = pipe_read_some(p, &buf, chunk)
    if !ok
      do vec_drop[U8](&buf, 1)
      ret (false, e)
    .end

    if n == 0
      do vec_drop[U8](&buf, 1)
      break
    .end

    let i: USize
    set i = 0
    while i < buf.len
      if !vec_push_byte(out, *((Ptr[U8])buf.data + i))
        do vec_drop[U8](&buf, 1)
        ret (false, ProcessError::OutOfMemory)
      .end
      set i = i + 1
    .end

    do vec_drop[U8](&buf, 1)
  .end

  ret (true, ProcessError::Ok)
.end

fn pipe_write_all(p: &Pipe, data: &Vec[U8]) -> (Bool, ProcessError)
  if p.fd < 0
    ret (false, ProcessError::Invalid)
  .end
  if data.len == 0
    ret (true, ProcessError::Ok)
  .end

  let off: USize
  set off = 0
  let d = (Ptr[U8])data.data

  loop
    if off >= data.len
      break
    .end

    let ok: Bool
    let e: ProcessError
    let n: USize
    (ok, e, n) = map_rt_i64(rt_proc_write(p.fd, d + off, data.len - off))
    if !ok
      ret (false, e)
    .end
    if n == 0
      ret (false, ProcessError::Io)
    .end

    set off = off + n
  .end

  ret (true, ProcessError::Ok)
.end

# -----------------------------------------------------------------------------
# Convenience: status() and output()
# -----------------------------------------------------------------------------

fn command_status(cmd: &Command) -> (Bool, ProcessError, ExitStatus)
  let ok: Bool
  let e: ProcessError
  let ch: Child

  (ok, e, ch) = spawn(cmd)
  if !ok
    ret (false, e, exitstatus_unknown())
  .end

  let st: ExitStatus
  (ok, e, st) = child_wait(&ch)
  do child_drop(&ch)
  if !ok
    ret (false, e, exitstatus_unknown())
  .end

  ret (true, ProcessError::Ok, st)
.end

fn command_output(cmd: &Command) -> (Bool, ProcessError, Output)
  # clone cmd with piped stdout/stderr
  let local = command_new()

  if !vec_assign_u8(&local.program, &cmd.program)
    do command_drop(&local)
    ret (false, ProcessError::OutOfMemory, output_new())
  .end

  # clone args
  let i: USize
  set i = 0
  while i < cmd.args.len
    let a = *((Ptr[Vec[U8]])cmd.args.data + i)
    if !command_arg(&local, &a)
      do command_drop(&local)
      ret (false, ProcessError::OutOfMemory, output_new())
    .end
    set i = i + 1
  .end

  # clone env
  set i = 0
  while i < cmd.env.len
    let ev = *((Ptr[EnvVar])cmd.env.data + i)
    if !command_env(&local, &ev.key, &ev.val)
      do command_drop(&local)
      ret (false, ProcessError::OutOfMemory, output_new())
    .end
    set i = i + 1
  .end

  if !vec_assign_u8(&local.cwd, &cmd.cwd)
    do command_drop(&local)
    ret (false, ProcessError::OutOfMemory, output_new())
  .end

  set local.stdin = cmd.stdin
  set local.stdout = Stdio::Piped
  set local.stderr = Stdio::Piped

  let ok: Bool
  let e: ProcessError
  let ch: Child
  (ok, e, ch) = spawn(&local)
  do command_drop(&local)
  if !ok
    ret (false, e, output_new())
  .end

  let out = output_new()

  # wait first, then drain pipes (portable if pipes are fully buffered by OS)
  let st: ExitStatus
  (ok, e, st) = child_wait(&ch)
  if !ok
    do child_drop(&ch)
    do output_drop(&out)
    ret (false, e, output_new())
  .end

  set out.status = st

  if pipe_is_valid(&ch.stdout)
    (ok, e) = pipe_read_to_end(&ch.stdout, &out.stdout)
    if !ok
      do child_drop(&ch)
      do output_drop(&out)
      ret (false, e, output_new())
    .end
  .end

  if pipe_is_valid(&ch.stderr)
    (ok, e) = pipe_read_to_end(&ch.stderr, &out.stderr)
    if !ok
      do child_drop(&ch)
      do output_drop(&out)
      ret (false, e, output_new())
    .end
  .end

  do child_drop(&ch)
  ret (true, ProcessError::Ok, out)
.end

# -----------------------------------------------------------------------------
# Misc helpers
# -----------------------------------------------------------------------------

fn getpid() -> (Bool, ProcessError, I32)
  let pid = rt_proc_getpid()
  if pid < 0
    ret (false, map_rt_rc(pid), -1)
  .end
  ret (true, ProcessError::Ok, pid)
.end

fn sleep_ms(ms: U32) -> (Bool, ProcessError)
  let rc = rt_proc_sleep_ms(ms)
  let e = map_rt_rc(rc)
  if e != ProcessError::Ok
    ret (false, e)
  .end
  ret (true, ProcessError::Ok)
.end

# -----------------------------------------------------------------------------
# Tests (scenarios) - runtime-independent
# -----------------------------------------------------------------------------

scn test_command_builder
  let c = command_new()
  do assert(command_set_program_cstr(&c, "prog"), "set prog")
  do assert(command_arg_cstr(&c, "a"), "arg")
  do assert(command_env_cstr(&c, "K", "V"), "env")
  do assert(command_cwd_cstr(&c, "/"), "cwd")

  do assert(c.program.len != 0, "prog len")
  do assert(c.args.len == 1, "args len")
  do assert(c.env.len == 1, "env len")

  do command_drop(&c)
.end

# End of std.process
