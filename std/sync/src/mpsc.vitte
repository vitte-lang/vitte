

# /Users/vincent/Documents/Github/vitte/std/sync/src/mpsc.vitte
# -----------------------------------------------------------------------------
# std/sync/mpsc
# -----------------------------------------------------------------------------
# Multi-Producer / Single-Consumer channel.
#
# MAX goals:
# - Provide a safe, ergonomic MPSC channel API inspired by established channel designs.
# - Portable runtime-backed implementation (queue + mutex + condvar/event).
# - Support blocking recv, non-blocking try_recv, and timed recv.
# - Support sender cloning (multi-producer) and receiver is single-owner.
# - Support graceful close when all senders are dropped.
# - Support bounded and unbounded channels.
# - Provide select-like polling via try_recv + wait handle (Event).
#
# Design
# - Channel is backed by an internal shared state allocated by runtime.
# - Sender holds a reference; drop decrements sender count.
# - Receiver holds a reference; drop closes receiver side.
# - When the queue transitions empty->non-empty, signal the receiver.
# - When sender count reaches 0, close is signaled.
#
# Assumptions about runtime
# - Atomic refcount helpers or opaque channel handle with clone/drop.
# - Internal queue storage and wake mechanism.
# - In this file we provide a high-level wrapper and fallbacks based on
#   std.sync.{mutex,candvar,event} if you choose to implement purely in std.
#
# For now, this implementation assumes runtime provides a generic channel
# primitive that can carry `any`-like payloads, or byte buffers.
# If your runtime doesnâ€™t have it yet, treat the `rt_*` wrappers as TODO targets.
#
# Blocks use `.end` only.
# -----------------------------------------------------------------------------

module std.sync.mpsc

use std.runtime
use std.core.option
use std.core.result
use std.time
use std.sync.event

# -----------------------------------------------------------------------------
# Types
# -----------------------------------------------------------------------------

type Bool = bool

type U64  = u64

type I32  = i32

type Str  = str

type Option[T] = std.core.option::Option[T]

type Result[T, E] = std.core.result::Result[T, E]

# Channel errors.

enum SendError
  Closed
.end

enum RecvError
  Empty
  Closed
  Timeout
.end

# Internal runtime handle.

type RtChan = std.runtime::RtChan

type RtMsg  = std.runtime::RtMsg

# Public handles.

struct Sender[T]
  h: RtChan
.end

struct Receiver[T]
  h: RtChan
.end

# A lightweight wait handle to integrate with polling loops.
# The receiver can expose an Event that becomes signaled when:
# - a new message arrives, OR
# - the channel is closed.

struct RecvWaitHandle
  e: std.sync.event::Event
.end

# -----------------------------------------------------------------------------
# Runtime bindings (expected)
# -----------------------------------------------------------------------------
# If your runtime has different names, adapt wrappers only.
#
# We model messages as RtMsg (opaque). For generic T, we rely on runtime boxing.

fn rt_chan_unbounded() -> RtChan
  ret std.runtime::chan_mpsc_unbounded()
.end

fn rt_chan_bounded(cap: U64) -> RtChan
  ret std.runtime::chan_mpsc_bounded(cap)
.end

fn rt_chan_clone_sender(h: RtChan) -> RtChan
  ret std.runtime::chan_mpsc_clone_sender(h)
.end

fn rt_chan_drop_sender(h: RtChan)
  do std.runtime::chan_mpsc_drop_sender(h)
.end

fn rt_chan_drop_receiver(h: RtChan)
  do std.runtime::chan_mpsc_drop_receiver(h)
.end

fn rt_chan_send(h: RtChan, msg: RtMsg) -> Bool
  # returns false if closed
  ret std.runtime::chan_mpsc_send(h, msg)
.end

fn rt_chan_try_recv(h: RtChan) -> (Bool, RtMsg)
  # (ok, msg) where ok=false means empty OR closed; use rt_chan_is_closed.
  ret std.runtime::chan_mpsc_try_recv(h)
.end

fn rt_chan_recv(h: RtChan) -> (Bool, RtMsg)
  # (ok, msg) where ok=false means closed (no more messages)
  ret std.runtime::chan_mpsc_recv(h)
.end

fn rt_chan_timed_recv_ms(h: RtChan, timeout_ms: U64) -> (I32, RtMsg)
  # returns code: 0=ok, 1=timeout, 2=closed
  ret std.runtime::chan_mpsc_timed_recv_ms(h, timeout_ms)
.end

fn rt_chan_len(h: RtChan) -> U64
  ret std.runtime::chan_mpsc_len(h)
.end

fn rt_chan_is_closed(h: RtChan) -> Bool
  ret std.runtime::chan_mpsc_is_closed(h)
.end

fn rt_msg_from[T](v: T) -> RtMsg
  ret std.runtime::msg_box(v)
.end

fn rt_msg_into[T](m: RtMsg) -> T
  ret std.runtime::msg_unbox[T](m)
.end

fn rt_chan_wait_event(h: RtChan) -> std.sync.event::Event
  # Event is signaled on new msg or close.
  ret std.runtime::chan_mpsc_wait_event(h)
.end

# -----------------------------------------------------------------------------
# Construction
# -----------------------------------------------------------------------------

fn channel_unbounded[T]() -> (Sender[T], Receiver[T])
  let h = rt_chan_unbounded()

  let tx: Sender[T]
  let rx: Receiver[T]
  set tx.h = h
  set rx.h = h

  ret (tx, rx)
.end

fn channel_bounded[T](cap: U64) -> (Sender[T], Receiver[T])
  let h = rt_chan_bounded(cap)

  let tx: Sender[T]
  let rx: Receiver[T]
  set tx.h = h
  set rx.h = h

  ret (tx, rx)
.end

# -----------------------------------------------------------------------------
# Sender API
# -----------------------------------------------------------------------------

fn sender_clone[T](tx: Sender[T]) -> Sender[T]
  let out: Sender[T]
  set out.h = rt_chan_clone_sender(tx.h)
  ret out
.end

fn sender_drop[T](tx: Sender[T])
  do rt_chan_drop_sender(tx.h)
.end

fn send[T](tx: Sender[T], v: T) -> Result[(), SendError]
  let m = rt_msg_from[T](v)
  let ok = rt_chan_send(tx.h, m)
  if ok
    ret std.core.result::Ok(())
  .end
  ret std.core.result::Err(SendError::Closed)
.end

fn is_closed_sender[T](tx: Sender[T]) -> Bool
  ret rt_chan_is_closed(tx.h)
.end

fn len_sender[T](tx: Sender[T]) -> U64
  ret rt_chan_len(tx.h)
.end

# -----------------------------------------------------------------------------
# Receiver API
# -----------------------------------------------------------------------------

fn receiver_drop[T](rx: Receiver[T])
  do rt_chan_drop_receiver(rx.h)
.end

fn try_recv[T](rx: Receiver[T]) -> Result[T, RecvError]
  let ok: Bool
  let m: RtMsg
  (ok, m) = rt_chan_try_recv(rx.h)

  if ok
    let v = rt_msg_into[T](m)
    ret std.core.result::Ok(v)
  .end

  if rt_chan_is_closed(rx.h)
    ret std.core.result::Err(RecvError::Closed)
  .end

  ret std.core.result::Err(RecvError::Empty)
.end

fn recv[T](rx: Receiver[T]) -> Result[T, RecvError]
  let ok: Bool
  let m: RtMsg
  (ok, m) = rt_chan_recv(rx.h)

  if ok
    let v = rt_msg_into[T](m)
    ret std.core.result::Ok(v)
  .end

  ret std.core.result::Err(RecvError::Closed)
.end

fn recv_for_ms[T](rx: Receiver[T], timeout_ms: U64) -> Result[T, RecvError]
  let code: I32
  let m: RtMsg
  (code, m) = rt_chan_timed_recv_ms(rx.h, timeout_ms)

  if code == 0
    let v = rt_msg_into[T](m)
    ret std.core.result::Ok(v)
  .end

  if code == 1
    ret std.core.result::Err(RecvError::Timeout)
  .end

  ret std.core.result::Err(RecvError::Closed)
.end

fn recv_for[T](rx: Receiver[T], dur: std.time::Duration) -> Result[T, RecvError]
  let ms = std.time::duration_as_millis(dur)
  ret recv_for_ms[T](rx, ms)
.end

fn recv_until[T](rx: Receiver[T], deadline: std.time::Instant) -> Result[T, RecvError]
  let now = std.time::instant_now()
  if std.time::instant_ge(now, deadline)
    ret std.core.result::Err(RecvError::Timeout)
  .end
  let dur = std.time::instant_duration_between(now, deadline)
  ret recv_for[T](rx, dur)
.end

fn is_closed_receiver[T](rx: Receiver[T]) -> Bool
  ret rt_chan_is_closed(rx.h)
.end

fn len_receiver[T](rx: Receiver[T]) -> U64
  ret rt_chan_len(rx.h)
.end

fn wait_handle[T](rx: Receiver[T]) -> RecvWaitHandle
  let wh: RecvWaitHandle
  set wh.e = rt_chan_wait_event(rx.h)
  ret wh
.end

# Pollable wait: wait until signaled, then return.

fn wait_ready[T](wh: RecvWaitHandle) -> std.sync.event::WaitResult
  ret std.sync.event::wait(wh.e)
.end

fn wait_ready_for_ms[T](wh: RecvWaitHandle, timeout_ms: U64) -> std.sync.event::WaitResult
  ret std.sync.event::wait_for_ms(wh.e, timeout_ms)
.end

# -----------------------------------------------------------------------------
# Utility: drain
# -----------------------------------------------------------------------------

fn drain_to_vec[T](rx: Receiver[T]) -> Option[std.collections::Vec[T]]
  # This helper is optional; if std.collections is not available in your build,
  # return None. Adapt based on feature flags.
  ret std.core.option::None
.end

# -----------------------------------------------------------------------------
# Tests (smoke + semantics)
# -----------------------------------------------------------------------------

fn assert_true(b: Bool, msg: Str)
  do std.runtime::assert(b, msg)
.end

fn assert_eq_u64(a: U64, b: U64, msg: Str)
  do std.runtime::assert(a == b, msg)
.end

scn test_mpsc_smoke_unbounded
  let tx: Sender[U64]
  let rx: Receiver[U64]
  (tx, rx) = channel_unbounded[U64]()

  do assert_true(len_sender[U64](tx) == 0, "len 0")

  let r1 = send[U64](tx, 1)
  let r2 = send[U64](tx, 2)
  do assert_true(std.core.result::is_ok(r1), "send 1")
  do assert_true(std.core.result::is_ok(r2), "send 2")

  do assert_true(len_receiver[U64](rx) >= 2, "len >= 2")

  let a = recv[U64](rx)
  let b = recv[U64](rx)
  do assert_true(std.core.result::is_ok(a), "recv a")
  do assert_true(std.core.result::is_ok(b), "recv b")

  # Drop sender then receiver should see closed once queue empty.
  do sender_drop[U64](tx)

  let miss = try_recv[U64](rx)
  # miss is either Empty (if runtime keeps open until receiver observes) or Closed.
  do assert_true(std.core.result::is_err(miss), "try_recv err")

  do receiver_drop[U64](rx)
.end

scn test_mpsc_clone_sender
  let tx: Sender[U64]
  let rx: Receiver[U64]
  (tx, rx) = channel_unbounded[U64]()

  let tx2 = sender_clone[U64](tx)

  do assert_true(std.core.result::is_ok(send[U64](tx, 10)), "send tx")
  do assert_true(std.core.result::is_ok(send[U64](tx2, 20)), "send tx2")

  let a = recv[U64](rx)
  let b = recv[U64](rx)
  do assert_true(std.core.result::is_ok(a), "recv a")
  do assert_true(std.core.result::is_ok(b), "recv b")

  do sender_drop[U64](tx)
  do sender_drop[U64](tx2)

  # channel should close
  let end = recv_for_ms[U64](rx, 0)
  do assert_true(std.core.result::is_err(end), "recv end")

  do receiver_drop[U64](rx)
.end

scn test_mpsc_timed_recv
  let tx: Sender[U64]
  let rx: Receiver[U64]
  (tx, rx) = channel_unbounded[U64]()

  # Expect timeout when empty.
  let r = recv_for_ms[U64](rx, 0)
  do assert_true(std.core.result::is_err(r), "timed err")

  do sender_drop[U64](tx)
  do receiver_drop[U64](rx)
.end

# End of std.sync.mpsc
