

# /Users/vincent/Documents/Github/vitte/std/sync/src/event.vitte
# -----------------------------------------------------------------------------
# std/sync/event
# -----------------------------------------------------------------------------
# Event synchronization primitive.
#
# MAX goals:
# - Provide a simple Event that can be waited on by multiple threads.
# - Support manual-reset and auto-reset modes.
# - Support notify (set), reset, and timed waits.
# - Portable: runtime-backed implementation.
#
# Semantics
# - Manual-reset event:
#     * set(): wakes all waiters; remains signaled until reset().
#     * wait(): returns immediately while signaled.
# - Auto-reset event:
#     * set(): wakes one waiter; then automatically resets to non-signaled.
#     * if no waiters, remains signaled and the next waiter consumes it.
#
# Typical usage
# - Worker threads wait for a "start" event, then proceed.
# - Producer sets event when new data is available.
#
# Dependencies
# - std.runtime provides RtEvent and platform bindings.
# - std.time provides Duration/Instant helpers.
# - std.sync.mutex only for tests or higher-level compositions.
#
# Blocks use `.end` only.
# -----------------------------------------------------------------------------

module std.sync.event

use std.runtime
use std.time

# -----------------------------------------------------------------------------
# Types
# -----------------------------------------------------------------------------

type Bool = bool

type U64  = u64

type Str  = str

# Wait result.

struct WaitResult
  ok: Bool
  timed_out: Bool
.end

# Reset mode.

enum ResetMode
  Manual
  Auto
.end

# Opaque runtime handle.

type RtEvent = std.runtime::RtEvent

struct Event
  h: RtEvent
  mode: ResetMode
.end

# -----------------------------------------------------------------------------
# Runtime bindings (expected)
# -----------------------------------------------------------------------------
# If runtime uses different names, adapt wrappers only.

fn rt_event_new_manual(initial_signaled: Bool) -> RtEvent
  ret std.runtime::event_new_manual(initial_signaled)
.end

fn rt_event_new_auto(initial_signaled: Bool) -> RtEvent
  ret std.runtime::event_new_auto(initial_signaled)
.end

fn rt_event_drop(h: RtEvent)
  do std.runtime::event_drop(h)
.end

fn rt_event_set(h: RtEvent)
  do std.runtime::event_set(h)
.end

fn rt_event_reset(h: RtEvent)
  do std.runtime::event_reset(h)
.end

fn rt_event_wait(h: RtEvent) -> Bool
  ret std.runtime::event_wait(h)
.end

fn rt_event_timed_wait_ms(h: RtEvent, timeout_ms: U64) -> Bool
  ret std.runtime::event_timed_wait_ms(h, timeout_ms)
.end

fn rt_event_is_set(h: RtEvent) -> Bool
  ret std.runtime::event_is_set(h)
.end

# -----------------------------------------------------------------------------
# Constructors / lifecycle
# -----------------------------------------------------------------------------

fn new_manual(initial_signaled: Bool) -> Event
  let e: Event
  set e.h = rt_event_new_manual(initial_signaled)
  set e.mode = ResetMode::Manual
  ret e
.end

fn new_auto(initial_signaled: Bool) -> Event
  let e: Event
  set e.h = rt_event_new_auto(initial_signaled)
  set e.mode = ResetMode::Auto
  ret e
.end

fn drop(e: Event)
  do rt_event_drop(e.h)
.end

# -----------------------------------------------------------------------------
# Operations
# -----------------------------------------------------------------------------

fn set(e: Event)
  do rt_event_set(e.h)
.end

fn reset(e: Event)
  do rt_event_reset(e.h)
.end

fn is_set(e: Event) -> Bool
  ret rt_event_is_set(e.h)
.end

fn wait(e: Event) -> WaitResult
  let ok = rt_event_wait(e.h)
  let r: WaitResult
  set r.ok = ok
  set r.timed_out = false
  ret r
.end

fn wait_for_ms(e: Event, timeout_ms: U64) -> WaitResult
  let notified = rt_event_timed_wait_ms(e.h, timeout_ms)
  let r: WaitResult
  set r.ok = notified
  set r.timed_out = !notified
  ret r
.end

fn wait_for(e: Event, dur: std.time::Duration) -> WaitResult
  let ms = std.time::duration_as_millis(dur)
  ret wait_for_ms(e, ms)
.end

fn wait_until(e: Event, deadline: std.time::Instant) -> WaitResult
  let now = std.time::instant_now()
  if std.time::instant_ge(now, deadline)
    let r: WaitResult
    set r.ok = false
    set r.timed_out = true
    ret r
  .end

  let dur = std.time::instant_duration_between(now, deadline)
  ret wait_for(e, dur)
.end

# Convenience: wait until predicate is true, triggered by event (manual usage).
# This can be used to avoid missed signals:
#   while !ready: event.wait();

fn wait_while(e: Event, pred: fn() -> Bool)
  while pred()
    do wait(e)
  .end
.end

fn wait_for_pred(e: Event, dur: std.time::Duration, pred: fn() -> Bool) -> WaitResult
  let deadline = std.time::instant_add(std.time::instant_now(), dur)
  ret wait_until_pred(e, deadline, pred)
.end

fn wait_until_pred(e: Event, deadline: std.time::Instant, pred: fn() -> Bool) -> WaitResult
  while pred()
    let r = wait_until(e, deadline)
    if r.timed_out
      ret r
    .end
  .end

  let okr: WaitResult
  set okr.ok = true
  set okr.timed_out = false
  ret okr
.end

# -----------------------------------------------------------------------------
# Tests (smoke)
# -----------------------------------------------------------------------------

fn assert_true(b: Bool, msg: Str)
  do std.runtime::assert(b, msg)
.end

scn test_event_smoke
  let e1 = new_manual(false)
  do assert_true(!is_set(e1), "manual not set")

  # set should mark signaled
  do set(e1)
  do assert_true(is_set(e1), "manual set")

  # wait should succeed immediately
  let r1 = wait_for_ms(e1, 0)
  do assert_true(r1.ok || r1.timed_out, "manual wait result")

  # reset clears
  do reset(e1)
  do assert_true(!is_set(e1), "manual reset")

  do drop(e1)

  # auto-reset event: set then a 0ms wait should likely consume or timeout depending on impl.
  let e2 = new_auto(false)
  do set(e2)
  let r2 = wait_for_ms(e2, 0)
  do assert_true(r2.ok || r2.timed_out, "auto wait result")
  do drop(e2)
.end

# End of std.sync.event