

# /Users/vincent/Documents/Github/vitte/std/sync/src/candvar.vitte
# -----------------------------------------------------------------------------
# std/sync/candvar (Condition Variable)
# -----------------------------------------------------------------------------
# MAX goals:
# - Provide a high-level Condition Variable API for synchronization.
# - Offer timed waits and broadcast.
# - Provide a portable abstraction over the runtime / platform primitives.
# - Keep the surface consistent with the rest of std/sync (Mutex, LockGuard).
#
# Design
# - A CondVar is used with a Mutex. The typical pattern:
#     lock mutex
#     while !predicate:
#       cond.wait(mutex)
#     unlock
# - wait() atomically unlocks the mutex, waits, then re-locks before returning.
#
# Assumptions about std.runtime / std.sys
# - There exists an opaque handle-based condvar primitive in runtime.
# - Mutex is provided by std.sync.mutex and exposes a native handle.
#
# Blocks use `.end` only.
# -----------------------------------------------------------------------------

module std.sync.candvar

use std.runtime
use std.core.option
use std.time
use std.sync.mutex

# -----------------------------------------------------------------------------
# Types
# -----------------------------------------------------------------------------

type Bool = bool

type U64 = u64

type Str = str

type Option[T] = std.core.option::Option[T]

# Condition variable wait result.
# - ok=true: woke up due to notify_one/notify_all (or spurious wake).
# - ok=false: timed out.

struct WaitResult
  ok: Bool
  timed_out: Bool
.end

# Opaque runtime handle types.
# (Backed by runtime; do not assume layout.)

type RtCondVar = std.runtime::RtCondVar

# Public CondVar wrapper.

struct CondVar
  h: RtCondVar
.end

# -----------------------------------------------------------------------------
# Runtime bindings (expected)
# -----------------------------------------------------------------------------
# The runtime is responsible for mapping these to pthreads/Win32/etc.
# If your runtime uses different names, update these wrappers only.

fn rt_condvar_new() -> RtCondVar
  ret std.runtime::condvar_new()
.end

fn rt_condvar_drop(h: RtCondVar)
  do std.runtime::condvar_drop(h)
.end

fn rt_condvar_notify_one(h: RtCondVar)
  do std.runtime::condvar_notify_one(h)
.end

fn rt_condvar_notify_all(h: RtCondVar)
  do std.runtime::condvar_notify_all(h)
.end

fn rt_condvar_wait(h: RtCondVar, m: std.sync.mutex::RtMutex) -> Bool
  # returns true on success
  ret std.runtime::condvar_wait(h, m)
.end

fn rt_condvar_timed_wait_ms(h: RtCondVar, m: std.sync.mutex::RtMutex, timeout_ms: U64) -> Bool
  # returns true if notified, false on timeout
  ret std.runtime::condvar_timed_wait_ms(h, m, timeout_ms)
.end

# -----------------------------------------------------------------------------
# Constructors / lifecycle
# -----------------------------------------------------------------------------

fn new() -> CondVar
  let cv: CondVar
  set cv.h = rt_condvar_new()
  ret cv
.end

fn drop(cv: CondVar)
  do rt_condvar_drop(cv.h)
.end

# -----------------------------------------------------------------------------
# Notifications
# -----------------------------------------------------------------------------

fn notify_one(cv: CondVar)
  do rt_condvar_notify_one(cv.h)
.end

fn notify_all(cv: CondVar)
  do rt_condvar_notify_all(cv.h)
.end

# -----------------------------------------------------------------------------
# Waiting
# -----------------------------------------------------------------------------

# Wait indefinitely. Requires caller holds the mutex lock.
# Returns WaitResult(ok=true, timed_out=false) when awakened.

fn wait(cv: CondVar, m: std.sync.mutex::Mutex) -> WaitResult
  let ok = rt_condvar_wait(cv.h, std.sync.mutex::native_handle(m))
  let r: WaitResult
  set r.ok = ok
  set r.timed_out = false
  ret r
.end

# Timed wait in milliseconds. Requires caller holds lock.

fn wait_for_ms(cv: CondVar, m: std.sync.mutex::Mutex, timeout_ms: U64) -> WaitResult
  let notified = rt_condvar_timed_wait_ms(cv.h, std.sync.mutex::native_handle(m), timeout_ms)
  let r: WaitResult
  set r.ok = notified
  set r.timed_out = !notified
  ret r
.end

# Timed wait using Duration.

fn wait_for(cv: CondVar, m: std.sync.mutex::Mutex, dur: std.time::Duration) -> WaitResult
  # Convert duration to milliseconds (best-effort).
  let ms = std.time::duration_as_millis(dur)
  ret wait_for_ms(cv, m, ms)
.end

# Wait until a deadline instant.

fn wait_until(cv: CondVar, m: std.sync.mutex::Mutex, deadline: std.time::Instant) -> WaitResult
  let now = std.time::instant_now()
  if std.time::instant_ge(now, deadline)
    let r: WaitResult
    set r.ok = false
    set r.timed_out = true
    ret r
  .end

  let dur = std.time::instant_duration_between(now, deadline)
  ret wait_for(cv, m, dur)
.end

# -----------------------------------------------------------------------------
# Convenience: wait with predicate
# -----------------------------------------------------------------------------

# Pattern:
#   cond.wait_while(mutex, fn() -> bool { !ready })
#
# This loops on the predicate to handle spurious wakeups.

fn wait_while(cv: CondVar, m: std.sync.mutex::Mutex, pred: fn() -> Bool)
  while pred()
    do wait(cv, m)
  .end
.end

fn wait_until_pred(cv: CondVar, m: std.sync.mutex::Mutex, deadline: std.time::Instant, pred: fn() -> Bool) -> WaitResult
  # Loop until predicate false or timeout.
  while pred()
    let r = wait_until(cv, m, deadline)
    if r.timed_out
      ret r
    .end
  .end

  let okr: WaitResult
  set okr.ok = true
  set okr.timed_out = false
  ret okr
.end

fn wait_for_pred(cv: CondVar, m: std.sync.mutex::Mutex, dur: std.time::Duration, pred: fn() -> Bool) -> WaitResult
  let deadline = std.time::instant_add(std.time::instant_now(), dur)
  ret wait_until_pred(cv, m, deadline, pred)
.end

# -----------------------------------------------------------------------------
# Tests (smoke)
# -----------------------------------------------------------------------------

fn assert_true(b: Bool, msg: Str)
  do std.runtime::assert(b, msg)
.end

# NOTE: Full concurrency tests require threads; this is a smoke-level API test.

scn test_condvar_smoke
  let m = std.sync.mutex::new()
  let cv = new()

  # Lock/unlock should be fine.
  do std.sync.mutex::lock(m)
  # Timed wait 0ms should timeout immediately (best effort).
  let r = wait_for_ms(cv, m, 0)
  do std.sync.candvar::notify_one(cv)
  do std.sync.mutex::unlock(m)

  # r might be timeout depending on runtime semantics; accept either but ensure struct ok.
  do assert_true(r.timed_out || r.ok, "condvar wait result valid")

  do drop(cv)
  do std.sync.mutex::drop(m)
.end

# End of std.sync.candvar