# C:\Users\gogin\Documents\GitHub\vitte\std\async\tests\executor_tests.vitte
mod std/async/tests/executor_tests

use std/prelude

use std/testing/test

use std/core/option
use std/core/result

use std/alloc/vec
use std/alloc/box
use std/alloc/string

use std/sync/atomic
use std/sync/mutex

use std/time/duration
use std/time/instant
use std/os/thread

use std/async/future
use std/async/executor/waker
use std/async/executor/local
use std/async/executor/multithread
use std/async/time/sleep

# =============================================================================
# Helpers
# =============================================================================

fn assert_ok_void(r: result::Result[void, string::String], msg: &str) -> void
  if r.is_err()
    test::fail(msg)
  .end
.end

# -----------------------------------------------------------------------------
# A small future that becomes Ready after N polls
# -----------------------------------------------------------------------------

struct PollNTimes
  n: u32
  cur: u32
.end

fn PollNTimes::new(n: u32) -> PollNTimes
  ret PollNTimes
    n: n
    cur: 0
  .end
.end

fn PollNTimes::poll(self: &mut PollNTimes, cx: &waker::Context) -> future::Poll[void]
  if self.cur >= self.n
    ret future::Poll::Ready(())
  .end
  self.cur = self.cur + 1
  cx.waker().wake_by_ref()
  ret future::Poll::Pending
.end

# -----------------------------------------------------------------------------
# A future that yields once, then Ready
# -----------------------------------------------------------------------------

struct YieldOnce
  done: bool
.end

fn YieldOnce::new() -> YieldOnce
  ret YieldOnce
    done: false
  .end
.end

fn YieldOnce::poll(self: &mut YieldOnce, cx: &waker::Context) -> future::Poll[void]
  if self.done
    ret future::Poll::Ready(())
  .end
  self.done = true
  cx.waker().wake_by_ref()
  ret future::Poll::Pending
.end

# -----------------------------------------------------------------------------
# Shared counter future: increments on Ready
# -----------------------------------------------------------------------------

struct IncOnReady
  c: &atomic::U64
  yielded: bool
.end

fn IncOnReady::new(c: &atomic::U64) -> IncOnReady
  ret IncOnReady
    c: c
    yielded: false
  .end
.end

fn IncOnReady::poll(self: &mut IncOnReady, cx: &waker::Context) -> future::Poll[void]
  if !self.yielded
    self.yielded = true
    cx.waker().wake_by_ref()
    ret future::Poll::Pending
  .end
  self.c.fetch_add(1)
  ret future::Poll::Ready(())
.end

# -----------------------------------------------------------------------------
# Local executor: smoke run
# -----------------------------------------------------------------------------

fn t_local_smoke_single_task() -> void
  let mut ex = local::LocalExecutor::new()
  ex.spawn(box::Box::new(PollNTimes::new(3)))
  ex.run()
  test::assert_true(ex.is_idle(), "local executor idle after run")
.end

fn t_local_many_tasks_complete() -> void
  let mut ex = local::LocalExecutor::new()
  let c = atomic::U64::new(0)

  let mut i: usize = 0
  while i < 100
    ex.spawn(box::Box::new(IncOnReady::new(&c)))
    i = i + 1
  .end

  ex.run()
  test::assert_true(c.load() == 100, "all tasks incremented")
.end

fn t_local_cancel_task() -> void
  let mut ex = local::LocalExecutor::new()
  let id = ex.spawn(box::Box::new(PollNTimes::new(1_000_000)))
  let ok = ex.cancel(id)
  test::assert_true(ok, "cancel returns true")
  ex.run_until_idle(10_000)
  test::assert_true(ex.is_idle(), "executor drains after cancel")
.end

fn t_local_fairness_round_robin_basic() -> void
  let mut ex = local::LocalExecutor::new()
  let c = atomic::U64::new(0)

  ex.spawn(box::Box::new(IncOnReady::new(&c)))
  ex.spawn(box::Box::new(IncOnReady::new(&c)))
  ex.spawn(box::Box::new(IncOnReady::new(&c)))

  ex.run()
  test::assert_true(c.load() == 3, "3 tasks done")
.end

# -----------------------------------------------------------------------------
# MultiThread executor tests (best-effort)
# -----------------------------------------------------------------------------

fn t_mt_spawn_and_shutdown() -> void
  let shared = multithread::Shared::new()
  let mut cfg = multithread::MultiThreadConfig::default()
  cfg.threads = 2
  cfg.busy = false
  cfg.max_polls_per_take = 1

  let mut ex = multithread::MultiThreadExecutor::new(&shared, cfg)

  let c = atomic::U64::new(0)

  let mut i: usize = 0
  while i < 200
    let r = ex.spawn(box::Box::new(IncOnReady::new(&c)))
    test::assert_true(r.is_ok(), "spawn ok")
    i = i + 1
  .end

  let drained = multithread::run_until_drained(&mut ex, 10_000)
  test::assert_true(drained, "queue drained")
  test::assert_true(c.load() == 200, "all tasks done")
  ex.shutdown()
.end

fn t_mt_many_yield_once() -> void
  let shared = multithread::Shared::new()
  let mut cfg = multithread::MultiThreadConfig::default()
  cfg.threads = 4
  cfg.busy = false
  cfg.max_polls_per_take = 1

  let mut ex = multithread::MultiThreadExecutor::new(&shared, cfg)

  let mut i: usize = 0
  while i < 500
    let _ = ex.spawn(box::Box::new(YieldOnce::new()))
    i = i + 1
  .end

  let drained = multithread::run_until_drained(&mut ex, 10_000)
  test::assert_true(drained, "queue drained after yield tasks")
  ex.shutdown()
.end

# -----------------------------------------------------------------------------
# Sleep future smoke with local executor (stub polling)
# -----------------------------------------------------------------------------

struct SleepMs
  f: option::Option[sleep::SleepFuture]
.end

fn SleepMs::new(ms: u64) -> SleepMs
  ret SleepMs
    f: option::Some(sleep::sleep_ms(ms).unwrap())
  .end
.end

fn SleepMs::poll(self: &mut SleepMs, cx: &waker::Context) -> future::Poll[void]
  let p = self.f.as_mut().unwrap().poll(cx)
  match p
    future::Poll::Pending =>
      ret future::Poll::Pending
    future::Poll::Ready(res) =>
      if res.is_err()
        ret future::Poll::Ready(())
      .end
      ret future::Poll::Ready(())
  .end
.end

fn t_local_sleep_smoke() -> void
  let mut ex = local::LocalExecutor::new()
  ex.spawn(box::Box::new(SleepMs::new(5)))
  ex.run()
  test::assert_true(ex.is_idle(), "sleep task completed")
.end

# -----------------------------------------------------------------------------
# Runner
# -----------------------------------------------------------------------------

fn run_all() -> void
  test::case("local_smoke_single_task", t_local_smoke_single_task)
  test::case("local_many_tasks_complete", t_local_many_tasks_complete)
  test::case("local_cancel_task", t_local_cancel_task)
  test::case("local_fairness_round_robin_basic", t_local_fairness_round_robin_basic)

  test::case("mt_spawn_and_shutdown", t_mt_spawn_and_shutdown)
  test::case("mt_many_yield_once", t_mt_many_yield_once)

  test::case("local_sleep_smoke", t_local_sleep_smoke)
.end

fn main() -> i32
  test::run("std::async::executor_tests", run_all)
  ret 0
.end
