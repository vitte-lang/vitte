

# std/async/src/main.vitte
#
# Async module entrypoint / demo runner.
#
# This file is intentionally "max" and bootstrap-friendly:
# - Exercises the public API surface of std/async.
# - Provides a stable program entry that can be used by CI / smoke runs.
# - Avoids relying on a concrete runtime; functions are stubs until the runtime
#   backend wires wakers, timers, queues, and allocation.

export all

# Import the library surface.
# (Path form is project-dependent; keep this consistent with your module loader.)
use std/async

# -----------------------------------------------------------------------------
# Local helpers
# -----------------------------------------------------------------------------

type U64 = u64

type DemoReport = struct
  ran_ready: bool
  ran_sleep: bool
  ran_channel: bool
  ran_select: bool
  value_ready: U64
  value_sleep: U64
.end

fn demo_report_new() -> DemoReport
  let r = DemoReport
    ran_ready: false
    ran_sleep: false
    ran_channel: false
    ran_select: false
    value_ready: 0
    value_sleep: 0
  .end
  ret r
.end

fn demo_print_report(r: DemoReport) -> void
  # Prefer stable, deterministic output.
  say "[std/async] demo report"
  say "  ready:   "
  say r.ran_ready
  say "  sleep:   "
  say r.ran_sleep
  say "  channel: "
  say r.ran_channel
  say "  select:  "
  say r.ran_select
  say "  value_ready: "
  say r.value_ready
  say "  value_sleep: "
  say r.value_sleep
.end

# -----------------------------------------------------------------------------
# Demo steps (wired to lib surface)
# -----------------------------------------------------------------------------

fn demo_step_ready(mut rep: DemoReport) -> DemoReport
  # ready_future_new() is currently a stub that returns a null Future.
  # Once wired, block_on should return 123.
  let f = ready_future_new(123)
  let v = block_on(f)
  rep.ran_ready = true
  rep.value_ready = v
  ret rep
.end

fn demo_step_sleep(mut rep: DemoReport) -> DemoReport
  let f = sleep_ms(10)
  let v = block_on(f)
  rep.ran_sleep = true
  rep.value_sleep = v
  ret rep
.end

fn demo_step_channel(mut rep: DemoReport) -> DemoReport
  let (tx, rx) = channel[U64](8)

  # In stub, send returns Err(Closed); recv returns Err(Empty).
  let s = sender_send[U64](tx, 7)
  let r = receiver_try_recv[U64](rx)
  (void)s
  (void)r

  rep.ran_channel = true
  ret rep
.end

fn demo_step_select(mut rep: DemoReport) -> DemoReport
  let a = yield_now()
  let b = sleep_ms(1)
  let f = select2(a, b)
  let v = block_on(f)
  (void)v

  rep.ran_select = true
  ret rep
.end

# -----------------------------------------------------------------------------
# Program entry
# -----------------------------------------------------------------------------

program std/async/main
  say "[std/async] demo start"

  let mut rep = demo_report_new()
  rep = demo_step_ready(rep)
  rep = demo_step_sleep(rep)
  rep = demo_step_channel(rep)
  rep = demo_step_select(rep)

  demo_print_report(rep)

  say "[std/async] demo end"
.end

# -----------------------------------------------------------------------------
# Additional scenarios (kept as smoke hooks)
# -----------------------------------------------------------------------------

scn t_async_main_smoke
  # Ensure the module loads and basic calls are available.
  let f0 = yield_now()
  let v0 = block_on(f0)
  (void)v0

  let f1 = sleep_ms(0)
  let v1 = block_on(f1)
  (void)v1
.end
