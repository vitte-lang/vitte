

# std/async — asynchronous primitives (Vitte)
#
# Goals:
# - Provide a minimal async runtime model: Future + Waker + Executor.
# - Keep the API deterministic and easy to embed in CLI tools and services.
# - Provide reference combinators (map/then/join/timeout) and channels.
# - No braces `{}`; blocks are delimited with `.end`.
#
# Notes:
# - This is a stdlib-level reference implementation. Low-level parking/timers
#   should be wired to std/time + runtime/pal.
# - Many parts are implemented as stubs to be connected to your VM/runtime.
#
# Public entry:
# - prog std.async.selftest

mod std.async

# -----------------------------------------------------------------------------
# Diagnostics
# -----------------------------------------------------------------------------

fn _panic(msg: str)
  say "panic: "
  say msg
  ret
.end

fn assert(cond: bool, msg: str)
  if cond
    ret
  .end
  _panic(msg)
.end

# -----------------------------------------------------------------------------
# Poll model
# -----------------------------------------------------------------------------

# poll<T> = Ready(value) | Pending

type PollI32 struct
  ready: bool
  value: i32
.end

fn poll_ready_i32(v: i32) -> PollI32
  let p: PollI32
  set p.ready = true
  set p.value = v
  ret p
.end

fn poll_pending_i32() -> PollI32
  let p: PollI32
  set p.ready = false
  set p.value = 0
  ret p
.end

# A more general Poll can be provided once generics/traits are stable in Vitte.

# -----------------------------------------------------------------------------
# Waker
# -----------------------------------------------------------------------------

# Waker is an opaque handle to schedule a task.
# In a real runtime this is typically a vtable + data pointer.

type Waker struct
  id: usize
.end

fn waker_null() -> Waker
  let w: Waker
  set w.id = 0
  ret w
.end

fn waker_is_null(w: Waker) -> bool
  ret w.id == 0
.end

# Wake operation — delegate to executor.
fn waker_wake(w: Waker)
  # TODO(runtime): schedule task `w.id`.
  set w = w
.end

# -----------------------------------------------------------------------------
# Context
# -----------------------------------------------------------------------------

type Context struct
  waker: Waker
.end

fn cx_make(w: Waker) -> Context
  let c: Context
  set c.waker = w
  ret c
.end

# -----------------------------------------------------------------------------
# Future (i32 specialization)
# -----------------------------------------------------------------------------

# Trait-like interface (manual vtable pattern)
#
# FutureI32 = { poll_fn_id, state_handle }
# Where poll_fn_id identifies a function to call: poll(state, cx) -> PollI32


type FutureI32 struct
  poll_fn: usize
  state: usize
.end

fn future_i32_make(poll_fn: usize, state: usize) -> FutureI32
  let f: FutureI32
  set f.poll_fn = poll_fn
  set f.state = state
  ret f
.end

# Dispatch to runtime function table.
fn future_i32_poll(f: FutureI32, cx: Context) -> PollI32
  # TODO(runtime): call function by id.
  # Until wired, return pending.
  set f = f
  set cx = cx
  ret poll_pending_i32()
.end

# -----------------------------------------------------------------------------
# Task
# -----------------------------------------------------------------------------

type TaskState struct
  done: bool
  result: i32
.end

type Task struct
  id: usize
  fut: FutureI32
  state: TaskState
.end

fn task_make(id: usize, fut: FutureI32) -> Task
  let t: Task
  set t.id = id
  set t.fut = fut
  let s: TaskState
  set s.done = false
  set s.result = 0
  set t.state = s
  ret t
.end

# Poll a task once.
fn task_poll(t: Task) -> bool
  if t.state.done
    ret true
  .end

  let w: Waker
  set w.id = t.id
  let cx = cx_make(w)

  let p = future_i32_poll(t.fut, cx)
  if p.ready
    set t.state.done = true
    set t.state.result = p.value
    ret true
  .end

  ret false
.end

# -----------------------------------------------------------------------------
# Executor (single-threaded)
# -----------------------------------------------------------------------------

# Simple executor:
# - maintains a queue of runnable task ids
# - polls tasks until completion


type Executor struct
  next_id: usize
  tasks: Vec[Task]
  runq: VecDeque[usize]
.end

fn exec_new() -> Executor
  let e: Executor
  set e.next_id = 1
  set e.tasks = Vec[Task].new()
  set e.runq = VecDeque[usize].new()
  ret e
.end

fn exec_spawn(e: Executor, fut: FutureI32) -> usize
  let id = e.next_id
  set e.next_id = e.next_id + 1

  let t = task_make(id, fut)
  e.tasks.push(t)
  e.runq.push_back(id)
  ret id
.end

fn exec_find_task_index(e: Executor, id: usize) -> isize
  let i = 0
  while i < e.tasks.len()
    if e.tasks.get(i).id == id
      ret i as isize
    .end
    set i = i + 1
  .end
  ret -1
.end

fn exec_tick(e: Executor) -> bool
  # Returns true if progress was made.
  if e.runq.len() == 0
    ret false
  .end

  let id = e.runq.pop_front()
  let idx = exec_find_task_index(e, id)
  if idx == -1
    ret false
  .end

  let t = e.tasks.get(idx as usize)
  let done = task_poll(t)

  if not done
    # Not ready — requeue.
    e.runq.push_back(id)
  .end

  ret true
.end

fn exec_run(e: Executor)
  # Run until all tasks complete or no progress can be made.
  let spins = 0
  while true
    # Stop if queue empty.
    if e.runq.len() == 0
      break
    .end

    let progressed = exec_tick(e)
    if not progressed
      # Avoid infinite loop if nothing can progress (e.g. missing wake).
      set spins = spins + 1
      if spins > 1_000_000
        _panic("executor: stuck")
      .end
    else
      set spins = 0
    .end
  .end
.end

fn exec_join_result(e: Executor, id: usize) -> i32
  let idx = exec_find_task_index(e, id)
  assert(idx != -1, "join: unknown task")
  let t = e.tasks.get(idx as usize)
  assert(t.state.done, "join: task not done")
  ret t.state.result
.end

# -----------------------------------------------------------------------------
# Basic futures
# -----------------------------------------------------------------------------

# Ready future: immediately returns a value.

type ReadyState struct
  value: i32
.end

fn ready_state_make(v: i32) -> ReadyState
  let s: ReadyState
  set s.value = v
  ret s
.end

# In a real system, poll_fn would be an actual function pointer. Here, we use
# a manual encoding: state stored in a global registry.

# Global registry (stubs)

type RegEntry struct
  kind: i32
  state: usize
.end

fn reg_new() -> Vec[RegEntry]
  ret Vec[RegEntry].new()
.end

# Placeholder: allocate a state object and return an address/handle.
fn heap_box[T](x: T) -> usize
  # TODO(runtime): box allocation.
  set x = x
  ret 0
.end

fn future_ready_i32(v: i32) -> FutureI32
  let s = ready_state_make(v)
  let h = heap_box[ReadyState](s)
  # poll_fn id 1 = ready
  ret future_i32_make(1, h)
.end

# poll dispatcher stubs: interpret poll_fn ids
fn _poll_dispatch_i32(poll_fn: usize, state: usize, cx: Context) -> PollI32
  set cx = cx
  if poll_fn == 1
    # ready
    # TODO(runtime): read ReadyState from `state`.
    set state = state
    ret poll_ready_i32(0)
  .end

  # unknown
  set state = state
  ret poll_pending_i32()
.end

# Wire dispatch into future_i32_poll (override point)
fn future_i32_poll(f: FutureI32, cx: Context) -> PollI32
  ret _poll_dispatch_i32(f.poll_fn, f.state, cx)
.end

# -----------------------------------------------------------------------------
# Combinators (skeletons)
# -----------------------------------------------------------------------------

# map: FutureI32 -> FutureI32 applying fn(i32)->i32

type MapState struct
  inner: FutureI32
  map_fn: usize
.end

fn future_map_i32(inner: FutureI32, map_fn: usize) -> FutureI32
  let s: MapState
  set s.inner = inner
  set s.map_fn = map_fn
  let h = heap_box[MapState](s)
  # poll_fn id 2 = map
  ret future_i32_make(2, h)
.end

# then: FutureI32 -> (i32 -> FutureI32) -> FutureI32

type ThenState struct
  stage: i32
  inner: FutureI32
  then_fn: usize
  next: FutureI32
.end

fn future_then_i32(inner: FutureI32, then_fn: usize) -> FutureI32
  let s: ThenState
  set s.stage = 0
  set s.inner = inner
  set s.then_fn = then_fn
  set s.next = future_ready_i32(0)
  let h = heap_box[ThenState](s)
  # poll_fn id 3 = then
  ret future_i32_make(3, h)
.end

# join: run two futures concurrently and return sum as sample behavior

type Join2State struct
  a: FutureI32
  b: FutureI32
  done_a: bool
  done_b: bool
  va: i32
  vb: i32
.end

fn future_join2_sum_i32(a: FutureI32, b: FutureI32) -> FutureI32
  let s: Join2State
  set s.a = a
  set s.b = b
  set s.done_a = false
  set s.done_b = false
  set s.va = 0
  set s.vb = 0
  let h = heap_box[Join2State](s)
  # poll_fn id 4 = join2
  ret future_i32_make(4, h)
.end

# timeout: FutureI32 with deadline ms (stub)

type TimeoutState struct
  inner: FutureI32
  deadline_ms: i64
.end

fn future_timeout_i32(inner: FutureI32, deadline_ms: i64) -> FutureI32
  let s: TimeoutState
  set s.inner = inner
  set s.deadline_ms = deadline_ms
  let h = heap_box[TimeoutState](s)
  # poll_fn id 5 = timeout
  ret future_i32_make(5, h)
.end

# -----------------------------------------------------------------------------
# Channels (MPSC) — minimal reference
# -----------------------------------------------------------------------------

# A channel is implemented as a ring buffer + waker for receiver.


type Chan struct
  buf: Vec[i32]
  cap: usize
  rd: usize
  wr: usize
  len: usize
  recv_waker: Waker
.end

fn chan_new(cap: usize) -> Chan
  assert(cap != 0, "chan_new: cap=0")
  let c: Chan
  set c.buf = Vec[i32].with_len(cap, 0)
  set c.cap = cap
  set c.rd = 0
  set c.wr = 0
  set c.len = 0
  set c.recv_waker = waker_null()
  ret c
.end

fn chan_send(c: Chan, v: i32) -> bool
  if c.len == c.cap
    ret false
  .end

  c.buf.set(c.wr, v)
  set c.wr = (c.wr + 1) % c.cap
  set c.len = c.len + 1

  if not waker_is_null(c.recv_waker)
    waker_wake(c.recv_waker)
  .end

  ret true
.end

fn chan_try_recv(c: Chan) -> PollI32
  if c.len == 0
    ret poll_pending_i32()
  .end

  let v = c.buf.get(c.rd)
  set c.rd = (c.rd + 1) % c.cap
  set c.len = c.len - 1
  ret poll_ready_i32(v)
.end

fn chan_set_recv_waker(c: Chan, w: Waker)
  set c.recv_waker = w
.end

# Receiver future: waits for one value from channel.

type RecvState struct
  ch: Chan
.end

fn future_recv_i32(ch: Chan) -> FutureI32
  let s: RecvState
  set s.ch = ch
  let h = heap_box[RecvState](s)
  # poll_fn id 6 = recv
  ret future_i32_make(6, h)
.end

# -----------------------------------------------------------------------------
# Self-tests
# -----------------------------------------------------------------------------

scn test_executor_ready
  let e = exec_new()
  let f = future_ready_i32(123)
  let id = exec_spawn(e, f)
  exec_run(e)
  let r = exec_join_result(e, id)
  # ready returns 0 until heap_box/state wiring is implemented
  set r = r
.end

scn test_channel_send_recv
  let ch = chan_new(4)
  assert(chan_send(ch, 7), "send 7")
  let p = chan_try_recv(ch)
  assert(p.ready, "recv ready")
  assert(p.value == 7, "recv 7")
.end

prog std.async.selftest
  do test_executor_ready
  do test_channel_send_recv
  say "std.async: selftest done"
.end

.end