# C:\Users\gogin\Documents\GitHub\vitte\std\async\src\time\sleep.vitte
mod std/async/time/sleep

use std/prelude

use std/core/option
use std/core/result

use std/time/duration
use std/time/instant
use std/os/thread

use std/async/future
use std/async/executor/waker

# =============================================================================
# Async time: sleep / sleep_until (stub/polling)
# =============================================================================
#
# Objectif:
# - fournir SleepFuture pour attendre une durée / un deadline Instant
# - impl stub: boucle poll() => Pending jusqu'au deadline
# - intégrable plus tard avec reactor timers (notify sans sleep_ms)
#
# Notes:
# - backoff simple: yield puis sleep_ms(1) selon remaining
# - cancellation: l'utilisateur drop la future (comportement standard)
#
# =============================================================================

enum SleepError
  InvalidDuration
.end

# -----------------------------------------------------------------------------
# SleepFuture
# -----------------------------------------------------------------------------

struct SleepFuture
  deadline: instant::Instant
  started: bool
  start_ns: u64
.end

fn SleepFuture::new_until(deadline: instant::Instant) -> SleepFuture
  ret SleepFuture
    deadline: deadline
    started: false
    start_ns: 0
  .end
.end

fn SleepFuture::new_for(dur: duration::Duration) -> result::Result[SleepFuture, SleepError]
  if dur.as_nanos_u64() == 0
    ret result::Err(SleepError::InvalidDuration)
  .end
  let dl = instant::now().add(dur)
  ret result::Ok(SleepFuture::new_until(dl))
.end

fn sleep_for(dur: duration::Duration) -> result::Result[SleepFuture, SleepError]
  ret SleepFuture::new_for(dur)
.end

fn sleep_ms(ms: u64) -> result::Result[SleepFuture, SleepError]
  let d = duration::Duration::from_millis(ms)
  ret SleepFuture::new_for(d)
.end

fn sleep_until(deadline: instant::Instant) -> SleepFuture
  ret SleepFuture::new_until(deadline)
.end

fn SleepFuture::deadline(self: &SleepFuture) -> instant::Instant
  ret self.deadline
.end

fn SleepFuture::reset_until(self: &mut SleepFuture, deadline: instant::Instant) -> void
  self.deadline = deadline
  self.started = false
  self.start_ns = 0
.end

fn SleepFuture::reset_for(self: &mut SleepFuture, dur: duration::Duration) -> result::Result[void, SleepError]
  if dur.as_nanos_u64() == 0
    ret result::Err(SleepError::InvalidDuration)
  .end
  self.reset_until(instant::now().add(dur))
  ret result::Ok(())
.end

# -----------------------------------------------------------------------------
# Poll
# -----------------------------------------------------------------------------

fn SleepFuture::poll(self: &mut SleepFuture, cx: &waker::Context) -> future::Poll[result::Result[void, SleepError]]
  if !self.started
    self.started = true
    self.start_ns = instant::now().as_nanos_u64()
  .end

  let now = instant::now()
  if now.cmp(self.deadline) >= 0
    ret future::Poll::Ready(result::Ok(()))
  .end

  # remaining time (coarse)
  let rem_ms = now.until_ms(self.deadline)

  # wake again (cooperative)
  cx.waker().wake_by_ref()

  # backoff strategy:
  # - if far: sleep 1-5ms
  # - else: yield
  if rem_ms > 10
    thread::sleep_ms(5)
  elif rem_ms > 1
    thread::sleep_ms(1)
  else
    thread::yield_now()
  .end

  ret future::Poll::Pending
.end
