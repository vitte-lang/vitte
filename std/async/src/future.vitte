# C:\Users\gogin\Documents\GitHub\vitte\std\async\src\future.vitte
mod std/async/future

use std/prelude

use std/core/option
use std/core/result

use std/alloc/box
use std/alloc/vec

use std/async/executor/waker

# =============================================================================
# Future / Poll (core async primitives)
# =============================================================================
#
# Objectif:
# - définir Poll[T] et trait Future[T]
# - fournir utilitaires: ready, pending, poll_fn
# - fournir futures de base: Ready, PendingOnce, YieldNow
# - fournir combinators simples: Map, Then, Inspect, Join2 (void)
#
# Notes:
# - Surface volontairement minimale, portable, sans allocation obligatoire.
# - Les executors (local / multithread) utilisent Future[void] boxed.
# - Pour retourner un résultat: Future[T] avec Poll[T].
#
# =============================================================================

# -----------------------------------------------------------------------------
# Poll
# -----------------------------------------------------------------------------

enum Poll[T]
  Ready(value: T)
  Pending
.end

fn Poll::is_ready(self: &Poll[T]) -> bool
  match self
    Poll::Ready(_) => ret true
    Poll::Pending  => ret false
  .end
.end

fn Poll::is_pending(self: &Poll[T]) -> bool
  ret !self.is_ready()
.end

# -----------------------------------------------------------------------------
# Future trait
# -----------------------------------------------------------------------------

trait Future[T]
  fn poll(self: &mut Self, cx: &waker::Context) -> Poll[T]
.end

# -----------------------------------------------------------------------------
# Helpers
# -----------------------------------------------------------------------------

fn ready[T](v: T) -> Poll[T]
  ret Poll::Ready(v)
.end

fn pending[T]() -> Poll[T]
  ret Poll::Pending
.end

# poll_fn: créer une future depuis une closure poll(cx)->Poll[T]
# (représentation minimale: wrapper autour d'une fn)
struct PollFn[T]
  f: fn(&waker::Context) -> Poll[T]
.end

fn poll_fn[T](f: fn(&waker::Context) -> Poll[T]) -> PollFn[T]
  ret PollFn[T]
    f: f
  .end
.end

fn PollFn::poll(self: &mut PollFn[T], cx: &waker::Context) -> Poll[T]
  ret self.f(cx)
.end

# -----------------------------------------------------------------------------
# Ready / PendingOnce
# -----------------------------------------------------------------------------

struct Ready[T]
  v: option::Option[T]
.end

fn Ready::new[T](v: T) -> Ready[T]
  ret Ready[T]
    v: option::Some(v)
  .end
.end

fn Ready::poll(self: &mut Ready[T], _cx: &waker::Context) -> Poll[T]
  # first poll returns value, then stays ready? (here: value moved once)
  if self.v.is_some()
    ret Poll::Ready(self.v.take().unwrap())
  .end
  # after completion, keep returning Pending (contract: shouldn't be polled again)
  ret Poll::Pending
.end

struct PendingOnce[T]
  fired: bool
  v: T
.end

fn PendingOnce::new(v: T) -> PendingOnce[T]
  ret PendingOnce[T]
    fired: false
    v: v
  .end
.end

fn PendingOnce::poll(self: &mut PendingOnce[T], cx: &waker::Context) -> Poll[T]
  if !self.fired
    self.fired = true
    cx.waker().wake_by_ref()
    ret Poll::Pending
  .end
  ret Poll::Ready(self.v)
.end

# -----------------------------------------------------------------------------
# YieldNow (generic: returns void)
# -----------------------------------------------------------------------------

struct YieldNow
  done: bool
.end

fn yield_now() -> YieldNow
  ret YieldNow
    done: false
  .end
.end

fn YieldNow::poll(self: &mut YieldNow, cx: &waker::Context) -> Poll[void]
  if self.done
    ret Poll::Ready(())
  .end
  self.done = true
  cx.waker().wake_by_ref()
  ret Poll::Pending
.end

# -----------------------------------------------------------------------------
# Combinators
# -----------------------------------------------------------------------------

struct Map[A, B, F, Fut: Future[A]]
  fut: Fut
  f: F
.end

fn map[A, B, F, Fut: Future[A]](fut: Fut, f: F) -> Map[A, B, F, Fut]
  ret Map[A, B, F, Fut]
    fut: fut
    f: f
  .end
.end

fn Map::poll(self: &mut Map[A, B, F, Fut], cx: &waker::Context) -> Poll[B]
  let p = self.fut.poll(cx)
  match p
    Poll::Pending =>
      ret Poll::Pending
    Poll::Ready(v) =>
      ret Poll::Ready(self.f(v))
  .end
.end

struct Then[A, B, F, Fut: Future[A], Fut2: Future[B]]
  fut: Fut
  f: F
  next: option::Option[Fut2]
.end

fn then[A, B, F, Fut: Future[A], Fut2: Future[B]](fut: Fut, f: F) -> Then[A, B, F, Fut, Fut2]
  ret Then[A, B, F, Fut, Fut2]
    fut: fut
    f: f
    next: option::None
  .end
.end

fn Then::poll(self: &mut Then[A, B, F, Fut, Fut2], cx: &waker::Context) -> Poll[B]
  if self.next.is_none()
    let p = self.fut.poll(cx)
    match p
      Poll::Pending =>
        ret Poll::Pending
      Poll::Ready(v) =>
        self.next = option::Some(self.f(v))
    .end
  .end

  let p2 = self.next.as_mut().unwrap().poll(cx)
  ret p2
.end

struct Inspect[T, F, Fut: Future[T]]
  fut: Fut
  f: F
.end

fn inspect[T, F, Fut: Future[T]](fut: Fut, f: F) -> Inspect[T, F, Fut]
  ret Inspect[T, F, Fut]
    fut: fut
    f: f
  .end
.end

fn Inspect::poll(self: &mut Inspect[T, F, Fut], cx: &waker::Context) -> Poll[T]
  let p = self.fut.poll(cx)
  match p
    Poll::Pending =>
      ret Poll::Pending
    Poll::Ready(v) =>
      self.f(v)
      ret Poll::Ready(v)
  .end
.end

# -----------------------------------------------------------------------------
# join2 for void futures (minimal)
# -----------------------------------------------------------------------------

struct Join2
  a: box::Box[Future[void]]
  b: box::Box[Future[void]]
  a_done: bool
  b_done: bool
.end

fn join2(a: box::Box[Future[void]], b: box::Box[Future[void]]) -> Join2
  ret Join2
    a: a
    b: b
    a_done: false
    b_done: false
  .end
.end

fn Join2::poll(self: &mut Join2, cx: &waker::Context) -> Poll[void]
  if !self.a_done
    match self.a.poll(cx)
      Poll::Ready(_) => self.a_done = true
      Poll::Pending  => do 0
    .end
  .end

  if !self.b_done
    match self.b.poll(cx)
      Poll::Ready(_) => self.b_done = true
      Poll::Pending  => do 0
    .end
  .end

  if self.a_done && self.b_done
    ret Poll::Ready(())
  .end

  cx.waker().wake_by_ref()
  ret Poll::Pending
.end

# -----------------------------------------------------------------------------
# boxed helper
# -----------------------------------------------------------------------------

fn boxed_void[Fut: Future[void]](f: Fut) -> box::Box[Future[void]]
  ret box::Box::new(f)
.end
