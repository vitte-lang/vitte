# C:\Users\gogin\Documents\GitHub\vitte\std\async\src\task.vitte
mod std/async/task

use std/prelude

use std/core/option
use std/core/result

use std/alloc/vec
use std/alloc/box
use std/alloc/string

use std/sync/atomic
use std/sync/mutex

use std/time/instant
use std/os/thread

use std/async/future
use std/async/executor/waker

# =============================================================================
# Task primitives (executor-facing)
# =============================================================================
#
# Objectif:
# - définir TaskId, TaskState, Task (boxed future)
# - fournir CancellationToken
# - fournir JoinHandle (oneshot simplifié) pour Future[void] ou Future[T]
#
# Notes:
# - API "max" mais reste portable: Mutex + atomics.
# - Le join "générique T" nécessite stockage du résultat; on propose:
#   - JoinState[T] avec Option[T] + done flag
#   - JoinHandle[T] qui expose une Future[T]
#
# =============================================================================

type TaskId = u64

# -----------------------------------------------------------------------------
# Errors
# -----------------------------------------------------------------------------

enum JoinError
  Cancelled
  Panicked
  RuntimeShutdown
.end

enum SpawnError
  Shutdown
.end

# -----------------------------------------------------------------------------
# Cancellation token
# -----------------------------------------------------------------------------

struct CancellationToken
  cancelled: atomic::Bool
.end

fn CancellationToken::new() -> CancellationToken
  ret CancellationToken
    cancelled: atomic::Bool::new(false)
  .end
.end

fn CancellationToken::cancel(self: &CancellationToken) -> void
  self.cancelled.store(true)
.end

fn CancellationToken::is_cancelled(self: &CancellationToken) -> bool
  ret self.cancelled.load()
.end

# -----------------------------------------------------------------------------
# Task state
# -----------------------------------------------------------------------------

enum TaskState
  Ready
  Waiting
  Completed
  Cancelled
.end

# -----------------------------------------------------------------------------
# TaskHeader (shared metadata)
# -----------------------------------------------------------------------------

struct TaskHeader
  id: TaskId
  state: atomic::U32        # encodes TaskState
  wake: waker::WakeFlag
  polls: atomic::U64
  created_ns: u64
  last_poll_ns: atomic::U64
.end

fn state_to_u32(s: TaskState) -> u32
  match s
    TaskState::Ready => ret 0
    TaskState::Waiting => ret 1
    TaskState::Completed => ret 2
    TaskState::Cancelled => ret 3
  .end
.end

fn u32_to_state(v: u32) -> TaskState
  if v == 0
    ret TaskState::Ready
  elif v == 1
    ret TaskState::Waiting
  elif v == 2
    ret TaskState::Completed
  else
    ret TaskState::Cancelled
  .end
.end

fn TaskHeader::new(id: TaskId) -> TaskHeader
  let now = instant::now().as_nanos_u64()
  let wf = waker::WakeFlag::new()
  wf.signal()
  ret TaskHeader
    id: id
    state: atomic::U32::new(state_to_u32(TaskState::Ready))
    wake: wf
    polls: atomic::U64::new(0)
    created_ns: now
    last_poll_ns: atomic::U64::new(0)
  .end
.end

fn TaskHeader::id(self: &TaskHeader) -> TaskId
  ret self.id
.end

fn TaskHeader::state(self: &TaskHeader) -> TaskState
  ret u32_to_state(self.state.load())
.end

fn TaskHeader::set_state(self: &TaskHeader, s: TaskState) -> void
  self.state.store(state_to_u32(s))
.end

fn TaskHeader::wake(self: &TaskHeader) -> void
  self.wake.signal()
.end

fn TaskHeader::take_wake(self: &TaskHeader) -> bool
  ret self.wake.take()
.end

# -----------------------------------------------------------------------------
# Task (void)
# -----------------------------------------------------------------------------

struct Task
  header: TaskHeader
  fut: box::Box[future::Future[void]]
  cancel: option::Option[CancellationToken]
.end

fn Task::new(id: TaskId, fut: box::Box[future::Future[void]]) -> Task
  ret Task
    header: TaskHeader::new(id)
    fut: fut
    cancel: option::None
  .end
.end

fn Task::with_cancel(id: TaskId, fut: box::Box[future::Future[void]], tok: CancellationToken) -> Task
  ret Task
    header: TaskHeader::new(id)
    fut: fut
    cancel: option::Some(tok)
  .end
.end

fn Task::id(self: &Task) -> TaskId
  ret self.header.id()
.end

fn Task::state(self: &Task) -> TaskState
  ret self.header.state()
.end

fn Task::cancel(self: &mut Task) -> void
  self.header.set_state(TaskState::Cancelled)
  self.header.wake()
.end

fn Task::poll(self: &mut Task, cx: &waker::Context) -> future::Poll[void]
  let st = self.header.state()
  if st == TaskState::Completed || st == TaskState::Cancelled
    ret future::Poll::Ready(())
  .end

  if self.cancel.is_some() && self.cancel.as_ref().unwrap().is_cancelled()
    self.header.set_state(TaskState::Cancelled)
    ret future::Poll::Ready(())
  .end

  self.header.polls.fetch_add(1)
  self.header.last_poll_ns.store(instant::now().as_nanos_u64())

  let p = self.fut.poll(cx)
  match p
    future::Poll::Ready(_) =>
      self.header.set_state(TaskState::Completed)
      ret future::Poll::Ready(())
    future::Poll::Pending =>
      self.header.set_state(TaskState::Waiting)
      ret future::Poll::Pending
  .end
.end

# -----------------------------------------------------------------------------
# Join state (generic)
# -----------------------------------------------------------------------------
# JoinState[T] stores:
# - done flag
# - result Option[T]
# - error Option[JoinError]
# Protected by Mutex (portable).

struct JoinState[T]
  done: bool
  val: option::Option[T]
  err: option::Option[JoinError]
  wake: waker::WakeFlag
.end

fn JoinState::new[T]() -> JoinState[T]
  ret JoinState[T]
    done: false
    val: option::None
    err: option::None
    wake: waker::WakeFlag::new()
  .end
.end

fn JoinState::set_ok[T](self: &mut JoinState[T], v: T) -> void
  self.done = true
  self.val = option::Some(v)
  self.wake.signal()
.end

fn JoinState::set_err[T](self: &mut JoinState[T], e: JoinError) -> void
  self.done = true
  self.err = option::Some(e)
  self.wake.signal()
.end

# -----------------------------------------------------------------------------
# JoinHandle[T] as a Future<Result[T, JoinError]>
# -----------------------------------------------------------------------------

struct JoinHandle[T]
  st: &mutex::Mutex[JoinState[T]]
.end

fn JoinHandle::new[T](st: &mutex::Mutex[JoinState[T]]) -> JoinHandle[T]
  ret JoinHandle[T]
    st: st
  .end
.end

fn JoinHandle::poll(self: &mut JoinHandle[T], cx: &waker::Context) -> future::Poll[result::Result[T, JoinError]]
  let mut g = self.st.lock()
  if g.done
    if g.err.is_some()
      let e = g.err.take().unwrap()
      g.unlock()
      ret future::Poll::Ready(result::Err(e))
    .end
    let v = g.val.take().unwrap()
    g.unlock()
    ret future::Poll::Ready(result::Ok(v))
  .end

  # not done: register wake (best-effort) and pend
  cx.waker().wake_by_ref()
  g.unlock()
  ret future::Poll::Pending
.end

# -----------------------------------------------------------------------------
# Spawn helper: wrap Future[T] into Task + JoinHandle[T]
# -----------------------------------------------------------------------------

struct JoinTask[T, Fut: future::Future[T]]
  fut: Fut
  st: &mutex::Mutex[JoinState[T]]
.end

fn JoinTask::new[T, Fut: future::Future[T]](fut: Fut, st: &mutex::Mutex[JoinState[T]]) -> JoinTask[T, Fut]
  ret JoinTask[T, Fut]
    fut: fut
    st: st
  .end
.end

fn JoinTask::poll(self: &mut JoinTask[T, Fut], cx: &waker::Context) -> future::Poll[void]
  let p = self.fut.poll(cx)
  match p
    future::Poll::Pending =>
      ret future::Poll::Pending
    future::Poll::Ready(v) =>
      let mut g = self.st.lock()
      g.set_ok(v)
      g.unlock()
      ret future::Poll::Ready(())
  .end
.end

# -----------------------------------------------------------------------------
# Utility: make_join_pair (allocates join state somewhere stable)
# -----------------------------------------------------------------------------
# Ici, on fournit une version "pointer-based" minimaliste.
# Si tu as Arc, remplace "&Mutex" par Arc[Mutex].

struct JoinPair[T, Fut: future::Future[T]]
  task: box::Box[future::Future[void]]
  handle: JoinHandle[T]
.end

fn make_join_pair[T, Fut: future::Future[T]](fut: Fut, st: &mutex::Mutex[JoinState[T]]) -> JoinPair[T, Fut]
  let jt = JoinTask::new[T, Fut](fut, st)
  ret JoinPair[T, Fut]
    task: box::Box::new(jt)
    handle: JoinHandle::new[T](st)
  .end
.end

# -----------------------------------------------------------------------------
# TaskSet (simple container)
# -----------------------------------------------------------------------------

struct TaskSet
  tasks: vec::Vec[Task]
.end

fn TaskSet::new() -> TaskSet
  ret TaskSet
    tasks: vec::Vec[Task]::new()
  .end
.end

fn TaskSet::push(self: &mut TaskSet, t: Task) -> void
  self.tasks.push(t)
.end

fn TaskSet::len(self: &TaskSet) -> usize
  ret self.tasks.len()
.end

fn TaskSet::drain_completed(self: &mut TaskSet) -> void
  let mut i: usize = 0
  while i < self.tasks.len()
    let st = self.tasks[i].state()
    if st == TaskState::Completed || st == TaskState::Cancelled
      self.tasks.swap_remove(i)
      continue
    .end
    i = i + 1
  .end
.end
