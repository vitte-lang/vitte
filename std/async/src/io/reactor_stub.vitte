# C:\Users\gogin\Documents\GitHub\vitte\std\async\src\io\reactor_stub.vitte
mod std/async/io/reactor_stub

use std/prelude

use std/core/option
use std/core/result

use std/alloc/vec
use std/alloc/box
use std/alloc/string

use std/sync/mutex
use std/sync/atomic

use std/time/instant
use std/os/thread

use std/async/executor/waker

# =============================================================================
# Reactor (stub) — portable minimum
# =============================================================================
#
# Objectif:
# - fournir une façade "reactor" pour intégrer IO + timers avec l'executor
# - ici: implémentation STUB, sans epoll/kqueue/iocp
# - assez pour: tests, fallback polling, architecture propre
#
# Idée:
# - registre de sources (fd/handle abstrait) + intérêts (READ/WRITE/TIMER)
# - wait() bloque/attend et réveille des WakeFlags
#
# Remplacement futur:
# - reactor_posix_epoll.vitte / reactor_posix_kqueue.vitte / reactor_win_iocp.vitte
#
# =============================================================================

# -----------------------------------------------------------------------------
# Basic types
# -----------------------------------------------------------------------------

type Token = u64

enum Interest
  Read
  Write
  ReadWrite
.end

enum ReactorErrorKind
  Other
  NotFound
  InvalidInput
.end

struct ReactorError
  kind: ReactorErrorKind
  message: string::String
.end

fn ReactorError::new(kind: ReactorErrorKind, msg: &str) -> ReactorError
  ret ReactorError
    kind: kind
    message: string::String::from_str(msg)
  .end
.end

# A "Source" is an abstract IO handle. In the stub we just store an integer id.
struct Source
  raw: i64
.end

fn Source::from_raw(raw: i64) -> Source
  ret Source
    raw: raw
  .end
.end

fn Source::raw(self: &Source) -> i64
  ret self.raw
.end

# -----------------------------------------------------------------------------
# Registration records
# -----------------------------------------------------------------------------

struct Registration
  token: Token
  src: Source
  interest: Interest
  wake: &waker::WakeFlag
  enabled: bool
.end

# -----------------------------------------------------------------------------
# Reactor
# -----------------------------------------------------------------------------

struct Reactor
  next_token: atomic::U64

  # registrations (mutex protected)
  regs: mutex::Mutex[vec::Vec[Registration]]

  # global wake for "something changed"
  global: waker::WakeFlag

  # stats
  waits: atomic::U64
  notifies: atomic::U64
.end

fn Reactor::new() -> Reactor
  ret Reactor
    next_token: atomic::U64::new(1)
    regs: mutex::Mutex[vec::Vec[Registration]]::new(vec::Vec[Registration]::new())
    global: waker::WakeFlag::new()
    waits: atomic::U64::new(0)
    notifies: atomic::U64::new(0)
  .end
.end

fn Reactor::register(self: &Reactor, src: Source, interest: Interest, wake: &waker::WakeFlag) -> result::Result[Token, ReactorError]
  let token = self.next_token.fetch_add(1)

  let mut g = self.regs.lock()
  g.push(Registration
    token: token
    src: src
    interest: interest
    wake: wake
    enabled: true
  .end)
  g.unlock()

  self.global.signal()
  ret result::Ok(token)
.end

fn Reactor::deregister(self: &Reactor, token: Token) -> result::Result[void, ReactorError]
  let mut g = self.regs.lock()

  let mut i: usize = 0
  while i < g.len()
    if g[i].token == token
      g.swap_remove(i)
      g.unlock()
      self.global.signal()
      ret result::Ok(())
    .end
    i = i + 1
  .end

  g.unlock()
  ret result::Err(ReactorError::new(ReactorErrorKind::NotFound, "token not found"))
.end

fn Reactor::set_enabled(self: &Reactor, token: Token, enabled: bool) -> bool
  let mut g = self.regs.lock()
  let mut i: usize = 0
  while i < g.len()
    if g[i].token == token
      g[i].enabled = enabled
      g.unlock()
      self.global.signal()
      ret true
    .end
    i = i + 1
  .end
  g.unlock()
  ret false
.end

fn Reactor::notify(self: &Reactor, token: Token) -> bool
  # Manual notify hook: mark a registration as ready and wake its task.
  self.notifies.fetch_add(1)

  let g = self.regs.lock()
  let mut i: usize = 0
  while i < g.len()
    if g[i].token == token && g[i].enabled
      g[i].wake.signal()
      g.unlock()
      ret true
    .end
    i = i + 1
  .end
  g.unlock()
  ret false
.end

fn Reactor::notify_all(self: &Reactor) -> void
  self.notifies.fetch_add(1)
  let g = self.regs.lock()
  let mut i: usize = 0
  while i < g.len()
    if g[i].enabled
      g[i].wake.signal()
    .end
    i = i + 1
  .end
  g.unlock()
.end

fn Reactor::wake_global(self: &Reactor) -> void
  self.global.signal()
.end

# -----------------------------------------------------------------------------
# wait()
# -----------------------------------------------------------------------------
# STUB semantics:
# - does not actually poll OS handles
# - just waits for global wake, timeout, or manual notify() calls
#
# In a real reactor:
# - wait(timeout) performs epoll_wait/kqueue/IOCP and calls wake.signal() for
#   matching registrations.
# -----------------------------------------------------------------------------

fn Reactor::wait(self: &Reactor, timeout_ms: u64) -> void
  self.waits.fetch_add(1)

  # fast path: already signaled
  if self.global.take()
    ret
  .end

  if timeout_ms == 0
    # non-blocking
    ret
  .end

  # coarse sleep: wake can be triggered by other threads calling wake_global()
  let start = instant::now()
  while true
    if self.global.take()
      ret
    .end

    if start.elapsed_ms() >= timeout_ms
      ret
    .end

    thread::sleep_ms(1)
  .end
.end

# -----------------------------------------------------------------------------
# stats
# -----------------------------------------------------------------------------

fn Reactor::stats(self: &Reactor) -> (u64, u64, usize)
  let g = self.regs.lock()
  let n = g.len()
  g.unlock()
  ret (self.waits.load(), self.notifies.load(), n)
.end

# -----------------------------------------------------------------------------
# Small helper: ReactorHandle (shared pointer placeholder)
# -----------------------------------------------------------------------------
# Si tu as Rc/Arc dans std/alloc ou std/sync, remplace par Arc[Reactor].

struct ReactorHandle
  r: &Reactor
.end

fn ReactorHandle::new(r: &Reactor) -> ReactorHandle
  ret ReactorHandle
    r: r
  .end
.end

fn ReactorHandle::reactor(self: &ReactorHandle) -> &Reactor
  ret self.r
.end
