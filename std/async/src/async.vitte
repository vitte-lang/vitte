# C:\Users\gogin\Documents\GitHub\vitte\std\async\src\async.vitte
mod std/async/async

use std/prelude

use std/core/option
use std/core/result

use std/alloc/vec
use std/alloc/box
use std/alloc/string

use std/sync/atomic
use std/time/duration
use std/time/instant
use std/os/thread

use std/async/future
use std/async/executor/mod
use std/async/executor/waker
use std/async/executor/local
use std/async/executor/multithread

use std/async/io/mod
use std/async/io/async_read_write
use std/async/io/reactor_stub

use std/async/time/sleep
use std/async/time/interval

# =============================================================================
# std::async façade
# =============================================================================
#
# Objectif:
# - fournir une façade "ergonomique" : spawn, block_on, sleep, interval
# - ne pas forcer un runtime unique: expose local + multithread
# - garder un API stable, même si l'impl interne évolue
#
# =============================================================================

# -----------------------------------------------------------------------------
# Runtime selector
# -----------------------------------------------------------------------------

enum RuntimeKind
  Local
  MultiThread
.end

struct Runtime
  kind: RuntimeKind

  # local runtime
  local_cfg: local::LocalConfig
  local_ex: option::Option[local::LocalExecutor]

  # multithread runtime (shared state + executor)
  mt_cfg: multithread::MultiThreadConfig
  mt_shared: option::Option[multithread::Shared]
  mt_ex: option::Option[multithread::MultiThreadExecutor]

  # reactor (stub)
  reactor: option::Option[reactor_stub::Reactor]
.end

fn Runtime::local() -> Runtime
  ret Runtime::with_local_config(local::LocalConfig::default())
.end

fn Runtime::with_local_config(cfg: local::LocalConfig) -> Runtime
  ret Runtime
    kind: RuntimeKind::Local
    local_cfg: cfg
    local_ex: option::Some(local::LocalExecutor::with_config(cfg))

    mt_cfg: multithread::MultiThreadConfig::default()
    mt_shared: option::None
    mt_ex: option::None

    reactor: option::Some(reactor_stub::Reactor::new())
  .end
.end

fn Runtime::multithread(threads: usize) -> Runtime
  let mut cfg = multithread::MultiThreadConfig::default()
  cfg.threads = threads
  ret Runtime::with_mt_config(cfg)
.end

fn Runtime::with_mt_config(cfg: multithread::MultiThreadConfig) -> Runtime
  let shared = multithread::Shared::new()

  ret Runtime
    kind: RuntimeKind::MultiThread

    local_cfg: local::LocalConfig::default()
    local_ex: option::None

    mt_cfg: cfg
    mt_shared: option::Some(shared)
    mt_ex: option::Some(multithread::MultiThreadExecutor::new(&shared, cfg))

    reactor: option::Some(reactor_stub::Reactor::new())
  .end
.end

fn Runtime::reactor(self: &Runtime) -> option::Option[&reactor_stub::Reactor]
  if self.reactor.is_none()
    ret option::None
  .end
  ret option::Some(self.reactor.as_ref().unwrap())
.end

fn Runtime::shutdown(self: &mut Runtime) -> void
  if self.kind == RuntimeKind::MultiThread
    if self.mt_ex.is_some()
      self.mt_ex.as_mut().unwrap().shutdown()
    .end
  .end
.end

# -----------------------------------------------------------------------------
# Spawn / Run
# -----------------------------------------------------------------------------

fn Runtime::spawn(self: &mut Runtime, fut: box::Box[future::Future[void]]) -> result::Result[u64, executor::MtExecError]
  if self.kind == RuntimeKind::Local
    let id = self.local_ex.as_mut().unwrap().spawn(fut)
    ret result::Ok(id)
  .end

  ret self.mt_ex.as_mut().unwrap().spawn(fut)
.end

fn Runtime::block_on(self: &mut Runtime, fut: box::Box[future::Future[void]]) -> void
  if self.kind == RuntimeKind::Local
    let id = self.local_ex.as_mut().unwrap().spawn(fut)
    do id
    self.local_ex.as_mut().unwrap().run()
    ret
  .end

  # multithread: spawn + wait drain best-effort
  let _ = self.mt_ex.as_mut().unwrap().spawn(fut)
  let _ = multithread::run_until_drained(self.mt_ex.as_mut().unwrap(), 10_000)
.end

# -----------------------------------------------------------------------------
# Convenience functions (module-level)
# -----------------------------------------------------------------------------

fn block_on(fut: box::Box[future::Future[void]]) -> void
  local::block_on(fut)
.end

fn spawn_local(ex: &mut local::LocalExecutor, fut: box::Box[future::Future[void]]) -> u64
  ret ex.spawn(fut)
.end

fn spawn_mt(ex: &mut multithread::MultiThreadExecutor, fut: box::Box[future::Future[void]]) -> result::Result[u64, multithread::MtExecError]
  ret ex.spawn(fut)
.end

# -----------------------------------------------------------------------------
# Time helpers
# -----------------------------------------------------------------------------

fn sleep_ms(ms: u64) -> sleep::SleepFuture
  # panic-free: clamp 0 => 1ms
  let m = if ms == 0 then 1 else ms
  ret sleep::sleep_ms(m).unwrap()
.end

fn sleep_for(d: duration::Duration) -> sleep::SleepFuture
  ret sleep::sleep_for(d).unwrap()
.end

fn sleep_until(dl: instant::Instant) -> sleep::SleepFuture
  ret sleep::sleep_until(dl)
.end

fn interval(period: duration::Duration) -> interval::Interval
  ret interval::Interval::new(period).unwrap()
.end

# -----------------------------------------------------------------------------
# Simple "yield" future
# -----------------------------------------------------------------------------

struct YieldNow
  done: bool
.end

fn yield_now() -> YieldNow
  ret YieldNow
    done: false
  .end
.end

fn YieldNow::poll(self: &mut YieldNow, cx: &waker::Context) -> future::Poll[void]
  if self.done
    ret future::Poll::Ready(())
  .end
  self.done = true
  cx.waker().wake_by_ref()
  thread::yield_now()
  ret future::Poll::Pending
.end

# -----------------------------------------------------------------------------
# JoinHandle (stub)
# -----------------------------------------------------------------------------
# Pour un vrai join: il faut Future[T] + channel/oneshot.
# Ici: handle minimal id + runtime kind.

struct JoinHandle
  id: u64
.end

fn JoinHandle::id(self: &JoinHandle) -> u64
  ret self.id
.end

# -----------------------------------------------------------------------------
# Example: spawn and run (doc-style)
# -----------------------------------------------------------------------------

fn example_local_run() -> void
  let mut rt = Runtime::local()
  let _ = rt.spawn(box::Box::new(fn() -> future::Poll[void]
    # pseudo future: immediate
    ret future::Poll::Ready(())
  .end))
  rt.block_on(box::Box::new(fn() -> future::Poll[void]
    ret future::Poll::Ready(())
  .end))
.end
