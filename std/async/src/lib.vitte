

# std/async/src/lib.vitte
#
# Async primitives (bootstrap-ready, runtime-agnostic).
#
# This module provides:
# - Poll/Context/Waker model
# - Future as a manual vtable (C-friendly ABI idea)
# - Task + Executor skeleton (single-thread cooperative)
# - Timers (sleep/yield) skeleton
# - Channels (mpsc) skeleton
#
# NOTE:
# This is a "max" scaffold: the API surface is stable, implementations are
# conservative and can be wired to the real runtime later.

# -----------------------------------------------------------------------------
# Public exports
# -----------------------------------------------------------------------------

export all

# -----------------------------------------------------------------------------
# Common types
# -----------------------------------------------------------------------------

type U8  = u8
type U16 = u16
type U32 = u32
type U64 = u64

type I32 = i32
type I64 = i64

type Bool = bool
type Str  = string

# A generic pointer-like handle (host/runtime decides actual representation).
# In stage0 this can map to an integer or opaque ref.

type Ptr[T] = u64

type TaskId     = u64
type InstantMs  = u64
type DurationMs = u64

type Result[T, E] = enum
  Ok(T)
  Err(E)
.end

# -----------------------------------------------------------------------------
# Poll / Context / Waker
# -----------------------------------------------------------------------------

type Poll[T] = enum
  Pending
  Ready(T)
.end

fn poll_pending[T]() -> Poll[T]
  ret Poll::Pending
.end

fn poll_ready[T](value: T) -> Poll[T]
  ret Poll::Ready(value)
.end

# Waker model (manual vtable).
# A waker can be cloned, woken, and dropped.

# Function pointer signatures as type aliases.
# In the C backend, these map to raw function pointers.

type WakerCloneFn = fn(data: Ptr[U8]) -> Ptr[U8]

type WakerWakeFn  = fn(data: Ptr[U8]) -> void

type WakerDropFn  = fn(data: Ptr[U8]) -> void

type WakerVTable = struct
  clone_fn: WakerCloneFn
  wake_fn:  WakerWakeFn
  drop_fn:  WakerDropFn
.end

type Waker = struct
  data:   Ptr[U8]
  vtable: Ptr[WakerVTable]
.end

fn waker_is_null(w: Waker) -> Bool
  # data==0 or vtable==0 treated as "null" waker
  ret (w.data == 0) or (w.vtable == 0)
.end

fn waker_clone(w: Waker) -> Waker
  if waker_is_null(w)
    ret w
  .end

  # Stub: default clone returns same waker.
  # Runtime backends can implement deep clone.
  ret w
.end

fn waker_wake(w: Waker) -> void
  if waker_is_null(w)
    ret
  .end

  # Stub: no-op.
  # Runtime backends should call vtable.wake_fn(w.data).
  ret
.end

fn waker_drop(w: Waker) -> void
  if waker_is_null(w)
    ret
  .end

  # Stub: no-op.
  # Runtime backends should call vtable.drop_fn(w.data).
  ret
.end

type Context = struct
  waker: Waker
  now_ms: InstantMs
.end

fn context_new(w: Waker, now_ms: InstantMs) -> Context
  let cx = Context
    waker: w
    now_ms: now_ms
  .end
  ret cx
.end

# -----------------------------------------------------------------------------
# Future model (manual vtable)
# -----------------------------------------------------------------------------

# Future polling signature.
# - data points to a state machine object.
# - cx provides waker and a monotonic time (ms).
#
# Convention: poll returns Poll[u64] for stage0 simplicity.
# You can lift it to generics later (Future[T]) once the type system is ready.

type FuturePollFn = fn(data: Ptr[U8], cx: Context) -> Poll[U64]

type FutureDropFn = fn(data: Ptr[U8]) -> void

type FutureVTable = struct
  poll_fn: FuturePollFn
  drop_fn: FutureDropFn
.end

type Future = struct
  data:   Ptr[U8]
  vtable: Ptr[FutureVTable]
.end

fn future_is_null(f: Future) -> Bool
  ret (f.data == 0) or (f.vtable == 0)
.end

fn future_poll(f: Future, cx: Context) -> Poll[U64]
  if future_is_null(f)
    # null future: ready with 0
    ret Poll::Ready(0)
  .end

  # Stub: runtime backends should call vtable.poll_fn(f.data, cx)
  # Here, we conservatively return Pending to avoid false readiness.
  ret Poll::Pending
.end

fn future_drop(f: Future) -> void
  if future_is_null(f)
    ret
  .end
  # Stub: runtime backends should call vtable.drop_fn(f.data)
  ret
.end

# Helper: a Future that is immediately ready with a constant value.

type ReadyFutureState = struct
  value: U64
  used: Bool
.end

fn ready_future_new(value: U64) -> Future
  # NOTE: allocation is runtime-specific; here we model it as opaque handle.
  # Backend will allocate ReadyFutureState and set data pointer.
  let f = Future
    data: 0
    vtable: 0
  .end
  # Stub placeholder
  ret f
.end

# -----------------------------------------------------------------------------
# Task model
# -----------------------------------------------------------------------------

type TaskState = enum
  New
  Running
  Waiting
  Completed
  Cancelled
.end

type CancelReason = enum
  User
  Timeout
  Shutdown
.end

type JoinError = enum
  Cancelled(CancelReason)
  Failed(Str)
.end

type Task = struct
  id: TaskId
  state: TaskState
  future: Future
  result: U64
.end

fn task_new(id: TaskId, fut: Future) -> Task
  let t = Task
    id: id
    state: TaskState::New
    future: fut
    result: 0
  .end
  ret t
.end

fn task_is_done(t: Task) -> Bool
  ret (t.state == TaskState::Completed) or (t.state == TaskState::Cancelled)
.end

# -----------------------------------------------------------------------------
# Executor (single-thread cooperative)
# -----------------------------------------------------------------------------

type ExecConfig = struct
  max_tasks: U32
  tick_budget: U32
.end

fn exec_config_default() -> ExecConfig
  let c = ExecConfig
    max_tasks: 4096
    tick_budget: 1024
  .end
  ret c
.end

type Executor = struct
  cfg: ExecConfig
  now_ms: InstantMs
  next_id: TaskId
  # Opaque runtime storage for tasks/queues
  tasks_ptr: Ptr[U8]
.end

fn executor_new(cfg: ExecConfig) -> Executor
  let ex = Executor
    cfg: cfg
    now_ms: 0
    next_id: 1
    tasks_ptr: 0
  .end
  ret ex
.end

fn executor_now(ex: Executor) -> InstantMs
  ret ex.now_ms
.end

fn executor_set_now(mut ex: Executor, now_ms: InstantMs) -> Executor
  ex.now_ms = now_ms
  ret ex
.end

fn executor_alloc_task_id(mut ex: Executor) -> TaskId
  let id = ex.next_id
  ex.next_id = ex.next_id + 1
  ret id
.end

# Spawn returns a TaskId (join handle can be added later).
fn executor_spawn(mut ex: Executor, fut: Future) -> TaskId
  let id = executor_alloc_task_id(ex)
  # TODO: store task into ex.tasks_ptr structure
  ret id
.end

# Run one tick: poll up to tick_budget tasks.
fn executor_tick(mut ex: Executor) -> U32
  # Stub tick: nothing scheduled
  # Future runtime: pop ready tasks, poll, reschedule on Pending.
  ret 0
.end

# Run until no runnable tasks or deadline.
fn executor_run(mut ex: Executor, max_ticks: U32) -> U32
  let ticks = 0
  loop
    if ticks >= max_ticks
      break
    .end

    let progressed = executor_tick(ex)
    if progressed == 0
      break
    .end

    ticks = ticks + 1
  .end

  ret ticks
.end

# block_on: run a single future to completion.
# For now it's a stub that polls a few times.
fn block_on(fut: Future) -> U64
  let cfg = exec_config_default()
  let mut ex = executor_new(cfg)
  let id = executor_spawn(ex, fut)
  # TODO: join task id and return result.
  (void)id
  executor_run(ex, 1024)
  ret 0
.end

# -----------------------------------------------------------------------------
# Timers / yield
# -----------------------------------------------------------------------------

type SleepState = struct
  deadline_ms: InstantMs
  armed: Bool
.end

# sleep_ms(): returns a Future that completes once now_ms >= deadline.
# Implementation is backend-specific; here we provide the API contract.

fn sleep_ms(ms: DurationMs) -> Future
  (void)ms
  let f = Future
    data: 0
    vtable: 0
  .end
  ret f
.end

# yield_now(): a Future that yields once (Pending) then becomes Ready.
fn yield_now() -> Future
  let f = Future
    data: 0
    vtable: 0
  .end
  ret f
.end

# -----------------------------------------------------------------------------
# Channels (mpsc) — skeleton
# -----------------------------------------------------------------------------

type ChanError = enum
  Closed
  Full
  Empty
.end

type Channel[T] = struct
  cap: U32
  # Opaque ringbuffer storage
  ptr: Ptr[U8]
  closed: Bool
.end

type Sender[T] = struct
  ch: Ptr[Channel[T]]
.end

type Receiver[T] = struct
  ch: Ptr[Channel[T]]
.end

fn channel[T](cap: U32) -> (Sender[T], Receiver[T])
  (void)cap
  let s = Sender[T]
    ch: 0
  .end
  let r = Receiver[T]
    ch: 0
  .end
  ret (s, r)
.end

fn sender_close[T](mut s: Sender[T]) -> void
  (void)s
  ret
.end

fn sender_send[T](s: Sender[T], value: T) -> Result[void, ChanError]
  (void)s
  (void)value
  ret Result::Err(ChanError::Closed)
.end

fn receiver_try_recv[T](r: Receiver[T]) -> Result[T, ChanError]
  (void)r
  # no value available in stub
  ret Result::Err(ChanError::Empty)
.end

# Async recv: returns a Future that resolves to Result[T, ChanError]
fn receiver_recv[T](r: Receiver[T]) -> Future
  (void)r
  let f = Future
    data: 0
    vtable: 0
  .end
  ret f
.end

# -----------------------------------------------------------------------------
# Select (2-way) — skeleton
# -----------------------------------------------------------------------------

type Select2 = enum
  A(U64)
  B(U64)
.end

# select2(): races two futures, returns which completed first.
fn select2(a: Future, b: Future) -> Future
  (void)a
  (void)b
  let f = Future
    data: 0
    vtable: 0
  .end
  ret f
.end

# -----------------------------------------------------------------------------
# Smoke scenarios (bootstrap tests)
# -----------------------------------------------------------------------------

scn t_async_smoke_ready
  let f = ready_future_new(123)
  let v = block_on(f)
  # In stub, block_on returns 0; once wired, assert v==123.
  (void)v
.end

scn t_async_smoke_sleep
  let f = sleep_ms(10)
  let v = block_on(f)
  (void)v
.end

scn t_async_smoke_channel
  let (tx, rx) = channel[U64](8)
  let r0 = sender_send[U64](tx, 7)
  let r1 = receiver_try_recv[U64](rx)
  (void)r0
  (void)r1
.end
