// Vitte Plugin Template
//
// This example shows how to create a Vitte plugin that can be dynamically
// loaded by a host application.

extern "C" {
    fn plugin_log(level: i32, msg: *const i8)
    fn plugin_alloc(size: usize) -> *mut i8
    fn plugin_free(ptr: *mut i8)
}

// Plugin information
pub const PLUGIN_NAME: &str = "my-plugin"
pub const PLUGIN_VERSION: &str = "0.1.0"
pub const PLUGIN_API_VERSION: i32 = 1

// Plugin status codes
pub enum PluginStatus {
    OK = 0,
    ERROR = 1,
    NOT_FOUND = 2,
    INIT_FAILED = 3,
}

// Plugin context (passed during initialization)
pub struct PluginContext {
    version: i32,
    flags: u32,
}

// Initialize plugin - called when plugin is loaded
#[no_mangle]
pub extern "C" fn plugin_init(ctx: *const PluginContext) -> PluginStatus {
    // Validate context
    if ctx.is_null() {
        return PluginStatus::ERROR
    }

    let context = unsafe { &*ctx }

    // Check API version compatibility
    if context.version < PLUGIN_API_VERSION {
        return PluginStatus::INIT_FAILED
    }

    // Perform initialization
    // (memory allocation, resource setup, etc.)

    PluginStatus::OK
}

// Execute plugin command
#[no_mangle]
pub extern "C" fn plugin_execute(
    name: *const i8,
    args: *const *const i8,
    argc: i32
) -> i32 {
    if name.is_null() || argc < 0 {
        return -1
    }

    // Match command name and execute
    // This is a simple example that just returns success

    0
}

// Shutdown plugin - called when plugin is unloaded
#[no_mangle]
pub extern "C" fn plugin_deinit() {
    // Clean up resources allocated during plugin lifetime
}

// Plugin metadata query (optional)
#[no_mangle]
pub extern "C" fn plugin_info() -> *const i8 {
    const INFO: &[u8] = b"my-plugin v0.1.0\0"
    INFO.as_ptr() as *const i8
}
