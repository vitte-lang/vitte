# =========================================================
# Vitte 1.0 — AST / Scoped Block
# =========================================================

space vitte/ast/block/scoped

share all

<<< doc
Ce module définit les blocs *scopés* dans l’AST Vitte.

Un scoped block :
- introduit un nouveau scope lexical
- contient des déclarations locales (make)
- permet l’analyse des portées (HIR)
- ne contient aucune logique d’exécution

Utilisé par :
- proc
- entry
- if / otherwise
- when
- select
>>>

# ---------------------------------------------------------
# Position source
# ---------------------------------------------------------

form Span
    field file as string
    field line_start as u32
    field line_end as u32
    field column_start as u32
    field column_end as u32
.end

# ---------------------------------------------------------
# Identifiant
# ---------------------------------------------------------

form Ident
    field name as string
    field span as Span
.end

# ---------------------------------------------------------
# Identifiant local résolu (pré-HIR)
# ---------------------------------------------------------

form LocalId
    field name as Ident
    field index as u32
.end

# ---------------------------------------------------------
# Scoped Block
# ---------------------------------------------------------

form ScopedBlock
    field statements as List[ScopedStmt]
    field scope as Scope
    field span as Span
.end

# ---------------------------------------------------------
# Scope lexical
# ---------------------------------------------------------

form Scope
    field locals as List[LocalBinding]
    field parent as Option[ScopeId]
.end

form ScopeId
    field id as u32
.end

form LocalBinding
    field name as Ident
    field local_id as LocalId
    field span as Span
.end

# ---------------------------------------------------------
# Statements scopés
# ---------------------------------------------------------

pick ScopedStmt
    case Make(stmt as ScopedMake)
    case Give(stmt as ScopedGive)
    case Emit(stmt as ScopedEmit)
    case If(stmt as ScopedIf)
    case Select(stmt as ScopedSelect)
    case Expr(stmt as ScopedExpr)
.end

# ---------------------------------------------------------
# make (introduit un symbole)
# ---------------------------------------------------------

form ScopedMake
    field binding as LocalBinding
    field ty as TypeExpr
    field value as Expr
    field span as Span
.end

# ---------------------------------------------------------
# give
# ---------------------------------------------------------

form ScopedGive
    field value as Expr
    field span as Span
.end

# ---------------------------------------------------------
# emit
# ---------------------------------------------------------

form ScopedEmit
    field value as Expr
    field span as Span
.end

# ---------------------------------------------------------
# if / otherwise (scopes distincts)
# ---------------------------------------------------------

form ScopedIf
    field condition as Expr
    field then_block as ScopedBlock
    field else_block as Option[ScopedBlock]
    field span as Span
.end

# ---------------------------------------------------------
# select / when / otherwise
# ---------------------------------------------------------

form ScopedSelect
    field value as Expr
    field whens as List[ScopedWhen]
    field otherwise as Option[ScopedBlock]
    field span as Span
.end

form ScopedWhen
    field pattern as Pattern
    field block as ScopedBlock
    field span as Span
.end

# ---------------------------------------------------------
# Expression statement
# ---------------------------------------------------------

form ScopedExpr
    field expr as Expr
    field span as Span
.end

# ---------------------------------------------------------
# Expressions (référence)
# ---------------------------------------------------------

pick Expr
    case Literal(value as Literal)
    case Local(id as LocalId)
    case Ident(name as Ident)
    case Call(expr as CallExpr)
    case Ctor(expr as CtorExpr)
    case Binary(expr as BinaryExpr)
    case Group(expr as Expr)
.end

form CallExpr
    field callee as Expr
    field args as List[Expr]
    field span as Span
.end

form CtorExpr
    field ty as TypeExpr
    field args as List[Expr]
    field span as Span
.end

form BinaryExpr
    field left as Expr
    field op as BinOp
    field right as Expr
    field span as Span
.end

pick BinOp
    case Add
    case Sub
    case Mul
    case Div
    case Eq
    case Ne
    case Lt
    case Le
    case Gt
    case Ge
    case And
    case Or
.end

# ---------------------------------------------------------
# Patterns
# ---------------------------------------------------------

pick Pattern
    case Ident(name as Ident)
    case Ctor(ty as TypeExpr, args as List[Pattern])
.end

# ---------------------------------------------------------
# Types
# ---------------------------------------------------------

pick TypeExpr
    case Simple(name as Ident)
    case Generic(name as Ident, args as List[TypeExpr])
.end

# ---------------------------------------------------------
# Literals
# ---------------------------------------------------------

pick Literal
    case Bool(value as bool)
    case Int(value as string)
    case String(value as string)
.end