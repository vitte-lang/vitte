vitte 1.0
space lingua/syntax/vitte_ast/expand/master

<<< master
  expand/master.vit — Vitte AST Expander (MAX)

  Purpose:
    - run early AST-to-AST expansion and normalization passes after parsing
    - remove/record doc zones (<<< ... >>>) and doc lines
    - evaluate cfg-style attributes and conditionally drop items/stmts
    - normalize surface sugar into a smaller “core AST shape” for lowering
    - run attribute validation/normalization on targets (re-using attr/master)
    - provide hooks for future macro / include / plugin expansion

  Non-goals:
    - typechecking
    - name resolution (beyond lightweight symbol lookup for cfg gates)

  Key ideas:
    - expansion is phase-driven (ordered pipeline)
    - expansion is pure AST rewrite + diagnostics; no I/O required
    - config controls strictness and enabled features (gates)

  Conventions:
    - blocks end ONLY with .end
    - locals: make/keep
    - assign: set
    - comment zones: <<< tag ... >>>
>>>

pull std/text as text
pull std/collections/list as list
pull std/collections/map as map

pull lingua/syntax/vitte_ast/span as span
pull lingua/syntax/vitte_ast/symbol as symbol
pull lingua/syntax/vitte_ast/diag as diag
pull lingua/syntax/vitte_ast/attr/master as attr

share all

bond Text means String


<<< =========================================================
  0) OPTIONAL GENERIC AST SURFACE (adapter friendly)

  This file is designed to work in two modes:
    A) Concrete AST mode: your project provides real AST node types.
    B) Adapter mode: this file manipulates generic Node records with kind + children.

  If you already have strong types (FormDecl, ProcDecl, Stmt, Expr...), you can:
    - keep the generic layer unused
    - map these helpers into your typed pass

  The generic Node model below is intentionally minimal but useful for expansion.
========================================================= >>>

pick NodeKind
case File()
case Item()
case Stmt()
case Expr()
case Type()
case Attr()
case DocZone()
case DocLine()
case Unknown()
.end

form NodeId
field raw as U32 = 0u32
.end

proc node_id_make(x as U32) gives NodeId
make id as NodeId = NodeId()
set id.raw = x
give id
.end

form Node
field id as NodeId = NodeId()
field kind as NodeKind = NodeKind.Unknown()
field tag as Text = ""                  # e.g. "proc", "form", "if", "loop_while"
field span as span.Span = span.Span()
field attrs as List of attr.Attribute = []
field text as Text = ""                 # optional payload (ident name, literal, etc.)
field kids as List of Node = []         # generic children
.end

proc node_make(id as NodeId, kind as NodeKind, tag as Text, sp as span.Span) gives Node
make n as Node = Node()
set n.id = id
set n.kind = kind
set n.tag = tag
set n.span = sp
set n.attrs = []
set n.text = ""
set n.kids = []
give n
.end

proc node_with_text(n as Node, t as Text) gives Node
make out as Node = n
set out.text = t
give out
.end

proc node_push_kid(n as Node, k as Node) gives Node
make out as Node = n
list.push(out.kids, k)
give out
.end

proc node_set_attrs(n as Node, a as List of attr.Attribute) gives Node
make out as Node = n
set out.attrs = a
give out
.end


<<< =========================================================
  1) EXPANSION PHASES / CONFIG / STATS
========================================================= >>>

pick ExpandPhase
case StripDocs()         # remove doc zones/lines from AST; optionally store in side table
case AttrNormalize()     # normalize/dedupe attrs based on registry + target
case CfgPrune()          # drop nodes controlled by cfg attributes
case Desugar()           # rewrite surface sugar into core forms
case DeferLowerPrep()    # normalize defer placement/shape for lowerer
case ValidateShape()     # light structural checks (no types)
.end

form ExpandConfig
field phases as List of ExpandPhase = []
field enable_trace as Bool = false
field keep_doc_nodes as Bool = false            # if true, do not remove doc nodes
field store_docs as Bool = true                 # store doc texts in a side table
field cfg_enabled as Bool = true                # cfg attribute evaluation
field cfg_default as Bool = true                # if cfg key missing => keep
field strict_cfg as Bool = false                # unknown cfg keys => error
field desugar_loop_until as Bool = true
field desugar_each as Bool = true
field desugar_select as Bool = false            # if true rewrite select -> match-like
field desugar_pack as Bool = false              # if true rewrite pack(...) to tuple node
field strict_shape as Bool = false
field attr_registry as attr.AttrRegistry = attr.default_registry()
.end

proc expand_config_default() gives ExpandConfig
make c as ExpandConfig = ExpandConfig()
# default pipeline ordering
set c.phases = [
  ExpandPhase.StripDocs(),
  ExpandPhase.AttrNormalize(),
  ExpandPhase.CfgPrune(),
  ExpandPhase.Desugar(),
  ExpandPhase.DeferLowerPrep(),
  ExpandPhase.ValidateShape()
]
give c
.end


form ExpandStats
field nodes_in as U64 = 0u64
field nodes_out as U64 = 0u64
field removed_docs as U64 = 0u64
field removed_cfg as U64 = 0u64
field rewritten as U64 = 0u64
field attr_normalized as U64 = 0u64
field errors as U64 = 0u64
field warnings as U64 = 0u64
.end

proc stats_new() gives ExpandStats
give ExpandStats()
.end


<<< trace
  Trace is useful to debug macro-like behaviors later.
>>>

form TraceEvent
field phase as Text = ""
field action as Text = ""
field node_id as U32 = 0u32
field node_tag as Text = ""
field note as Text = ""
.end

form ExpandTrace
field events as List of TraceEvent = []
.end

proc trace_new() gives ExpandTrace
make t as ExpandTrace = ExpandTrace()
set t.events = []
give t
.end

proc trace_add(tr as ExpandTrace, phase as Text, action as Text, n as Node, note as Text) gives ExpandTrace
make out as ExpandTrace = tr
make e as TraceEvent = TraceEvent()
set e.phase = phase
set e.action = action
set e.node_id = n.id.raw
set e.node_tag = n.tag
set e.note = note
list.push(out.events, e)
give out
.end


<<< =========================================================
  2) DOC STORAGE
========================================================= >>>

form DocChunk
field node_id as U32 = 0u32
field tag as Text = ""          # optional doc zone tag
field text as Text = ""         # raw lines joined with '\n'
field span as span.Span = span.Span()
.end

form DocStore
field by_node as Map of U32 to List of DocChunk = {}
.end

proc doc_store_new() gives DocStore
make s as DocStore = DocStore()
set s.by_node = map.new()
give s
.end

proc doc_store_add(store as DocStore, node_id as U32, chunk as DocChunk) gives DocStore
make out as DocStore = store
if map.has(out.by_node, node_id) == false
  map.put(out.by_node, node_id, [])
.end
make xs as List of DocChunk = map.get(out.by_node, node_id)
list.push(xs, chunk)
map.put(out.by_node, node_id, xs)
give out
.end


<<< =========================================================
  3) CFG EVALUATION (attribute-driven pruning)
========================================================= >>>

pick CfgOp
case All()
case Any()
case Not()
.end

form CfgExpr
field op as CfgOp = CfgOp.All()
field key as Text = ""                 # for leaf: key
field value as Text = ""               # optional value
field kids as List of CfgExpr = []
.end

proc cfg_leaf(key as Text, value as Text) gives CfgExpr
make e as CfgExpr = CfgExpr()
set e.op = CfgOp.All()
set e.key = key
set e.value = value
set e.kids = []
give e
.end

proc cfg_all(items as List of CfgExpr) gives CfgExpr
make e as CfgExpr = CfgExpr()
set e.op = CfgOp.All()
set e.kids = items
give e
.end

proc cfg_any(items as List of CfgExpr) gives CfgExpr
make e as CfgExpr = CfgExpr()
set e.op = CfgOp.Any()
set e.kids = items
give e
.end

proc cfg_not(inner as CfgExpr) gives CfgExpr
make e as CfgExpr = CfgExpr()
set e.op = CfgOp.Not()
set e.kids = [inner]
give e
.end


<<< cfg_env
  Environment values are simple string flags.
  Examples:
    os=linux
    arch=x86_64
    feature=foo
    debug=true
>>>

form CfgEnv
field kv as Map of Text to Text = {}
.end

proc cfg_env_new() gives CfgEnv
make e as CfgEnv = CfgEnv()
set e.kv = map.new()
give e
.end

proc cfg_env_put(env as CfgEnv, key as Text, value as Text) gives CfgEnv
make out as CfgEnv = env
map.put(out.kv, key, value)
give out
.end

proc cfg_env_get(env as CfgEnv, key as Text) gives Text
if map.has(env.kv, key)
  give map.get(env.kv, key)
.end
give ""
.end

proc cfg_env_has(env as CfgEnv, key as Text) gives Bool
give map.has(env.kv, key)
.end


proc cfg_eval(env as CfgEnv, expr as CfgExpr, cfg_default as Bool) gives Bool
# Leaf form: key/value stored in expr.key/expr.value with kids empty
if list.len(expr.kids) == 0
  if expr.key == ""
    give cfg_default
  .end
  if cfg_env_has(env, expr.key) == false
    give cfg_default
  .end
  make v as Text = cfg_env_get(env, expr.key)
  if expr.value == ""
    # key present means true unless explicit "false"
    if v == "false"
      give false
    .end
    give true
  .end
  give v == expr.value
.end

select expr.op
when CfgOp.All()
  make i as Int = 0
  loop while i < list.len(expr.kids)
    if cfg_eval(env, expr.kids[i], cfg_default) == false
      give false
    .end
    set i += 1
  .end
  give true
.end
when CfgOp.Any()
  make i as Int = 0
  loop while i < list.len(expr.kids)
    if cfg_eval(env, expr.kids[i], cfg_default)
      give true
    .end
    set i += 1
  .end
  give false
.end
when CfgOp.Not()
  if list.len(expr.kids) == 0
    give true
  .end
  give not cfg_eval(env, expr.kids[0], cfg_default)
.end
otherwise
  give cfg_default
.end
.end
.end


<<< cfg_from_attr
  Parse cfg attribute from AttrValue Map/Text/Symbol patterns.
  Expected attribute shape (flexible):
    #[cfg(os="linux", arch="x86_64", feature="x")]
  We interpret named args as AND conditions.
  Unknown values -> leaf with default key/value.
>>>

proc cfg_expr_from_attribute(a as attr.Attribute) gives CfgExpr
# default: keep
make terms as List of CfgExpr = []

make i as Int = 0
loop while i < list.len(a.args)
  select a.args[i]
  when attr.AttrArg.Named(k, v)
    select v
    when attr.AttrValue.Text(s)
      list.push(terms, cfg_leaf(k, s))
    .end
    when attr.AttrValue.Symbol(sym)
      list.push(terms, cfg_leaf(k, symbol.to_text(sym)))
    .end
    when attr.AttrValue.Bool(b)
      list.push(terms, cfg_leaf(k, (if b then "true" else "false")))
    .end
    otherwise
      list.push(terms, cfg_leaf(k, ""))
    .end
    .end
  .end
  when attr.AttrArg.Pos(attr.AttrValue.Text(s))
    # allow positional: cfg("os=linux") (best-effort)
    list.push(terms, cfg_leaf(s, "true"))
  .end
  when attr.AttrArg.Pos(attr.AttrValue.Symbol(sym))
    list.push(terms, cfg_leaf(symbol.to_text(sym), "true"))
  .end
  otherwise
  .end
  .end
  set i += 1
.end

if list.len(terms) == 0
  give cfg_leaf("", "")
.end

give cfg_all(terms)
.end


<<< =========================================================
  4) EXPAND CONTEXT / RESULT
========================================================= >>>

form ExpandContext
field config as ExpandConfig = ExpandConfig()
field env as CfgEnv = CfgEnv()
field docs as DocStore = DocStore()
field trace as ExpandTrace = ExpandTrace()
field stats as ExpandStats = ExpandStats()
field diags as List of diag.Diagnostic = []
field next_id as U32 = 1u32
.end

proc ctx_new(cfg as ExpandConfig, env as CfgEnv) gives ExpandContext
make c as ExpandContext = ExpandContext()
set c.config = cfg
set c.env = env
set c.docs = doc_store_new()
set c.trace = trace_new()
set c.stats = stats_new()
set c.diags = []
set c.next_id = 1u32
give c
.end

proc ctx_fresh_id(ctx as ExpandContext) gives NodeId
make id as NodeId = node_id_make(ctx.next_id)
set ctx.next_id += 1u32
give id
.end

form ExpandResult
field root as Node = Node()
field docs as DocStore = DocStore()
field trace as ExpandTrace = ExpandTrace()
field stats as ExpandStats = ExpandStats()
field diags as List of diag.Diagnostic = []
.end


<<< =========================================================
  5) CORE ENTRYPOINT
========================================================= >>>

proc expand_file(root as Node, cfg as ExpandConfig, env as CfgEnv, diags as List of diag.Diagnostic) gives ExpandResult
make ctx as ExpandContext = ctx_new(cfg, env)
set ctx.diags = diags

set ctx.stats.nodes_in = _count_nodes(root)

make cur as Node = root
make p as Int = 0
loop while p < list.len(cfg.phases)
  make phase as ExpandPhase = cfg.phases[p]
  select phase
  when ExpandPhase.StripDocs()
    set cur = _phase_strip_docs(ctx, cur)
  .end
  when ExpandPhase.AttrNormalize()
    set cur = _phase_attr_normalize(ctx, cur)
  .end
  when ExpandPhase.CfgPrune()
    set cur = _phase_cfg_prune(ctx, cur)
  .end
  when ExpandPhase.Desugar()
    set cur = _phase_desugar(ctx, cur)
  .end
  when ExpandPhase.DeferLowerPrep()
    set cur = _phase_defer_prep(ctx, cur)
  .end
  when ExpandPhase.ValidateShape()
    set cur = _phase_validate_shape(ctx, cur)
  .end
  otherwise
    # ignore
  .end
  .end
  set p += 1
.end

set ctx.stats.nodes_out = _count_nodes(cur)

make out as ExpandResult = ExpandResult()
set out.root = cur
set out.docs = ctx.docs
set out.trace = ctx.trace
set out.stats = ctx.stats
set out.diags = ctx.diags
give out
.end


<<< =========================================================
  6) PHASE: STRIP DOCS
========================================================= >>>

proc _phase_strip_docs(ctx as ExpandContext, root as Node) gives Node
make phase_name as Text = "StripDocs"

if ctx.config.enable_trace
  set ctx.trace = trace_add(ctx.trace, phase_name, "begin", root, "")
.end

if ctx.config.keep_doc_nodes
  # optionally still store docs, but keep nodes
  if ctx.config.store_docs
    _collect_docs(ctx, root, 0u32)
  .end
  if ctx.config.enable_trace
    set ctx.trace = trace_add(ctx.trace, phase_name, "keep", root, "")
  .end
  give root
.end

if ctx.config.store_docs
  _collect_docs(ctx, root, 0u32)
.end

make out as Node = _strip_docs_rec(ctx, root)

if ctx.config.enable_trace
  set ctx.trace = trace_add(ctx.trace, phase_name, "end", out, "")
.end

give out
.end

proc _collect_docs(ctx as ExpandContext, n as Node, attach_to as U32)
# attach_to is the nearest “real” node id; 0 means file-level
make current_attach as U32 = attach_to

# if this is not a doc node, it becomes the new attach point
select n.kind
when NodeKind.DocZone()
  _store_doc_zone(ctx, n, current_attach)
  set ctx.stats.removed_docs += 1u64
  give
.end
when NodeKind.DocLine()
  _store_doc_line(ctx, n, current_attach)
  set ctx.stats.removed_docs += 1u64
  give
.end
otherwise
  if n.id.raw != 0u32
    set current_attach = n.id.raw
  .end
.end
.end

# walk children
make i as Int = 0
loop while i < list.len(n.kids)
  _collect_docs(ctx, n.kids[i], current_attach)
  set i += 1
.end
give
.end

proc _store_doc_zone(ctx as ExpandContext, n as Node, attach_to as U32)
make ch as DocChunk = DocChunk()
set ch.node_id = attach_to
set ch.tag = n.tag
set ch.text = n.text
set ch.span = n.span
set ctx.docs = doc_store_add(ctx.docs, attach_to, ch)
give
.end

proc _store_doc_line(ctx as ExpandContext, n as Node, attach_to as U32)
make ch as DocChunk = DocChunk()
set ch.node_id = attach_to
set ch.tag = "doc"
set ch.text = n.text
set ch.span = n.span
set ctx.docs = doc_store_add(ctx.docs, attach_to, ch)
give
.end

proc _strip_docs_rec(ctx as ExpandContext, n as Node) gives Node
# remove doc nodes from children recursively
select n.kind
when NodeKind.DocZone()
  # should be removed by parent; return an empty placeholder
  make z as Node = n
  set z.kids = []
  give z
.end
when NodeKind.DocLine()
  make z as Node = n
  set z.kids = []
  give z
.end
otherwise
.end
.end

make out as Node = n
set out.kids = []

make i as Int = 0
loop while i < list.len(n.kids)
  make k as Node = n.kids[i]
  select k.kind
  when NodeKind.DocZone()
    set ctx.stats.removed_docs += 1u64
    if ctx.config.enable_trace
      set ctx.trace = trace_add(ctx.trace, "StripDocs", "remove", k, "doc_zone")
    .end
  .end
  when NodeKind.DocLine()
    set ctx.stats.removed_docs += 1u64
    if ctx.config.enable_trace
      set ctx.trace = trace_add(ctx.trace, "StripDocs", "remove", k, "doc_line")
    .end
  .end
  otherwise
    list.push(out.kids, _strip_docs_rec(ctx, k))
  .end
  .end
  set i += 1
.end

give out
.end


<<< =========================================================
  7) PHASE: ATTRIBUTE NORMALIZATION
========================================================= >>>

proc _phase_attr_normalize(ctx as ExpandContext, root as Node) gives Node
make phase_name as Text = "AttrNormalize"
if ctx.config.enable_trace
  set ctx.trace = trace_add(ctx.trace, phase_name, "begin", root, "")
.end

make out as Node = _attr_normalize_rec(ctx, root)

if ctx.config.enable_trace
  set ctx.trace = trace_add(ctx.trace, phase_name, "end", out, "")
.end
give out
.end

proc _attr_target_for_node(n as Node) gives attr.AttrTarget
# Map node tags/kinds to attribute targets.
# Customize when you wire this to concrete AST.
if n.kind is NodeKind.File()
  give attr.AttrTarget.File()
.end

if n.kind is NodeKind.Item()
  if n.tag == "space"  give attr.AttrTarget.Space()  .end
  if n.tag == "pull"   give attr.AttrTarget.Pull()   .end
  if n.tag == "share"  give attr.AttrTarget.Share()  .end
  if n.tag == "build"  give attr.AttrTarget.Build()  .end
  if n.tag == "form"   give attr.AttrTarget.Form()   .end
  if n.tag == "pick"   give attr.AttrTarget.Pick()   .end
  if n.tag == "bond"   give attr.AttrTarget.Bond()   .end
  if n.tag == "proc"   give attr.AttrTarget.Proc()   .end
  if n.tag == "flow"   give attr.AttrTarget.Flow()   .end
  if n.tag == "entry"  give attr.AttrTarget.Entry()  .end
.end

if n.kind is NodeKind.Stmt()
  give attr.AttrTarget.Stmt()
.end
if n.kind is NodeKind.Expr()
  give attr.AttrTarget.Expr()
.end

give attr.AttrTarget.Any()
.end

proc _attr_normalize_rec(ctx as ExpandContext, n as Node) gives Node
make out as Node = n

# normalize attrs on this node
if list.len(out.attrs) > 0
  make s as attr.AttrSet = attr.attr_set_new()
  make i as Int = 0
  loop while i < list.len(out.attrs)
    set s = attr.attr_set_add(s, out.attrs[i])
    set i += 1
  .end

  make t as attr.AttrTarget = _attr_target_for_node(out)
  make norm as attr.AttrSet = attr.attr_set_normalize(ctx.config.attr_registry, s, t, ctx.diags)

  set out.attrs = norm.items
  set ctx.stats.attr_normalized += 1u64

  if ctx.config.enable_trace
    set ctx.trace = trace_add(ctx.trace, "AttrNormalize", "normalize", out, attr_target_key(t))
  .end
.end

# recurse
set out.kids = []
make j as Int = 0
loop while j < list.len(n.kids)
  list.push(out.kids, _attr_normalize_rec(ctx, n.kids[j]))
  set j += 1
.end

give out
.end


<<< =========================================================
  8) PHASE: CFG PRUNE
========================================================= >>>

proc _phase_cfg_prune(ctx as ExpandContext, root as Node) gives Node
make phase_name as Text = "CfgPrune"
if ctx.config.enable_trace
  set ctx.trace = trace_add(ctx.trace, phase_name, "begin", root, "")
.end

if ctx.config.cfg_enabled == false
  if ctx.config.enable_trace
    set ctx.trace = trace_add(ctx.trace, phase_name, "skip", root, "cfg_disabled")
  .end
  give root
