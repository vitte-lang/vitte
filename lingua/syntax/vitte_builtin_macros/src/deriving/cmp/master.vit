vitte 1.0
space lingua/syntax/vitte_builtin_macros/deriving/cmp/master

<<< master
  vitte_builtin_macros/deriving/cmp/master.vit â€” Builtin derive macro: cmp (MAX)

  Goal:
    - Provide compiler-friendly generation for comparison traits/ops:
        * Eq      : equals(a,b)
        * Ord     : compare(a,b) -> Int (negative/0/positive)
        * Hash    : hash_into(state, value)
    - Work on type declarations in expanded AST or lowered AST/IR.
    - Deterministic output:
        * stable field order
        * explicit comparisons for each field
        * early returns for lexicographic ordering
    - No reflection at runtime; code is generated at compile time.

  Surface:
    @derive(cmp)
    form Point
      field x as I32
      field y as I32
    .end

  Expansion result:
    - Generates procs in same module scope:
        proc Point.eq(a as Point, b as Point) gives Bool
        proc Point.cmp(a as Point, b as Point) gives I32
    - Optionally also emits operator helpers:
        proc Point.lt(a,b) -> Bool using cmp < 0
        proc Point.le(a,b) -> Bool ...
        proc Point.gt ...
        proc Point.ge ...
    - Configurable naming conventions.

  Integration:
    - Called from AST expansion or a dedicated macro pass.
    - Uses:
        * attr registry to detect @derive
        * diag for errors
        * expand node builder utilities (or IR builder)
>>>

pull std/text as text
pull std/collections/list as list
pull std/collections/map as map

pull lingua/syntax/vitte_ast/span as span
pull lingua/syntax/vitte_ast/diag as diag
pull lingua/syntax/vitte_ast/attr/master as attr
pull lingua/syntax/vitte_ast/expand/master as expand
pull lingua/syntax/vitte_ast_ir/master as ir

share all

bond Text means String


<<< =========================================================
  0) CONFIG / RESULT
========================================================= >>>

pick DeriveCmpKind
case Eq()
case Ord()
case Hash()
case Full()     # Eq + Ord
.end

form DeriveCmpConfig
field kind as DeriveCmpKind = DeriveCmpKind.Full()
field attach_in_same_scope as Bool = true
field namespace_style as Text = "Type.member"   # "Type.member" or "member_Type"
field emit_ops as Bool = true                  # lt/le/gt/ge based on cmp
field eq_name as Text = "eq"
field cmp_name as Text = "cmp"
field hash_name as Text = "hash_into"
field order_return_type as Text = "I32"         # order type text, stable for IR mapping
field error_on_unsupported_field as Bool = true
field allow_generic_types as Bool = true
field require_form as Bool = true              # only "form" (struct-like)
.end

proc derive_cmp_config_default() gives DeriveCmpConfig
give DeriveCmpConfig()
.end

form DeriveCmpStats
field types_seen as U64 = 0u64
field derived_eq as U64 = 0u64
field derived_cmp as U64 = 0u64
field derived_hash as U64 = 0u64
field errors as U64 = 0u64
.end

form DeriveCmpResult
field extra_items as List of expand.Node = []
field stats as DeriveCmpStats = DeriveCmpStats()
.end


<<< =========================================================
  1) DETECT + ENTRYPOINTS
========================================================= >>>

proc derive_cmp_on_item(item as expand.Node, cfg as DeriveCmpConfig, diags as List of diag.Diagnostic) gives DeriveCmpResult
# If item is a type declaration carrying @derive(cmp), returns generated items.
# Otherwise returns empty result.
make r as DeriveCmpResult = DeriveCmpResult()
set r.extra_items = []
set r.stats = DeriveCmpStats()

if item.tag != "form" and cfg.require_form
  give r
.end

set r.stats.types_seen = 1u64

if _has_derive_cmp(item) == false
  give r
.end

make tinfo as TypeInfo = _collect_form_info(item, diags)
if tinfo.ok == false
  set r.stats.errors += 1u64
  give r
.end

# generate eq / cmp / hash based on cfg.kind
if cfg.kind is DeriveCmpKind.Eq() or cfg.kind is DeriveCmpKind.Full()
  list.push(r.extra_items, _gen_eq_proc(tinfo, cfg))
  set r.stats.derived_eq += 1u64
.end

if cfg.kind is DeriveCmpKind.Ord() or cfg.kind is DeriveCmpKind.Full()
  list.push(r.extra_items, _gen_cmp_proc(tinfo, cfg))
  set r.stats.derived_cmp += 1u64
  if cfg.emit_ops
    make ops as List of expand.Node = _gen_ops(tinfo, cfg)
    make i as Int = 0
    loop while i < list.len(ops)
      list.push(r.extra_items, ops[i])
      set i += 1
    .end
  .end
.end

if cfg.kind is DeriveCmpKind.Hash()
  list.push(r.extra_items, _gen_hash_proc(tinfo, cfg))
  set r.stats.derived_hash += 1u64
.end

give r
.end


proc _has_derive_cmp(item as expand.Node) gives Bool
# Expect attributes in item.attrs containing "derive" with "cmp"
# Since attribute encoding is project-specific, accept:
# - attr named "derive" where args contain name "cmp"
make i as Int = 0
loop while i < list.len(item.attrs)
  make a as attr.Attribute = item.attrs[i]
  if a.name == "derive"
    # positional args
    make j as Int = 0
    loop while j < list.len(a.args)
      if attr.value_is_name(a.args[j], "cmp") give true .end
      set j += 1
    .end
    # named args: derive = [cmp, ...]
    j = 0
    loop while j < list.len(a.named)
      if a.named[j].key == "value"
        if attr.value_contains_name(a.named[j].value, "cmp") give true .end
      .end
      set j += 1
    .end
  .end
  set i += 1
.end
give false
.end


<<< =========================================================
  2) TYPE INFO EXTRACTION (form fields)
========================================================= >>>

form FieldInfo
field name as Text = ""
field ty as expand.Node = expand.Node()   # Type node
field span as span.Span = span.Span()
.end

form TypeInfo
field ok as Bool = false
field type_name as Text = ""
field fields as List of FieldInfo = []
field span as span.Span = span.Span()
.end

proc _collect_form_info(item as expand.Node, diags as List of diag.Diagnostic) gives TypeInfo
make t as TypeInfo = TypeInfo()
set t.ok = false
set t.type_name = item.text
set t.fields = []
set t.span = item.span

if t.type_name == ""
  list.push(diags, diag.error("derive-cmp-missing-type-name", item.span))
  give t
.end

# fields are children with tag "field"
make i as Int = 0
loop while i < list.len(item.kids)
  make k as expand.Node = item.kids[i]
  if k.tag == "field"
    make f as FieldInfo = FieldInfo()
    set f.name = k.text
    set f.span = k.span
    # field type is the first Type child
    make j as Int = 0
    loop while j < list.len(k.kids)
      if k.kids[j].kind is expand.NodeKind.Type()
        set f.ty = k.kids[j]
        loop while false .end
      .end
      set j += 1
    .end
    if f.name == ""
      list.push(diags, diag.error("derive-cmp-empty-field", k.span))
    else
      list.push(t.fields, f)
    .end
  .end
  set i += 1
.end

if list.len(t.fields) == 0
  list.push(diags, diag.error("derive-cmp-no-fields", item.span))
  give t
.end

set t.ok = true
give t
.end


<<< =========================================================
  3) NAME POLICY
========================================================= >>>

proc _member_name(t as TypeInfo, member as Text, cfg as DeriveCmpConfig) gives Text
if cfg.namespace_style == "member_Type"
  give member + "_" + t.type_name
.end
give t.type_name + "." + member
.end

proc _param_type_node(type_name as Text) gives expand.Node
make ty as expand.Node = expand.node_make(expand.node_id_make(0u32), expand.NodeKind.Type(), "named", span.Span())
set ty.text = type_name
give ty
.end

proc _bool_type_node() gives expand.Node
make ty as expand.Node = expand.node_make(expand.node_id_make(0u32), expand.NodeKind.Type(), "named", span.Span())
set ty.text = "Bool"
give ty
.end

proc _i32_type_node(cfg as DeriveCmpConfig) gives expand.Node
make ty as expand.Node = expand.node_make(expand.node_id_make(0u32), expand.NodeKind.Type(), "named", span.Span())
set ty.text = cfg.order_return_type
give ty
.end


<<< =========================================================
  4) GENERATE EQ
========================================================= >>>

proc _gen_eq_proc(t as TypeInfo, cfg as DeriveCmpConfig) gives expand.Node
# proc Type.eq(a as Type, b as Type) gives Bool
make p as expand.Node = expand.node_make(expand.node_id_make(0u32), expand.NodeKind.Item(), "proc", t.span)
set p.text = _member_name(t, cfg.eq_name, cfg)

# params
make params as expand.Node = expand.node_make(expand.node_id_make(0u32), expand.NodeKind.Item(), "params", t.span)

make pa as expand.Node = _param("a", _param_type_node(t.type_name))
make pb as expand.Node = _param("b", _param_type_node(t.type_name))
list.push(params.kids, pa)
list.push(params.kids, pb)
list.push(p.kids, params)

# ret
make ret as expand.Node = expand.node_make(expand.node_id_make(0u32), expand.NodeKind.Item(), "ret", t.span)
list.push(ret.kids, _bool_type_node())
list.push(p.kids, ret)

# block
make blk as expand.Node = expand.node_make(expand.node_id_make(0u32), expand.NodeKind.Stmt(), "block", t.span)
# compute: a.f1 == b.f1 and a.f2 == b.f2 ...
make expr as expand.Node = _eq_chain_expr(t)
make g as expand.Node = expand.node_make(expand.node_id_make(0u32), expand.NodeKind.Stmt(), "give", t.span)
list.push(g.kids, expr)
list.push(blk.kids, g)

list.push(p.kids, _wrap_block(blk))
give p
.end

proc _eq_chain_expr(t as TypeInfo) gives expand.Node
# build binary chain with "and"
make i as Int = 0
make cur as expand.Node = expand.Node()

loop while i < list.len(t.fields)
  make f as FieldInfo = t.fields[i]
  make left as expand.Node = _field(_name("a"), f.name)
  make right as expand.Node = _field(_name("b"), f.name)
  make eq as expand.Node = _binary(left, "==", right)

  if i == 0
    set cur = eq
  else
    set cur = _binary(cur, "and", eq)
  .end
  set i += 1
.end

give cur
.end


<<< =========================================================
  5) GENERATE CMP (lexicographic)
========================================================= >>>

proc _gen_cmp_proc(t as TypeInfo, cfg as DeriveCmpConfig) gives expand.Node
# proc Type.cmp(a as Type, b as Type) gives I32
make p as expand.Node = expand.node_make(expand.node_id_make(0u32), expand.NodeKind.Item(), "proc", t.span)
set p.text = _member_name(t, cfg.cmp_name, cfg)

# params
make params as expand.Node = expand.node_make(expand.node_id_make(0u32), expand.NodeKind.Item(), "params", t.span)
list.push(params.kids, _param("a", _param_type_node(t.type_name)))
list.push(params.kids, _param("b", _param_type_node(t.type_name)))
list.push(p.kids, params)

# ret
make ret as expand.Node = expand.node_make(expand.node_id_make(0u32), expand.NodeKind.Item(), "ret", t.span)
list.push(ret.kids, _i32_type_node(cfg))
list.push(p.kids, ret)

# block: for each field:
#   make da = a.f
#   make db = b.f
#   if da < db give -1
#   if da > db give 1
# finally give 0
make blk as expand.Node = expand.node_make(expand.node_id_make(0u32), expand.NodeKind.Stmt(), "block", t.span)

make i as Int = 0
loop while i < list.len(t.fields)
  make f as FieldInfo = t.fields[i]

  make da as expand.Node = _make("da", _field(_name("a"), f.name))
  make db as expand.Node = _make("db", _field(_name("b"), f.name))
  list.push(blk.kids, da)
  list.push(blk.kids, db)

  # if da < db => give -1
  list.push(blk.kids, _if_give(_binary(_name("da"), "<", _name("db")), _int_lit("-1")))
  # if da > db => give 1
  list.push(blk.kids, _if_give(_binary(_name("da"), ">", _name("db")), _int_lit("1")))

  set i += 1
.end

# give 0
make g as expand.Node = expand.node_make(expand.node_id_make(0u32), expand.NodeKind.Stmt(), "give", t.span)
list.push(g.kids, _int_lit("0"))
list.push(blk.kids, g)

list.push(p.kids, _wrap_block(blk))
give p
.end


proc _gen_ops(t as TypeInfo, cfg as DeriveCmpConfig) gives List of expand.Node
# lt/le/gt/ge based on cmp result
make out as List of expand.Node = []
list.push(out, _gen_op(t, cfg, "lt", "<"))
list.push(out, _gen_op(t, cfg, "le", "<="))
list.push(out, _gen_op(t, cfg, "gt", ">"))
list.push(out, _gen_op(t, cfg, "ge", ">="))
give out
.end

proc _gen_op(t as TypeInfo, cfg as DeriveCmpConfig, name as Text, op as Text) gives expand.Node
# proc Type.lt(a,b) gives Bool => give Type.cmp(a,b) < 0
make p as expand.Node = expand.node_make(expand.node_id_make(0u32), expand.NodeKind.Item(), "proc", t.span)
set p.text = _member_name(t, name, cfg)

make params as expand.Node = expand.node_make(expand.node_id_make(0u32), expand.NodeKind.Item(), "params", t.span)
list.push(params.kids, _param("a", _param_type_node(t.type_name)))
list.push(params.kids, _param("b", _param_type_node(t.type_name)))
list.push(p.kids, params)

make ret as expand.Node = expand.node_make(expand.node_id_make(0u32), expand.NodeKind.Item(), "ret", t.span)
list.push(ret.kids, _bool_type_node())
list.push(p.kids, ret)

make blk as expand.Node = expand.node_make(expand.node_id_make(0u32), expand.NodeKind.Stmt(), "block", t.span)
make call as expand.Node = _call(_path(_member_name(t, cfg.cmp_name, cfg)), [_name("a"), _name("b")])
make cmp0 as expand.Node = _binary(call, op, _int_lit("0"))
make g as expand.Node = expand.node_make(expand.node_id_make(0u32), expand.NodeKind.Stmt(), "give", t.span)
list.push(g.kids, cmp0)
list.push(blk.kids, g)

list.push(p.kids, _wrap_block(blk))
give p
.end


<<< =========================================================
  6) GENERATE HASH
========================================================= >>>

proc _gen_hash_proc(t as TypeInfo, cfg as DeriveCmpConfig) gives expand.Node
# proc Type.hash_into(state as HashState, value as Type)
# For MAX robustness, we generate a minimal deterministic hash combiner call per field:
#   emit builtin.hash_field(state, value.field)
make p as expand.Node = expand.node_make(expand.node_id_make(0u32), expand.NodeKind.Item(), "proc", t.span)
set p.text = _member_name(t, cfg.hash_name, cfg)

make params as expand.Node = expand.node_make(expand.node_id_make(0u32), expand.NodeKind.Item(), "params", t.span)
list.push(params.kids, _param("state", _param_type_node("HashState")))
list.push(params.kids, _param("value", _param_type_node(t.type_name)))
list.push(p.kids, params)

# no return
make blk as expand.Node = expand.node_make(expand.node_id_make(0u32), expand.NodeKind.Stmt(), "block", t.span)

make i as Int = 0
loop while i < list.len(t.fields)
  make f as FieldInfo = t.fields[i]
  make cal as expand.Node = _call(_path("builtin.hash_field"), [_name("state"), _field(_name("value"), f.name)])
  make em as expand.Node = expand.node_make(expand.node_id_make(0u32), expand.NodeKind.Stmt(), "emit", t.span)
  list.push(em.kids, cal)
  list.push(blk.kids, em)
  set i += 1
.end

make g as expand.Node = expand.node_make(expand.node_id_make(0u32), expand.NodeKind.Stmt(), "give", t.span)
list.push(blk.kids, g)

list.push(p.kids, _wrap_block(blk))
give p
.end


<<< =========================================================
  7) NODE BUILDERS (small DSL)
========================================================= >>>

proc _wrap_block(blk as expand.Node) gives expand.Node
# In this project, proc items carry a child node tagged "block".
make n as expand.Node = expand.node_make(expand.node_id_make(0u32), expand.NodeKind.Item(), "block", blk.span)
set n.kids = blk.kids
give n
.end

proc _param(name as Text, ty as expand.Node) gives expand.Node
make p as expand.Node = expand.node_make(expand.node_id_make(0u32), expand.NodeKind.Item(), "param", span.Span())
set p.text = name
list.push(p.kids, ty)
give p
.end

proc _name(s as Text) gives expand.Node
make n as expand.Node = expand.node_make(expand.node_id_make(0u32), expand.NodeKind.Expr(), "name", span.Span())
set n.text = s
give n
.end

proc _path(s as Text) gives expand.Node
make n as expand.Node = expand.node_make(expand.node_id_make(0u32), expand.NodeKind.Expr(), "path", span.Span())
set n.text = s
give n
.end

proc _int_lit(s as Text) gives expand.Node
make n as expand.Node = expand.node_make(expand.node_id_make(0u32), expand.NodeKind.Expr(), "int", span.Span())
set n.text = s
give n
.end

proc _call(callee as expand.Node, args as List of expand.Node) gives expand.Node
make n as expand.Node = expand.node_make(expand.node_id_make(0u32), expand.NodeKind.Expr(), "call", span.Span())
list.push(n.kids, callee)
make i as Int = 0
loop while i < list.len(args)
  list.push(n.kids, args[i])
  set i += 1
.end
give n
.end

proc _field(base as expand.Node, name as Text) gives expand.Node
make n as expand.Node = expand.node_make(expand.node_id_make(0u32), expand.NodeKind.Expr(), "field", span.Span())
set n.text = name
list.push(n.kids, base)
give n
.end

proc _binary(l as expand.Node, op as Text, r as expand.Node) gives expand.Node
make n as expand.Node = expand.node_make(expand.node_id_make(0u32), expand.NodeKind.Expr(), "binary", span.Span())
list.push(n.kids, l)
make o as expand.Node = expand.node_make(expand.node_id_make(0u32), expand.NodeKind.Expr(), "op", span.Span())
set o.text = op
list.push(n.kids, o)
list.push(n.kids, r)
give n
.end

proc _make(name as Text, init as expand.Node) gives expand.Node
make st as expand.Node = expand.node_make(expand.node_id_make(0u32), expand.NodeKind.Stmt(), "make", span.Span())
set st.text = name
list.push(st.kids, init)
give st
.end

proc _if_give(cond as expand.Node, value as expand.Node) gives expand.Node
make st as expand.Node = expand.node_make(expand.node_id_make(0u32), expand.NodeKind.Stmt(), "if", span.Span())
list.push(st.kids, cond)
make blk as expand.Node = expand.node_make(expand.node_id_make(0u32), expand.NodeKind.Stmt(), "block", span.Span())
make g as expand.Node = expand.node_make(expand.node_id_make(0u32), expand.NodeKind.Stmt(), "give", span.Span())
list.push(g.kids, value)
list.push(blk.kids, g)
list.push(st.kids, blk)
give st
.end


<<< =========================================================
  8) SMOKE TEST
========================================================= >>>

proc _test(diags as List of diag.Diagnostic)
# form Point with @derive(cmp)
make item as expand.Node = expand.node_make(expand.node_id_make(1u32), expand.NodeKind.Item(), "form", span.Span())
set item.text = "Point"
# fake attr
set item.attrs = []
list.push(item.attrs, attr.attribute_derive(["cmp"]))

# fields
make fx as expand.Node = expand.node_make(expand.node_id_make(2u32), expand.NodeKind.Item(), "field", span.Span())
set fx.text = "x"
list.push(fx.kids, _param_type_node("I32"))
list.push(item.kids, fx)

make fy as expand.Node = expand.node_make(expand.node_id_make(3u32), expand.NodeKind.Item(), "field", span.Span())
set fy.text = "y"
list.push(fy.kids, _param_type_node("I32"))
list.push(item.kids, fy)

make cfg as DeriveCmpConfig = derive_cmp_config_default()
make res as DeriveCmpResult = derive_cmp_on_item(item, cfg, diags)

emit text.from_int(list.len(res.extra_items))
give
.end
