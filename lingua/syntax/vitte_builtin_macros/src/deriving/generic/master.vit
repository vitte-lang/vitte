vitte 1.0
space lingua/syntax/vitte_builtin_macros/deriving/generic/master

<<< master
  vitte_builtin_macros/deriving/generic/master.vit â€” Builtin derive engine (generic) (MAX)

  Goal:
    - Provide a unified derive pipeline for builtin macros:
        * cmp (eq/ord/hash)
        * clone
        * debug
        * default
        * serialize / deserialize (optional)
    - Work in a compilation-friendly way:
        * deterministic output
        * no runtime reflection
        * predictable naming and scoping
        * schema validation with good diagnostics
    - Allow multiple derive requests:
        @derive(cmp, debug, clone)
    - Support basic knobs:
        @derive(cmp(kind="eq", ops=true))
        @derive(debug(style="compact"))
        @derive(default)
    - Keep "derive" data model stable so later codegen stages can use it.

  Inputs:
    - expanded AST items (types)
    - attribute list (normalized)
    - registry of builtin derivations (handlers)

  Outputs:
    - a list of extra items inserted into module scope
    - diagnostics

  Note:
    - This module does NOT parse attributes; it consumes normalized Attribute from vitte_attr_parsing.
>>>

pull std/text as text
pull std/collections/list as list
pull std/collections/map as map

pull lingua/syntax/vitte_ast/span as span
pull lingua/syntax/vitte_ast/diag as diag
pull lingua/syntax/vitte_ast/attr/master as attr
pull lingua/syntax/vitte_ast/expand/master as expand

pull lingua/syntax/vitte_builtin_macros/deriving/cmp/master as derive_cmp

share all

bond Text means String


<<< =========================================================
  0) DERIVE REQUEST MODEL
========================================================= >>>

pick DeriveName
case Cmp()
case Debug()
case Clone()
case Default()
case Hash()
case Serde()
case Custom()
.end

form DeriveArg
field key as Text = ""                # empty => positional
field value as attr.AttrValue = attr.AttrValue()
field span as span.Span = span.Span()
.end

form DeriveRequest
field name as Text = ""               # "cmp" / "debug" / ...
field args as List of DeriveArg = []
field span as span.Span = span.Span()
.end

form DeriveSet
field items as List of DeriveRequest = []
field span as span.Span = span.Span()
.end

proc derive_set_empty() gives DeriveSet
make s as DeriveSet = DeriveSet()
set s.items = []
give s
.end


<<< =========================================================
  1) MAIN API
========================================================= >>>

form DeriveEngineConfig
field allow_unknown as Bool = false
field stop_on_error as Bool = false
field stable_order as Bool = true
field builtin_only as Bool = true
.end

proc derive_engine_config_default() gives DeriveEngineConfig
give DeriveEngineConfig()
.end

form DeriveEngineStats
field items_seen as U64 = 0u64
field items_with_derive as U64 = 0u64
field derives_total as U64 = 0u64
field derives_applied as U64 = 0u64
field derives_skipped as U64 = 0u64
field errors as U64 = 0u64
.end

form DeriveEngineResult
field extra_items as List of expand.Node = []
field stats as DeriveEngineStats = DeriveEngineStats()
.end


proc apply_derives_to_item(item as expand.Node, cfg as DeriveEngineConfig, diags as List of diag.Diagnostic) gives DeriveEngineResult
# Reads @derive(...) on a type item and dispatches to builtin derive handlers.
make out as DeriveEngineResult = DeriveEngineResult()
set out.extra_items = []
set out.stats = DeriveEngineStats()
set out.stats.items_seen = 1u64

make dset as DeriveSet = read_derives(item, diags)
if list.len(dset.items) == 0
  give out
.end

set out.stats.items_with_derive = 1u64
set out.stats.derives_total = u64_from_int(list.len(dset.items))

# stable order: sort by known precedence if desired
make reqs as List of DeriveRequest = dset.items
if cfg.stable_order
  set reqs = _stable_sort(reqs)
.end

make i as Int = 0
loop while i < list.len(reqs)
  make req as DeriveRequest = reqs[i]
  make ok as Bool = _dispatch_builtin(item, req, cfg, out, diags)
  if ok
    set out.stats.derives_applied += 1u64
  else
    set out.stats.derives_skipped += 1u64
    set out.stats.errors += 1u64
    if cfg.stop_on_error
      give out
    .end
  .end
  set i += 1
.end

give out
.end


<<< =========================================================
  2) READ @derive(...)
========================================================= >>>

proc read_derives(item as expand.Node, diags as List of diag.Diagnostic) gives DeriveSet
make ds as DeriveSet = derive_set_empty()
set ds.span = item.span

make i as Int = 0
loop while i < list.len(item.attrs)
  make a as attr.Attribute = item.attrs[i]
  if a.name == "derive"
    make reqs as List of DeriveRequest = _derive_requests_from_attribute(a, diags)
    make j as Int = 0
    loop while j < list.len(reqs)
      list.push(ds.items, reqs[j])
      set j += 1
    .end
  .end
  set i += 1
.end

give ds
.end


proc _derive_requests_from_attribute(a as attr.Attribute, diags as List of diag.Diagnostic) gives List of DeriveRequest
# Supported shapes:
#   @derive(cmp, debug)
#   @derive(cmp(kind="eq"))
#   @derive(name="cmp")  (fallback)
#
# In this normalized model:
# - positional: AttrValue.Name("cmp")
# - function-like: Name("cmp") followed by Map/List values (depending on parser conventions)
#
# This module keeps parsing minimal and deterministic.
make out as List of DeriveRequest = []

# If positional args: each Name becomes a request
make i as Int = 0
loop while i < list.len(a.args)
  make v as attr.AttrValue = a.args[i]

  if v.kind is attr.AttrValueKind.Name()
    list.push(out, _req_from_name(v.text, a.span))
  elif v.kind is attr.AttrValueKind.Text()
    # allow "cmp"
    list.push(out, _req_from_name(v.text, a.span))
  elif v.kind is attr.AttrValueKind.Map()
    # allow { name: "cmp", ... }
    list.push(out, _req_from_map(v, a.span, diags))
  else
    list.push(diags, diag.warn("derive-arg-ignored", a.span))
  .end

  set i += 1
.end

# If named args: allow derive = [cmp, ...] or derive(name="cmp")
if list.len(a.named) > 0
  make j as Int = 0
  loop while j < list.len(a.named)
    if a.named[j].key == "name"
      list.push(out, _req_from_name(attr.value_text(a.named[j].value), a.span))
    elif a.named[j].key == "value"
      # allow list
      make v as attr.AttrValue = a.named[j].value
      if v.kind is attr.AttrValueKind.List()
        make k as Int = 0
        loop while k < list.len(v.items)
          if v.items[k].kind is attr.AttrValueKind.Name()
            list.push(out, _req_from_name(v.items[k].text, a.span))
          elif v.items[k].kind is attr.AttrValueKind.Text()
            list.push(out, _req_from_name(v.items[k].text, a.span))
          .end
          set k += 1
        .end
      .end
    .end
    set j += 1
  .end
.end

# dedup by name (keep first) for robustness
give _dedup_keep_first(out)
.end


proc _req_from_name(name as Text, sp as span.Span) gives DeriveRequest
make r as DeriveRequest = DeriveRequest()
set r.name = text.trim(name)
set r.args = []
set r.span = sp
give r
.end

proc _req_from_map(v as attr.AttrValue, sp as span.Span, diags as List of diag.Diagnostic) gives DeriveRequest
make r as DeriveRequest = DeriveRequest()
set r.name = ""
set r.args = []
set r.span = sp

# find "name" entry
make i as Int = 0
loop while i < list.len(v.pairs)
  if v.pairs[i].key == "name"
    set r.name = text.trim(attr.value_text(v.pairs[i].value))
  else
    make da as DeriveArg = DeriveArg()
    set da.key = v.pairs[i].key
    set da.value = v.pairs[i].value
    set da.span = sp
    list.push(r.args, da)
  .end
  set i += 1
.end

if r.name == ""
  list.push(diags, diag.error("derive-map-missing-name", sp))
.end

give r
.end


<<< =========================================================
  3) DISPATCH BUILTIN DERIVES
========================================================= >>>

proc _dispatch_builtin(item as expand.Node, req as DeriveRequest, cfg as DeriveEngineConfig, out as DeriveEngineResult, diags as List of diag.Diagnostic) gives Bool
make name as Text = req.name
if name == ""
  list.push(diags, diag.error("derive-empty-name", req.span))
  give false
.end

# cmp
if name == "cmp"
  make dcfg as derive_cmp.DeriveCmpConfig = derive_cmp.derive_cmp_config_default()
  set dcfg.kind = _cmp_kind_from_args(req.args, diags, req.span)
  set dcfg.emit_ops = _cmp_ops_from_args(req.args)
  make r as derive_cmp.DeriveCmpResult = derive_cmp.derive_cmp_on_item(item, dcfg, diags)

  make i as Int = 0
  loop while i < list.len(r.extra_items)
    list.push(out.extra_items, r.extra_items[i])
    set i += 1
  .end
  give (r.stats.errors == 0u64)
.end

# debug/clone/default can be wired later
if name == "debug"
  list.push(diags, diag.warn("derive-debug-unimplemented", req.span))
  give false
.end
if name == "clone"
  list.push(diags, diag.warn("derive-clone-unimplemented", req.span))
  give false
.end
if name == "default"
  list.push(diags, diag.warn("derive-default-unimplemented", req.span))
  give false
.end

# unknown
if cfg.allow_unknown
  list.push(diags, diag.note("derive-unknown-ignored", req.span))
  give true
.end

list.push(diags, diag.error("derive-unknown-name", req.span))
give false
.end


proc _cmp_kind_from_args(args as List of DeriveArg, diags as List of diag.Diagnostic, sp as span.Span) gives derive_cmp.DeriveCmpKind
# Accept:
#   @derive({name:"cmp", kind:"eq"})
#   @derive(cmp, kind="ord")   (depending on attribute parser model)
make i as Int = 0
loop while i < list.len(args)
  if args[i].key == "kind"
    make v as Text = text.lower(attr.value_text(args[i].value))
    if v == "eq" give derive_cmp.DeriveCmpKind.Eq() .end
    if v == "ord" give derive_cmp.DeriveCmpKind.Ord() .end
    if v == "hash" give derive_cmp.DeriveCmpKind.Hash() .end
    if v == "full" give derive_cmp.DeriveCmpKind.Full() .end
    list.push(diags, diag.error("derive-cmp-kind-invalid", sp))
    give derive_cmp.DeriveCmpKind.Full()
  .end
  set i += 1
.end
give derive_cmp.DeriveCmpKind.Full()
.end

proc _cmp_ops_from_args(args as List of DeriveArg) gives Bool
make i as Int = 0
loop while i < list.len(args)
  if args[i].key == "ops"
    make v as Text = text.lower(attr.value_text(args[i].value))
    if v == "false" give false .end
    if v == "0" give false .end
    give true
  .end
  set i += 1
.end
give true
.end


<<< =========================================================
  4) UTIL: STABLE SORT + DEDUP
========================================================= >>>

proc _rank(name as Text) gives Int
# fixed order to keep generated code predictable
if name == "cmp" give 10 .end
if name == "clone" give 20 .end
if name == "debug" give 30 .end
if name == "default" give 40 .end
if name == "hash" give 50 .end
if name == "serde" give 60 .end
give 999
.end

proc _stable_sort(xs as List of DeriveRequest) gives List of DeriveRequest
# insertion sort (small lists)
make out as List of DeriveRequest = xs
make n as Int = list.len(out)
make i as Int = 1
loop while i < n
  make key as DeriveRequest = out[i]
  make rk as Int = _rank(key.name)
  make j as Int = i - 1
  loop while j >= 0 and _rank(out[j].name) > rk
    set out[j + 1] = out[j]
    set j -= 1
  .end
  set out[j + 1] = key
  set i += 1
.end
give out
.end

proc _dedup_keep_first(xs as List of DeriveRequest) gives List of DeriveRequest
make out as List of DeriveRequest = []
make seen as Map of Text to Bool = map.new()

make i as Int = 0
loop while i < list.len(xs)
  if seen[xs[i].name] != true
    set seen[xs[i].name] = true
    list.push(out, xs[i])
  .end
  set i += 1
.end

give out
.end

proc u64_from_int(x as Int) gives U64
# placeholder; replace with builtin cast when available
give 0u64
.end


<<< =========================================================
  5) SMOKE TEST
========================================================= >>>

proc _test(diags as List of diag.Diagnostic)
make item as expand.Node = expand.node_make(expand.node_id_make(1u32), expand.NodeKind.Item(), "form", span.Span())
set item.text = "Point"
set item.attrs = []
list.push(item.attrs, attr.attribute_derive(["cmp", "debug"]))

make cfg as DeriveEngineConfig = derive_engine_config_default()
make r as DeriveEngineResult = apply_derives_to_item(item, cfg, diags)

emit text.from_int(list.len(r.extra_items))
give
.end
