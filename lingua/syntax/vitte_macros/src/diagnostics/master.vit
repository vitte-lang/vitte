# File: C:\Users\gogin\Documents\GitHub\vitte\lingua\syntax\vitte_macros\src\diagnostics\master.vit
space lingua/syntax/vitte_macros/diagnostics/master

<<< master
  vitte_macros/diagnostics/master.vit â€” Macro diagnostics subsystem (MAX)

  Purpose:
    - Provide a stable, compiler-grade diagnostics layer used by:
        * builtin macros (printf format, derive-like, etc.)
        * MBE expander (macro-by-example)
        * macro dispatcher / expansion driver
    - Ensure diagnostics are:
        * deterministic
        * span-precise (byte offsets)
        * localizable (messages.ftl keys)
        * structured (severity, code, labels, notes, helps)
        * easy to build from macros without depending on full parser internals

  Design:
    - Diagnostic builder API: error/warn/note/help
    - Labels: primary/secondary spans with messages
    - Suggestions (optional): replacements with applicability
    - Emission: push into List<diag.Diagnostic> (AST diag type), but can also
      maintain a macro-local buffer.

  Integration:
    - This module intentionally mirrors lingua/syntax/vitte_ast/diag but provides
      convenience helpers and macro-specific codes/namespacing.
>>>

pull std/text as text
pull std/collections/list as list
pull std/collections/map as map

pull lingua/syntax/vitte_ast/span as span
pull lingua/syntax/vitte_ast/diag as ast_diag

share all

bond Text means String


<<< =========================================================
  0) PUBLIC TYPES
========================================================= >>>

pick Applicability
case MachineApplicable()
case MaybeIncorrect()
case HasPlaceholders()
case Unspecified()
.end

pick LabelStyle
case Primary()
case Secondary()
.end

form Label
field style as LabelStyle = LabelStyle.Primary()
field sp as span.Span = span.Span()
field message as Text = ""
.end

form FixIt
field replacement as Text = ""
field sp as span.Span = span.Span()
field applicability as Applicability = Applicability.Unspecified()
.end

form Diagnostic
field severity as ast_diag.Severity = ast_diag.Severity.Error()
field code as Text = ""               # stable code string, e.g. "vitte-macro-printf"
field message_key as Text = ""        # Fluent key, e.g. "vitte-macro-e-printf-percent-n"
field message as Text = ""            # optional resolved message (debug mode)
field sp as span.Span = span.Span()   # primary span fallback
field labels as List of Label = []
field notes as List of Text = []
field helps as List of Text = []
field fixits as List of FixIt = []
field meta as Map of Text to Text = map.new()    # extra key/values (e.g., {var:"x"})
.end

proc diag_new() gives Diagnostic
give Diagnostic()
.end

proc diag_push(buf as List of Diagnostic, d as Diagnostic)
list.push(buf, d)
.end


<<< =========================================================
  1) BUILDERS (ERROR / WARN / NOTE / HELP)
========================================================= >>>

proc error(code as Text, key as Text, sp as span.Span) gives Diagnostic
make d as Diagnostic = diag_new()
set d.severity = ast_diag.Severity.Error()
set d.code = code
set d.message_key = key
set d.sp = sp
give d
.end

proc warn(code as Text, key as Text, sp as span.Span) gives Diagnostic
make d as Diagnostic = diag_new()
set d.severity = ast_diag.Severity.Warning()
set d.code = code
set d.message_key = key
set d.sp = sp
give d
.end

proc note(code as Text, key as Text, sp as span.Span) gives Diagnostic
make d as Diagnostic = diag_new()
set d.severity = ast_diag.Severity.Note()
set d.code = code
set d.message_key = key
set d.sp = sp
give d
.end

proc help(code as Text, key as Text, sp as span.Span) gives Diagnostic
make d as Diagnostic = diag_new()
set d.severity = ast_diag.Severity.Help()
set d.code = code
set d.message_key = key
set d.sp = sp
give d
.end


<<< =========================================================
  2) LABELS / NOTES / HELPS / META
========================================================= >>>

proc add_primary(d as Diagnostic, sp as span.Span, msg as Text)
make l as Label = Label()
set l.style = LabelStyle.Primary()
set l.sp = sp
set l.message = msg
list.push(d.labels, l)
.end

proc add_secondary(d as Diagnostic, sp as span.Span, msg as Text)
make l as Label = Label()
set l.style = LabelStyle.Secondary()
set l.sp = sp
set l.message = msg
list.push(d.labels, l)
.end

proc add_note(d as Diagnostic, msg as Text)
list.push(d.notes, msg)
.end

proc add_help(d as Diagnostic, msg as Text)
list.push(d.helps, msg)
.end

proc add_meta(d as Diagnostic, k as Text, v as Text)
map.set(d.meta, k, v)
.end

proc add_fixit(d as Diagnostic, sp as span.Span, repl as Text, app as Applicability)
make f as FixIt = FixIt()
set f.sp = sp
set f.replacement = repl
set f.applicability = app
list.push(d.fixits, f)
.end


<<< =========================================================
  3) CONVERSION TO AST DIAGNOSTIC
========================================================= >>>

proc to_ast(d as Diagnostic) gives ast_diag.Diagnostic
# This maps the macro diagnostic into the compiler's canonical diagnostic type.
# Replace this with the real conversion when ast_diag has concrete fields.
make out as ast_diag.Diagnostic = ast_diag.Diagnostic()
set out.severity = d.severity
set out.code = d.code
set out.message_key = d.message_key
set out.span = d.sp

# labels / notes / helps / fixits can be mapped if supported; otherwise keep as notes.
make i as Int = 0
loop while i < list.len(d.labels)
  ast_diag.add_label(out, d.labels[i].sp, d.labels[i].message, (d.labels[i].style is LabelStyle.Primary()))
  set i += 1
.end

set i = 0
loop while i < list.len(d.notes)
  ast_diag.add_note(out, d.notes[i])
  set i += 1
.end

set i = 0
loop while i < list.len(d.helps)
  ast_diag.add_help(out, d.helps[i])
  set i += 1
.end

set i = 0
loop while i < list.len(d.fixits)
  ast_diag.add_fixit(out, d.fixits[i].sp, d.fixits[i].replacement, _app_to_text(d.fixits[i].applicability))
  set i += 1
.end

give out
.end

proc _app_to_text(a as Applicability) gives Text
if a is Applicability.MachineApplicable() give "machine-applicable" .end
if a is Applicability.MaybeIncorrect() give "maybe-incorrect" .end
if a is Applicability.HasPlaceholders() give "has-placeholders" .end
give "unspecified"
.end


<<< =========================================================
  4) MACRO NAMESPACES (RECOMMENDED CODES / KEYS)
========================================================= >>>

# Standard code prefixes for this crate
bond CODE_MBE means "vitte-macro-mbe"
bond CODE_PRINTF means "vitte-macro-printf"
bond CODE_BUILTIN means "vitte-macro-builtin"
bond CODE_DERIVE means "vitte-macro-derive"
bond CODE_ATTR means "vitte-macro-attr"

# Helpers to build common mbe diags
proc mbe_error(key as Text, sp as span.Span) gives Diagnostic
give error(CODE_MBE, key, sp)
.end

proc printf_error(key as Text, sp as span.Span) gives Diagnostic
give error(CODE_PRINTF, key, sp)
.end


<<< =========================================================
  5) EMIT HELPERS (DIRECT INTO AST BUFFER)
========================================================= >>>

proc push_error_ast(buf as List of ast_diag.Diagnostic, code as Text, key as Text, sp as span.Span)
make d as Diagnostic = error(code, key, sp)
list.push(buf, to_ast(d))
.end

proc push_warn_ast(buf as List of ast_diag.Diagnostic, code as Text, key as Text, sp as span.Span)
make d as Diagnostic = warn(code, key, sp)
list.push(buf, to_ast(d))
.end


<<< =========================================================
  6) SMOKE TEST
========================================================= >>>

proc _test(buf as List of ast_diag.Diagnostic)
make d as Diagnostic = error(CODE_MBE, "vitte-expand-e-no-rules", span.Span())
add_primary(d, span.Span(), "macro has no rules")
add_help(d, "define at least one rule: (pat) => (tpl)")
add_note(d, "enable tracing with --trace-macros")
list.push(buf, to_ast(d))
give
.end
