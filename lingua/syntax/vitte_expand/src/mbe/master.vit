# File: C:\Users\gogin\Documents\GitHub\vitte\lingua\syntax\vitte_expand\src\mbe\master.vit
space lingua/syntax/vitte_expand/mbe/master

<<< master
  vitte_expand/mbe/master.vit — MBE macro expander (MAX, TT-in → TT-out)

  Purpose:
    - Compiler-facing Macro-By-Example expander:
        * compile pattern TT → matcher IR
        * match input TT against rules (deterministic, first rule wins)
        * capture metavariables ($name[:frag]) with nested repetition
        * transcribe template TT using captures (supports repetition nesting)
        * emit stable diagnostics

  This file is self-contained at the algorithm level.
  It assumes a TokenTree module `tt` and diagnostics `diag` exist.

  Notes:
    - Fragment validation (expr/ty/etc) is not performed here; FragSpec is carried as metadata.
    - Repetition syntax supported (Rust-like TT form):
        * $name
        * $name:frag
        * $( ... )*
        * $( ... )+
        * $( ... )?
        * optional single-token separator between group and op, e.g. $( $i ),*
>>>

pull std/text as text
pull std/collections/list as list
pull std/collections/map as map

pull lingua/syntax/vitte_ast/span as span
pull lingua/syntax/vitte_ast/diag as diag
pull lingua/syntax/vitte_token_tree/master as tt

share all

bond Text means String


<<< =========================================================
  0) PUBLIC API
========================================================= >>>

form MbeRule
field pat as List of tt.Tt = []
field tpl as List of tt.Tt = []
field span as span.Span = span.Span()
.end

form ExpandRequest
field rules as List of MbeRule = []
field input as List of tt.Tt = []
field call_span as span.Span = span.Span()
field macro_name as Text = ""
field trace as Bool = false
.end

form ExpandResult
field ok as Bool = true
field output as List of tt.Tt = []
field matched_rule as Int = -1
field notes as List of Text = []
.end

proc expand(req as ExpandRequest, diags as List of diag.Diagnostic) gives ExpandResult
make out as ExpandResult = ExpandResult()
set out.ok = false

if list.len(req.rules) == 0
  list.push(diags, diag.error("mbe-no-rules", req.call_span))
  give out
.end

make compiled as List of CompiledRule = _compile_rules(req.rules, diags)
if list.len(compiled) == 0
  list.push(diags, diag.error("mbe-rules-invalid", req.call_span))
  give out
.end

make ri as Int = 0
loop while ri < list.len(compiled)
  make caps as Captures = captures_new()
  make st as MatchState = match_state_new(req.input)

  make ok as Bool = _match_seq(compiled[ri].pat, st, caps, diags, req.trace).ok
  if ok
    set out.ok = true
    set out.matched_rule = ri
    make tr as TranscribeCtx = transcribe_ctx_new(compiled[ri].tpl, caps, req.call_span, diags, req.trace)
    set out.output = _transcribe_top(tr)
    give out
  .end

  set ri += 1
.end

list.push(diags, diag.error("mbe-no-rules-matched", req.call_span))
give out
.end


<<< =========================================================
  1) INTERNAL IR (PATTERN + TEMPLATE NODES)
========================================================= >>>

pick FragSpec
case Ident()
case Path()
case Ty()
case Expr()
case Stmt()
case Pat()
case Item()
case Block()
case Meta()
case Tt()
case Literal()
case Unknown()
.end

proc frag_from_name(name as Text) gives FragSpec
if name == "ident"   give FragSpec.Ident()   .end
if name == "path"    give FragSpec.Path()    .end
if name == "ty"      give FragSpec.Ty()      .end
if name == "expr"    give FragSpec.Expr()    .end
if name == "stmt"    give FragSpec.Stmt()    .end
if name == "pat"     give FragSpec.Pat()     .end
if name == "item"    give FragSpec.Item()    .end
if name == "block"   give FragSpec.Block()   .end
if name == "meta"    give FragSpec.Meta()    .end
if name == "tt"      give FragSpec.Tt()      .end
if name == "literal" give FragSpec.Literal() .end
give FragSpec.Unknown()
.end

pick RepOp
case ZeroOrMore()
case OneOrMore()
case Optional()
.end

form RepeatSpec
field op as RepOp = RepOp.ZeroOrMore()
field sep as tt.Tt = tt.tt_none()
field has_sep as Bool = false
.end

# Pattern nodes
pick PatNode
case Lit(tt.Tt)                        # exact token or delim group (structure checked)
case Meta(name=Text, frag=FragSpec)    # capture single tt subtree (leaf or group)
case Repeat(body=List of PatNode, spec=RepeatSpec, span=span.Span)
.end

# Template nodes
pick TplNode
case Lit(tt.Tt)                        # literal output node
case Meta(name=Text, span=span.Span)   # splice capture
case Repeat(body=List of TplNode, spec=RepeatSpec, span=span.Span)
.end

form CompiledRule
field pat as List of PatNode = []
field tpl as List of TplNode = []
field span as span.Span = span.Span()
.end


<<< =========================================================
  2) CAPTURES (BINDINGS)
========================================================= >>>

# Capture value supports nested repetition:
# - Atom: a concrete token-tree sequence
# - Many: list of capture values (one per repetition iteration)
pick CapVal
case Atom(ts=List of tt.Tt)
case Many(xs=List of CapVal)
.end

form Captures
field map as Map of Text to CapVal = map.new()
.end

proc captures_new() gives Captures
give Captures()
.end

proc cap_has(c as Captures, name as Text) gives Bool
give map.has(c.map, name)
.end

proc cap_get(c as Captures, name as Text) gives CapVal
# caller must ensure exists
give map.get(c.map, name)
.end

proc cap_set(c as Captures, name as Text, v as CapVal)
map.set(c.map, name, v)
.end

proc cap_push_many(c as Captures, name as Text, v as CapVal)
# Ensure binding is Many and append; used for repetition capture accumulation.
if map.has(c.map, name) == false
  make xs as List of CapVal = []
  list.push(xs, v)
  map.set(c.map, name, CapVal.Many(xs))
  give
.end

make cur as CapVal = map.get(c.map, name)
if cur is CapVal.Many()
  make xs as List of CapVal = cur.xs
  list.push(xs, v)
  map.set(c.map, name, CapVal.Many(xs))
  give
.end

# If previously Atom, promote to Many([Atom, v]) (rare but tolerable)
make xs2 as List of CapVal = []
list.push(xs2, cur)
list.push(xs2, v)
map.set(c.map, name, CapVal.Many(xs2))
.end

proc cap_check_compatible(existing as CapVal, incoming as CapVal) gives Bool
# Conservative equality check for repeated binding consistency:
# - Atom vs Atom: token texts must match structurally
# - Many vs Many: lengths must match and each element compatible
# - Otherwise: incompatible
if existing is CapVal.Atom() and incoming is CapVal.Atom()
  give _tt_seq_eq(existing.ts, incoming.ts)
.end

if existing is CapVal.Many() and incoming is CapVal.Many()
  if list.len(existing.xs) != list.len(incoming.xs)
    give false
  .end
  make i as Int = 0
  loop while i < list.len(existing.xs)
    if cap_check_compatible(existing.xs[i], incoming.xs[i]) == false
      give false
    .end
    set i += 1
  .end
  give true
.end

give false
.end


<<< =========================================================
  3) MATCH ENGINE
========================================================= >>>

form MatchState
field input as List of tt.Tt = []
field pos as Int = 0
.end

form MatchRes
field ok as Bool = true
field state as MatchState = MatchState()
field caps as Captures = Captures()
.end

proc match_state_new(xs as List of tt.Tt) gives MatchState
make s as MatchState = MatchState()
set s.input = xs
set s.pos = 0
give s
.end

proc _state_at_end(s as MatchState) gives Bool
give s.pos >= list.len(s.input)
.end

proc _peek(s as MatchState) gives tt.Tt
if s.pos >= list.len(s.input)
  give tt.tt_eof()
.end
give s.input[s.pos]
.end

proc _advance(s as MatchState) gives MatchState
let mut out = s
set out.pos = out.pos + 1
give out
.end

proc _match_seq(nodes as List of PatNode, st as MatchState, caps as Captures, diags as List of diag.Diagnostic, trace as Bool) gives MatchRes
make res as MatchRes = MatchRes()
set res.ok = false
set res.state = st
set res.caps = caps

make i as Int = 0
make cur_st as MatchState = st
make cur_caps as Captures = caps

loop while i < list.len(nodes)
  make n as PatNode = nodes[i]

  if n is PatNode.Lit()
    if _state_at_end(cur_st)
      if trace
        list.push(diags, diag.note("mbe-trace-unexpected-eof", tt.tt_span_stub(tt.tt_eof())))
      .end
      give res
    .end

    if _tt_eq(n.0, _peek(cur_st)) == false
      give res
    .end

    set cur_st = _advance(cur_st)
    set i += 1
    loop while false .end
  .end

  if n is PatNode.Meta()
    # Capture one TT node (leaf or group) as-is
    if _state_at_end(cur_st)
      give res
    .end
    make got as tt.Tt = _peek(cur_st)
    make incoming as CapVal = CapVal.Atom([got])
    if cap_has(cur_caps, n.name)
      if cap_check_compatible(cap_get(cur_caps, n.name), incoming) == false
        give res
      .end
    else
      cap_set(cur_caps, n.name, incoming)
    .end
    set cur_st = _advance(cur_st)
    set i += 1
    loop while false .end
  .end

  if n is PatNode.Repeat()
    make rres as RepeatMatchRes = _match_repeat_pat(n.body, n.spec, cur_st, cur_caps, diags, trace)
    if rres.ok == false
      give res
    .end
    set cur_st = rres.state
    set cur_caps = rres.caps
    set i += 1
    loop while false .end
  .end

  # unreachable
  set i += 1
.end

set res.ok = true
set res.state = cur_st
set res.caps = cur_caps
give res
.end


form RepeatMatchRes
field ok as Bool = true
field state as MatchState = MatchState()
field caps as Captures = Captures()
.end

proc _match_repeat_pat(body as List of PatNode, spec as RepeatSpec, st as MatchState, caps as Captures, diags as List of diag.Diagnostic, trace as Bool) gives RepeatMatchRes
make out as RepeatMatchRes = RepeatMatchRes()
set out.ok = false
set out.state = st
set out.caps = caps

make iters as Int = 0
make cur_st as MatchState = st
make cur_caps as Captures = caps

# We must accumulate captures across iterations, but keep iteration boundaries:
# approach:
# - For each iteration: run _match_seq on body with a temporary capture map cloned from cur_caps
# - Then merge the newly produced captures into cur_caps, by converting meta vars to Many as needed.
# This retains ordering but is conservative about nested structure.

loop while true
  make before_pos as Int = cur_st.pos
  make tmp_caps as Captures = _caps_clone(cur_caps)

  make m as MatchRes = _match_seq(body, cur_st, tmp_caps, diags, trace)
  if m.ok == false
    loop while false .end
  .end

  # guard: ensure progress (avoid infinite loop on empty body)
  if m.state.pos == before_pos
    if trace
      list.push(diags, diag.note("mbe-trace-repeat-no-progress", span.Span()))
    .end
    loop while false .end
  .end

  # merge captures from tmp into cur, as repetition iteration
  _caps_merge_iteration(cur_caps, tmp_caps)

  set cur_st = m.state
  set iters = iters + 1

  # optional separator: must match after each iteration (except maybe last)
  if spec.has_sep
    if cur_st.pos < list.len(cur_st.input)
      if _tt_eq(spec.sep, _peek(cur_st))
        set cur_st = _advance(cur_st)
      else
        # no sep => stop repeating
        loop while false .end
      .end
    else
      loop while false .end
    .end
  .end
.end

# Check min constraints
if spec.op is RepOp.OneOrMore()
  if iters < 1
    give out
  .end
.end

if spec.op is RepOp.Optional()
  if iters > 1
    give out
  .end
.end

set out.ok = true
set out.state = cur_st
set out.caps = cur_caps
give out
.end


<<< =========================================================
  4) TRANSCRIPTION
========================================================= >>>

form TranscribeCtx
field tpl as List of TplNode = []
field caps as Captures = Captures()
field call_span as span.Span = span.Span()
field diags as List of diag.Diagnostic = []
field trace as Bool = false
field rep_stack as List of Int = []   # repetition indices for nested Many traversal
.end

proc transcribe_ctx_new(tpl as List of TplNode, caps as Captures, sp as span.Span, diags as List of diag.Diagnostic, trace as Bool) gives TranscribeCtx
make c as TranscribeCtx = TranscribeCtx()
set c.tpl = tpl
set c.caps = caps
set c.call_span = sp
set c.diags = diags
set c.trace = trace
set c.rep_stack = []
give c
.end

proc _transcribe_top(ctx as TranscribeCtx) gives List of tt.Tt
give _transcribe_seq(ctx, ctx.tpl)
.end

proc _transcribe_seq(ctx as TranscribeCtx, nodes as List of TplNode) gives List of tt.Tt
make out as List of tt.Tt = []
make i as Int = 0
loop while i < list.len(nodes)
  make n as TplNode = nodes[i]

  if n is TplNode.Lit()
    list.push(out, n.0)
    set i += 1
    loop while false .end
  .end

  if n is TplNode.Meta()
    if cap_has(ctx.caps, n.name) == false
      list.push(ctx.diags, diag.error("mbe-unknown-metavar", ctx.call_span))
      set i += 1
      loop while false .end
    .end
    make v as CapVal = cap_get(ctx.caps, n.name)
    make ts as List of tt.Tt = _cap_select(v, ctx.rep_stack, ctx.diags, ctx.call_span)
    _list_extend(out, ts)
    set i += 1
    loop while false .end
  .end

  if n is TplNode.Repeat()
    # Determine number of iterations from captures referenced inside the repeat body:
    # - Take first metavar in body that is Many; use its length as iteration count.
    make count as Int = _infer_repeat_count(ctx, n.body)
    if n.spec.op is RepOp.OneOrMore()
      if count < 1
        list.push(ctx.diags, diag.error("mbe-repeat-empty", n.span))
        set i += 1
        loop while false .end
      .end
    .end
    if n.spec.op is RepOp.Optional()
      if count > 1
        # optional but multiple iterations implied => mismatch
        list.push(ctx.diags, diag.error("mbe-repeat-optional-mismatch", n.span))
      .end
      if count > 1
        set count = 1
      .end
    .end

    make k as Int = 0
    loop while k < count
      list.push(ctx.rep_stack, k)
      make inner as List of tt.Tt = _transcribe_seq(ctx, n.body)
      _list_pop(ctx.rep_stack)
      _list_extend(out, inner)
      if n.spec.has_sep and k + 1 < count
        list.push(out, n.spec.sep)
      .end
      set k += 1
    .end

    set i += 1
    loop while false .end
  .end

  set i += 1
.end

give out
.end

proc _infer_repeat_count(ctx as TranscribeCtx, body as List of TplNode) gives Int
# Find first Meta inside body whose capture is Many at current nesting depth.
make i as Int = 0
loop while i < list.len(body)
  if body[i] is TplNode.Meta()
    if cap_has(ctx.caps, body[i].name)
      make v as CapVal = cap_get(ctx.caps, body[i].name)
      make m as Option of Int = _cap_many_len_at_depth(v, list.len(ctx.rep_stack))
      if m is Option.Some()
        give m.0
      .end
    .end
  .end

  if body[i] is TplNode.Repeat()
    make nested as Int = _infer_repeat_count(ctx, body[i].body)
    if nested > 0
      give nested
    .end
  .end

  set i += 1
.end
give 0
.end


<<< =========================================================
  5) RULE COMPILATION (TT → IR)
========================================================= >>>

proc _compile_rules(rules as List of MbeRule, diags as List of diag.Diagnostic) gives List of CompiledRule
make out as List of CompiledRule = []
make i as Int = 0
loop while i < list.len(rules)
  make r as MbeRule = rules[i]
  make cr as Option of CompiledRule = _compile_rule(r, diags)
  if cr is Option.Some()
    list.push(out, cr.0)
  .end
  set i += 1
.end
give out
.end

proc _compile_rule(r as MbeRule, diags as List of diag.Diagnostic) gives Option of CompiledRule
make pat as Option of List of PatNode = _compile_pat_seq(r.pat, diags)
if pat is Option.None()
  give Option.None()
.end
make tpl as Option of List of TplNode = _compile_tpl_seq(r.tpl, diags)
if tpl is Option.None()
  give Option.None()
.end

make out as CompiledRule = CompiledRule()
set out.pat = pat.0
set out.tpl = tpl.0
set out.span = r.span
give Option.Some(out)
.end


<<< =========================================================
  6) PATTERN PARSER (TT sequence)
========================================================= >>>

proc _compile_pat_seq(xs as List of tt.Tt, diags as List of diag.Diagnostic) gives Option of List of PatNode
make out as List of PatNode = []
make i as Int = 0

loop while i < list.len(xs)
  # meta or repeat begins with '$' punct
  if tt.tt_is_leaf_punct(xs[i], "$")
    if i + 1 >= list.len(xs)
      list.push(diags, diag.error("mbe-invalid-metavar", tt.tt_span(xs[i])))
      give Option.None()
    .end

    # repetition: $( ... ) op
    if tt.tt_is_delim_paren(xs[i + 1])
      make grp as tt.Delim = tt.tt_as_delim(xs[i + 1])
      make j as Int = i + 2

      # optional single-token separator before op
      make sep_has as Bool = false
      make sep_tt as tt.Tt = tt.tt_none()

      if j >= list.len(xs)
        list.push(diags, diag.error("mbe-invalid-repetition", tt.tt_span(xs[i + 1])))
        give Option.None()
      .end

      # Determine op position:
      # - If immediate token is '*','+','?' => no separator
      # - Else treat next token as separator and following as op
      if _is_rep_op_tt(xs[j])
        # no sep
      else
        set sep_has = true
        set sep_tt = xs[j]
        set j = j + 1
        if j >= list.len(xs)
          list.push(diags, diag.error("mbe-invalid-repetition", tt.tt_span(sep_tt)))
          give Option.None()
        .end
      .end

      if _is_rep_op_tt(xs[j]) == false
        list.push(diags, diag.error("mbe-invalid-repetition-op", tt.tt_span(xs[j])))
        give Option.None()
      .end

      make spec as RepeatSpec = RepeatSpec()
      set spec.has_sep = sep_has
      set spec.sep = sep_tt
      set spec.op = _rep_op_from_tt(xs[j])

      make inner as Option of List of PatNode = _compile_pat_seq(grp.inner, diags)
      if inner is Option.None()
        give Option.None()
      .end

      list.push(out, PatNode.Repeat(inner.0, spec, tt.tt_span(xs[i + 1])))
      set i = j + 1
      loop while false .end
    .end

    # metavariable: $name or $name:frag
    make name_tt as tt.Tt = xs[i + 1]
    if tt.tt_is_leaf_ident(name_tt) == false
      list.push(diags, diag.error("mbe-invalid-metavar-name", tt.tt_span(name_tt)))
      give Option.None()
    .end

    make name as Text = tt.tt_leaf_text(name_tt)
    make frag as FragSpec = FragSpec.Tt()

    # optional : frag
    if i + 3 < list.len(xs)
      if tt.tt_is_leaf_punct(xs[i + 2], ":")
        if tt.tt_is_leaf_ident(xs[i + 3]) == false
          list.push(diags, diag.error("mbe-invalid-frag", tt.tt_span(xs[i + 3])))
          give Option.None()
        .end
        set frag = frag_from_name(tt.tt_leaf_text(xs[i + 3]))
        list.push(out, PatNode.Meta(name, frag))
        set i = i + 4
        loop while false .end
      .end
    .end

    list.push(out, PatNode.Meta(name, frag))
    set i = i + 2
    loop while false .end
  .end

  # literal token tree
  list.push(out, PatNode.Lit(xs[i]))
  set i += 1
.end

give Option.Some(out)
.end

proc _is_rep_op_tt(x as tt.Tt) gives Bool
if tt.tt_is_leaf_punct(x, "*") give true .end
if tt.tt_is_leaf_punct(x, "+") give true .end
if tt.tt_is_leaf_punct(x, "?") give true .end
give false
.end

proc _rep_op_from_tt(x as tt.Tt) gives RepOp
if tt.tt_is_leaf_punct(x, "+") give RepOp.OneOrMore() .end
if tt.tt_is_leaf_punct(x, "?") give RepOp.Optional()  .end
give RepOp.ZeroOrMore()
.end


<<< =========================================================
  7) TEMPLATE PARSER (TT sequence)
========================================================= >>>

proc _compile_tpl_seq(xs as List of tt.Tt, diags as List of diag.Diagnostic) gives Option of List of TplNode
make out as List of TplNode = []
make i as Int = 0

loop while i < list.len(xs)
  if tt.tt_is_leaf_punct(xs[i], "$")
    if i + 1 >= list.len(xs)
      list.push(diags, diag.error("mbe-invalid-metavar", tt.tt_span(xs[i])))
      give Option.None()
    .end

    # repetition template: $( ... ) op
    if tt.tt_is_delim_paren(xs[i + 1])
      make grp as tt.Delim = tt.tt_as_delim(xs[i + 1])
      make j as Int = i + 2

      make sep_has as Bool = false
      make sep_tt as tt.Tt = tt.tt_none()

      if j >= list.len(xs)
        list.push(diags, diag.error("mbe-invalid-repetition", tt.tt_span(xs[i + 1])))
        give Option.None()
      .end

      if _is_rep_op_tt(xs[j])
        # no sep
      else
        set sep_has = true
        set sep_tt = xs[j]
        set j = j + 1
        if j >= list.len(xs)
          list.push(diags, diag.error("mbe-invalid-repetition", tt.tt_span(sep_tt)))
          give Option.None()
        .end
      .end

      if _is_rep_op_tt(xs[j]) == false
        list.push(diags, diag.error("mbe-invalid-repetition-op", tt.tt_span(xs[j])))
        give Option.None()
      .end

      make spec as RepeatSpec = RepeatSpec()
      set spec.has_sep = sep_has
      set spec.sep = sep_tt
      set spec.op = _rep_op_from_tt(xs[j])

      make inner as Option of List of TplNode = _compile_tpl_seq(grp.inner, diags)
      if inner is Option.None()
        give Option.None()
      .end

      list.push(out, TplNode.Repeat(inner.0, spec, tt.tt_span(xs[i + 1])))
      set i = j + 1
      loop while false .end
    .end

    # metavariable splice: $name (template does not accept :frag)
    make name_tt as tt.Tt = xs[i + 1]
    if tt.tt_is_leaf_ident(name_tt) == false
      list.push(diags, diag.error("mbe-invalid-metavar-name", tt.tt_span(name_tt)))
      give Option.None()
    .end

    list.push(out, TplNode.Meta(tt.tt_leaf_text(name_tt), tt.tt_span(name_tt)))
    set i = i + 2
    loop while false .end
  .end

  list.push(out, TplNode.Lit(xs[i]))
  set i += 1
.end

give Option.Some(out)
.end


<<< =========================================================
  8) HELPERS: TOKEN TREE EQUALITY / CLONE / LIST OPS
========================================================= >>>

proc _tt_eq(a as tt.Tt, b as tt.Tt) gives Bool
# Structural equality by shape + leaf text + delim kind.
# Spans are ignored for matching.
if tt.tt_is_leaf(a) and tt.tt_is_leaf(b)
  give tt.tt_leaf_kind(a) == tt.tt_leaf_kind(b) and tt.tt_leaf_text(a) == tt.tt_leaf_text(b)
.end

if tt.tt_is_delim(a) and tt.tt_is_delim(b)
  make da as tt.Delim = tt.tt_as_delim(a)
  make db as tt.Delim = tt.tt_as_delim(b)
  if da.kind != db.kind
    give false
  .end
  give _tt_seq_eq(da.inner, db.inner)
.end

give false
.end

proc _tt_seq_eq(xs as List of tt.Tt, ys as List of tt.Tt) gives Bool
if list.len(xs) != list.len(ys)
  give false
.end
make i as Int = 0
loop while i < list.len(xs)
  if _tt_eq(xs[i], ys[i]) == false
    give false
  .end
  set i += 1
.end
give true
.end

proc _list_extend(dst as List of tt.Tt, src as List of tt.Tt)
make i as Int = 0
loop while i < list.len(src)
  list.push(dst, src[i])
  set i += 1
.end
.end

proc _list_pop(xs as List of Int)
# pop last element (assumes non-empty)
list.pop(xs)
.end

proc _caps_clone(c as Captures) gives Captures
# Shallow clone: map values are immutable-ish (CapVal trees), so ok.
make out as Captures = Captures()
set out.map = map.clone(c.map)
give out
.end

proc _caps_merge_iteration(base as Captures, iter_caps as Captures)
# For each name in iter_caps:
# - If base does not have it: set to Many([Atom]) if Atom, or Many([v]) otherwise
# - If base has Atom: promote to Many([Atom, new])
# - If base has Many: append new
make names as List of Text = map.keys(iter_caps.map)
make i as Int = 0
loop while i < list.len(names)
  make k as Text = names[i]
  make v as CapVal = map.get(iter_caps.map, k)

  if map.has(base.map, k) == false
    cap_push_many(base, k, v)
  else
    cap_push_many(base, k, v)
  .end

  set i += 1
.end
.end


<<< =========================================================
  9) HELPERS: CAPTURE SELECTION (NESTED MANY)
========================================================= >>>

proc _cap_many_len_at_depth(v as CapVal, depth as Int) gives Option of Int
# depth=0 => if v is Many => len
# depth>0 => step into Many[rep_stack[0]] ... until depth then take Many len
if depth == 0
  if v is CapVal.Many()
    give Option.Some(list.len(v.xs))
  .end
  give Option.None()
.end

# For depth>0, we cannot choose without indices; this helper is used only to infer
# counts at current depth, so we must find a Many at exactly this depth:
# We return None unless v itself is Many (depth==0 case).
give Option.None()
.end

proc _cap_select(v as CapVal, rep_stack as List of Int, diags as List of diag.Diagnostic, sp as span.Span) gives List of tt.Tt
# Select the capture branch following rep_stack.
# Rules:
# - If v is Atom => return its ts.
# - If v is Many => index by rep_stack[0], then recurse with stack[1..]
if v is CapVal.Atom()
  give v.ts
.end

if v is CapVal.Many()
  if list.len(rep_stack) == 0
    # Splicing a repeated capture without a repetition context: flatten by concatenating all Atom leaves.
    make flat as List of tt.Tt = []
    make i as Int = 0
    loop while i < list.len(v.xs)
      make part as List of tt.Tt = _cap_select(v.xs[i], [], diags, sp)
      _list_extend(flat, part)
      set i += 1
    .end
    give flat
  .end

  make idx as Int = rep_stack[0]
  if idx < 0 or idx >= list.len(v.xs)
    list.push(diags, diag.error("mbe-repetition-index-oob", sp))
    give []
  .end

  make rest as List of Int = _slice_int(rep_stack, 1)
  give _cap_select(v.xs[idx], rest, diags, sp)
.end

give []
.end

proc _slice_int(xs as List of Int, start as Int) gives List of Int
make out as List of Int = []
make i as Int = start
loop while i < list.len(xs)
  list.push(out, xs[i])
  set i += 1
.end
give out
.end


<<< =========================================================
  10) SMOKE TEST HOOKS (OPTIONAL)
========================================================= >>>

proc _smoke(diags as List of diag.Diagnostic)
# Example rule:
#   pat:  [$, ident(x)]
#   tpl:  [ident(x)]
# This is just a placeholder; real TT construction occurs elsewhere.
give
.end
