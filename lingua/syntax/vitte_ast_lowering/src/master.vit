vitte 1.0
space lingua/syntax/vitte_ast_lowering/master

<<< master
  vitte_ast_lowering/master.vit â€” Lowering (AST -> AST-IR) (MAX)

  Responsibilities:
    - Lower surface AST (vitte_ast) into normalized AST-IR (vitte_ast_ir)
    - Apply final canonical rewrites (loop_until, each, select) if expander didn't
    - Normalize attribute sets per target via attr/master registry
    - Convert surface type expressions into IR TypeRef
    - Convert expressions/statements/items into IR equivalents with stable IDs
    - Emit diagnostics for unsupported / malformed nodes (error recovery)

  Inputs:
    - vitte_ast (surface AST)
    - expand/master (optional; but lowering can run standalone)

  Output:
    - vitte_ast_ir::IrFile

  Notes:
    - This module provides an adapter-based approach: it can work with either
      a strongly typed vitte_ast, or a generic node model (like expand/master).
    - To integrate with your real AST, implement the Adapter interface at bottom.
>>>

pull std/text as text
pull std/collections/list as list
pull std/collections/map as map

pull lingua/syntax/vitte_ast/span as span
pull lingua/syntax/vitte_ast/symbol as symbol
pull lingua/syntax/vitte_ast/diag as diag
pull lingua/syntax/vitte_ast/attr/master as attr

pull lingua/syntax/vitte_ast_ir/master as ir

share all

bond Text means String


<<< =========================================================
  0) LOWERING CONFIG / CONTEXT
========================================================= >>>

form LowerConfig
field attr_registry as attr.AttrRegistry = attr.default_registry()
field normalize_attrs as Bool = true
field desugar_loop_until as Bool = true
field desugar_each as Bool = true
field desugar_select as Bool = false
field strict as Bool = false
.end

proc lower_config_default() gives LowerConfig
give LowerConfig()
.end


form LowerStats
field items_in as U64 = 0u64
field items_out as U64 = 0u64
field exprs_out as U64 = 0u64
field stmts_out as U64 = 0u64
field blocks_out as U64 = 0u64
field errors as U64 = 0u64
.end

proc stats_new() gives LowerStats
give LowerStats()
.end


form LowerContext
field cfg as LowerConfig = LowerConfig()
field gen as ir.IdGen = ir.idgen_new()
field stats as LowerStats = LowerStats()
field diags as List of diag.Diagnostic = []
.end

proc ctx_new(cfg as LowerConfig, diags as List of diag.Diagnostic) gives LowerContext
make c as LowerContext = LowerContext()
set c.cfg = cfg
set c.gen = ir.idgen_new()
set c.stats = stats_new()
set c.diags = diags
give c
.end


<<< =========================================================
  1) ADAPTER INTERFACE (AST SOURCE)
========================================================= >>>

pick AstNodeKind
case File()
case Item()
case Stmt()
case Expr()
case Type()
case Pattern()
.end

form AstNode
field kind as AstNodeKind = AstNodeKind.Expr()
field tag as Text = ""                  # e.g. "proc", "form", "make", "if", "+"
field text as Text = ""                 # names, literal raw text, etc.
field span as span.Span = span.Span()
field attrs as List of attr.Attribute = []
field kids as List of AstNode = []
.end

proc ast_node(kind as AstNodeKind, tag as Text, sp as span.Span) gives AstNode
make n as AstNode = AstNode()
set n.kind = kind
set n.tag = tag
set n.text = ""
set n.span = sp
set n.attrs = []
set n.kids = []
give n
.end

proc ast_with_text(n as AstNode, t as Text) gives AstNode
make out as AstNode = n
set out.text = t
give out
.end

proc ast_push(n as AstNode, k as AstNode) gives AstNode
make out as AstNode = n
list.push(out.kids, k)
give out
.end

proc ast_set_attrs(n as AstNode, a as List of attr.Attribute) gives AstNode
make out as AstNode = n
set out.attrs = a
give out
.end


<<< =========================================================
  2) PUBLIC ENTRYPOINT
========================================================= >>>

form LowerResult
field file as ir.IrFile = ir.IrFile()
field stats as LowerStats = LowerStats()
field diags as List of diag.Diagnostic = []
.end

proc lower_file(root as AstNode, cfg as LowerConfig, diags as List of diag.Diagnostic) gives LowerResult
make ctx as LowerContext = ctx_new(cfg, diags)

make f as ir.IrFile = ir.IrFile()
set f.id = ir.file_id(1u32)
set f.items = []
set f.span = root.span
set f.attrs = _lower_attrs(ctx, root.attrs, attr.AttrTarget.File())

# root should contain item kids
make i as Int = 0
loop while i < list.len(root.kids)
  make n as AstNode = root.kids[i]
  if n.kind is AstNodeKind.Item()
    make it as ir.Item = _lower_item(ctx, n)
    list.push(f.items, it)
    set ctx.stats.items_out += 1u64
  else
    if cfg.strict
      diag.error(ctx.diags, "unexpected non-item at file top-level", n.span)
      set ctx.stats.errors += 1u64
    .end
  .end
  set i += 1
.end

make out as LowerResult = LowerResult()
set out.file = f
set out.stats = ctx.stats
set out.diags = ctx.diags
give out
.end


<<< =========================================================
  3) ATTR LOWERING / NORMALIZATION
========================================================= >>>

proc _lower_attrs(ctx as LowerContext, xs as List of attr.Attribute, target as attr.AttrTarget) gives ir.Attrs
if list.len(xs) == 0
  give ir.attrs_empty()
.end

# normalize by registry if enabled
if ctx.cfg.normalize_attrs
  make s as attr.AttrSet = attr.attr_set_new()
  make i as Int = 0
  loop while i < list.len(xs)
    set s = attr.attr_set_add(s, xs[i])
    set i += 1
  .end
  make norm as attr.AttrSet = attr.attr_set_normalize(ctx.cfg.attr_registry, s, target, ctx.diags)
  give ir.attrs_from_list(norm.items)
.end

give ir.attrs_from_list(xs)
.end


<<< =========================================================
  4) ITEM LOWERING
========================================================= >>>

proc _lower_item(ctx as LowerContext, n as AstNode) gives ir.Item
make out as ir.Item = ir.Item()
set out.id = ir.idgen_item(ctx.gen)
set out.span = n.span

# Determine item kind by tag
if n.tag == "space"
  set out.kind = ir.ItemKind.Space(_lower_space(ctx, n))
  give out
.end
if n.tag == "pull"
  set out.kind = ir.ItemKind.Pull(_lower_pull(ctx, n))
  give out
.end
if n.tag == "share"
  set out.kind = ir.ItemKind.Share(_lower_share(ctx, n))
  give out
.end
if n.tag == "build"
  set out.kind = ir.ItemKind.Build(_lower_build(ctx, n))
  give out
.end
if n.tag == "form"
  set out.kind = ir.ItemKind.Form(_lower_form(ctx, n))
  give out
.end
if n.tag == "pick"
  set out.kind = ir.ItemKind.Pick(_lower_pick(ctx, n))
  give out
.end
if n.tag == "bond"
  set out.kind = ir.ItemKind.Bond(_lower_bond(ctx, n))
  give out
.end
if n.tag == "proc"
  set out.kind = ir.ItemKind.Proc(_lower_proc(ctx, n))
  give out
.end
if n.tag == "flow"
  set out.kind = ir.ItemKind.Flow(_lower_flow(ctx, n))
  give out
.end
if n.tag == "entry"
  set out.kind = ir.ItemKind.Entry(_lower_entry(ctx, n))
  give out
.end
if n.tag == "global"
  set out.kind = ir.ItemKind.Global(_lower_global(ctx, n))
  give out
.end

diag.error(ctx.diags, "unknown item tag: " + n.tag, n.span)
set ctx.stats.errors += 1u64
set out.kind = ir.ItemKind.Hole()
give out
.end


proc _lower_space(ctx as LowerContext, n as AstNode) gives ir.SpaceItem
make it as ir.SpaceItem = ir.SpaceItem()
set it.path = ir.path_from_text(n.text)
set it.attrs = _lower_attrs(ctx, n.attrs, attr.AttrTarget.Space())
set it.span = n.span
give it
.end

proc _lower_pull(ctx as LowerContext, n as AstNode) gives ir.PullItem
# Convention:
#  n.text = path
#  kids may include: as(name), only(list)
make it as ir.PullItem = ir.PullItem()
set it.path = ir.path_from_text(n.text)
set it.attrs = _lower_attrs(ctx, n.attrs, attr.AttrTarget.Pull())
set it.span = n.span

make i as Int = 0
loop while i < list.len(n.kids)
  make k as AstNode = n.kids[i]
  if k.tag == "as"
    set it.as_name = ir.name_from_text(k.text)
    set it.has_as = true
  .end
  if k.tag == "only"
    set it.only = _lower_name_list(ctx, k)
    set it.has_only = true
  .end
  set i += 1
.end

give it
.end

proc _lower_share(ctx as LowerContext, n as AstNode) gives ir.ShareItem
# Convention:
#  tag "share_all" or "share_list"; else infer by kids empty
make it as ir.ShareItem = ir.ShareItem()
set it.attrs = _lower_attrs(ctx, n.attrs, attr.AttrTarget.Share())
set it.span = n.span

if n.tag == "share_all" or n.text == "all"
  set it.all = true
  set it.names = []
  give it
.end

set it.all = false
set it.names = _lower_name_list(ctx, n)
give it
.end

proc _lower_build(ctx as LowerContext, n as AstNode) gives ir.BuildItem
# Convention:
#  n.text = key, kid[0] literal node
make it as ir.BuildItem = ir.BuildItem()
set it.key = n.text
set it.attrs = _lower_attrs(ctx, n.attrs, attr.AttrTarget.Build())
set it.span = n.span

if list.len(n.kids) > 0
  set it.value = _lower_literal_node(ctx, n.kids[0])
else
  set it.value = ir.Literal.Text("")
.end
give it
.end


proc _lower_form(ctx as LowerContext, n as AstNode) gives ir.FormItem
# Convention:
#  n.text = name
#  kids: type_params?, fields...
make it as ir.FormItem = ir.FormItem()
set it.name = ir.name_from_text(n.text)
set it.vis = ir.Vis.Hid()
set it.type_params = []
set it.fields = []
set it.attrs = _lower_attrs(ctx, n.attrs, attr.AttrTarget.Form())
set it.span = n.span

make i as Int = 0
loop while i < list.len(n.kids)
  make k as AstNode = n.kids[i]
  if k.tag == "pub" set it.vis = ir.Vis.Pub() .end
  if k.tag == "type_params" set it.type_params = _lower_name_list(ctx, k) .end
  if k.tag == "field" list.push(it.fields, _lower_field(ctx, k)) .end
  set i += 1
.end

give it
.end

proc _lower_pick(ctx as LowerContext, n as AstNode) gives ir.PickItem
make it as ir.PickItem = ir.PickItem()
set it.name = ir.name_from_text(n.text)
set it.vis = ir.Vis.Hid()
set it.type_params = []
set it.cases = []
set it.attrs = _lower_attrs(ctx, n.attrs, attr.AttrTarget.Pick())
set it.span = n.span

make i as Int = 0
loop while i < list.len(n.kids)
  make k as AstNode = n.kids[i]
  if k.tag == "pub" set it.vis = ir.Vis.Pub() .end
  if k.tag == "type_params" set it.type_params = _lower_name_list(ctx, k) .end
  if k.tag == "case" list.push(it.cases, _lower_case(ctx, k)) .end
  set i += 1
.end

give it
.end

proc _lower_bond(ctx as LowerContext, n as AstNode) gives ir.BondItem
# Convention:
#  n.text = name, kids: type_params?, target_type
make it as ir.BondItem = ir.BondItem()
set it.name = ir.name_from_text(n.text)
set it.vis = ir.Vis.Hid()
set it.type_params = []
set it.target = ir.TypeRef.Hole()
set it.attrs = _lower_attrs(ctx, n.attrs, attr.AttrTarget.Bond())
set it.span = n.span

make i as Int = 0
loop while i < list.len(n.kids)
  make k as AstNode = n.kids[i]
  if k.tag == "pub" set it.vis = ir.Vis.Pub() .end
  if k.tag == "type_params" set it.type_params = _lower_name_list(ctx, k) .end
  if k.kind is AstNodeKind.Type()
    set it.target = _lower_type(ctx, k)
  .end
  set i += 1
.end

give it
.end


proc _lower_proc(ctx as LowerContext, n as AstNode) gives ir.ProcItem
# Convention:
#  n.text = name
#  kids: pub?, params, ret_type?, body(block)
make it as ir.ProcItem = ir.ProcItem()
set it.name = ir.name_from_text(n.text)
set it.vis = ir.Vis.Hid()
set it.sig = ir.Sig()
set it.sig.params = []
set it.sig.has_ret = false
set it.body = ir.block_new(ctx.gen, n.span)
set it.attrs = _lower_attrs(ctx, n.attrs, attr.AttrTarget.Proc())
set it.span = n.span

make i as Int = 0
loop while i < list.len(n.kids)
  make k as AstNode = n.kids[i]
  if k.tag == "pub" set it.vis = ir.Vis.Pub() .end
  if k.tag == "params"
    set it.sig.params = _lower_params(ctx, k)
  .end
  if k.tag == "ret"
    set it.sig.ret = _lower_type(ctx, k.kids[0])
    set it.sig.has_ret = true
  .end
  if k.tag == "block"
    set it.body = _lower_block(ctx, k)
  .end
  set i += 1
.end

give it
.end

proc _lower_flow(ctx as LowerContext, n as AstNode) gives ir.FlowItem
make it as ir.FlowItem = ir.FlowItem()
set it.name = ir.name_from_text(n.text)
set it.vis = ir.Vis.Hid()
set it.sig = ir.Sig()
set it.sig.params = []
set it.sig.has_ret = false
set it.body = ir.block_new(ctx.gen, n.span)
set it.attrs = _lower_attrs(ctx, n.attrs, attr.AttrTarget.Flow())
set it.span = n.span

make i as Int = 0
loop while i < list.len(n.kids)
  make k as AstNode = n.kids[i]
  if k.tag == "pub" set it.vis = ir.Vis.Pub() .end
  if k.tag == "params" set it.sig.params = _lower_params(ctx, k) .end
  if k.tag == "ret"
    set it.sig.ret = _lower_type(ctx, k.kids[0])
    set it.sig.has_ret = true
  .end
  if k.tag == "block" set it.body = _lower_block(ctx, k) .end
  set i += 1
.end

give it
.end

proc _lower_entry(ctx as LowerContext, n as AstNode) gives ir.EntryItem
# Convention:
#  n.text = kind, kid[0] = path, kid[1] = block
make it as ir.EntryItem = ir.EntryItem()
set it.kind = _lower_entry_kind(n.text)
set it.at = ir.path_from_text(if list.len(n.kids)>0 then n.kids[0].text else "" )
set it.body = ir.block_new(ctx.gen, n.span)
set it.attrs = _lower_attrs(ctx, n.attrs, attr.AttrTarget.Entry())
set it.span = n.span

if list.len(n.kids) > 1
  set it.body = _lower_block(ctx, n.kids[1])
.end
give it
.end

proc _lower_global(ctx as LowerContext, n as AstNode) gives ir.GlobalItem
# Convention:
#  n.tag = "const" or "var"
#  n.text = name
#  kids: type?, init?
make it as ir.GlobalItem = ir.GlobalItem()
set it.is_const = (n.tag == "const")
set it.name = ir.name_from_text(n.text)
set it.vis = ir.Vis.Hid()
set it.has_ty = false
set it.has_init = false
set it.ty = ir.TypeRef.Hole()
set it.init = ir.Expr()
set it.attrs = _lower_attrs(ctx, n.attrs, attr.AttrTarget.Type()) # closest
set it.span = n.span

make i as Int = 0
loop while i < list.len(n.kids)
  make k as AstNode = n.kids[i]
  if k.kind is AstNodeKind.Type()
    set it.ty = _lower_type(ctx, k)
    set it.has_ty = true
  .end
  if k.kind is AstNodeKind.Expr()
    set it.init = _lower_expr(ctx, k)
    set it.has_init = true
  .end
  if k.tag == "pub" set it.vis = ir.Vis.Pub() .end
  set i += 1
.end

give it
.end


<<< =========================================================
  5) FIELD / CASE / PARAM LOWERING
========================================================= >>>

proc _lower_field(ctx as LowerContext, n as AstNode) gives ir.Field
# Convention:
#  n.text = field name
#  kids: type node, optional init expr
make f as ir.Field = ir.Field()
set f.name = ir.name_from_text(n.text)
set f.vis = ir.Vis.Hid()
set f.ty = ir.TypeRef.Hole()
set f.has_init = false
set f.init = ir.Expr()
set f.span = n.span
set f.attrs = _lower_attrs(ctx, n.attrs, attr.AttrTarget.Field())

make i as Int = 0
loop while i < list.len(n.kids)
  make k as AstNode = n.kids[i]
  if k.tag == "pub" set f.vis = ir.Vis.Pub() .end
  if k.kind is AstNodeKind.Type()
    set f.ty = _lower_type(ctx, k)
  .end
  if k.kind is AstNodeKind.Expr()
    set f.init = _lower_expr(ctx, k)
    set f.has_init = true
  .end
  set i += 1
.end

give f
.end

proc _lower_case(ctx as LowerContext, n as AstNode) gives ir.Case
# Convention:
#  n.text = case name
#  kids: payload type nodes (0..N)
make c as ir.Case = ir.Case()
set c.name = ir.name_from_text(n.text)
set c.vis = ir.Vis.Hid()
set c.payload = []
set c.attrs = _lower_attrs(ctx, n.attrs, attr.AttrTarget.Pick())
set c.span = n.span

make i as Int = 0
loop while i < list.len(n.kids)
  make k as AstNode = n.kids[i]
  if k.tag == "pub" set c.vis = ir.Vis.Pub() .end
  if k.kind is AstNodeKind.Type()
    list.push(c.payload, _lower_type(ctx, k))
  .end
  set i += 1
.end

give c
.end

proc _lower_params(ctx as LowerContext, n as AstNode) gives List of ir.Param
# kids are param nodes
make out as List of ir.Param = []
make i as Int = 0
loop while i < list.len(n.kids)
  list.push(out, _lower_param(ctx, n.kids[i]))
  set i += 1
.end
give out
.end

proc _lower_param(ctx as LowerContext, n as AstNode) gives ir.Param
# Convention:
#  n.text = param name
#  kids: type?, default?
make p as ir.Param = ir.Param()
set p.id = ir.param_id(ctx.gen.next_param)
set ctx.gen.next_param += 1u32
set p.name = ir.name_from_text(n.text)
set p.ty = ir.TypeRef.Hole()
set p.has_ty = false
set p.default = ir.Expr()
set p.has_default = false
set p.span = n.span
set p.attrs = _lower_attrs(ctx, n.attrs, attr.AttrTarget.Param())

make i as Int = 0
loop while i < list.len(n.kids)
  make k as AstNode = n.kids[i]
  if k.kind is AstNodeKind.Type()
    set p.ty = _lower_type(ctx, k)
    set p.has_ty = true
  .end
  if k.kind is AstNodeKind.Expr()
    set p.default = _lower_expr(ctx, k)
    set p.has_default = true
  .end
  set i += 1
.end

give p
.end

proc _lower_name_list(ctx as LowerContext, n as AstNode) gives List of ir.Name
make out as List of ir.Name = []
make i as Int = 0
loop while i < list.len(n.kids)
  list.push(out, ir.name_from_text(n.kids[i].text))
  set i += 1
.end
give out
.end


<<< =========================================================
  6) TYPE LOWERING (surface -> IR TypeRef)
========================================================= >>>

proc _lower_type(ctx as LowerContext, n as AstNode) gives ir.TypeRef
# Convention: n.tag describes type form, kids contain subtypes
# Allowed tags: "builtin", "named", "list_of", "map_of", "pack_of", "or"
if n.tag == "builtin"
  give ir.TypeRef.Builtin(ir.name_from_text(n.text))
.end
if n.tag == "named"
  # n.text = path text, kids = args
  make args as List of ir.TypeRef = []
  make i as Int = 0
  loop while i < list.len(n.kids)
    list.push(args, _lower_type(ctx, n.kids[i]))
    set i += 1
  .end
  give ir.TypeRef.Named(ir.path_from_text(n.text), args)
.end
if n.tag == "list_of"
  if list.len(n.kids) > 0
    give ir.TypeRef.ListOf(_lower_type(ctx, n.kids[0]))
  .end
  give ir.TypeRef.ListOf(ir.TypeRef.Hole())
.end
if n.tag == "map_of"
  if list.len(n.kids) >= 2
    give ir.TypeRef.MapOf(_lower_type(ctx, n.kids[0]), _lower_type(ctx, n.kids[1]))
  .end
  give ir.TypeRef.MapOf(ir.TypeRef.Hole(), ir.TypeRef.Hole())
.end
if n.tag == "pack_of"
  make items as List of ir.TypeRef = []
  make i as Int = 0
  loop while i < list.len(n.kids)
    list.push(items, _lower_type(ctx, n.kids[i]))
    set i += 1
  .end
  give ir.TypeRef.PackOf(items)
.end
if n.tag == "or"
  if list.len(n.kids) >= 2
    give ir.TypeRef.Or(_lower_type(ctx, n.kids[0]), _lower_type(ctx, n.kids[1]))
  .end
  give ir.TypeRef.Or(ir.TypeRef.Hole(), ir.TypeRef.Hole())
.end

# fallback: treat text as named path, maybe builtin
if n.text != ""
  give ir.TypeRef.Named(ir.path_from_text(n.text), [])
.end

diag.error(ctx.diags, "unknown type node", n.span)
set ctx.stats.errors += 1u64
give ir.TypeRef.Hole()
.end


<<< =========================================================
  7) BLOCK / STMT LOWERING
========================================================= >>>

proc _lower_block(ctx as LowerContext, n as AstNode) gives ir.Block
make b as ir.Block = ir.block_new(ctx.gen, n.span)
set ctx.stats.blocks_out += 1u64

# Convention: children are stmt nodes
make i as Int = 0
loop while i < list.len(n.kids)
  make s as ir.Stmt = _lower_stmt(ctx, n.kids[i])
  list.push(b.stmts, s)
  set i += 1
.end

give b
.end

proc _lower_stmt(ctx as LowerContext, n as AstNode) gives ir.Stmt
make s as ir.Stmt = ir.Stmt()
set s.id = ir.idgen_stmt(ctx.gen)
set s.span = n.span
set s.attrs = _lower_attrs(ctx, n.attrs, attr.AttrTarget.Stmt())
set s.kind = ir.StmtKind.Hole()
set ctx.stats.stmts_out += 1u64

if n.tag == "make"
  set s.kind = _lower_stmt_make(ctx, n)
  give s
.end
if n.tag == "keep"
  set s.kind = _lower_stmt_keep(ctx, n)
  give s
.end
if n.tag == "set"
  set s.kind = _lower_stmt_set(ctx, n)
  give s
.end
if n.tag == "if"
  set s.kind = _lower_stmt_if(ctx, n)
  give s
.end
if n.tag == "loop_while" or n.tag == "loop_until"
  set s.kind = _lower_stmt_loop(ctx, n)
  give s
.end
if n.tag == "each"
  set s.kind = _lower_stmt_each(ctx, n)
  give s
.end
if n.tag == "select"
  set s.kind = _lower_stmt_select(ctx, n)
  give s
.end
if n.tag == "give"
  set s.kind = _lower_stmt_give(ctx, n)
  give s
.end
if n.tag == "emit"
  set s.kind = _lower_stmt_emit(ctx, n)
  give s
.end
if n.tag == "defer"
  set s.kind = _lower_stmt_defer(ctx, n)
  give s
.end
if n.tag == "assert"
  set s.kind = _lower_stmt_assert(ctx, n)
  give s
.end
if n.tag == "halt"
  set s.kind = ir.StmtKind.Halt()
  give s
.end
if n.tag == "next"
  set s.kind = ir.StmtKind.Next()
  give s
.end
if n.kind is AstNodeKind.Expr()
  set s.kind = ir.StmtKind.ExprStmt(_lower_expr(ctx, n))
  give s
.end

diag.error(ctx.diags, "unknown stmt tag: " + n.tag, n.span)
set ctx.stats.errors += 1u64
give s
.end


proc _lower_stmt_make(ctx as LowerContext, n as AstNode) gives ir.StmtKind
# Convention:
#  n.text = name
#  kids: type? expr?
make nm as ir.Name = ir.name_from_text(n.text)
make ty as ir.TypeRef = ir.TypeRef.Hole()
make has_ty as Bool = false
make init as ir.Expr = ir.Expr()
make has_init as Bool = false

make i as Int = 0
loop while i < list.len(n.kids)
  make k as AstNode = n.kids[i]
  if k.kind is AstNodeKind.Type()
    set ty = _lower_type(ctx, k)
    set has_ty = true
  .end
  if k.kind is AstNodeKind.Expr()
    set init = _lower_expr(ctx, k)
    set has_init = true
  .end
  set i += 1
.end

give ir.StmtKind.Make(nm, ty, has_ty, init, has_init)
.end

proc _lower_stmt_keep(ctx as LowerContext, n as AstNode) gives ir.StmtKind
make nm as ir.Name = ir.name_from_text(n.text)
make ty as ir.TypeRef = ir.TypeRef.Hole()
make has_ty as Bool = false
make init as ir.Expr = ir.Expr()

make i as Int = 0
loop while i < list.len(n.kids)
  make k as AstNode = n.kids[i]
  if k.kind is AstNodeKind.Type()
    set ty = _lower_type(ctx, k)
    set has_ty = true
  .end
  if k.kind is AstNodeKind.Expr()
    set init = _lower_expr(ctx, k)
  .end
  set i += 1
.end

give ir.StmtKind.Keep(nm, ty, has_ty, init)
.end

proc _lower_stmt_set(ctx as LowerContext, n as AstNode) gives ir.StmtKind
# Convention:
#  kids[0]=target expr, kids[1]=op text, kids[2]=value expr
make tgt as ir.Target = ir.Target()
set tgt.base = if list.len(n.kids)>0 then _lower_expr(ctx, n.kids[0]) else ir.Expr()

make op as ir.SetOp = ir.SetOp.Assign()
if list.len(n.kids) > 1
  set op = _lower_set_op(n.kids[1].text)
.end

make val as ir.Expr = if list.len(n.kids)>2 then _lower_expr(ctx, n.kids[2]) else ir.Expr()

give ir.StmtKind.Set(tgt, op, val)
.end

proc _lower_set_op(t as Text) gives ir.SetOp
if t == "+=" give ir.SetOp.AddAssign() .end
if t == "-=" give ir.SetOp.SubAssign() .end
if t == "*=" give ir.SetOp.MulAssign() .end
if t == "/=" give ir.SetOp.DivAssign() .end
if t == "%=" give ir.SetOp.RemAssign() .end
give ir.SetOp.Assign()
.end

proc _lower_stmt_if(ctx as LowerContext, n as AstNode) gives ir.StmtKind
# Convention:
#  kids: cond expr, then block, zero+ elif nodes, optional else block
make cond as ir.Expr = if list.len(n.kids)>0 then _lower_expr(ctx, n.kids[0]) else ir.Expr()
make then_b as ir.Block = if list.len(n.kids)>1 then _lower_block(ctx, n.kids[1]) else ir.block_new(ctx.gen, n.span)

make elifs as List of ir.ElifPart = []
make else_b as ir.Block = ir.block_new(ctx.gen, n.span)
make has_else as Bool = false

make i as Int = 2
loop while i < list.len(n.kids)
  make k as AstNode = n.kids[i]
  if k.tag == "elif"
    make e as ir.ElifPart = ir.ElifPart()
    set e.cond = if list.len(k.kids)>0 then _lower_expr(ctx, k.kids[0]) else ir.Expr()
    set e.body = if list.len(k.kids)>1 then _lower_block(ctx, k.kids[1]) else ir.block_new(ctx.gen, k.span)
    list.push(elifs, e)
  elif k.tag == "else"
    set else_b = if list.len(k.kids)>0 then _lower_block(ctx, k.kids[0]) else ir.block_new(ctx.gen, k.span)
    set has_else = true
  .end
  set i += 1
.end

give ir.StmtKind.If(cond, then_b, elifs, else_b, has_else)
.end

proc _lower_stmt_loop(ctx as LowerContext, n as AstNode) gives ir.StmtKind
# Convention:
#  kids[0]=cond expr, kids[1]=body block
make label as ir.LabelId = ir.idgen_label(ctx.gen)

if n.tag == "loop_until" and ctx.cfg.desugar_loop_until
  # loop until c  => loop while not c
  make cond0 as ir.Expr = if list.len(n.kids)>0 then _lower_expr(ctx, n.kids[0]) else ir.Expr()
  make neg as ir.Expr = _expr_not(ctx, cond0, n.span)
  make body as ir.Block = if list.len(n.kids)>1 then _lower_block(ctx, n.kids[1]) else ir.block_new(ctx.gen, n.span)
  give ir.StmtKind.LoopWhile(neg, body, label)
.end

make cond as ir.Expr = if list.len(n.kids)>0 then _lower_expr(ctx, n.kids[0]) else ir.Expr()
make body as ir.Block = if list.len(n.kids)>1 then _lower_block(ctx, n.kids[1]) else ir.block_new(ctx.gen, n.span)
give ir.StmtKind.LoopWhile(cond, body, label)
.end

proc _expr_not(ctx as LowerContext, e as ir.Expr, sp as span.Span) gives ir.Expr
make out as ir.Expr = ir.Expr()
set out.id = ir.idgen_expr(ctx.gen)
set out.span = sp
set out.attrs = ir.attrs_empty()
set out.kind = ir.ExprKind.Unary(ir.UnaryOp.Not(), e)
set out.ty = ir.TypeRef.Hole()
set ctx.stats.exprs_out += 1u64
give out
.end

proc _lower_stmt_each(ctx as LowerContext, n as AstNode) gives ir.StmtKind
# Convention:
#  n.text = item name
#  kids: iterable expr, body block, optional index name node(tag="index", text="i")
make item as ir.Name = ir.name_from_text(n.text)
make index as ir.Name = ir.name_from_text("")
make has_index as Bool = false

make iterable as ir.Expr = if list.len(n.kids)>0 then _lower_expr(ctx, n.kids[0]) else ir.Expr()
make body as ir.Block = if list.len(n.kids)>1 then _lower_block(ctx, n.kids[1]) else ir.block_new(ctx.gen, n.span)

make i as Int = 2
loop while i < list.len(n.kids)
  if n.kids[i].tag == "index"
    set index = ir.name_from_text(n.kids[i].text)
    set has_index = true
  .end
  set i += 1
.end

make label as ir.LabelId = ir.idgen_label(ctx.gen)

# If desugar_each enabled, keep LoopEach (already normalized in IR)
if ctx.cfg.desugar_each
  give ir.StmtKind.LoopEach(item, index, has_index, iterable, body, label)
.end

# else fallback: still use LoopEach
give ir.StmtKind.LoopEach(item, index, has_index, iterable, body, label)
.end

proc _lower_stmt_select(ctx as LowerContext, n as AstNode) gives ir.StmtKind
# Convention:
#  kids[0]=scrut expr, kids[1..]=when/otherwise nodes
make scrut as ir.Expr = if list.len(n.kids)>0 then _lower_expr(ctx, n.kids[0]) else ir.Expr()
make arms as List of ir.WhenArm = []
make other as ir.Block = ir.block_new(ctx.gen, n.span)
make has_other as Bool = false

make i as Int = 1
loop while i < list.len(n.kids)
  make k as AstNode = n.kids[i]
  if k.tag == "when"
    make arm as ir.WhenArm = ir.WhenArm()
    set arm.pat = if list.len(k.kids)>0 then _lower_pattern(ctx, k.kids[0]) else ir.Pattern()
    set arm.body = if list.len(k.kids)>1 then _lower_block(ctx, k.kids[1]) else ir.block_new(ctx.gen, k.span)
    list.push(arms, arm)
  elif k.tag == "otherwise"
    set other = if list.len(k.kids)>0 then _lower_block(ctx, k.kids[0]) else ir.block_new(ctx.gen, k.span)
    set has_other = true
  .end
  set i += 1
.end

give ir.StmtKind.Select(scrut, arms, other, has_other)
.end

proc _lower_stmt_give(ctx as LowerContext, n as AstNode) gives ir.StmtKind
if list.len(n.kids) > 0
  give ir.StmtKind.Give(_lower_expr(ctx, n.kids[0]), true)
.end
give ir.StmtKind.Give(ir.Expr(), false)
.end

proc _lower_stmt_emit(ctx as LowerContext, n as AstNode) gives ir.StmtKind
make e as ir.Expr = if list.len(n.kids)>0 then _lower_expr(ctx, n.kids[0]) else ir.Expr()
give ir.StmtKind.Emit(e)
.end

proc _lower_stmt_defer(ctx as LowerContext, n as AstNode) gives ir.StmtKind
# Convention:
#  kid[0] = action node tagged "call"/"set"/"emit"
if list.len(n.kids) == 0
  give ir.StmtKind.Defer(ir.DeferAction.Hole())
.end

make k as AstNode = n.kids[0]
if k.tag == "call"
  give ir.StmtKind.Defer(ir.DeferAction.Call(_lower_expr(ctx, k.kids[0])))
.end
if k.tag == "set"
  make tgt as ir.Target = ir.Target()
  set tgt.base = _lower_expr(ctx, k.kids[0])
  make op as ir.SetOp = _lower_set_op(k.kids[1].text)
  make v as ir.Expr = _lower_expr(ctx, k.kids[2])
  give ir.StmtKind.Defer(ir.DeferAction.SetInline(tgt, op, v))
.end
if k.tag == "emit"
  give ir.StmtKind.Defer(ir.DeferAction.EmitInline(_lower_expr(ctx, k.kids[0])))
.end

give ir.StmtKind.Defer(ir.DeferAction.Hole())
.end

proc _lower_stmt_assert(ctx as LowerContext, n as AstNode) gives ir.StmtKind
make cond as ir.Expr = if list.len(n.kids)>0 then _lower_expr(ctx, n.kids[0]) else ir.Expr()
if list.len(n.kids) > 1
  give ir.StmtKind.Assert(cond, _lower_expr(ctx, n.kids[1]), true)
.end
give ir.StmtKind.Assert(cond, ir.Expr(), false)
.end


<<< =========================================================
  8) EXPR LOWERING
========================================================= >>>

proc _lower_expr(ctx as LowerContext, n as AstNode) gives ir.Expr
make e as ir.Expr = ir.Expr()
set e.id = ir.idgen_expr(ctx.gen)
set e.span = n.span
set e.attrs = _lower_attrs(ctx, n.attrs, attr.AttrTarget.Expr())
set e.ty = ir.TypeRef.Hole()
set ctx.stats.exprs_out += 1u64

# Determine expression by tag
if n.tag == "lit"
  set e.kind = ir.ExprKind.Lit(_lower_literal_node(ctx, n))
  give e
.end
if n.tag == "name"
  set e.kind = ir.ExprKind.NameRef(ir.name_from_text(n.text))
  give e
.end
if n.tag == "path"
  set e.kind = ir.ExprKind.PathRef(ir.path_from_text(n.text))
  give e
.end
if n.tag == "call"
  set e.kind = _lower_call(ctx, n)
  give e
.end
if n.tag == "index"
  set e.kind = ir.ExprKind.Index(_lower_expr(ctx, n.kids[0]), _lower_expr(ctx, n.kids[1]))
  give e
.end
if n.tag == "field"
  set e.kind = ir.ExprKind.Field(_lower_expr(ctx, n.kids[0]), ir.name_from_text(n.text))
  give e
.end
if n.tag == "unary"
  set e.kind = _lower_unary(ctx, n)
  give e
.end
if n.tag == "binary"
  set e.kind = _lower_binary(ctx, n)
  give e
.end
if n.tag == "list"
  set e.kind = ir.ExprKind.ListLit(_lower_expr_list(ctx, n))
  give e
.end
if n.tag == "map"
  set e.kind = ir.ExprKind.MapLit(_lower_map_entries(ctx, n))
  give e
.end
if n.tag == "pack"
  set e.kind = ir.ExprKind.PackLit(_lower_expr_list(ctx, n))
  give e
.end

diag.error(ctx.diags, "unknown expr tag: " + n.tag, n.span)
set ctx.stats.errors += 1u64
set e.kind = ir.ExprKind.Hole()
give e
.end

proc _lower_literal_node(ctx as LowerContext, n as AstNode) gives ir.Literal
# Convention: n.text contains raw literal; n.tag may refine: "int","float","text","bool","null"
if n.tag == "null"
  give ir.Literal.Null()
.end
if n.tag == "bool"
  give ir.Literal.Bool(n.text == "true")
.end
if n.tag == "text"
  give ir.Literal.Text(n.text)
.end
if n.tag == "int"
  give ir.Literal.Int(n.text, ir.IntSuffix.None())
.end
if n.tag == "float"
  give ir.Literal.Float(n.text, ir.FloatSuffix.None())
.end
# fallback: treat as text
give ir.Literal.Text(n.text)
.end

proc _lower_call(ctx as LowerContext, n as AstNode) gives ir.ExprKind
# kids[0]=callee expr, remaining kids are args nodes
make cal as ir.Expr = _lower_expr(ctx, n.kids[0])
make args as List of ir.Arg = []
make i as Int = 1
loop while i < list.len(n.kids)
  list.push(args, _lower_arg(ctx, n.kids[i]))
  set i += 1
.end
give ir.ExprKind.Call(cal, args)
.end

proc _lower_arg(ctx as LowerContext, n as AstNode) gives ir.Arg
# Convention:
#  tag "named_arg": text=name, kids[0]=expr
#  else: positional expr
make a as ir.Arg = ir.Arg()
set a.name = ir.name_from_text("")
set a.has_name = false
set a.value = ir.Expr()

if n.tag == "named_arg"
  set a.name = ir.name_from_text(n.text)
  set a.has_name = true
  set a.value = _lower_expr(ctx, n.kids[0])
  give a
.end

set a.value = _lower_expr(ctx, n)
give a
.end

proc _lower_unary(ctx as LowerContext, n as AstNode) gives ir.ExprKind
# kids[0]=op text, kids[1]=expr
make op as ir.UnaryOp = ir.UnaryOp.Not()
if list.len(n.kids) > 0
  if n.kids[0].text == "-" set op = ir.UnaryOp.Neg() .end
  if n.kids[0].text == "not" set op = ir.UnaryOp.Not() .end
.end
make inner as ir.Expr = if list.len(n.kids)>1 then _lower_expr(ctx, n.kids[1]) else ir.Expr()
give ir.ExprKind.Unary(op, inner)
.end

proc _lower_binary(ctx as LowerContext, n as AstNode) gives ir.ExprKind
# kids[0]=left, kids[1]=op text, kids[2]=right
make left as ir.Expr = _lower_expr(ctx, n.kids[0])
make op as ir.BinaryOp = _lower_binop(if list.len(n.kids)>1 then n.kids[1].text else "")
make right as ir.Expr = _lower_expr(ctx, n.kids[2])
give ir.ExprKind.Binary(op, left, right)
.end

proc _lower_binop(t as Text) gives ir.BinaryOp
if t == "+"  give ir.BinaryOp.Add() .end
if t == "-"  give ir.BinaryOp.Sub() .end
if t == "*"  give ir.BinaryOp.Mul() .end
if t == "/"  give ir.BinaryOp.Div() .end
if t == "%"  give ir.BinaryOp.Rem() .end
if t == "==" give ir.BinaryOp.Eq()  .end
if t == "!=" give ir.BinaryOp.Ne()  .end
if t == "<"  give ir.BinaryOp.Lt()  .end
if t == "<=" give ir.BinaryOp.Le()  .end
if t == ">"  give ir.BinaryOp.Gt()  .end
if t == ">=" give ir.BinaryOp.Ge()  .end
if t == "and" give ir.BinaryOp.And() .end
give ir.BinaryOp.Or()
.end

proc _lower_expr_list(ctx as LowerContext, n as AstNode) gives List of ir.Expr
make out as List of ir.Expr = []
make i as Int = 0
loop while i < list.len(n.kids)
  list.push(out, _lower_expr(ctx, n.kids[i]))
  set i += 1
.end
give out
.end

proc _lower_map_entries(ctx as LowerContext, n as AstNode) gives List of ir.MapEntry
# kids are entry nodes: each has kids[0]=key, kids[1]=value
make out as List of ir.MapEntry = []
make i as Int = 0
loop while i < list.len(n.kids)
  make e as ir.MapEntry = ir.MapEntry()
  set e.key = _lower_expr(ctx, n.kids[i].kids[0])
  set e.value = _lower_expr(ctx, n.kids[i].kids[1])
  list.push(out, e)
  set i += 1
.end
give out
.end


<<< =========================================================
  9) PATTERN LOWERING
========================================================= >>>

proc _lower_pattern(ctx as LowerContext, n as AstNode) gives ir.Pattern
make p as ir.Pattern = ir.Pattern()
set p.span = n.span
set p.kind = ir.PatternKind.Hole()

if n.tag == "_"
  set p.kind = ir.PatternKind.Wild()
  give p
.end
if n.tag == "lit"
  set p.kind = ir.PatternKind.Lit(_lower_literal_node(ctx, n))
  give p
.end
if n.tag == "name"
  set p.kind = ir.PatternKind.NameBind(ir.name_from_text(n.text))
  give p
.end
if n.tag == "tuple"
  set p.kind = ir.PatternKind.Tuple(_lower_pat_list(ctx, n))
  give p
.end
if n.tag == "list"
  set p.kind = ir.PatternKind.List(_lower_pat_list(ctx, n))
  give p
.end
if n.tag == "variant"
  # n.text = type path, kid[0] = case name, remaining kids = payload patterns
  make ty as ir.Path = ir.path_from_text(n.text)
  make cn as ir.Name = ir.name_from_text(if list.len(n.kids)>0 then n.kids[0].text else "")
  make payload as List of ir.Pattern = []
  make i as Int = 1
  loop while i < list.len(n.kids)
    list.push(payload, _lower_pattern(ctx, n.kids[i]))
    set i += 1
  .end
  set p.kind = ir.PatternKind.Variant(ty, cn, payload)
  give p
.end

diag.error(ctx.diags, "unknown pattern tag: " + n.tag, n.span)
set ctx.stats.errors += 1u64
give p
.end

proc _lower_pat_list(ctx as LowerContext, n as AstNode) gives List of ir.Pattern
make out as List of ir.Pattern = []
make i as Int = 0
loop while i < list.len(n.kids)
  list.push(out, _lower_pattern(ctx, n.kids[i]))
  set i += 1
.end
give out
.end


<<< =========================================================
  10) ENTRY KIND MAP
========================================================= >>>

proc _lower_entry_kind(t as Text) gives ir.EntryKind
if t == "app"      give ir.EntryKind.App() .end
if t == "service"  give ir.EntryKind.Service() .end
if t == "tool"     give ir.EntryKind.Tool() .end
if t == "pipeline" give ir.EntryKind.Pipeline() .end
if t == "driver"   give ir.EntryKind.Driver() .end
if t == "kernel"   give ir.EntryKind.Kernel() .end
give ir.EntryKind.Tool()
.end


<<< =========================================================
  11) SMOKE TESTS (adapter-based)
========================================================= >>>

proc _test_lower_proc(diags as List of diag.Diagnostic)
make cfg as LowerConfig = lower_config_default()

# file -> proc item
make file as AstNode = ast_node(AstNodeKind.File(), "file", span.Span())

make proc_it as AstNode = ast_node(AstNodeKind.Item(), "proc", span.Span())
set proc_it = ast_with_text(proc_it, "main")

make params as AstNode = ast_node(AstNodeKind.Item(), "params", span.Span())
set proc_it = ast_push(proc_it, params)

make blk as AstNode = ast_node(AstNodeKind.Item(), "block", span.Span())

# body: emit "hello"
make lit as AstNode = ast_node(AstNodeKind.Expr(), "text", span.Span())
set lit = ast_with_text(lit, "hello")
make emit as AstNode = ast_node(AstNodeKind.Stmt(), "emit", span.Span())
set emit = ast_push(emit, lit)
set blk = ast_push(blk, emit)

set proc_it = ast_push(proc_it, blk)
set file = ast_push(file, proc_it)

make res as LowerResult = lower_file(file, cfg, diags)
emit ir.ir_file_summary(res.file)
give
.end
