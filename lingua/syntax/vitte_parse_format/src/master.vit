# File: C:\Users\gogin\Documents\GitHub\vitte\lingua\syntax\vitte_parse_format\src\master.vit
space lingua/syntax/vitte_parse_format/master

<<< master
  vitte_parse_format/master.vit — Format-string parsing (generic, MAX)

  Purpose:
    - Provide a generic, reusable format-string parsing subsystem for Vitte:
        * tokenize format strings with offset spans
        * parse specifiers using pluggable grammars (printf, rust-like, etc.)
        * validate arity and argument expectations
        * produce a deterministic "FormatPlan" for compiler lowering
    - This crate is intended to be used by builtin macros:
        * format_foreign/printf (C printf)
        * future: format_core (Vitte fmt), logging macros, etc.

  Philosophy:
    - linear-time scan
    - stable diagnostics (keys in messages.ftl) with byte offsets inside the
      format literal
    - strict separation of: scan -> parse -> validate -> lowering hints

  Notes:
    - "format strings" here means textual placeholders embedded in a string.
    - This module is generic; printf-specific details live in the printf builtin.

  Suggested layout:
    - master.vit: public API and shared types
    - scan.vit: tokenizer
    - diag.vit: diag helpers + message keys
>>>

pull std/text as text
pull std/collections/list as list
pull std/collections/map as map

pull lingua/syntax/vitte_ast/span as span
pull lingua/syntax/vitte_ast/diag as diag

share all

bond Text means String


<<< =========================================================
  0) TOKENS
========================================================= >>>

pick FmtTokKind
case Text()            # raw text segment
case LBrace()          # '{'
case RBrace()          # '}'
case Percent()         # '%'
case Spec()            # a full parsed spec (optional aggregation)
case Error()           # bad token / invalid sequence
.end

form FmtTok
field kind as FmtTokKind = FmtTokKind.Text()
field text as Text = ""
field off_lo as Int = 0          # offsets within the format string (0..len)
field off_hi as Int = 0
.end

proc tok(kind as FmtTokKind, text as Text, lo as Int, hi as Int) gives FmtTok
make t as FmtTok = FmtTok()
set t.kind = kind
set t.text = text
set t.off_lo = lo
set t.off_hi = hi
give t
.end


<<< =========================================================
  1) PLAN / EXPECTATIONS
========================================================= >>>

form ArgExpectation
field index as Int = 0           # 1-based argument index (excluding format string itself)
field expected as Text = ""      # stable type category: "int", "uint", "double", "cstring", "ptr", "unknown", ...
field reason as Text = ""        # short explanation (conv + length + rule)
field off_lo as Int = 0
field off_hi as Int = 0
.end

form FormatSpec
field raw as Text = ""           # raw spec text ("%08x", "{:>8}", ...)
field kind as Text = ""          # "printf", "brace", "custom"
field off_lo as Int = 0
field off_hi as Int = 0

# plugin-defined fields in `meta`
field meta as Map of Text to Text = map.new()
.end

form FormatPlan
field text_parts as List of FmtTok = []          # including Text + Spec placeholders
field specs as List of FormatSpec = []
field expects as List of ArgExpectation = []
field arg_count_min as Int = 0
field uses_positional as Bool = false
field uses_star as Bool = false
field has_hazards as Bool = false
.end


<<< =========================================================
  2) DIAGNOSTICS (FORMAT-LOCAL OFFSETS)
========================================================= >>>

form FmtDiag
field key as Text = ""           # messages.ftl key
field severity as diag.Severity = diag.Severity.Error()
field off_lo as Int = 0
field off_hi as Int = 0
field note as Text = ""
.end

proc fmt_error(key as Text, lo as Int, hi as Int) gives FmtDiag
make d as FmtDiag = FmtDiag()
set d.key = key
set d.severity = diag.Severity.Error()
set d.off_lo = lo
set d.off_hi = hi
give d
.end

proc fmt_warn(key as Text, lo as Int, hi as Int) gives FmtDiag
make d as FmtDiag = FmtDiag()
set d.key = key
set d.severity = diag.Severity.Warning()
set d.off_lo = lo
set d.off_hi = hi
give d
.end

proc fmt_note(d as FmtDiag, msg as Text)
set d.note = msg
.end


<<< =========================================================
  3) PLUGGABLE SPEC PARSER INTERFACE
========================================================= >>>

# The plugin takes the format string and a cursor at a marker (like '%' or '{')
# and returns either:
#  - a parsed spec + how many bytes were consumed
#  - or an error diag
pick SpecParseResultKind
case Ok()
case Err()
.end

form SpecParseResult
field kind as SpecParseResultKind = SpecParseResultKind.Err()
field spec as FormatSpec = FormatSpec()
field consumed as Int = 0
field diags as List of FmtDiag = []
.end

proc spec_ok(spec as FormatSpec, consumed as Int) gives SpecParseResult
make r as SpecParseResult = SpecParseResult()
set r.kind = SpecParseResultKind.Ok()
set r.spec = spec
set r.consumed = consumed
set r.diags = []
give r
.end

proc spec_err(ds as List of FmtDiag) gives SpecParseResult
make r as SpecParseResult = SpecParseResult()
set r.kind = SpecParseResultKind.Err()
set r.diags = ds
give r
.end

form SpecParser
# callable interface emulation: store function names / dispatch keys
field kind as Text = ""     # "printf", "brace", ...
.end

proc parse_at(parser as SpecParser, fmt as Text, at as Int) gives SpecParseResult
# Dispatch placeholder; concrete parsers will override/replace this.
make ds as List of FmtDiag = [fmt_error("vitte-format-e-no-parser", at, at + 1)]
give spec_err(ds)
.end


<<< =========================================================
  4) MAIN API: SCAN + PARSE
========================================================= >>>

form ParseOptions
field max_len as Int = 65536
field max_specs as Int = 1024
field allow_nul as Bool = true
.end

proc parse_options_default() gives ParseOptions
give ParseOptions()
.end

form ParseResult
field plan as FormatPlan = FormatPlan()
field ok as Bool = true
field diags as List of FmtDiag = []
.end

proc parse_format(fmt as Text, parser as SpecParser, opts as ParseOptions) gives ParseResult
make r as ParseResult = ParseResult()
set r.ok = true
set r.diags = []
set r.plan = FormatPlan()

# guards
if text.len(fmt) > opts.max_len
  list.push(r.diags, fmt_error("vitte-format-e-too-long", 0, text.len(fmt)))
  set r.ok = false
  give r
.end

# scan linearly; parse specs at markers
make i as Int = 0
make last_text as Int = 0
make spec_count as Int = 0

loop while i < text.len(fmt)
  make c as Text = text.at(fmt, i)

  # marker for plugin (printf uses '%', brace uses '{')
  if c == "%" or c == "{"
    # flush pending text
    if i > last_text
      list.push(r.plan.text_parts, tok(FmtTokKind.Text(), text.slice(fmt, last_text, i), last_text, i))
    .end

    make pr as SpecParseResult = parse_at(parser, fmt, i)
    if pr.kind is SpecParseResultKind.Err()
      _append_fmt_diags(r.diags, pr.diags)
      # recover: consume 1 byte and continue
      list.push(r.plan.text_parts, tok(FmtTokKind.Error(), c, i, i + 1))
      set i = i + 1
      set last_text = i
      set r.ok = false
      loop while false .end
    .end

    # accept spec
    set spec_count = spec_count + 1
    if spec_count > opts.max_specs
      list.push(r.diags, fmt_error("vitte-format-e-too-many-specs", i, i + 1))
      set r.ok = false
      give r
    .end

    list.push(r.plan.specs, pr.spec)
    list.push(r.plan.text_parts, tok(FmtTokKind.Spec(), pr.spec.raw, pr.spec.off_lo, pr.spec.off_hi))

    set i = i + pr.consumed
    set last_text = i
    loop while false .end
  .end

  set i = i + 1
.end

# trailing text
if last_text < text.len(fmt)
  list.push(r.plan.text_parts, tok(FmtTokKind.Text(), text.slice(fmt, last_text, text.len(fmt)), last_text, text.len(fmt)))
.end

give r
.end

proc _append_fmt_diags(dst as List of FmtDiag, src as List of FmtDiag)
make i as Int = 0
loop while i < list.len(src)
  list.push(dst, src[i])
  set i += 1
.end
.end


<<< =========================================================
  5) VALIDATION (ARITY / EXPECTATIONS) — GENERIC HELPERS
========================================================= >>>

form ValidationReport
field ok as Bool = true
field expects as List of ArgExpectation = []
field uses_positional as Bool = false
field uses_star as Bool = false
field hazards as List of Text = []          # stable hazard codes
.end

proc validate_plan_generic(plan as FormatPlan, max_args as Int) gives ValidationReport
make r as ValidationReport = ValidationReport()
set r.ok = true
set r.expects = plan.expects
set r.uses_positional = plan.uses_positional
set r.uses_star = plan.uses_star
set r.hazards = []

# compute arg_count_min from expectations
make max_idx as Int = 0
make i as Int = 0
loop while i < list.len(r.expects)
  if r.expects[i].index > max_idx
    set max_idx = r.expects[i].index
  .end
  set i += 1
.end
set plan.arg_count_min = max_idx

if max_idx > max_args
  set r.ok = false
.end

give r
.end


<<< =========================================================
  6) OFFSET→SPAN MAPPING HELPERS
========================================================= >>>

proc fmt_offsets_to_span(lit_span as span.Span, off_lo as Int, off_hi as Int) gives span.Span
# If lit_span covers the literal token including quotes, adjust in caller.
# Here we assume off_lo/off_hi are relative to the string content start.
give span.shift_range(lit_span, off_lo, off_hi)
.end


<<< =========================================================
  7) SMOKE TEST
========================================================= >>>

proc _test()
make parser as SpecParser = SpecParser()
set parser.kind = "printf" # (placeholder)
make opts as ParseOptions = parse_options_default()
make r as ParseResult = parse_format("x=%d y=%08x", parser, opts)
emit "ok=" + (if r.ok then "true" else "false")
emit "specs=" + text.from_int(list.len(r.plan.specs))
give
.end
