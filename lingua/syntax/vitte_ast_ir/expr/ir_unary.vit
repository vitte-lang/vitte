# ============================================================
# vitte — expr/mod.vit
# AST-IR Expression Aggregator — ULTRA MAX
# ============================================================

space vitte/ast_ir/expr

# ----------------------------
# Submodules
# ----------------------------

pull vitte/ast_ir/expr/ir_assign
pull vitte/ast_ir/expr/ir_binary
pull vitte/ast_ir/expr/ir_unary
pull vitte/ast_ir/expr/ir_call
pull vitte/ast_ir/expr/ir_cast
pull vitte/ast_ir/expr/ir_expr

# ----------------------------
# Public API
# ----------------------------

share all

# ----------------------------
# Expression bundle (optional helper)
# ----------------------------

type ExprBundle
    exprs   : List[IrExpr]
.end

# ----------------------------
# Constructors
# ----------------------------

proc ExprBundle.new() -> ExprBundle
    return ExprBundle {
        exprs = List.new()
    }
.end

# ----------------------------
# Management helpers
# ----------------------------

proc push(b: ExprBundle, e: IrExpr)
    b.exprs.push(e)
.end

proc all_used_values(b: ExprBundle) -> Set[ValueId]
    let out = Set.new()
    for e in b.exprs
        out = out.union(ir_expr.used_values(e))
    .end
    return out
.end

proc all_defined_values(b: ExprBundle) -> Set[ValueId]
    let out = Set.new()
    for e in b.exprs
        out = out.union(ir_expr.defined_values(e))
    .end
    return out
.end

# ----------------------------
# Validation
# ----------------------------

proc validate(b: ExprBundle, ctx: DiagnosticCtx)
    for e in b.exprs
        ir_expr.validate(e, ctx)
    .end
.end

# ----------------------------
# Debug / Dump
# ----------------------------

proc dump(b: ExprBundle)
    say "=== ExprBundle ==="
    for e in b.exprs
        ir_expr.dump(e)
    .end
.end

# ----------------------------
# End of module
# ----------------------------
