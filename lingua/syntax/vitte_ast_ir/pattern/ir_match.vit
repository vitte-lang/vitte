# ============================================================
# vitte — ir_match.vit
# AST-IR Pattern Matching / Match Expressions — ULTRA MAX
# ============================================================

space vitte/ast_ir/pattern

# ----------------------------
# Imports
# ----------------------------

pull vitte/ast_ir/common
pull vitte/ast_ir/attribute
pull vitte/ast_ir/control_flow
pull vitte/ast_ir/expr
pull vitte/collections/map
pull vitte/collections/list
pull vitte/collections/set

# ----------------------------
# Public API
# ----------------------------

share all

# ----------------------------
# Pattern kind
# ----------------------------

type PatternKind
    Wildcard                # _
    Literal(value: int)     # literal match
    Range(lo: int, hi: int) # inclusive range
    Binding(name: String)   # bind value
    Variant(type: String, fields: List[Pattern])
.end

# ----------------------------
# Pattern
# ----------------------------

type Pattern
    kind    : PatternKind
    attrs   : AttributeBundle
.end

# ----------------------------
# Match arm
# ----------------------------

type MatchArm
    pattern     : Pattern
    guard       : ValueId?
    target      : BlockId
.end

# ----------------------------
# IR Match
# ----------------------------

type IrMatch
    scrutinee   : ValueId
    arms        : List[MatchArm]
    default     : BlockId?
    attrs       : AttributeBundle
.end

# ----------------------------
# Constructors
# ----------------------------

proc Pattern.wildcard() -> Pattern
    return Pattern {
        kind  = PatternKind::Wildcard,
        attrs = AttributeBundle.new()
    }
.end

proc Pattern.literal(v: int) -> Pattern
    return Pattern {
        kind  = PatternKind::Literal(v),
        attrs = AttributeBundle.new()
    }
.end

proc Pattern.range(lo: int, hi: int) -> Pattern
    return Pattern {
        kind  = PatternKind::Range(lo, hi),
        attrs = AttributeBundle.new()
    }
.end

proc Pattern.binding(name: String) -> Pattern
    return Pattern {
        kind  = PatternKind::Binding(name),
        attrs = AttributeBundle.new()
    }
.end

proc Pattern.variant(ty: String, fields: List[Pattern]) -> Pattern
    return Pattern {
        kind  = PatternKind::Variant(ty, fields),
        attrs = AttributeBundle.new()
    }
.end

proc MatchArm.new(pat: Pattern, guard: ValueId?, target: BlockId) -> MatchArm
    return MatchArm {
        pattern = pat,
        guard   = guard,
        target  = target
    }
.end

proc IrMatch.new(scrutinee: ValueId) -> IrMatch
    return IrMatch {
        scrutinee = scrutinee,
        arms      = List.new(),
        default   = none,
        attrs     = AttributeBundle.new()
    }
.end

# ----------------------------
# Arm management
# ----------------------------

proc add_arm(m: IrMatch, arm: MatchArm)
    m.arms.push(arm)
.end

proc set_default(m: IrMatch, b: BlockId)
    m.default = some(b)
.end

# ----------------------------
# Analysis helpers
# ----------------------------

proc bindings(p: Pattern) -> Set[String]
    let out = Set.new()
    match p.kind
        PatternKind::Binding(n) => out.insert(n)
        PatternKind::Variant(_, fs) =>
            for f in fs
                out = out.union(bindings(f))
            .end
        .end
        _ => ()
    .end
    return out
.end

proc is_exhaustive(m: IrMatch) -> bool
    # conservative: wildcard or default
    for a in m.arms
        if a.pattern.kind == PatternKind::Wildcard
            return true
        .end
    .end
    return m.default?
.end

# ----------------------------
# Lowering to control-flow
# ----------------------------

proc lower_to_select(m: IrMatch) -> IrSelect
    let sel = IrSelect.match(m.scrutinee)

    for a in m.arms
        match a.pattern.kind
            PatternKind::Literal(v) => sel.add_case(List.of(v), a.target)
            _ => ()
        .end
    .end

    if m.default?
        sel.set_default(m.default?)
    .end

    return sel
.end

# ----------------------------
# Debug / Dump
# ----------------------------

proc dump_pattern(p: Pattern)
    say "Pattern ", p.kind
.end

proc dump_match(m: IrMatch)
    say "IrMatch scrutinee=", m.scrutinee
    for a in m.arms
        say " arm -> ", a.target
        dump_pattern(a.pattern)
        if a.guard?
            say "  guard=", a.guard?
        .end
    .end
    if m.default?
        say " default -> ", m.default?
    .end
.end

# ----------------------------
# End of module
# ----------------------------
