# ============================================================
# vitte â€” ir_meta.vit
# AST-IR Metadata System (ULTRA MAX)
# ============================================================

space vitte/ast_ir/attribute

# ----------------------------
# Imports
# ----------------------------

pull vitte/ast_ir/value
pull vitte/ast_ir/block
pull vitte/ast_ir/instruction
pull vitte/collections/map
pull vitte/collections/list

# ----------------------------
# Public API
# ----------------------------

share all

# ----------------------------
# Metadata kinds
# ----------------------------

type MetaKind
    Source      # source-level info (file, line, column)
    Debug       # debug / tooling metadata
    Analysis    # analysis results (dominance, liveness, etc.)
    Codegen     # backend / lowering hints
    Custom      # user or pass-defined
.end

# ----------------------------
# Metadata value
# ----------------------------

type MetaValue
    Bool(value: bool)
    Int(value: int)
    String(value: String)
    List(value: List[String])
    Map(value: Map[String, String])
    Unknown
.end

# ----------------------------
# Metadata entry
# ----------------------------

type Meta
    key         : String
    kind        : MetaKind
    value       : MetaValue
.end

# ----------------------------
# Metadata container
# ----------------------------

type MetaMap
    data        : Map[String, Meta]
.end

# ----------------------------
# Constructors
# ----------------------------

proc MetaMap.new() -> MetaMap
    return MetaMap {
        data = Map.new()
    }
.end

proc Meta.new(key: String, kind: MetaKind, value: MetaValue) -> Meta
    return Meta {
        key   = key,
        kind  = kind,
        value = value
    }
.end

# ----------------------------
# MetaMap operations
# ----------------------------

proc set(map: MetaMap, meta: Meta)
    map.data[meta.key] = meta
.end

proc has(map: MetaMap, key: String) -> bool
    return map.data.contains(key)
.end

proc get(map: MetaMap, key: String) -> Meta?
    if map.data.contains(key)
        return some(map.data[key])
    .end
    return none
.end

proc remove(map: MetaMap, key: String)
    if map.data.contains(key)
        map.data.remove(key)
    .end
.end

# ----------------------------
# Typed helpers
# ----------------------------

proc get_string(map: MetaMap, key: String) -> String?
    let m? = get(map, key)
    if m? && m?.value is MetaValue::String
        return some(m?.value.value)
    .end
    return none
.end

proc get_int(map: MetaMap, key: String) -> int?
    let m? = get(map, key)
    if m? && m?.value is MetaValue::Int
        return some(m?.value.value)
    .end
    return none
.end

proc get_bool(map: MetaMap, key: String) -> bool?
    let m? = get(map, key)
    if m? && m?.value is MetaValue::Bool
        return some(m?.value.value)
    .end
    return none
.end

# ----------------------------
# Common metadata helpers
# ----------------------------

proc set_source(map: MetaMap, file: String, line: int, column: int)
    set(map, Meta.new("source.file", MetaKind::Source, MetaValue::String(file)))
    set(map, Meta.new("source.line", MetaKind::Source, MetaValue::Int(line)))
    set(map, Meta.new("source.column", MetaKind::Source, MetaValue::Int(column)))
.end

proc set_debug_name(map: MetaMap, name: String)
    set(map, Meta.new("debug.name", MetaKind::Debug, MetaValue::String(name)))
.end

proc set_pass(map: MetaMap, pass: String)
    set(map, Meta.new("analysis.pass", MetaKind::Analysis, MetaValue::String(pass)))
.end

# ----------------------------
# Queries
# ----------------------------

proc has_source(map: MetaMap) -> bool
    return has(map, "source.file")
.end

proc debug_name(map: MetaMap) -> String?
    return get_string(map, "debug.name")
.end

# ----------------------------
# Merge
# ----------------------------

proc merge(dst: MetaMap, src: MetaMap)
    for (k, v) in src.data
        dst.data[k] = v
    .end
.end

# ----------------------------
# Debug / Dump
# ----------------------------

proc dump(map: MetaMap)
    say "Metadata"
    for (k, m) in map.data
        say " ", k, " = ", m.value
    .end
.end

# ----------------------------
# End of module
# ----------------------------
