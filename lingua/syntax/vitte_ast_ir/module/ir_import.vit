# ============================================================
# vitte — ir_import.vit
# AST-IR Import & Module Dependency System — ULTRA MAX
# ============================================================

space vitte/ast_ir/module

# ----------------------------
# Imports
# ----------------------------

pull vitte/ast_ir/common
pull vitte/ast_ir/attribute
pull vitte/collections/map
pull vitte/collections/set
pull vitte/collections/list

# ----------------------------
# Public API
# ----------------------------

share all

# ----------------------------
# Import kind
# ----------------------------

type ImportKind
    Module          # import module path
    Symbol          # import specific symbol
    Glob            # import *
.end

# ----------------------------
# Import path
# ----------------------------

type ImportPath
    segments    : List[String]
.end

# ----------------------------
# IR Import
# ----------------------------

type IrImport
    kind        : ImportKind
    path        : ImportPath
    alias       : String?
    symbols     : List[String]
    attrs       : AttributeBundle
.end

# ----------------------------
# Module dependency
# ----------------------------

type ModuleDep
    path        : ImportPath
    resolved    : bool
    module_id   : int?
.end

# ----------------------------
# Import table
# ----------------------------

type ImportTable
    imports     : List[IrImport]
    deps        : Map[String, ModuleDep]
.end

# ----------------------------
# Constructors
# ----------------------------

proc ImportPath.new(segs: List[String]) -> ImportPath
    return ImportPath { segments = segs }
.end

proc ImportPath.to_string(p: ImportPath) -> String
    let out = ""
    for s in p.segments
        if out != ""
            out = out + "/"
        .end
        out = out + s
    .end
    return out
.end

proc IrImport.module(path: ImportPath, alias: String?) -> IrImport
    return IrImport {
        kind    = ImportKind::Module,
        path    = path,
        alias   = alias,
        symbols = List.new(),
        attrs   = AttributeBundle.new()
    }
.end

proc IrImport.symbols(path: ImportPath, names: List[String], alias: String?) -> IrImport
    return IrImport {
        kind    = ImportKind::Symbol,
        path    = path,
        alias   = alias,
        symbols = names,
        attrs   = AttributeBundle.new()
    }
.end

proc IrImport.glob(path: ImportPath, alias: String?) -> IrImport
    return IrImport {
        kind    = ImportKind::Glob,
        path    = path,
        alias   = alias,
        symbols = List.new(),
        attrs   = AttributeBundle.new()
    }
.end

proc ImportTable.new() -> ImportTable
    return ImportTable {
        imports = List.new(),
        deps    = Map.new()
    }
.end

# ----------------------------
# Registration
# ----------------------------

proc add_import(tab: ImportTable, imp: IrImport)
    tab.imports.push(imp)

    let key = ImportPath.to_string(imp.path)
    if !tab.deps.contains(key)
        tab.deps[key] = ModuleDep {
            path      = imp.path,
            resolved  = false,
            module_id = none
        }
    .end
.end

# ----------------------------
# Resolution
# ----------------------------

proc mark_resolved(tab: ImportTable, path: ImportPath, module_id: int)
    let key = ImportPath.to_string(path)
    if tab.deps.contains(key)
        tab.deps[key].resolved  = true
        tab.deps[key].module_id = some(module_id)
    .end
.end

proc is_resolved(tab: ImportTable, path: ImportPath) -> bool
    let key = ImportPath.to_string(path)
    return tab.deps.contains(key) && tab.deps[key].resolved
.end

# ----------------------------
# Queries
# ----------------------------

proc imported_modules(tab: ImportTable) -> Set[String]
    let out = Set.new()
    for (k, _) in tab.deps
        out.insert(k)
    .end
    return out
.end

proc imported_symbols(tab: ImportTable) -> Map[String, List[String]]
    let out = Map.new()
    for imp in tab.imports
        if imp.kind == ImportKind::Symbol
            let key = ImportPath.to_string(imp.path)
            out.get_or_insert(key, List.new()).extend(imp.symbols)
        .end
    .end
    return out
.end

# ----------------------------
# Validation
# ----------------------------

proc validate(tab: ImportTable, ctx: DiagnosticCtx)
    for imp in tab.imports
        if imp.kind == ImportKind::Symbol && imp.symbols.is_empty()
            let err = error.error(ErrorCode::Validate, "empty symbol import")
            emit_error(ctx, err)
        .end
    .end
.end

# ----------------------------
# Debug / Dump
# ----------------------------

proc dump(tab: ImportTable)
    say "=== ImportTable ==="
    for imp in tab.imports
        say " import ", ImportPath.to_string(imp.path), " kind=", imp.kind,
            " alias=", imp.alias, " symbols=", imp.symbols
    .end

    say "-- Dependencies"
    for (k, d) in tab.deps
        say " ", k, " resolved=", d.resolved, " module_id=", d.module_id
    .end
.end

# ----------------------------
# End of module
# ----------------------------
