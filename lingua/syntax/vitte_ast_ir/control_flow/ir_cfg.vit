# ============================================================
# vitte — ir_cfg.vit
# AST-IR Control Flow Graph (CFG) — ULTRA MAX
# ============================================================

space vitte/ast_ir/control_flow

# ----------------------------
# Imports
# ----------------------------

pull vitte/ast_ir/common
pull vitte/ast_ir/control_flow/ir_block
pull vitte/collections/map
pull vitte/collections/list
pull vitte/collections/set

# ----------------------------
# Public API
# ----------------------------

share all

# ----------------------------
# Control Flow Graph
# ----------------------------

type Cfg
    blocks      : Map[BlockId, IrBlock]
    entry       : BlockId
.end

# ----------------------------
# Constructors
# ----------------------------

proc Cfg.new(entry: BlockId) -> Cfg
    return Cfg {
        blocks = Map.new(),
        entry  = entry
    }
.end

# ----------------------------
# Block management
# ----------------------------

proc add_block(cfg: Cfg, block: IrBlock)
    cfg.blocks[block.id] = block
.end

proc has_block(cfg: Cfg, id: BlockId) -> bool
    return cfg.blocks.contains(id)
.end

proc block(cfg: Cfg, id: BlockId) -> IrBlock
    return cfg.blocks[id]
.end

proc blocks(cfg: Cfg) -> List[BlockId]
    let out = List.new()
    for (id, _) in cfg.blocks
        out.push(id)
    .end
    return out
.end

# ----------------------------
# Entry
# ----------------------------

proc entry(cfg: Cfg) -> BlockId
    return cfg.entry
.end

# ----------------------------
# CFG linking
# ----------------------------

proc link(cfg: Cfg)
    # clear preds
    for (_, b) in cfg.blocks
        b.preds.clear()
        b.succs.clear()
    .end

    # recompute edges
    for (_, b) in cfg.blocks
        if b.terminator?
            for t in b.terminator?.targets
                if cfg.blocks.contains(t)
                    b.succs.insert(t)
                    cfg.blocks[t].preds.insert(b.id)
                .end
            .end
        .end
    .end
.end

# ----------------------------
# Queries
# ----------------------------

proc predecessors(cfg: Cfg, b: BlockId) -> Set[BlockId]
    return cfg.blocks[b].preds
.end

proc successors(cfg: Cfg, b: BlockId) -> Set[BlockId]
    return cfg.blocks[b].succs
.end

proc is_exit(cfg: Cfg, b: BlockId) -> bool
    let blk = cfg.blocks[b]
    if !blk.terminator?
        return false
    .end

    match blk.terminator?.kind
        TerminatorKind::Return      => true
        TerminatorKind::Unreachable => true
        _                           => false
    .end
.end

# ----------------------------
# Traversals
# ----------------------------

proc blocks_rev_postorder(cfg: Cfg) -> List[BlockId]
    let visited = Set.new()
    let order   = List.new()

    proc dfs(b: BlockId)
        if visited.contains(b)
            return
        .end
        visited.insert(b)
        for s in cfg.successors(b)
            dfs(s)
        .end
        order.push(b)
    .end

    dfs(cfg.entry)
    return order
.end

proc blocks_postorder(cfg: Cfg) -> List[BlockId]
    let rpo = blocks_rev_postorder(cfg)
    rpo.reverse()
    return rpo
.end

# ----------------------------
# Reverse CFG
# ----------------------------

proc reverse(cfg: Cfg) -> Cfg
    let new_entry = cfg.entry
    let rcfg = Cfg.new(new_entry)

    # clone blocks without edges
    for (_, b) in cfg.blocks
        let nb = IrBlock.new(b.id, b.name)
        nb.instrs     = b.instrs.clone()
        nb.terminator = b.terminator
        rcfg.add_block(nb)
    .end

    # reverse edges
    for (_, b) in cfg.blocks
        for s in b.succs
            rcfg.blocks[s].succs.insert(b.id)
            rcfg.blocks[b.id].preds.insert(s)
        .end
    .end

    return rcfg
.end

# ----------------------------
# Validation
# ----------------------------

proc validate(cfg: Cfg) -> bool
    # entry must exist
    if !cfg.blocks.contains(cfg.entry)
        return false
    .end

    # all successors must exist
    for (_, b) in cfg.blocks
        for s in b.succs
            if !cfg.blocks.contains(s)
                return false
            .end
        .end
    .end

    return true
.end

# ----------------------------
# Debug / Dump
# ----------------------------

proc dump(cfg: Cfg)
    say "CFG(entry=", cfg.entry, ")"
    for (_, b) in cfg.blocks
        b.dump()
        say "  preds=", b.preds, " succs=", b.succs
    .end
.end

# ----------------------------
# End of module
# ----------------------------
