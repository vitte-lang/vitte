// vitte_ast_ir skeleton

# ============================================================
# vitte — control_flow/mod.vit
# AST-IR Control Flow Aggregator — ULTRA MAX
# ============================================================

space vitte/ast_ir/control_flow

# ----------------------------
# Submodules
# ----------------------------

pull vitte/ast_ir/control_flow/ir_block
pull vitte/ast_ir/control_flow/ir_cfg
pull vitte/ast_ir/control_flow/ir_loop
pull vitte/ast_ir/control_flow/ir_select
pull vitte/ast_ir/control_flow/ir_terminator

# ----------------------------
# Public API
# ----------------------------

share all

# ----------------------------
# Control-flow bundle
# ----------------------------

type ControlFlowBundle
    cfg         : Cfg
    loops       : LoopForest?
.end

# ----------------------------
# Constructors
# ----------------------------

proc ControlFlowBundle.new(cfg: Cfg) -> ControlFlowBundle
    return ControlFlowBundle {
        cfg   = cfg,
        loops = none
    }
.end

# ----------------------------
# Analysis helpers
# ----------------------------

proc compute_loops(bundle: ControlFlowBundle, dom: DominatorTree)
    let forest = ir_loop.find_natural_loops(bundle.cfg, dom)
    bundle.loops = some(forest)
.end

# ----------------------------
# Queries
# ----------------------------

proc has_loops(bundle: ControlFlowBundle) -> bool
    return bundle.loops?
.end

proc is_loop_header(bundle: ControlFlowBundle, b: BlockId) -> bool
    if bundle.loops?
        return bundle.loops?.loops.contains(b)
    .end
    return false
.end

# ----------------------------
# Debug / Dump
# ----------------------------

proc dump(bundle: ControlFlowBundle)
    say "=== ControlFlowBundle ==="
    bundle.cfg.dump()

    if bundle.loops?
        bundle.loops?.dump()
    .end
.end

# ----------------------------
# End of module
# ----------------------------