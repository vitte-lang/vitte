# ============================================================
# vitte — ir_select.vit
# AST-IR Select / Switch Control-Flow Representation — ULTRA MAX
# ============================================================

space vitte/ast_ir/control_flow

# ----------------------------
# Imports
# ----------------------------

pull vitte/ast_ir/common
pull vitte/ast_ir/control_flow/ir_block
pull vitte/ast_ir/control_flow/ir_cfg
pull vitte/ast_ir/attribute
pull vitte/collections/map
pull vitte/collections/list
pull vitte/collections/set

# ----------------------------
# Public API
# ----------------------------

share all

# ----------------------------
# Select / Switch kinds
# ----------------------------

type SelectKind
    IfElse          # lowered conditional if/else chain
    Match           # value-based match / switch
    JumpTable       # dense integer dispatch
.end

# ----------------------------
# Select case
# ----------------------------

type SelectCase
    values      : List[int]         # case values (empty for default)
    target      : BlockId
.end

# ----------------------------
# IR Select
# ----------------------------

type IrSelect
    kind        : SelectKind
    scrutinee   : ValueId?
    cases       : List[SelectCase]
    default     : BlockId?
    attrs       : AttributeBundle
.end

# ----------------------------
# Constructors
# ----------------------------

proc SelectCase.new(values: List[int], target: BlockId) -> SelectCase
    return SelectCase {
        values = values,
        target = target
    }
.end

proc IrSelect.if_else(cond: ValueId, then_b: BlockId, else_b: BlockId) -> IrSelect
    return IrSelect {
        kind      = SelectKind::IfElse,
        scrutinee = some(cond),
        cases     = List.of(SelectCase.new(List.of(1), then_b)),
        default   = some(else_b),
        attrs     = AttributeBundle.new()
    }
.end

proc IrSelect.match(scrutinee: ValueId) -> IrSelect
    return IrSelect {
        kind      = SelectKind::Match,
        scrutinee = some(scrutinee),
        cases     = List.new(),
        default   = none,
        attrs     = AttributeBundle.new()
    }
.end

# ----------------------------
# Case management
# ----------------------------

proc add_case(sel: IrSelect, values: List[int], target: BlockId)
    sel.cases.push(SelectCase.new(values, target))
.end

proc set_default(sel: IrSelect, target: BlockId)
    sel.default = some(target)
.end

# ----------------------------
# CFG lowering
# ----------------------------

proc lower_to_cfg(sel: IrSelect, cfg: Cfg, from: BlockId)
    let blk = cfg.block(from)

    match sel.kind
        SelectKind::IfElse =>
            let then_b = sel.cases[0].target
            let else_b = sel.default?
            blk.set_terminator(Terminator.branch(then_b, else_b, sel.scrutinee?))
        .end

        SelectKind::Match =>
            # naive lowering: chain of branches
            let current = from
            for case in sel.cases
                let test_blk = cfg.block(current)
                let next_blk = cfg.block(case.target)
                test_blk.set_terminator(Terminator.jump(next_blk.id))
                current = case.target
            .end

            if sel.default?
                cfg.block(current).set_terminator(Terminator.jump(sel.default?))
            .end
        .end

        SelectKind::JumpTable =>
            # backend-specific lowering, keep abstract
            ()
        .end
    .end
.end

# ----------------------------
# Queries
# ----------------------------

proc is_exhaustive(sel: IrSelect) -> bool
    return sel.default?
.end

proc targets(sel: IrSelect) -> Set[BlockId]
    let out = Set.new()
    for c in sel.cases
        out.insert(c.target)
    .end
    if sel.default?
        out.insert(sel.default?)
    .end
    return out
.end

# ----------------------------
# Debug / Dump
# ----------------------------

proc dump(sel: IrSelect)
    say "IrSelect kind=", sel.kind
    say " scrutinee=", sel.scrutinee
    for c in sel.cases
        say "  case ", c.values, " -> ", c.target
    .end
    if sel.default?
        say "  default -> ", sel.default?
    .end
.end

# ----------------------------
# End of module
# ----------------------------
