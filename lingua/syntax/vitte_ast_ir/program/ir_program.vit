# ============================================================
# vitte — ir_program.vit
# AST-IR Program / Compilation Root — ULTRA MAX
# ============================================================

space vitte/ast_ir/program

# ----------------------------
# Imports
# ----------------------------

pull vitte/ast_ir/common
pull vitte/ast_ir/module
pull vitte/ast_ir/analysis
pull vitte/ast_ir/control_flow
pull vitte/ast_ir/expr
pull vitte/ast_ir/pattern
pull vitte/collections/map
pull vitte/collections/list
pull vitte/collections/set

# ----------------------------
# Public API
# ----------------------------

share all

# ----------------------------
# Entry kind
# ----------------------------

type EntryKind
    Program
    Service
    Tool
    Library
.end

# ----------------------------
# Program entry
# ----------------------------

type ProgramEntry
    kind        : EntryKind
    module      : String
    function    : String
    attrs       : AttributeBundle
.end

# ----------------------------
# IR Program (root)
# ----------------------------

type IrProgram
    modules     : ModuleBundle
    entry       : ProgramEntry?
    ctx         : CommonContext
    attrs       : AttributeBundle
.end

# ----------------------------
# Constructors
# ----------------------------

proc ProgramEntry.new(kind: EntryKind, module: String, function: String) -> ProgramEntry
    return ProgramEntry {
        kind     = kind,
        module   = module,
        function = function,
        attrs    = AttributeBundle.new()
    }
.end

proc IrProgram.new() -> IrProgram
    return IrProgram {
        modules = ModuleBundle.new(),
        entry   = none,
        ctx     = CommonContext.new(),
        attrs   = AttributeBundle.new()
    }
.end

# ----------------------------
# Registration helpers
# ----------------------------

proc add_module(p: IrProgram, m: IrModule)
    p.modules.add_module(m)
.end

proc set_entry(p: IrProgram, e: ProgramEntry)
    p.entry = some(e)
.end

# ----------------------------
# Queries
# ----------------------------

proc has_entry(p: IrProgram) -> bool
    return p.entry?
.end

proc entry_function(p: IrProgram) -> (String, String)?
    if p.entry?
        return some((p.entry?.module, p.entry?.function))
    .end
    return none
.end

# ----------------------------
# Global analysis helpers
# ----------------------------

proc build_all_ssa(p: IrProgram)
    for (_, m) in p.modules.modules
        m.build_ssa(p.ctx)
    .end
.end

proc validate(p: IrProgram, ctx: DiagnosticCtx)
    p.modules.validate(ctx)

    if p.entry?
        let (m, f) = (p.entry?.module, p.entry?.function)
        if !p.modules.has_module(m)
            let err = error.error(ErrorCode::Validate, "entry module not found")
            emit_error(ctx, err)
        .end
        if p.modules.has_module(m) && !p.modules.module(m).has_function(f)
            let err = error.error(ErrorCode::Validate, "entry function not found")
            emit_error(ctx, err)
        .end
    .end
.end

# ----------------------------
# Debug / Dump
# ----------------------------

proc dump(p: IrProgram)
    say "=== IrProgram ==="

    if p.entry?
        say "Entry ", p.entry?.kind, " -> ", p.entry?.module, "::", p.entry?.function
    .end

    p.modules.dump()
.end

# ----------------------------
# End of module
# ----------------------------
