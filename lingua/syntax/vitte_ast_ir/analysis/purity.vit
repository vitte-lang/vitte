# ============================================================
# vitte — purity.vit
# Purity & Side-Effect Analysis — ULTRA MAX
# ============================================================

space vitte/ast_ir/analysis

# ----------------------------
# Imports
# ----------------------------

pull vitte/ast_ir/cfg
pull vitte/ast_ir/block
pull vitte/ast_ir/value
pull vitte/ast_ir/instruction
pull vitte/collections/map
pull vitte/collections/set
pull vitte/collections/list

# ----------------------------
# Public API
# ----------------------------

share all

# ----------------------------
# Purity kinds
# ----------------------------

type Purity
    Pure            # no side effects, deterministic
    ReadOnly        # reads memory, no mutation
    Write           # writes memory
    Io              # performs I/O
    Unknown         # conservative fallback
.end

# ----------------------------
# Function purity summary
# ----------------------------

type PuritySummary
    purity      : Purity
    reads       : Set[ValueId]
    writes      : Set[ValueId]
    calls       : Set[String]
.end

# ----------------------------
# Constructors
# ----------------------------

proc PuritySummary.new() -> PuritySummary
    return PuritySummary {
        purity = Purity::Pure,
        reads  = Set.new(),
        writes = Set.new(),
        calls  = Set.new()
    }
.end

# ----------------------------
# Join / Lattice operations
# ----------------------------

proc join(a: Purity, b: Purity) -> Purity
    match (a, b)
        (Purity::Io, _) => Purity::Io
        (_, Purity::Io) => Purity::Io
        (Purity::Write, _) => Purity::Write
        (_, Purity::Write) => Purity::Write
        (Purity::ReadOnly, _) => Purity::ReadOnly
        (_, Purity::ReadOnly) => Purity::ReadOnly
        _ => Purity::Pure
    .end
.end

# ----------------------------
# Instruction classification
# ----------------------------

proc inst_purity(inst: Instruction) -> Purity
    if inst.is_call()
        return Purity::Unknown
    .end

    if inst.is_store()
        return Purity::Write
    .end

    if inst.is_load()
        return Purity::ReadOnly
    .end

    if inst.is_io()
        return Purity::Io
    .end

    return Purity::Pure
.end

# ----------------------------
# Block purity
# ----------------------------

proc analyze_block(cfg: Cfg, b: BlockId, sum: PuritySummary)
    for inst in cfg.block(b).instructions()
        let p = inst_purity(inst)
        sum.purity = join(sum.purity, p)

        if p == Purity::ReadOnly
            for v in inst.operands()
                sum.reads.insert(v)
            .end
        .end

        if p == Purity::Write
            for v in inst.operands()
                sum.writes.insert(v)
            .end
        .end

        if inst.is_call()
            sum.calls.insert(inst.callee_name())
        .end
    .end
.end

# ----------------------------
# Function / CFG purity
# ----------------------------

proc analyze(cfg: Cfg) -> PuritySummary
    let sum = PuritySummary.new()

    for b in cfg.blocks()
        analyze_block(cfg, b, sum)
    .end

    return sum
.end

# ----------------------------
# Queries
# ----------------------------

proc is_pure(sum: PuritySummary) -> bool
    return sum.purity == Purity::Pure
.end

proc is_readonly(sum: PuritySummary) -> bool
    return sum.purity == Purity::ReadOnly
.end

proc has_side_effect(sum: PuritySummary) -> bool
    return sum.purity != Purity::Pure
.end

# ----------------------------
# Debug / Dump
# ----------------------------

proc dump(sum: PuritySummary)
    say "PuritySummary"
    say " purity = ", sum.purity
    say " reads  = ", sum.reads
    say " writes = ", sum.writes
    say " calls  = ", sum.calls
.end

# ----------------------------
# End of module
# ----------------------------
