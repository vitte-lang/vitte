# ============================================================
# vitte — scope.vit
# Lexical Scope & Symbol Resolution Analysis — ULTRA MAX
# ============================================================

space vitte/ast_ir/analysis

# ----------------------------
# Imports
# ----------------------------

pull vitte/ast_ir/cfg
pull vitte/ast_ir/block
pull vitte/ast_ir/value
pull vitte/ast_ir/instruction
pull vitte/collections/map
pull vitte/collections/set
pull vitte/collections/list

# ----------------------------
# Public API
# ----------------------------

share all

# ----------------------------
# Scope kinds
# ----------------------------

type ScopeKind
    Function
    Block
    Loop
    Conditional
.end

# ----------------------------
# Symbol
# ----------------------------

type Symbol
    name        : String
    value       : ValueId
    defined_at  : BlockId
.end

# ----------------------------
# Scope
# ----------------------------

type Scope
    id          : int
    kind        : ScopeKind
    parent      : int?
    symbols     : Map[String, Symbol]
    children    : List[int]
.end

# ----------------------------
# Scope tree
# ----------------------------

type ScopeTree
    scopes      : Map[int, Scope]
    root        : int
    next_id     : int
.end

# ----------------------------
# Constructors
# ----------------------------

proc ScopeTree.new() -> ScopeTree
    let root_scope = Scope {
        id       = 0,
        kind     = ScopeKind::Function,
        parent   = none,
        symbols  = Map.new(),
        children = List.new()
    }

    let map = Map.new()
    map[0] = root_scope

    return ScopeTree {
        scopes  = map,
        root    = 0,
        next_id = 1
    }
.end

# ----------------------------
# Scope management
# ----------------------------

proc enter(tree: ScopeTree, kind: ScopeKind, parent: int) -> int
    let id = tree.next_id
    tree.next_id = tree.next_id + 1

    let scope = Scope {
        id       = id,
        kind     = kind,
        parent   = some(parent),
        symbols  = Map.new(),
        children = List.new()
    }

    tree.scopes[id] = scope
    tree.scopes[parent].children.push(id)

    return id
.end

proc define(tree: ScopeTree, scope: int, name: String, val: ValueId, b: BlockId)
    let sym = Symbol {
        name       = name,
        value      = val,
        defined_at = b
    }
    tree.scopes[scope].symbols[name] = sym
.end

# ----------------------------
# Resolution
# ----------------------------

proc resolve(tree: ScopeTree, scope: int, name: String) -> Symbol?
    let current = some(scope)

    while current?
        let sc = tree.scopes[current?]
        if sc.symbols.contains(name)
            return some(sc.symbols[name])
        .end
        current = sc.parent
    .end

    return none
.end

# ----------------------------
# Analysis
# ----------------------------

proc analyze(cfg: Cfg) -> ScopeTree
    let tree = ScopeTree.new()

    # Map block -> scope
    let block_scope = Map[BlockId, int].new()
    block_scope[cfg.entry()] = tree.root

    for b in cfg.blocks()
        let parent_scope = block_scope.get_or(b, tree.root)
        let current_scope = parent_scope

        if cfg.is_loop_header(b)
            current_scope = enter(tree, ScopeKind::Loop, parent_scope)
        elif cfg.is_conditional(b)
            current_scope = enter(tree, ScopeKind::Conditional, parent_scope)
        .end

        block_scope[b] = current_scope

        for inst in cfg.block(b).instructions()
            if inst.result?
                define(tree, current_scope, inst.result_name(), inst.result?, b)
            .end
        .end

        for s in cfg.successors(b)
            if !block_scope.contains(s)
                block_scope[s] = current_scope
            .end
        .end
    .end

    return tree
.end

# ----------------------------
# Queries
# ----------------------------

proc symbol_defined_in(tree: ScopeTree, scope: int) -> List[String]
    let out = List.new()
    for (name, _) in tree.scopes[scope].symbols
        out.push(name)
    .end
    return out
.end

proc scope_of_block(tree: ScopeTree, cfg: Cfg, b: BlockId) -> int
    # recompute mapping conservatively
    let tmp = analyze(cfg)
    for (id, sc) in tmp.scopes
        if sc.defined_at? && sc.defined_at? == b
            return id
        .end
    .end
    return tree.root
.end

# ----------------------------
# Debug / Dump
# ----------------------------

proc dump(tree: ScopeTree)
    say "ScopeTree"
    for (id, sc) in tree.scopes
        say " scope ", id, " kind=", sc.kind, " parent=", sc.parent
        for (name, sym) in sc.symbols
            say "   symbol ", name, " -> ", sym.value
        .end
    .end
.end

# ----------------------------
# End of module
# ----------------------------
