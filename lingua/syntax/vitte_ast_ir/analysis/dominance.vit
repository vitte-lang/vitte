# ============================================================
# vitte â€” dominance.vit
# Dominance & Post-Dominance Analysis (ULTRA MAX)
# ============================================================

space vitte/ast_ir/analysis

# ----------------------------
# Imports
# ----------------------------

pull vitte/ast_ir/cfg
pull vitte/ast_ir/block
pull vitte/ast_ir/value
pull vitte/collections/map
pull vitte/collections/set
pull vitte/collections/list

# ----------------------------
# Public API
# ----------------------------

share all

# ----------------------------
# Types
# ----------------------------

type DominatorTree
    entry       : BlockId
    doms        : Map[BlockId, Set[BlockId]]
    idom        : Map[BlockId, BlockId?]
    children    : Map[BlockId, List[BlockId]]
.end

# ----------------------------
# Constructors
# ----------------------------

proc DominatorTree.new(entry: BlockId) -> DominatorTree
    return DominatorTree {
        entry    = entry,
        doms     = Map.new(),
        idom     = Map.new(),
        children = Map.new()
    }
.end

# ----------------------------
# Dominator computation (classic algorithm)
# ----------------------------

proc compute(cfg: Cfg) -> DominatorTree
    let entry = cfg.entry()
    let dom = DominatorTree.new(entry)

    # Initialize
    for b in cfg.blocks()
        if b == entry
            dom.doms[b] = Set.of(b)
        else
            dom.doms[b] = Set.from(cfg.blocks())
        .end
    .end

    # Iterative refinement
    let changed = true
    while changed
        changed = false

        for b in cfg.blocks()
            if b == entry
                continue
            .end

            let preds = cfg.predecessors(b)
            if preds.is_empty()
                continue
            .end

            let new_set = Set.from(cfg.blocks())
            for p in preds
                new_set = new_set.intersect(dom.doms[p])
            .end
            new_set.insert(b)

            if new_set != dom.doms[b]
                dom.doms[b] = new_set
                changed = true
            .end
        .end
    .end

    # Immediate dominators
    for b in cfg.blocks()
        if b == entry
            dom.idom[b] = none
            continue
        .end

        let candidates = dom.doms[b].clone()
        candidates.remove(b)

        let id = none
        for c in candidates
            let is_idom = true
            for other in candidates
                if other != c && dom.doms[other].contains(c)
                    is_idom = false
                    break
                .end
            .end
            if is_idom
                id = some(c)
                break
            .end
        .end
        dom.idom[b] = id
    .end

    # Build tree children
    for (b, parent?) in dom.idom
        if parent?
            dom.children.get_or_insert(parent?, List.new()).push(b)
        .end
    .end

    return dom
.end

# ----------------------------
# Queries
# ----------------------------

proc dominates(dom: DominatorTree, a: BlockId, b: BlockId) -> bool
    return dom.doms[b].contains(a)
.end

proc strictly_dominates(dom: DominatorTree, a: BlockId, b: BlockId) -> bool
    return a != b && dominates(dom, a, b)
.end

proc immediate_dominator(dom: DominatorTree, b: BlockId) -> BlockId?
    return dom.idom[b]
.end

proc dominance_frontier(cfg: Cfg, dom: DominatorTree) -> Map[BlockId, Set[BlockId]]
    let df = Map.new()

    for b in cfg.blocks()
        df[b] = Set.new()
    .end

    for b in cfg.blocks()
        let preds = cfg.predecessors(b)
        if preds.len() >= 2
            for p in preds
                let runner = p
                while runner? && runner != dom.idom[b]
                    df[runner].insert(b)
                    runner = dom.idom[runner]
                .end
            .end
        .end
    .end

    return df
.end

# ----------------------------
# Post-dominance (reverse CFG)
# ----------------------------

proc compute_post(cfg: Cfg) -> DominatorTree
    let rcfg = cfg.reverse()
    return compute(rcfg)
.end

# ----------------------------
# Debug / Dump
# ----------------------------

proc dump(dom: DominatorTree)
    say "DominatorTree(entry=", dom.entry, ")"
    for (b, set) in dom.doms
        say " block ", b, " doms=", set
    .end
.end

# ----------------------------
# End of module
# ----------------------------
