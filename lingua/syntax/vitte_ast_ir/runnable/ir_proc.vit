# ============================================================
# vitte — ir_proc.vit
# AST-IR Procedure / Proc Definition — ULTRA MAX
# ============================================================

space vitte/ast_ir/runnable

# ----------------------------
# Imports
# ----------------------------

pull vitte/ast_ir/common
pull vitte/ast_ir/module
pull vitte/ast_ir/control_flow
pull vitte/ast_ir/analysis
pull vitte/ast_ir/attribute
pull vitte/collections/map
pull vitte/collections/list
pull vitte/collections/set

# ----------------------------
# Public API
# ----------------------------

share all

# ----------------------------
# Proc kind
# ----------------------------

type ProcKind
    Function        # standard callable procedure
    Task            # async / scheduled task
    Kernel          # low-level / system proc
    Foreign         # FFI / external symbol
.end

# ----------------------------
# Proc signature
# ----------------------------

type ProcSignature
    params      : List[String]      # parameter types
    returns     : String?           # return type
    variadic    : bool
.end

# ----------------------------
# IR Proc
# ----------------------------

type IrProc
    kind        : ProcKind
    name        : String
    module      : String
    signature   : ProcSignature
    cfg         : Cfg?
    attrs       : AttributeBundle
.end

# ----------------------------
# Proc table
# ----------------------------

type ProcTable
    procs       : Map[String, IrProc]
.end

# ----------------------------
# Constructors
# ----------------------------

proc ProcSignature.new(params: List[String], returns: String?, variadic: bool) -> ProcSignature
    return ProcSignature {
        params   = params,
        returns  = returns,
        variadic = variadic
    }
.end

proc IrProc.new(kind: ProcKind, module: String, name: String, sig: ProcSignature, cfg: Cfg?) -> IrProc
    return IrProc {
        kind      = kind,
        module    = module,
        name      = name,
        signature = sig,
        cfg       = cfg,
        attrs     = AttributeBundle.new()
    }
.end

proc ProcTable.new() -> ProcTable
    return ProcTable {
        procs = Map.new()
    }
.end

# ----------------------------
# Registration helpers
# ----------------------------

proc register(tab: ProcTable, p: IrProc)
    let key = p.module + "::" + p.name
    tab.procs[key] = p
.end

proc has_proc(tab: ProcTable, module: String, name: String) -> bool
    return tab.procs.contains(module + "::" + name)
.end

proc get(tab: ProcTable, module: String, name: String) -> IrProc?
    let key = module + "::" + name
    if tab.procs.contains(key)
        return some(tab.procs[key])
    .end
    return none
.end

# ----------------------------
# Queries
# ----------------------------

proc all_procs(tab: ProcTable) -> List[IrProc]
    let out = List.new()
    for (_, p) in tab.procs
        out.push(p)
    .end
    return out
.end

proc by_kind(tab: ProcTable, k: ProcKind) -> List[IrProc]
    let out = List.new()
    for (_, p) in tab.procs
        if p.kind == k
            out.push(p)
        .end
    .end
    return out
.end

# ----------------------------
# Analysis helpers
# ----------------------------

proc build_ssa(p: IrProc, ctx: CommonContext)
    if p.cfg?
        let dom  = dominance.build(p.cfg?)
        let live = liveness.compute(p.cfg?)
        let _ssa = ssa.build(p.cfg?, dom, live, ctx)
    .end
.end

# ----------------------------
# Validation
# ----------------------------

proc validate(p: IrProc, ctx: DiagnosticCtx)
    # foreign procs may not have CFG
    if p.kind != ProcKind::Foreign && !p.cfg?
        let err = error.error(ErrorCode::Validate, "proc without body")
        emit_error(ctx, err)
    .end

    if p.cfg?
        p.cfg?.validate(ctx)
    .end
.end

proc validate_all(tab: ProcTable, ctx: DiagnosticCtx)
    for (_, p) in tab.procs
        validate(p, ctx)
    .end
.end

# ----------------------------
# Debug / Dump
# ----------------------------

proc dump_proc(p: IrProc)
    say "IrProc ", p.kind, " ", p.module, "::", p.name
    say " signature=", p.signature.params, " -> ", p.signature.returns, " variadic=", p.signature.variadic
    if p.cfg?
        p.cfg?.dump()
    .end
.end

proc dump(tab: ProcTable)
    say "=== ProcTable ==="
    for (_, p) in tab.procs
        dump_proc(p)
    .end
.end

# ----------------------------
# End of module
# ----------------------------
