# ============================================================
# vitte — ir_entry.vit
# AST-IR Runnable / Entry Points — ULTRA MAX
# ============================================================

space vitte/ast_ir/runnable

# ----------------------------
# Imports
# ----------------------------

pull vitte/ast_ir/common
pull vitte/ast_ir/module
pull vitte/ast_ir/control_flow
pull vitte/ast_ir/analysis
pull vitte/ast_ir/attribute
pull vitte/collections/map
pull vitte/collections/list
pull vitte/collections/set

# ----------------------------
# Public API
# ----------------------------

share all

# ----------------------------
# Runnable kind
# ----------------------------

type RunnableKind
    Program         # standard executable program
    Service         # long-running service / daemon
    Tool            # CLI tool
    Script          # script-style entry
    LibraryInit     # library init hook
.end

# ----------------------------
# Entry signature
# ----------------------------

type EntrySignature
    params      : List[String]      # parameter types
    returns     : String?           # return type
.end

# ----------------------------
# IR Entry (runnable)
# ----------------------------

type IrEntry
    kind        : RunnableKind
    module      : String
    function    : String
    signature   : EntrySignature
    cfg         : Cfg
    attrs       : AttributeBundle
.end

# ----------------------------
# Entry table
# ----------------------------

type EntryTable
    entries     : Map[String, IrEntry]
.end

# ----------------------------
# Constructors
# ----------------------------

proc EntrySignature.new(params: List[String], returns: String?) -> EntrySignature
    return EntrySignature {
        params  = params,
        returns = returns
    }
.end

proc IrEntry.new(kind: RunnableKind, module: String, function: String, sig: EntrySignature, cfg: Cfg) -> IrEntry
    return IrEntry {
        kind      = kind,
        module    = module,
        function  = function,
        signature = sig,
        cfg       = cfg,
        attrs     = AttributeBundle.new()
    }
.end

proc EntryTable.new() -> EntryTable
    return EntryTable {
        entries = Map.new()
    }
.end

# ----------------------------
# Registration helpers
# ----------------------------

proc register(tab: EntryTable, e: IrEntry)
    let key = e.module + "::" + e.function
    tab.entries[key] = e
.end

proc has_entry(tab: EntryTable, module: String, function: String) -> bool
    return tab.entries.contains(module + "::" + function)
.end

proc get(tab: EntryTable, module: String, function: String) -> IrEntry?
    let key = module + "::" + function
    if tab.entries.contains(key)
        return some(tab.entries[key])
    .end
    return none
.end

# ----------------------------
# Queries
# ----------------------------

proc all_entries(tab: EntryTable) -> List[IrEntry]
    let out = List.new()
    for (_, e) in tab.entries
        out.push(e)
    .end
    return out
.end

proc by_kind(tab: EntryTable, k: RunnableKind) -> List[IrEntry]
    let out = List.new()
    for (_, e) in tab.entries
        if e.kind == k
            out.push(e)
        .end
    .end
    return out
.end

# ----------------------------
# Analysis helpers
# ----------------------------

proc build_ssa(e: IrEntry, ctx: CommonContext)
    let dom  = dominance.build(e.cfg)
    let live = liveness.compute(e.cfg)
    let _ssa = ssa.build(e.cfg, dom, live, ctx)
.end

# ----------------------------
# Validation
# ----------------------------

proc validate(e: IrEntry, ctx: DiagnosticCtx)
    # basic signature sanity
    if e.signature.params.is_empty() && e.kind == RunnableKind::Program
        ()
    .end

    e.cfg.validate(ctx)
.end

proc validate_all(tab: EntryTable, ctx: DiagnosticCtx)
    for (_, e) in tab.entries
        validate(e, ctx)
    .end
.end

# ----------------------------
# Debug / Dump
# ----------------------------

proc dump_entry(e: IrEntry)
    say "IrEntry ", e.kind, " ", e.module, "::", e.function
    say " signature=", e.signature.params, " -> ", e.signature.returns
    e.cfg.dump()
.end

proc dump(tab: EntryTable)
    say "=== EntryTable ==="
    for (_, e) in tab.entries
        dump_entry(e)
    .end
.end

# ----------------------------
# End of module
# ----------------------------
