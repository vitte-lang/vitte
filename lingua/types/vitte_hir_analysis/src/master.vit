# File: C:\Users\gogin\Documents\GitHub\vitte\lingua\types\vitte_hir_analysis\src\master.vit
space lingua/types/vitte_hir_analysis/master

<<< master
  vitte_hir_analysis/master.vit — HIR analyses (MAX)

  Purpose:
    - Provide reusable analyses over HIR (lingua/types/vitte_hir):
        * CFG construction for bodies
        * dominators / post-dominators
        * liveness (locals)
        * move analysis (place-based)
        * borrow-region pre-analysis hooks (for borrowck)
        * call graph (optional)
        * side-effect classification

  Design constraints:
    - Deterministic results.
    - Stable IDs and spans for diagnostics.
    - Pluggable (analyses can be used independently).
    - Focused on compile-time: no allocations explosion.

  Notes:
    - This file contains:
        * core analysis IR views (CFG nodes)
        * analysis entrypoints
        * algorithms skeletons (MAX, but safe)
>>>

pull std/text as text
pull std/collections/list as list
pull std/collections/map as map

pull lingua/syntax/vitte_ast/span as span
pull lingua/syntax/vitte_ast/diag as diag

pull lingua/types/vitte_hir/master as hir

share all

bond Text means String


<<< =========================================================
  0) CFG VIEW
========================================================= >>>

bond NodeId means Int

form CfgNode
field id as NodeId = 0
field block as hir.BlockId = 0
field preds as List of NodeId = []
field succs as List of NodeId = []
field sp as span.Span = span.Span()
.end

form Cfg
field nodes as List of CfgNode = []
field entry as NodeId = 0
field exit as NodeId = 0
.end

proc cfg_new() gives Cfg
give Cfg()
.end


<<< =========================================================
  1) BUILD CFG (BODY)
========================================================= >>>

form CfgBuildOptions
field add_virtual_exit as Bool = true
field trace as Bool = false
.end

proc cfg_build_options_default() gives CfgBuildOptions
give CfgBuildOptions()
.end

proc build_cfg(body as hir.Body, opts as CfgBuildOptions, diags as List of diag.Diagnostic) gives Cfg
# HIR Block has stmts, but edges aren't stored in the skeleton.
# This builder assumes blocks are already structured with terminators in future.
# For now:
#   - create one CFG node per block
#   - connect sequentially by block id order (placeholder)
make cfg as Cfg = Cfg()
set cfg.nodes = []

# nodes
make bi as Int = 0
loop while bi < list.len(body.blocks)
  make n as CfgNode = CfgNode()
  set n.id = bi + 1
  set n.block = body.blocks[bi].id
  set n.preds = []
  set n.succs = []
  set n.sp = body.blocks[bi].sp
  list.push(cfg.nodes, n)
  set bi += 1
.end

if list.len(cfg.nodes) == 0
  set cfg.entry = 0
  set cfg.exit = 0
  give cfg
.end

set cfg.entry = 1

# linear succs placeholder
set bi = 0
loop while bi + 1 < list.len(cfg.nodes)
  list.push(cfg.nodes[bi].succs, cfg.nodes[bi + 1].id)
  list.push(cfg.nodes[bi + 1].preds, cfg.nodes[bi].id)
  set bi += 1
.end

set cfg.exit = cfg.nodes[list.len(cfg.nodes) - 1].id

# optional virtual exit node
if opts.add_virtual_exit
  make ex as CfgNode = CfgNode()
  set ex.id = list.len(cfg.nodes) + 1
  set ex.block = 0
  set ex.preds = [cfg.exit]
  set ex.succs = []
  set ex.sp = span.Span()
  list.push(cfg.nodes, ex)

  list.push(cfg.nodes[cfg.exit - 1].succs, ex.id)
  set cfg.exit = ex.id
.end

give cfg
.end


<<< =========================================================
  2) DOMINATORS (SKELETON)
========================================================= >>>

form Dominators
field idom as Map of NodeId to NodeId = map.new()     # immediate dominator
field doms as Map of NodeId to List of NodeId = map.new()
.end

proc compute_dominators(cfg as Cfg) gives Dominators
# Classic iterative algorithm (placeholder):
# For MAX skeleton, we return empty maps if cfg small.
make d as Dominators = Dominators()
set d.idom = map.new()
set d.doms = map.new()

if cfg.entry == 0
  give d
.end

# initialize: idom(entry)=entry
map.set(d.idom, cfg.entry, cfg.entry)

# For now, treat linear CFG as chain
make i as Int = 0
loop while i < list.len(cfg.nodes)
  make n as CfgNode = cfg.nodes[i]
  if n.id != cfg.entry
    if list.len(n.preds) > 0
      map.set(d.idom, n.id, n.preds[0])
    else
      map.set(d.idom, n.id, cfg.entry)
    .end
  .end
  set i += 1
.end

give d
.end


<<< =========================================================
  3) LIVENESS (LOCALS) — SKELETON
========================================================= >>>

form LiveSet
field locals as Map of hir.LocalId to Bool = map.new()
.end

proc liveset_new() gives LiveSet
make s as LiveSet = LiveSet()
set s.locals = map.new()
give s
.end

proc liveset_add(s as LiveSet, id as hir.LocalId)
map.set(s.locals, id, true)
.end

proc liveset_has(s as LiveSet, id as hir.LocalId) gives Bool
give map.has(s.locals, id)
.end

form Liveness
field in_sets as Map of NodeId to LiveSet = map.new()
field out_sets as Map of NodeId to LiveSet = map.new()
.end

proc compute_liveness(body as hir.Body, cfg as Cfg) gives Liveness
# Placeholder:
#   - Treat every local as live everywhere.
make lv as Liveness = Liveness()
set lv.in_sets = map.new()
set lv.out_sets = map.new()

make all as LiveSet = liveset_new()
make i as Int = 0
loop while i < list.len(body.locals)
  liveset_add(all, body.locals[i].id)
  set i += 1
.end

set i = 0
loop while i < list.len(cfg.nodes)
  map.set(lv.in_sets, cfg.nodes[i].id, all)
  map.set(lv.out_sets, cfg.nodes[i].id, all)
  set i += 1
.end

give lv
.end


<<< =========================================================
  4) MOVE ANALYSIS — SKELETON
========================================================= >>>

pick MoveState
case Available()
case Moved()
case Unknown()
.end

form MoveInfo
field state as Map of hir.LocalId to MoveState = map.new()
.end

proc compute_moves(body as hir.Body, cfg as Cfg) gives MoveInfo
# Placeholder:
#   - Scan expressions, mark locals moved if ExprKind.Move is present.
make mi as MoveInfo = MoveInfo()
set mi.state = map.new()

make i as Int = 0
loop while i < list.len(body.locals)
  map.set(mi.state, body.locals[i].id, MoveState.Available())
  set i += 1
.end

make ei as Int = 0
loop while ei < list.len(body.exprs)
  make e as hir.Expr = body.exprs[ei]
  if e.kind is hir.ExprKind.Move()
    # In skeleton, place is ExprId not LocalId; real impl uses Place.
    # Keep conservative: unknown
    set i = 0
    loop while i < list.len(body.locals)
      map.set(mi.state, body.locals[i].id, MoveState.Unknown())
      set i += 1
    .end
  .end
  set ei += 1
.end

give mi
.end


<<< =========================================================
  5) CALL GRAPH — OPTIONAL
========================================================= >>>

form CallEdge
field caller as Text = ""
field callee as Text = ""
field sp as span.Span = span.Span()
.end

form CallGraph
field edges as List of CallEdge = []
.end

proc build_call_graph(unit as hir.Unit) gives CallGraph
make g as CallGraph = CallGraph()
set g.edges = []

# Placeholder: scan bodies for ExprKind.Call(Path) and create edges
make bi as Int = 0
loop while bi < list.len(unit.bodies)
  make b as hir.Body = unit.bodies[bi]
  make ei as Int = 0
  loop while ei < list.len(b.exprs)
    make e as hir.Expr = b.exprs[ei]
    if e.kind is hir.ExprKind.Call()
      # if callee is ExprKind.Path, record; skeleton only
      make ce as CallEdge = CallEdge()
      set ce.caller = b.name
      set ce.callee = "<call>"
      set ce.sp = e.sp
      list.push(g.edges, ce)
    .end
    set ei += 1
  .end
  set bi += 1
.end

give g
.end


<<< =========================================================
  6) ANALYSIS BUNDLE (CONVENIENCE)
========================================================= >>>

form AnalysisBundle
field cfg as Cfg = Cfg()
field dom as Dominators = Dominators()
field live as Liveness = Liveness()
field moves as MoveInfo = MoveInfo()
.end

proc analyze_body(body as hir.Body, diags as List of diag.Diagnostic) gives AnalysisBundle
make opts as CfgBuildOptions = cfg_build_options_default()
make cfg as Cfg = build_cfg(body, opts, diags)

make bundle as AnalysisBundle = AnalysisBundle()
set bundle.cfg = cfg
set bundle.dom = compute_dominators(cfg)
set bundle.live = compute_liveness(body, cfg)
set bundle.moves = compute_moves(body, cfg)

give bundle
.end
