// Constraint solving implementations

impl ConstraintSet {
    pub fn new() -> Self {
        ConstraintSet {
            constraints: Vec::new(),
        }
    }

    pub fn add(&mut self, constraint: Constraint) {
        self.constraints.push(constraint);
    }

    pub fn len(&self) -> u64 {
        self.constraints.len() as u64
    }

    pub fn is_empty(&self) -> bool {
        self.constraints.is_empty()
    }
}

impl ConstraintContext {
    pub fn new() -> Self {
        ConstraintContext {
            constraints: ConstraintSet::new(),
            variables: std::collections::HashMap::new(),
        }
    }

    pub fn add_constraint(&mut self, constraint: Constraint) {
        self.constraints.add(constraint);
    }

    pub fn bind_variable(&mut self, name: string, ty: Type) {
        self.variables.insert(name, ty);
    }

    pub fn lookup_variable(&self, name: &string) -> Option<Type> {
        self.variables.get(name).cloned()
    }
}

impl Type {
    pub fn primitive(name: string) -> Self {
        Type::Primitive(name)
    }

    pub fn is_unknown(&self) -> bool {
        matches!(self, Type::Unknown)
    }

    pub fn function(params: Vec<Type>, return_type: Type) -> Self {
        Type::Function {
            params,
            return_type: Box::new(return_type),
        }
    }
}

impl Trait {
    pub fn new(name: string) -> Self {
        Trait {
            name,
            methods: Vec::new(),
        }
    }

    pub fn add_method(&mut self, method: TraitMethod) {
        self.methods.push(method);
    }

    pub fn len(&self) -> u64 {
        self.methods.len() as u64
    }
}

impl TraitMethod {
    pub fn new(name: string, signature: string) -> Self {
        TraitMethod { name, signature }
    }
}

impl UnificationEngine {
    pub fn new() -> Self {
        UnificationEngine {
            substitutions: std::collections::HashMap::new(),
        }
    }

    pub fn unify(&mut self, t1: Type, t2: Type) -> bool {
        match (t1, t2) {
            (Type::Unknown, Type::Unknown) => true,
            (Type::Primitive(a), Type::Primitive(b)) => a == b,
            _ => false,
        }
    }

    pub fn apply_substitution(&self, ty: &Type) -> Type {
        match ty {
            Type::Primitive(name) => {
                if let Some(sub) = self.substitutions.get(name) {
                    sub.clone()
                } else {
                    ty.clone()
                }
            }
            _ => ty.clone(),
        }
    }
}
