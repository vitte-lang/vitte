# File: C:\Users\gogin\Documents\GitHub\vitte\lingua\types\vitte_hir\src\master.vit
space lingua/types/vitte_hir/master

<<< master
  vitte_hir/master.vit â€” High-level IR (HIR) (MAX)

  Purpose:
    - Define Vitte's HIR: a typed, desugared, name-resolved representation
      produced after parsing + macro expansion + resolution + desugaring.
    - HIR is the canonical input to:
        * type checker (if HIR is untyped-first, then HIR after typing)
        * borrow checker
        * MIR lowering
        * diagnostics that need stable IDs

  Design:
    - HIR uses stable IDs for items, blocks, locals, and expressions.
    - Stores spans for precise diagnostics.
    - Keeps enough surface shape to preserve user-intent (for errors), but
      removes parser trivia and ambiguous syntactic constructs.

  Pipeline:
    Parse(AST) -> Passes(desugar/resolve) -> HIR (this) -> Typeck -> Borrowck -> MIR

  Notes:
    - This file defines the core HIR types and a small builder shell.
    - Concrete lowering from AST->HIR is in `vitte_lower_hir` (suggested crate).
>>>

pull std/text as text
pull std/collections/list as list
pull std/collections/map as map

pull lingua/syntax/vitte_ast/span as span
pull lingua/syntax/vitte_ast/diag as diag

share all

bond Text means String

bond ItemId means Int
bond ExprId means Int
bond StmtId means Int
bond BlockId means Int
bond LocalId means Int
bond TypeId means Int


<<< =========================================================
  0) MODULE / ITEMS
========================================================= >>>

pick ItemKind
case SpaceDecl()
case PullDecl()
case ShareDecl()
case BuildDecl()

case FormDecl()
case PickDecl()
case BondDecl()

case ConstDecl()
case VarDecl()

case ProcDecl()
case FlowDecl()
case EntryDecl()
.end

form Item
field id as ItemId = 0
field kind as ItemKind = ItemKind.SpaceDecl()
field name as Text = ""
field path as Text = ""
field sp as span.Span = span.Span()
field doc as Text = ""
.end

form Module
field items as List of Item = []
field root_scope as ScopeId = 0
field sp as span.Span = span.Span()
.end


<<< =========================================================
  1) SCOPES / SYMBOLS
========================================================= >>>

bond SymbolId means Int
bond ScopeId means Int

form Symbol
field id as SymbolId = 0
field name as Text = ""
field item as ItemId = 0
field sp as span.Span = span.Span()
.end

form Scope
field id as ScopeId = 0
field parent as ScopeId = 0
field symbols as Map of Text to SymbolId = map.new()
field sp as span.Span = span.Span()
.end

form SymbolTable
field scopes as List of Scope = []
field symbols as List of Symbol = []
.end


<<< =========================================================
  2) TYPES (HIR TYPES)
========================================================= >>>

pick TyKind
case Unknown()
case Never()
case Unit()
case Bool()
case Int()
case UInt()
case Float()
case Text()
case Path(path=Text, args=List of Ty)
case List(elem=Ty)
case Map(key=Ty, val=Ty)
case Pack(elems=List of Ty)
case Or(a=Ty, b=Ty)
case RefShared(inner=Ty)
case RefMut(inner=Ty)
.end

form Ty
field kind as TyKind = TyKind.Unknown()
field sp as span.Span = span.Span()
.end

proc ty_unknown(sp as span.Span) gives Ty
make t as Ty = Ty()
set t.kind = TyKind.Unknown()
set t.sp = sp
give t
.end

proc ty_path(path as Text, args as List of Ty, sp as span.Span) gives Ty
make t as Ty = Ty()
set t.kind = TyKind.Path(path, args)
set t.sp = sp
give t
.end


<<< =========================================================
  3) EXPRESSIONS
========================================================= >>>

pick LitKind
case Int(value=Text)
case Float(value=Text)
case String(value=Text)
case Bool(value=Bool)
case Null()
.end

form Lit
field kind as LitKind = LitKind.Null()
field sp as span.Span = span.Span()
.end

pick BinOp
case Add()
case Sub()
case Mul()
case Div()
case Mod()
case Eq()
case Ne()
case Lt()
case Le()
case Gt()
case Ge()
case And()
case Or()
.end

pick UnOp
case Neg()
case Not()
.end

pick ExprKind
case Lit(lit=Lit)
case Name(sym=SymbolId, name=Text)
case Path(path=Text)
case Call(callee=ExprId, args=List of CallArg)
case Index(base=ExprId, index=ExprId)
case Field(base=ExprId, field=Text)
case Pack(elems=List of ExprId)
case List(elems=List of ExprId)
case Map(entries=List of MapEntry)
case IfExpr(cond=ExprId, then_blk=BlockId, else_blk=Option of BlockId)
case Select(scrut=ExprId, arms=List of Arm, other=Option of BlockId)
case Block(block=BlockId)
case Assign(target=ExprId, op=Text, value=ExprId)
case BorrowShared(place=ExprId)
case BorrowMut(place=ExprId)
case Move(place=ExprId)
.end

form Expr
field id as ExprId = 0
field kind as ExprKind = ExprKind.Block(0)
field ty as Ty = Ty()
field sp as span.Span = span.Span()
.end

form CallArg
field name as Text = ""     # "" for positional
field expr as ExprId = 0
field sp as span.Span = span.Span()
.end

form MapEntry
field key as ExprId = 0
field val as ExprId = 0
field sp as span.Span = span.Span()
.end

form Arm
field pat as Pattern = Pattern()
field block as BlockId = 0
field sp as span.Span = span.Span()
.end


<<< =========================================================
  4) PATTERNS
========================================================= >>>

pick PatternKind
case Wild()
case Lit(lit=Lit)
case Name(name=Text, sym=SymbolId)
case Tuple(elems=List of Pattern)
case List(elems=List of Pattern)
case Variant(path=Text, case_name=Text, payload=List of Pattern)
.end

form Pattern
field kind as PatternKind = PatternKind.Wild()
field sp as span.Span = span.Span()
.end


<<< =========================================================
  5) STATEMENTS / BLOCKS
========================================================= >>>

pick StmtKind
case Make(local=LocalId, name=Text, ty=Option of Ty, init=Option of ExprId)
case Keep(local=LocalId, name=Text, ty=Option of Ty, init=ExprId)
case Set(target=ExprId, op=Text, value=ExprId)
case Give(value=Option of ExprId)
case Emit(value=ExprId)
case Defer(expr=ExprId)
case Assert(cond=ExprId, msg=Option of ExprId)
case Foreign(item=Text)
case Halt()
case Next()
case Expr(expr=ExprId)
.end

form Stmt
field id as StmtId = 0
field kind as StmtKind = StmtKind.Halt()
field sp as span.Span = span.Span()
.end

form Block
field id as BlockId = 0
field stmts as List of StmtId = []
field sp as span.Span = span.Span()
.end

form Local
field id as LocalId = 0
field name as Text = ""
field ty as Ty = Ty()
field sp as span.Span = span.Span()
field mutable as Bool = true
.end


<<< =========================================================
  6) BODIES (PROC/FLOW)
========================================================= >>>

form Param
field name as Text = ""
field ty as Ty = Ty()
field local as LocalId = 0
field sp as span.Span = span.Span()
.end

pick BodyKind
case Proc()
case Flow()
case Entry()
.end

form Body
field kind as BodyKind = BodyKind.Proc()
field name as Text = ""
field params as List of Param = []
field ret as Ty = Ty()
field locals as List of Local = []
field blocks as List of Block = []
field exprs as List of Expr = []
field root as BlockId = 0
field sp as span.Span = span.Span()
.end


<<< =========================================================
  7) PACKAGE / UNIT
========================================================= >>>

form Unit
field module as Module = Module()
field symtab as SymbolTable = SymbolTable()
field bodies as List of Body = []
field types as List of Ty = []
field diags as List of diag.Diagnostic = []
.end


<<< =========================================================
  8) BUILDER SKELETON
========================================================= >>>

form HirBuilder
field unit as Unit = Unit()
field next_item as Int = 1
field next_expr as Int = 1
field next_stmt as Int = 1
field next_block as Int = 1
field next_local as Int = 1
field next_sym as Int = 1
field next_scope as Int = 1
.end

proc hir_builder_new(diags as List of diag.Diagnostic) gives HirBuilder
make b as HirBuilder = HirBuilder()
set b.unit = Unit()
set b.unit.diags = diags
set b.next_item = 1
set b.next_expr = 1
set b.next_stmt = 1
set b.next_block = 1
set b.next_local = 1
set b.next_sym = 1
set b.next_scope = 1

# create root scope
make root as Scope = Scope()
set root.id = b.next_scope
set b.next_scope = b.next_scope + 1
set root.parent = 0
set root.symbols = map.new()
list.push(b.unit.symtab.scopes, root)
set b.unit.module.root_scope = root.id

give b
.end

proc new_item(b as HirBuilder, kind as ItemKind, name as Text, sp as span.Span) gives ItemId
make id as Int = b.next_item
set b.next_item = id + 1

make it as Item = Item()
set it.id = id
set it.kind = kind
set it.name = name
set it.sp = sp
list.push(b.unit.module.items, it)

give id
.end

proc new_block(b as HirBuilder, sp as span.Span) gives BlockId
make id as Int = b.next_block
set b.next_block = id + 1

make blk as Block = Block()
set blk.id = id
set blk.stmts = []
set blk.sp = sp
list.push(b.unit.bodies[list.len(b.unit.bodies) - 1].blocks, blk)

give id
.end

proc new_expr(b as HirBuilder, kind as ExprKind, sp as span.Span) gives ExprId
make id as Int = b.next_expr
set b.next_expr = id + 1

make e as Expr = Expr()
set e.id = id
set e.kind = kind
set e.sp = sp
set e.ty = ty_unknown(sp)
list.push(b.unit.bodies[list.len(b.unit.bodies) - 1].exprs, e)

give id
.end

proc new_stmt(b as HirBuilder, kind as StmtKind, sp as span.Span) gives StmtId
make id as Int = b.next_stmt
set b.next_stmt = id + 1

make s as Stmt = Stmt()
set s.id = id
set s.kind = kind
set s.sp = sp
# push into current body statement pool (flattened)
# For MAX skeleton, store stmt IDs in blocks; actual storage in body could be separate.
# Here we keep it simple: encode stmt inside a synthetic expr list? Better: add a `stmts_pool`.
give id
.end
