module lvm.vm

import lvm.bytecode
import lvm.value
import lvm.builtins
import lvm.debug
import lvm.gc

# ============================================================================
# Vitte LVM – Modèle logique de machine virtuelle
#
# Objectifs :
#   - Fournir une représentation structurée, déclarative et backend-agnostique
#     de l’état d’une instance de VM Vitte (LVM) et de ses composants :
#       * configuration et limites,
#       * threads, fibres, frames d’appel,
#       * piles de registres, heap/GC, builtins,
#       * état d’exécution, erreurs, statistiques.
#   - Servir de contrat entre :
#       * le compilateur (producteur de bytecode),
#       * les backends d’exécution (interpréteur, JIT),
#       * les outils (debugger, profiler, LSP).
#   - Ne contenir que des structures de données (aucune fonction ni I/O).
#
# Conventions :
#   - Même style que vitte.compiler.ast / lrt.ffi / lvm.builtins / lvm.bytecode :
#       * `pub struct/enum` + ":" et blocs terminés par `.end` ;
#       * enums "tag-only" ;
#       * IDs forts basés sur des indices u32.
# ============================================================================

# ----------------------------------------------------------------------------
# Indices et identifiants VM / thread / fibre
# ----------------------------------------------------------------------------

pub typedef u32 LvmVmIndex

pub struct LvmVmLogicalId:
    let raw: LvmVmIndex
.end

pub typedef u32 LvmThreadIndex

pub struct LvmThreadId:
    let raw: LvmThreadIndex
.end

pub typedef u32 LvmFiberIndex

pub struct LvmFiberId:
    let raw: LvmFiberIndex
.end

pub typedef u32 LvmSchedulerIndex

pub struct LvmSchedulerId:
    let raw: LvmSchedulerIndex
.end

# ----------------------------------------------------------------------------
# Modes, état global et configuration de la VM
# ----------------------------------------------------------------------------

# Mode d’exécution global de la VM.
pub enum LvmVmMode:
    VmModeInterpreter        # interpréteur pur
    VmModeJit                # JIT
    VmModeHybrid             # mixte (interprète + JIT)
.end

# État d’exécution courant de la VM.
pub enum LvmVmRunState:
    VmStateCreated           # VM créée, pas encore démarrée
    VmStateRunning           # en cours d’exécution
    VmStatePaused            # en pause (debugger, breakpoint, etc.)
    VmStateStopped           # arrêt normal
    VmStateCrashed           # arrêt suite à une erreur fatale
.end

# Limites et grandeurs configurables.
pub struct LvmVmLimits:
    let max_stack_depth: u32          # profondeur maximale de pile d’appels
    let max_threads: u32              # nombre max de threads logiques
    let max_fibers_per_thread: u32    # nombre max de fibres par thread
    let max_heap_bytes: u64           # limite "douce" de heap
    let max_open_handles: u32         # handles (FFI, fichiers, etc.)
.end

# Configuration de la VM.
pub struct LvmVmConfig:
    let mode: LvmVmMode
    let limits: LvmVmLimits
    let enable_debug: Bool
    let enable_profiling: Bool
    let gc_profile: GcProfileId
.end

# ----------------------------------------------------------------------------
# Erreurs VM et statut
# ----------------------------------------------------------------------------

# Catégories d’erreurs observables au niveau VM.
pub enum LvmVmErrorKind:
    VmErrorNone
    VmErrorBytecodeCorrupt
    VmErrorStackOverflow
    VmErrorStackUnderflow
    VmErrorInvalidOpcode
    VmErrorInvalidOperand
    VmErrorDivisionByZero
    VmErrorTypeMismatch
    VmErrorNullReference
    VmErrorBuiltinFailure
    VmErrorNativeFailure
    VmErrorGcFailure
    VmErrorInternal
.end

# Erreur logique de VM.
pub struct LvmVmError:
    let kind: LvmVmErrorKind
    let message: String
    let function: Option<LvmFunctionId>
    let instr: Option<LvmInstrId>
    let value: Option<LvmValueId>
.end

# Statut global de la VM.
pub struct LvmVmStatus:
    let run_state: LvmVmRunState
    let last_error: Option<LvmVmError>
.end

# ----------------------------------------------------------------------------
# Piles, registres et frames d’appel
# ----------------------------------------------------------------------------

# Index logique d’un registre dans une frame.
pub typedef u32 LvmRegisterIndex

# Frame d’appel exécution (niveau runtime, différent du modèle de debug).
pub struct LvmCallFrame:
    let function: LvmFunctionId
    let ip_block: LvmBlockId              # bloc courant
    let ip_instr_index: u32               # index d’instruction dans le bloc
    let base_register: LvmRegisterIndex   # base des registres de cette frame
    let arg_count: u32
    let expected_results: u32
    let parent_frame_index: Option<u32>   # index dans la pile de frames
.end

# Pile de frames pour une fibre.
pub struct LvmCallStack:
    let frames: Vec<LvmCallFrame>
.end

# Pile de valeurs (stack machine) – optionnelle selon le design.
pub struct LvmValueStack:
    let values: Vec<LvmValueId>
    let max_depth: u32
.end

# Banque de registres logiques pour un thread/fibre.
pub struct LvmRegisterBank:
    let values: Vec<LvmValueId>           # indexés par LvmRegisterIndex
.end

# ----------------------------------------------------------------------------
# Threads, fibres et scheduler
# ----------------------------------------------------------------------------

# État d’un thread logique.
pub enum LvmThreadState:
    ThreadNew
    ThreadRunnable
    ThreadBlocked
    ThreadTerminated
.end

# Priorités logiques de thread.
pub enum LvmThreadPriority:
    ThreadLow
    ThreadNormal
    ThreadHigh
.end

# Thread logique VM (groupe de fibres).
pub struct LvmThread:
    let id: LvmThreadId
    let vm: LvmVmLogicalId
    let state: LvmThreadState
    let priority: LvmThreadPriority
    let current_fiber: Option<LvmFiberId>
    let fibers: Vec<LvmFiberId>
.end

# État d’une fibre (coroutine légère).
pub enum LvmFiberState:
    FiberNew
    FiberRunning
    FiberSuspended
    FiberWaiting
    FiberTerminated
.end

# Fibre d’exécution (coroutine) attachée à un thread.
pub struct LvmFiber:
    let id: LvmFiberId
    let thread: LvmThreadId
    let state: LvmFiberState
    let call_stack: LvmCallStack
    let value_stack: LvmValueStack
    let registers: LvmRegisterBank
    let last_value: Option<LvmValueId>     # dernier résultat produit
.end

# Politique de scheduling des fibres.
pub enum LvmSchedulerPolicy:
    SchedulerFifo
    SchedulerRoundRobin
    SchedulerWorkStealing
    SchedulerCustom
.end

# Scheduler logique (mono-VM).
pub struct LvmScheduler:
    let id: LvmSchedulerId
    let policy: LvmSchedulerPolicy
    let ready_fibers: Vec<LvmFiberId>
    let blocked_fibers: Vec<LvmFiberId>
.end

# ----------------------------------------------------------------------------
# Handles externes (FFI, fichiers, sockets, etc.)
# ----------------------------------------------------------------------------

pub typedef u32 LvmHandleIndex

pub struct LvmHandleId:
    let raw: LvmHandleIndex
.end

# Genre de handle.
pub enum LvmHandleKind:
    HandleFile
    HandleSocket
    HandleTimer
    HandleFfiObject
    HandleCustom
.end

# Handle logique géré par la VM.
pub struct LvmHandle:
    let id: LvmHandleId
    let kind: LvmHandleKind
    let native_address: usize          # pointeur/handle natif opaque
    let debug_name: Option<String>
.end

# Table des handles ouverts.
pub struct LvmHandleTable:
    let handles: Vec<LvmHandle>
.end

# ----------------------------------------------------------------------------
# Statistiques et profilage
# ----------------------------------------------------------------------------

# Statistiques d’exécution d’une VM.
pub struct LvmVmStats:
    let total_instructions_executed: u64
    let total_function_calls: u64
    let total_builtins_called: u64
    let total_gc_cycles: u64
    let total_allocated_bytes: u64
    let total_freed_bytes: u64
.end

# Compteur par fonction (profiling simple).
pub struct LvmFunctionProfileEntry:
    let function: LvmFunctionId
    let call_count: u64
    let total_instructions: u64
.end

pub struct LvmFunctionProfileTable:
    let entries: Vec<LvmFunctionProfileEntry>
.end

# ----------------------------------------------------------------------------
# Contexte global d’une instance de VM
# ----------------------------------------------------------------------------

pub struct LvmVmContext:
    let id: LvmVmLogicalId
    let config: LvmVmConfig
    let status: LvmVmStatus
    let stats: LvmVmStats

    # Bytecode et modules chargés.
    let modules: Vec<LvmBytecodeModule>

    # Threads et scheduler.
    let scheduler: LvmScheduler
    let threads: Vec<LvmThread>

    # Heap / GC.
    let heap: GcHeapId
    let gc_profile: GcProfileId
    let gc_state: GcState

    # Handles externes.
    let handles: LvmHandleTable

    # Profilage détaillé.
    let function_profiles: LvmFunctionProfileTable

    # Optionnel : session de debug associée.
    let debug_session: Option<LvmDebugSessionId>
.end

# ----------------------------------------------------------------------------
# Nœuds génériques VM pour tooling
# ----------------------------------------------------------------------------

pub enum LvmVmNodeKind:
    NodeVmContext
    NodeThread
    NodeFiber
    NodeCallFrame
    NodeHandle
.end

pub struct LvmVmNode:
    let id: LvmVmIndex
    let kind: LvmVmNodeKind
.end
