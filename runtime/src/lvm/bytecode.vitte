module lvm.bytecode

# ============================================================================
# Vitte LVM – Modèle logique de bytecode
#
# Objectifs :
#   - Fournir une représentation structurée, déclarative et backend-agnostique
#     du bytecode de la machine virtuelle Vitte (LVM).
#   - Modéliser :
#       * constantes (pool constant),
#       * registres et emplacements de variables,
#       * instructions, opérandes, blocs de contrôle,
#       * fonctions (protos), modules et méta-informations,
#       * informations de debug (lignes, fichiers, symboles).
#   - Servir de base commune pour :
#       * le compilateur (émission de bytecode),
#       * l’interpréteur / JIT (exécution),
#       * les outils (désassembleur, profiler, LSP).
#
# Conventions :
#   - Même style que vitte.compiler.ast / lrt.ffi / lvm.builtins :
#       * `pub struct/enum` + ":" et blocs terminés par `.end` ;
#       * enums "tag-only" ;
#       * IDs forts basés sur des indices (u32) ;
#       * pas de fonctions ici, uniquement des structures de données.
# ============================================================================

# ----------------------------------------------------------------------------
# Indices et identifiants de base
# ----------------------------------------------------------------------------

pub typedef u32 LvmBcIndex

pub struct LvmFunctionId:
    let raw: LvmBcIndex
.end

pub struct LvmBlockId:
    let raw: LvmBcIndex
.end

pub struct LvmInstrId:
    let raw: LvmBcIndex
.end

pub struct LvmConstId:
    let raw: LvmBcIndex
.end

pub struct LvmRegisterId:
    let raw: LvmBcIndex
.end

pub struct LvmUpvalueId:
    let raw: LvmBcIndex
.end

pub struct LvmLocalId:
    let raw: LvmBcIndex
.end


pub struct LvmGlobalId:
    let raw: LvmBcIndex
.end

pub struct LvmModuleId:
    let raw: LvmBcIndex
.end

# ----------------------------------------------------------------------------
# Pool de constantes
# ----------------------------------------------------------------------------

# Genre des constantes stockées dans le pool global d’un module de bytecode.
pub enum LvmConstKind:
    ConstInt
    ConstFloat
    ConstBool
    ConstString
    ConstBytes
    ConstUnit          # équivalent de "none"/"()"
    ConstFunctionRef   # référence à une fonction du module
.end

# Constante entière (peut servir aussi pour des indices).
pub struct LvmConstInt:
    let value: i64
.end

# Constante flottante (double précision).
pub struct LvmConstFloat:
    let value: f64
.end

# Constante booléenne.
pub struct LvmConstBool:
    let value: Bool
.end

# Constante chaîne UTF‑8.
pub struct LvmConstString:
    let value: String
.end

# Constante binaire (octets bruts).
pub struct LvmConstBytes:
    let bytes: Vec<u8>
.end

# Constante référence de fonction.
pub struct LvmConstFunctionRef:
    let function: LvmFunctionId
.end

# Valeur concrète d’une constante.
pub struct LvmConstValue:
    let kind: LvmConstKind
    let int_value: Option<LvmConstInt>
    let float_value: Option<LvmConstFloat>
    let bool_value: Option<LvmConstBool>
    let string_value: Option<LvmConstString>
    let bytes_value: Option<LvmConstBytes>
    let function_ref: Option<LvmConstFunctionRef>
.end

# Entrée du pool de constantes.
pub struct LvmConstEntry:
    let id: LvmConstId
    let value: LvmConstValue
.end

# Pool de constantes complet pour un module de bytecode.
pub struct LvmConstPool:
    let entries: Vec<LvmConstEntry>   # indexé par LvmConstId.raw
.end

# ----------------------------------------------------------------------------
# Registres, variables locales, upvalues et globals
# ----------------------------------------------------------------------------

# Genre de slot de stockage à l’exécution.
pub enum LvmSlotKind:
    SlotRegister
    SlotLocal
    SlotUpvalue
    SlotGlobal
.end

pub struct LvmRegister:
    let id: LvmRegisterId
    let debug_name: Option<String>    # nom symbolique, si connu
.end

pub struct LvmLocal:
    let id: LvmLocalId
    let register: LvmRegisterId       # registre associé à cette variable
    let debug_name: Option<String>
    let is_captured: Bool             # vrai si capturée par une closure
.end

pub struct LvmUpvalue:
    let id: LvmUpvalueId
    let from_function: LvmFunctionId  # fonction d’origine
    let from_local: LvmLocalId        # variable locale capturée
.end

pub struct LvmGlobal:
    let id: LvmGlobalId
    let name: String
.end

# ----------------------------------------------------------------------------
# Opérandes et opcodes
# ----------------------------------------------------------------------------

# Catégorie d’instruction (pour docs/profilage).
pub enum LvmOpcodeCategory:
    OpControlFlow       # jumps, returns, etc.
    OpMove              # move/copy de valeurs
    OpLoadStore         # loads/stores de constantes/globals/locals
    OpArithmetic        # +, -, *, /, %, ...
    OpComparison        # ==, !=, <, <=, ...
    OpLogical           # not, and, or
    OpBitwise           # &, |, ^, <<, >>
    OpCall              # appels de fonction, tail-calls
    OpDataStructure     # listes, maps, indexation
    OpClosure           # création de closures / upvalues
    OpMisc              # nop, debug, etc.
.end

# Ensemble canonique des opcodes LVM.
pub enum LvmOpcode:
    # Contrôle de flux
    OpNop               # no-op
    OpJump              # saut inconditionnel
    OpJumpIfTrue        # saut si condition vraie
    OpJumpIfFalse       # saut si condition fausse
    OpReturn            # retour depuis la fonction
    OpTrap              # trap/debug/breakpoint

    # Déplacement / copies
    OpMove              # move registre->registre
    OpCopy              # copy registre->registre (conventionnelle)
    OpSwap              # swap de deux registres

    # Chargements / stockage
    OpLoadConst         # charger une constante dans un registre
    OpLoadUnit          # charger la valeur unit/none
    OpLoadBool          # charger un bool immédiat
    OpLoadInt           # charger un int immédiat
    OpLoadFloat         # charger un float immédiat
    OpLoadGlobal        # charger une global
    OpStoreGlobal       # écrire une global
    OpLoadLocal         # charger une locale
    OpStoreLocal        # écrire une locale
    OpLoadUpvalue       # charger un upvalue
    OpStoreUpvalue      # écrire un upvalue

    # Arithmétique
    OpAdd
    OpSub
    OpMul
    OpDiv
    OpMod
    OpNeg               # négation unitaire

    # Comparaison
    OpEq
    OpNe
    OpLt
    OpLe
    OpGt
    OpGe

    # Logique booléenne
    OpNot

    # Bitwise
    OpBitAnd
    OpBitOr
    OpBitXor
    OpBitShl
    OpBitShr

    # Appels
    OpCall              # appel de fonction normal
    OpTailCall          # appel avec tail-call optimisé

    # Structures de données
    OpNewList           # création de liste
    OpNewMap            # création de map
    OpIndexGet          # accès index/sous-script
    OpIndexSet          # écriture index/sous-script
    OpFieldGet          # accès champ (objets/records)
    OpFieldSet          # écriture champ

    # Closures / upvalues
    OpMakeClosure       # création d’une closure à partir d’un proto
    OpCaptureUpvalue    # capture d’un upvalue
.end

# Genre d’opérande utilisé par le bytecode.
pub enum LvmOperandKind:
    OpndReg             # registre
    OpndConst           # constante du pool
    OpndIntImm          # entier immédiat (offset, index, etc.)
    OpndBlock           # identifiant de bloc (pour jumps)
    OpndFunction        # identifiant de fonction
    OpndUpvalue         # identifiant d’upvalue
    OpndLocal           # identifiant de locale
    OpndGlobal          # identifiant de global
.end

# Opérande concret.
pub struct LvmOperand:
    let kind: LvmOperandKind
    let reg: Option<LvmRegisterId>
    let const_id: Option<LvmConstId>
    let int_imm: Option<i64>
    let block: Option<LvmBlockId>
    let function: Option<LvmFunctionId>
    let upvalue: Option<LvmUpvalueId>
    let local: Option<LvmLocalId>
    let global: Option<LvmGlobalId>
.end

# Liste ordonnée d’opérandes pour une instruction.
pub struct LvmOperandList:
    let operands: Vec<LvmOperand>
.end

# ----------------------------------------------------------------------------
# Instructions et blocs de contrôle
# ----------------------------------------------------------------------------

# Instruction unique de bytecode.
pub struct LvmInstr:
    let id: LvmInstrId
    let opcode: LvmOpcode
    let category: LvmOpcodeCategory
    let operands: LvmOperandList
    let debug_comment: Option<String>    # commentaire/debug human-friendly
    let debug_span_index: Option<u32>    # index vers table de debug ligne/col
.end

# Bloc basique de bytecode (suite d’instructions avec un seul successeur
# "normal", les autres sorties se faisant par jumps explicites).
pub struct LvmBlock:
    let id: LvmBlockId
    let instructions: Vec<LvmInstrId>
    let fallthrough: Option<LvmBlockId>  # bloc suivant si pas de jump explicite
.end

# ----------------------------------------------------------------------------
# Prototypes de fonction et organisation du code
# ----------------------------------------------------------------------------

# Information sur un paramètre de fonction au niveau bytecode.
pub struct LvmFunctionParam:
    let index: u32
    let register: LvmRegisterId
    let debug_name: Option<String>
.end

# Prologue de pile (taille stack frame / registres).
pub struct LvmFrameLayout:
    let register_count: u32
    let local_count: u32
    let upvalue_count: u32
.end

# Prototype de fonction en bytecode (corps + métadonnées).
pub struct LvmFunctionProto:
    let id: LvmFunctionId
    let name: Option<String>          # nom debug/lié au symbole source
    let params: Vec<LvmFunctionParam>
    let frame: LvmFrameLayout
    let entry_block: LvmBlockId
    let blocks: Vec<LvmBlockId>
    let const_pool: LvmConstPool      # pool local (optionnel) ou vue sur global
    let is_variadic: Bool
    let is_generator: Bool            # si la fonction peut yield
    let is_async: Bool                # si la fonction modélise un async
.end

# Table des fonctions d’un module de bytecode.
pub struct LvmFunctionTable:
    let functions: Vec<LvmFunctionProto>   # indexé par LvmFunctionId.raw
.end

# ----------------------------------------------------------------------------
# Informations de debug
# ----------------------------------------------------------------------------


# Ligne/colonne pour debug, associée à une fonction/fichier.
pub struct LvmDebugLocation:
    let file: String
    let line: u32
    let column: u32
    let file_id: Option<LvmDebugFileId>   # référence optionnelle dans la table de fichiers
.end

pub struct LvmDebugFileId:
    let raw: LvmBcIndex
.end

pub struct LvmDebugFile:
    let id: LvmDebugFileId
    let path: String                    # chemin complet ou logique du fichier
.end

pub struct LvmDebugFileTable:
    let files: Vec<LvmDebugFile>
.end

# Mapping indexé utilisé par les instructions : debug_span_index -> location.
pub struct LvmDebugTable:
    let locations: Vec<LvmDebugLocation>
.end

# Symbole source (nom logique + portée), utile pour debugger.
pub struct LvmDebugSymbol:
    let name: String
    let function: Option<LvmFunctionId>
    let local: Option<LvmLocalId>
    let global: Option<LvmGlobalId>
.end

pub struct LvmDebugSymbolTable:
    let symbols: Vec<LvmDebugSymbol>
.end

# ----------------------------------------------------------------------------
# Module de bytecode complet (unité de chargement/exécution)
# ----------------------------------------------------------------------------

# Point d’entrée de module (program/service/kernel/driver/...).
pub enum LvmEntryPointKind:
    EntryProgram
    EntryService
    EntryKernel
    EntryDriver
    EntryTool
    EntryScenario
    EntryPipeline
.end

pub struct LvmEntryPoint:
    let kind: LvmEntryPointKind
    let function: LvmFunctionId
.end


# Module de bytecode complet pour la LVM.
pub struct LvmBytecodeModule:
    let id: Option<LvmModuleId>          # identifiant logique du module, si fourni
    let name: Option<String>             # nom logique du module
    let globals: Vec<LvmGlobal>
    let functions: LvmFunctionTable
    let entry_points: Vec<LvmEntryPoint>
    let debug_files: Option<LvmDebugFileTable>
    let debug_table: Option<LvmDebugTable>
    let debug_symbols: Option<LvmDebugSymbolTable>
    let stats: Option<LvmBytecodeModuleStats>   # statistiques dérivées, si disponibles
.end
# Statistiques détaillées sur le bytecode d un module.
pub struct LvmBytecodeFunctionStats:
    let function: LvmFunctionId
    let block_count: u32
    let instr_count: u32
.end

pub struct LvmBytecodeOpcodeStats:
    let opcode: LvmOpcode
    let count: u64
.end

pub struct LvmBytecodeModuleStats:
    let function_stats: Vec<LvmBytecodeFunctionStats>
    let opcode_stats: Vec<LvmBytecodeOpcodeStats>
    let total_blocks: u64
    let total_instructions: u64
    let total_constants: u64
.end

# ----------------------------------------------------------------------------
# Nœuds génériques pour tooling (facultatif)
# ----------------------------------------------------------------------------

pub enum LvmBytecodeNodeKind:
    NodeConst
    NodeInstr
    NodeBlock
    NodeFunction
    NodeModule
.end

pub struct LvmBytecodeNode:
    let id: LvmBcIndex
    let kind: LvmBytecodeNodeKind
.end
