module lrt.ffi

# ============================================================================
# Vitte runtime – Modèle logique FFI (Foreign Function Interface) – ultra complet
#
# Objectifs :
#   - Fournir une représentation structurée, déclarative et backend-agnostique
#     de l interface FFI du runtime Vitte.
#   - Modéliser bibliothèques, symboles, ABI, types, signatures d appel,
#     valeurs, commandes et résultats d appel.
#   - Ajouter une vue runtime globale (registries + backends + commandes),
#     des indicateurs d erreurs plus riches et des capacités avancées.
#   - Servir de base commune pour :
#       * les backends C17 / Vitte-Light / Rust,
#       * la validation des signatures,
#       * les outils externes (inspecteurs, documentation, LSP, etc.).
#
# Conventions :
#   - Même style que vitte.compiler.ast :
#       * `pub struct/enum` + ":" et blocs terminés par `.end` ;
#       * enums "tag-only" : la donnée est portée par des structs dédiées ;
#       * identifiants forts (Id) basés sur un index FfiIndex.
#   - Aucune logique exécutable (ni fonction), uniquement des données.
# ============================================================================

# ----------------------------------------------------------------------------
# Indices et identifiants FFI
# ----------------------------------------------------------------------------

pub typedef u32 FfiIndex

pub struct FfiLibraryId:
    let raw: FfiIndex
.end

pub struct FfiSymbolId:
    let raw: FfiIndex
.end

pub struct FfiTypeId:
    let raw: FfiIndex
.end

pub struct FfiSignatureId:
    let raw: FfiIndex
.end

pub struct FfiBackendId:
    let raw: FfiIndex
.end

pub struct FfiCallSiteId:
    let raw: FfiIndex
.end

# Identifiant logique d un appel FFI individuel (une exécution).

pub struct FfiCallId:
    let raw: FfiIndex
.end

pub struct FfiThreadId:
    let raw: u64
.end

pub struct FfiProcessId:
    let raw: u64
.end

# Contexte logique d un appel FFI (thread, process, stack, etc.).
pub struct FfiCallContext:
    let thread: Option<FfiThreadId>      # thread logique d exécution
    let process: Option<FfiProcessId>    # processus logique d exécution
    let stack_used_bytes: u64           # estimation de la stack utilisée
    let stack_limit_bytes: u64          # limite logique de stack
.end

# ----------------------------------------------------------------------------
# Erreurs et statut FFI
# ----------------------------------------------------------------------------

# Catégories d erreur lors des opérations FFI.

# Sévérité logique d une erreur FFI.
pub enum FfiErrorSeverity:
    ErrorWarning    # anomalie non fatale
    ErrorNonFatal   # erreur récupérable
    ErrorFatal      # erreur fatale / abort
.end
pub enum FfiErrorKind:
    None                # aucune erreur

    # Bibliothèque / symbole
    LibraryNotFound     # bibliothèque introuvable
    LibraryOpenFailed   # échec à l ouverture (corruption, ABI, permissions...)
    SymbolNotFound      # symbole absent de la bibliothèque

    # Signature et arguments
    InvalidSignature    # signature Vitte != signature native
    InvalidArgument     # argument incompatible avec la signature

    # Exécution de l appel
    CallFailed          # échec à l exécution (trap, signal, exception...)
    Timeout             # appel dépassant un délai logique
    ResourceLimit       # limite de ressources dépassée (stack, heap, handles)

    # Backend / plateforme
    UnsupportedAbi      # ABI non supportée sur cette plateforme
    BackendMismatch     # backend non compatible avec ce symbole/bibliothèque
    BackendFailure      # erreur interne de backend (implémentation)

    # Autres
    SerializationError  # erreur dans le marshalling/unmarshalling
    NotImplemented      # opération non implémentée par le backend
    InternalError       # erreur interne FFI (bug, assertion)
.end

# Détail d une erreur FFI.
pub struct FfiError:
    let kind: FfiErrorKind
    let severity: FfiErrorSeverity      # sévérité logique de l erreur
    let message: String                  # message humain, éventuellement vide

    # Contexte optionnel.
    let backend: Option<FfiBackendId>    # backend concerné
    let library: Option<FfiLibraryId>    # bibliothèque concernée
    let symbol: Option<FfiSymbolId>      # symbole concerné
    let call_site: Option<FfiCallSiteId> # site d appel logique (code source)
    let call_id: Option<FfiCallId>       # appel précis, si connu

    # Code d erreur natif (errno, GetLastError...), si propagé.
    let native_code: i32

    let timestamp_ns: u64               # horodatage logique (nanosecondes)
.end

# Statut générique d une opération FFI.
pub struct FfiStatus:
    let is_ok: Bool              # true si aucune erreur
    let error: Option<FfiError>  # None si is_ok == true
.end

# ----------------------------------------------------------------------------
# ABI, types et paramètres
# ----------------------------------------------------------------------------

# ABI supportées par le runtime FFI.
pub enum FfiAbi:
    AbiC            # ABI C par défaut
    AbiSystem       # ABI "système" (peut différer de C)
    AbiFast         # convention d appel rapide (registre) si dispo
    AbiStdCall      # stdcall (Windows / APIs historiques)
    AbiThisCall     # thiscall (C++ historique)
    AbiVectorCall   # vectorcall (optimisée registre)
    AbiSysV         # System V AMD64 / x86_64
    AbiWin64        # ABI Windows x64
    AbiAapcs        # ABI ARM AAPCS
    AbiOther        # autre ABI spécifique
.end

# Genre primitif des types FFI que le runtime sait marshaller.
pub enum FfiTypeKind:
    Void

    # Entiers signés
    Int8
    Int16
    Int32
    Int64

    # Entiers non signés
    UInt8
    UInt16
    UInt32
    UInt64

    # Flottants
    Float32
    Float64

    # Booléen
    Bool

    # Pointeurs / handles opaques
    RawPtr          # équivalent à void*
    CString         # const char* UTF‑8
    Custom          # layout opaque / struct utilisateur
.end

# Qualificateurs de type (const / volatile / restrict).
pub enum FfiTypeQualifier:
    QualConst
    QualVolatile
    QualRestrict
.end

# Type FFI logique, attaché à la plateforme cible (taille/alignement).
pub struct FfiType:
    let id: FfiTypeId
    let kind: FfiTypeKind
    let qualifiers: Vec<FfiTypeQualifier>

    # Taille et alignement natifs.
    let size_in_bytes: u32
    let align_in_bytes: u32

    # Indique si ce type est signé (pour les entiers).
    let is_signed: Bool

    # Indique si ce type représente un pointeur.
    let is_pointer: Bool
.end

# Direction d un paramètre.
pub enum FfiParamMode:
    In      # Vitte -> code externe
    Out     # code externe -> Vitte
    InOut   # lecture + écriture
.end

# Paramètre d une fonction FFI.
pub struct FfiParam:
    let name: String         # nom logique, éventuellement vide
    let ty: FfiTypeId
    let mode: FfiParamMode
.end

# Liste de paramètres FFI.
pub struct FfiParamList:
    let params: Vec<FfiParam>
.end

# Signature logique d une fonction FFI.
pub struct FfiSignature:
    let id: FfiSignatureId
    let name: String             # nom logique (peut être vide)
    let abi: FfiAbi
    let params: FfiParamList
    let return_type: FfiTypeId
    let is_variadic: Bool        # variadique style C (...)

    # Indique si la fonction ne retourne jamais (noreturn).
    let is_noreturn: Bool

    # Indique si la fonction peut lever des exceptions natives.
    let can_throw: Bool
.end

# ----------------------------------------------------------------------------
# Bibliothèques, symboles et registres
# ----------------------------------------------------------------------------

# Genre de bibliothèque FFI.
pub enum FfiLibraryKind:
    LibDynamic      # bibliothèque dynamique (shared object / dll)
    LibStatic       # bibliothèque statique
    LibFramework    # framework (ex: macOS)
    LibPlugin       # plugin chargeable
    LibOther
.end

# Bibliothèque dynamique chargée.
pub struct FfiLibrary:
    let id: FfiLibraryId

    # Genre de bibliothèque.
    let kind: FfiLibraryKind

    # Nom logique (ex: "c", "m", "user32").
    let name: String

    # Chemin réel si connu, sinon chaîne vide.
    let path: String

    # Indique si le handle natif est vivant.
    let is_loaded: Bool
.end

# Genre de symbole FFI.
pub enum FfiSymbolKind:
    SymFunction     # fonction
    SymVariable     # variable globale
    SymTls          # donnée TLS
    SymOther
.end

# Visibilité logique d un symbole.
pub enum FfiSymbolVisibility:
    SymVisDefault
    SymVisHidden
    SymVisProtected
    SymVisInternal
.end

# Symbole FFI dans une bibliothèque.
pub struct FfiSymbol:
    let id: FfiSymbolId
    let library: FfiLibraryId

    # Nom exact du symbole (mangling déjà résolu).
    let name: String

    # Genre et visibilité.
    let kind: FfiSymbolKind
    let visibility: FfiSymbolVisibility

    # Signature logique déclarée.
    let signature: FfiSignatureId
.end

# Registre de types FFI.
pub struct FfiTypeRegistry:
    let types: Vec<FfiType>      # indexé par FfiTypeId.raw
.end

# Registre de signatures FFI.
pub struct FfiSignatureRegistry:
    let signatures: Vec<FfiSignature>   # indexé par FfiSignatureId.raw
.end

# Registre global des bibliothèques et symboles.
pub struct FfiLibraryRegistry:
    let libraries: Vec<FfiLibrary>      # indexé par FfiLibraryId.raw
    let symbols: Vec<FfiSymbol>         # indexé par FfiSymbolId.raw
.end

# Adresse résolue d un symbole FFI.
pub struct FfiSymbolAddress:
    let symbol: FfiSymbolId
    let address: usize            # adresse native telle que vue par le backend
    let is_resolved: Bool         # true si le symbole a été résolu avec succès
.end

# Résultats structurés pour les opérations de bibliothèque/symbole.
pub struct FfiLibraryResult:
    let status: FfiStatus
    let library: Option<FfiLibrary>
.end

pub struct FfiSymbolResult:
    let status: FfiStatus
    let symbol: Option<FfiSymbol>
.end

# ----------------------------------------------------------------------------
# Valeurs, arguments et résultats d appel
# ----------------------------------------------------------------------------

# Genre de valeur FFI (tag-only).
pub enum FfiValueKind:
    ValInt8
    ValInt16
    ValInt32
    ValInt64
    ValUInt8
    ValUInt16
    ValUInt32
    ValUInt64
    ValFloat32
    ValFloat64
    ValBool
    ValPtr         # pointeur brut
.end

# Valeur FFI concrète.
# On sépare le "tag" (kind) des champs concrets ; les champs non pertinents
# peuvent être laissés à zéro / valeur par défaut.
pub struct FfiValue:
    let kind: FfiValueKind

    # Entier signé/non signé
    let int_value: i64       # utilisé pour Int8..Int64 (avec signe) et pour
                             # UInt8..UInt64 (représentation brute)

    # Flottant
    let float_value: f64     # utilisé pour Float32/Float64

    # Booléen
    let bool_value: Bool

    # Pointeur brut (adresse mémoire)
    let ptr_value: usize
.end

# Argument FFI = (type logique, valeur).
pub struct FfiArg:
    let ty: FfiTypeId
    let value: FfiValue
.end

# Liste d arguments (ordre positionnel).
pub struct FfiArgList:
    let args: Vec<FfiArg>
.end

# Paramètres optionnels associés à un appel.
pub struct FfiCallOptions:
    # Timeout logique en millisecondes (0 = illimité).
    let timeout_ms: u32

    # Nombre maximal de tentatives (retries).
    let max_retries: u32

    # Indique si l appel est autorisé à bloquer le thread.
    let allow_blocking: Bool

    # Indique si les métriques détaillées doivent être capturées.
    let capture_metrics: Bool

    # Indique si les callbacks peuvent réentrer dans le runtime Vitte.
    let allow_reentry: Bool
.end

# Statut d un appel FFI.
pub enum FfiCallStatusKind:
    CallOk          # appel réussi
    CallError       # erreur récupérable (runtime error)
    CallFatal       # erreur fatale / abort
.end

pub struct FfiCallStatus:
    let kind: FfiCallStatusKind
    let error: Option<FfiError>
.end

# Résultat d un appel FFI.
pub struct FfiCallResult:
    let status: FfiCallStatus
    let call_id: FfiCallId
    let return_type: FfiTypeId
    let return_value: Option<FfiValue>
.end

# Snapshot logique d un appel FFI complet (commandes haut niveau).
pub struct FfiCallSnapshot:
    let id: FfiCallId
    let symbol: FfiSymbolId
    let signature: FfiSignatureId

    # Site d appel et backend.
    let backend: FfiBackendId
    let call_site: Option<FfiCallSiteId>

    # Arguments utilisés.
    let args: FfiArgList
    let options: FfiCallOptions
    let context: Option<FfiCallContext>
    let metrics: Option<FfiCallMetrics>

    # Résultat de l appel.
    let result: FfiCallResult
.end

# ----------------------------------------------------------------------------
# Backends FFI et capacités
# ----------------------------------------------------------------------------

# Backend FFI logique (implémentation concrète : système, sandbox, mock...).
pub struct FfiBackend:
    let id: FfiBackendId
    let name: String                # ex: "system", "sandbox"

    # Chaîne de version logique (ex: "1.0.0", "dev").
    let version: String

    # Indique si ce backend est préféré par défaut.
    let is_default: Bool
.end

# Capacités d un backend FFI.
pub enum FfiBackendCapability:
    CanLoadLibraries
    CanLookupSymbols
    CanCallFunctions
    CanUseThreadLocalState
    CanUseCustomAbi        # support de plusieurs ABI spécifiques
    CanShareHandles        # partage de handles entre backends
    CanSandbox             # exécution sandboxée
    CanMock                # backend factice pour tests
.end

pub struct FfiBackendProfile:
    let backend: FfiBackendId
    let capabilities: Vec<FfiBackendCapability>

    # ABIs supportées explicitement par ce backend.
    let supported_abis: Vec<FfiAbi>
.end

# Registre des backends disponibles.
pub struct FfiBackendRegistry:
    let backends: Vec<FfiBackend>
    let profiles: Vec<FfiBackendProfile>

    # Backend par défaut, s il est connu.
    let default_backend: Option<FfiBackendId>
.end

# ----------------------------------------------------------------------------
# Commandes FFI (description déclarative des opérations)
# ----------------------------------------------------------------------------

# Type de commande FFI.
pub enum FfiCommandKind:
    OpenLibrary
    CloseLibrary
    LookupSymbol
    Call
.end

# Commandes spécialisées.

pub struct FfiOpenLibraryCommand:
    let name: String             # nom logique demandé
    let path: Option<String>     # chemin explicite facultatif
.end

pub struct FfiCloseLibraryCommand:
    let library: FfiLibraryId
.end

pub struct FfiLookupSymbolCommand:
    let library: FfiLibraryId
    let symbol_name: String
.end

pub struct FfiCallCommand:
    let symbol: FfiSymbolId
    let signature: FfiSignatureId
    let args: FfiArgList
    let call_site: Option<FfiCallSiteId>   # pour rattacher au code source
    let call_id: Option<FfiCallId>        # identifiant logique d appel
    let options: Option<FfiCallOptions>   # options avancées d appel
.end

# Commande FFI générique.
pub struct FfiCommand:
    let id: FfiIndex
    let backend: FfiBackendId
    let kind: FfiCommandKind
    let open_library: Option<FfiOpenLibraryCommand>
    let close_library: Option<FfiCloseLibraryCommand>
    let lookup_symbol: Option<FfiLookupSymbolCommand>
    let call: Option<FfiCallCommand>
.end

# ----------------------------------------------------------------------------
# Résultats de commandes FFI
# ----------------------------------------------------------------------------

pub enum FfiCommandResultKind:
    ResOpenLibrary
    ResCloseLibrary
    ResLookupSymbol
    ResCall
.end

pub struct FfiOpenLibraryResult:
    let result: FfiLibraryResult
.end

pub struct FfiCloseLibraryResult:
    let status: FfiStatus
.end

pub struct FfiLookupSymbolResult:
    let result: FfiSymbolResult
.end

pub struct FfiCallCommandResult:
    let result: FfiCallResult
.end

pub struct FfiCommandResult:
    let command_id: FfiIndex
    let kind: FfiCommandResultKind
    let open_library: Option<FfiOpenLibraryResult>
    let close_library: Option<FfiCloseLibraryResult>
    let lookup_symbol: Option<FfiLookupSymbolResult>
    let call: Option<FfiCallCommandResult>
.end

# ----------------------------------------------------------------------------
# Nœuds FFI génériques et vue runtime globale
# ----------------------------------------------------------------------------

pub enum FfiNodeKind:
    NodeLibrary
    NodeSymbol
    NodeType
    NodeSignature
    NodeBackend
    NodeCommand
    NodeCommandResult
    NodeCall
    NodeError
.end

pub struct FfiNode:
    let id: FfiIndex
    let kind: FfiNodeKind
.end

# Informations de plateforme pour le FFI (OS/arch).
pub enum FfiOsKind:
    OsUnknown
    OsLinux
    OsMacOs
    OsWindows
    OsBsd
    OsOther
.end

pub enum FfiArchKind:
    ArchUnknown
    ArchX86_64
    ArchAarch64
    ArchX86
    ArchArm
    ArchRiscV64
    ArchOther
.end

pub struct FfiPlatformInfo:
    let os: FfiOsKind
    let arch: FfiArchKind
    let pointer_width_bytes: u8     # largeur des pointeurs en octets
    let is_little_endian: Bool
.end

# Politique de sécurité FFI (sandbox, limites globales).
pub struct FfiSecurityPolicy:
    let max_memory_bytes: u64           # mémoire max autorisée pour le FFI
    let max_stack_bytes: u64            # stack max autorisée pour le FFI
    let allow_filesystem: Bool          # autoriser les appels FFI touchant au FS
    let allow_network: Bool             # autoriser les appels FFI réseau
    let allow_process_spawn: Bool       # autoriser la création de processus
.end

# Configuration runtime FFI.
pub struct FfiRuntimeConfig:
    let allow_network_backends: Bool   # autoriser les backends réseau/remote
    let security_policy: Option<FfiSecurityPolicy>   # politique de sécurité FFI
.end

# Snapshot runtime global FFI – agrège les registres et l historique.
pub struct FfiRuntimeSnapshot:
    # Snapshot runtime global FFI – agrège les registres et l historique.
    let config: FfiRuntimeConfig
    let platform: FfiPlatformInfo

    # Registres statiques.
    let types: FfiTypeRegistry
    let signatures: FfiSignatureRegistry
    let libraries: FfiLibraryRegistry
    let backends: FfiBackendRegistry

    let stats: FfiStatisticsSnapshot

    # Commandes et résultats récents.
    let commands: Vec<FfiCommand>
    let command_results: Vec<FfiCommandResult>

    # Appels FFI récents.
    let calls: Vec<FfiCallSnapshot>

    # Dernières erreurs FFI connues.
    let recent_errors: Vec<FfiError>
.end
