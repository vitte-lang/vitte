module lrt.env

import std.collections as coll

# =============================================================================
# lrt.env – Environnement d’exécution pour les programmes L/Vitte
# =============================================================================
#
# Objectifs :
#   - Fournir une représentation logique de l’environnement :
#       * arguments de ligne de commande,
#       * variables d’environnement (clé/valeur).
#   - Offrir une API pure (sans I/O OS direct) :
#       * snapshots immuables (EnvSnapshot),
#       * helpers de requête (get/set/unset/find/merge),
#       * conversions vers des formes simples (vecteur argv, "NAME=VALUE").
#   - L’intégration avec l’OS (vrai argv/environ) est laissée aux couches
#     inférieures du runtime (C, Rust, etc.) qui pourront :
#       * construire un EnvSnapshot initial,
#       * le passer comme valeur globale ou comme argument au main.
# =============================================================================

# -----------------------------------------------------------------------------
# Structures de base
# -----------------------------------------------------------------------------

pub struct EnvVar:
    let name: String
    let value: String
.end

pub struct EnvSnapshot:
    let args: Vec<String>   # argv[0..n)
    let vars: Vec<EnvVar>   # environnement (peut contenir des doublons de nom)
.end

# -----------------------------------------------------------------------------
# Construction / snapshots
# -----------------------------------------------------------------------------

pub fn env_snapshot_empty() -> EnvSnapshot:
    let args: Vec<String> = Vec<String>::new()
    let vars: Vec<EnvVar> = Vec<EnvVar>::new()
    let snap = EnvSnapshot(
        args = args,
        vars = vars
    )
    return snap
.end

pub fn env_snapshot_from_args(args: Vec<String>) -> EnvSnapshot:
    let vars: Vec<EnvVar> = Vec<EnvVar>::new()
    let snap = EnvSnapshot(
        args = args,
        vars = vars
    )
    return snap
.end

pub fn env_snapshot_from(
    args: Vec<String>,
    vars: Vec<EnvVar>
) -> EnvSnapshot:
    let snap = EnvSnapshot(
        args = args,
        vars = vars
    )
    return snap
.end

# -----------------------------------------------------------------------------
# Accès aux arguments
# -----------------------------------------------------------------------------

pub fn env_arg_count(
    EnvSnapshot env
) -> u32:
    let args = env.args
    let n = args.len()
    return n as u32
.end

pub fn env_args(
    EnvSnapshot env
) -> Vec<String>:
    # Retourne une copie logique du vecteur d’arguments.
    let args = env.args
    return args
.end

pub fn env_arg_get(
    EnvSnapshot env,
    u32 index
) -> coll.Option<String>:
    let args = env.args
    let n = args.len()
    let idx = index as usize
    if idx >= n:
        let none_s = coll.option_none<String>()
        return none_s
    .end
    let s = args[idx]
    let some_s = coll.option_some<String>(s)
    return some_s
.end

pub fn env_program_name(
    EnvSnapshot env
) -> coll.Option<String>:
    # argv[0] si présent.
    let opt = env_arg_get(env, 0u32)
    return opt
.end

# -----------------------------------------------------------------------------
# Accès aux variables d’environnement
# -----------------------------------------------------------------------------

pub fn env_var_count(
    EnvSnapshot env
) -> u32:
    let vars = env.vars
    let n = vars.len()
    return n as u32
.end

pub fn env_find_var_index(
    EnvSnapshot env,
    String name
) -> coll.Option<u32>:
    let vars = env.vars
    let n = vars.len()
    let i = 0usize

    while i < n:
        let v = vars[i]
        if v.name == name:
            let idx_u32 = i as u32
            let some_idx = coll.option_some<u32>(idx_u32)
            return some_idx
        .end
        let i = i + 1usize
    .end

    let none_idx = coll.option_none<u32>()
    return none_idx
.end

pub fn env_get_var(
    EnvSnapshot env,
    String name
) -> coll.Option<String>:
    let vars = env.vars
    let n = vars.len()
    let i = 0usize
    let found_val = coll.option_none<String>()

    while i < n:
        let v = vars[i]
        if v.name == name:
            let some_val = coll.option_some<String>(v.value)
            let found_val = some_val
        .end
        let i = i + 1usize
    .end

    return found_val
.end

pub fn env_has_var(
    EnvSnapshot env,
    String name
) -> Bool:
    let opt = env_get_var(env, name)
    let b = coll.option_is_some<String>(opt)
    return b
.end

pub fn env_vars(
    EnvSnapshot env
) -> Vec<EnvVar>:
    # Retourne une copie logique du vecteur de variables.
    let vars = env.vars
    return vars
.end

# -----------------------------------------------------------------------------
# Modification immuable des snapshots
# -----------------------------------------------------------------------------

pub fn env_set_var(
    EnvSnapshot env,
    String name,
    String value
) -> EnvSnapshot:
    # Stratégie :
    #   - si le nom existe déjà, on remplace sa dernière occurrence,
    #   - sinon on ajoute une nouvelle variable à la fin.
    let args = env.args
    let vars_old = env.vars

    let vars: Vec<EnvVar> = Vec<EnvVar>::new()
    let n = vars_old.len()
    let i = 0usize
    let replaced = false

    while i < n:
        let v = vars_old[i]
        if v.name == name:
            # On remplace cette occurrence par la nouvelle valeur.
            let new_v = EnvVar(
                name = name,
                value = value
            )
            vars.push(new_v)
            let replaced = true
        else:
            vars.push(v)
        .end
        let i = i + 1usize
    .end

    if not replaced:
        let nv = EnvVar(
            name = name,
            value = value
        )
        vars.push(nv)
    .end

    let snap = EnvSnapshot(
        args = args,
        vars = vars
    )
    return snap
.end

pub fn env_unset_var(
    EnvSnapshot env,
    String name
) -> EnvSnapshot:
    let args = env.args
    let vars_old = env.vars

    let vars: Vec<EnvVar> = Vec<EnvVar>::new()
    let n = vars_old.len()
    let i = 0usize

    while i < n:
        let v = vars_old[i]
        if v.name != name:
            vars.push(v)
        .end
        let i = i + 1usize
    .end

    let snap = EnvSnapshot(
        args = args,
        vars = vars
    )
    return snap
.end

pub fn env_merge_overlays(
    EnvSnapshot base,
    EnvSnapshot overlay
) -> EnvSnapshot:
    # Fusionne deux environnements :
    #   - les args sont ceux de base (overlay ne les modifie pas),
    #   - pour les variables :
    #       * on part de base,
    #       * chaque variable de overlay remplace ou ajoute une entrée dans le résultat.
    let args = base.args
    let vars_base = base.vars

    let snap0 = EnvSnapshot(
        args = args,
        vars = vars_base
    )

    let overlay_vars = overlay.vars
    let m = overlay_vars.len()
    let j = 0usize
    let cur = snap0

    while j < m:
        let ov = overlay_vars[j]
        let cur = env_set_var(cur, ov.name, ov.value)
        let j = j + 1usize
    .end

    return cur
.end

# -----------------------------------------------------------------------------
# Conversions
# -----------------------------------------------------------------------------

pub fn env_args_to_vec(
    EnvSnapshot env
) -> Vec<String>:
    let args = env.args
    return args
.end

pub fn env_vars_to_vec_pairs(
    EnvSnapshot env
) -> Vec<String>:
    # Encode chaque variable sous forme "NAME=VALUE".
    let vars = env.vars
    let n = vars.len()
    let i = 0usize
    let out: Vec<String> = Vec<String>::new()

    while i < n:
        let v = vars[i]
        let pair = v.name + "=" + v.value
        out.push(pair)
        let i = i + 1usize
    .end

    return out
.end

# -----------------------------------------------------------------------------
# Snapshot par défaut / "processus courant"
# -----------------------------------------------------------------------------
#
# Ces fonctions sont volontairement logiques. L’intégration avec le véritable
# environnement du processus (args système, envp, etc.) doit être faite dans
# une couche inférieure (C/Rust) qui appellera ces fonctions ou les
# remplacera. Pour l’instant, on fournit simplement des helpers pour créer un
# EnvSnapshot "processus courant" factice ou configurable.
# -----------------------------------------------------------------------------

pub struct EnvProcessInfo:
    let program_name: String
.end

pub struct EnvRuntime:
    let snapshot: EnvSnapshot
    let info: EnvProcessInfo
.end

pub fn env_process_info_from_snapshot(
    EnvSnapshot snap
) -> EnvProcessInfo:
    let opt_name = env_program_name(snap)
    if coll.option_is_some<String>(opt_name):
        let name = coll.option_unwrap_unsafe<String>(opt_name)
        let info = EnvProcessInfo(
            program_name = name
        )
        return info
    .end

    let info2 = EnvProcessInfo(
        program_name = ""
    )
    return info2
.end

pub fn env_runtime_new(
    EnvSnapshot snap
) -> EnvRuntime:
    let info = env_process_info_from_snapshot(snap)
    let rt = EnvRuntime(
        snapshot = snap,
        info = info
    )
    return rt
.end

pub fn env_runtime_snapshot(
    EnvRuntime rt
) -> EnvSnapshot:
    return rt.snapshot
.end

pub fn env_runtime_program_name(
    EnvRuntime rt
) -> String:
    return rt.info.program_name
.end

# -----------------------------------------------------------------------------
# Helpers de debug (simples)
# -----------------------------------------------------------------------------

pub fn env_snapshot_debug(
    EnvSnapshot env
) -> String:
    # Représentation textuelle très simple, sans details numériques.
    if env_arg_count(env) == 0u32 and env_var_count(env) == 0u32:
        return "EnvSnapshot{args=[], vars=[]}"
    .end
    return "EnvSnapshot{...}"
.end

# -----------------------------------------------------------------------------
# Scenario de smoke test
# -----------------------------------------------------------------------------

scenario env_smoke_test():
    # Construction basique
    let snap0 = env_snapshot_empty()

    let args: Vec<String> = Vec<String>::new()
    args.push("prog")
    args.push("one")
    args.push("two")
    let snap1 = env_snapshot_from_args(args)

    let has_prog = env_program_name(snap1)
    let argc = env_arg_count(snap1)

    let snap2 = env_set_var(snap1, "HOME", "/home/user")
    let snap3 = env_set_var(snap2, "PATH", "/usr/bin")
    let snap4 = env_set_var(snap3, "HOME", "/tmp/home")   # override

    let home_opt = env_get_var(snap4, "HOME")
    let path_opt = env_get_var(snap4, "PATH")
    let has_home = env_has_var(snap4, "HOME")
    let has_shell = env_has_var(snap4, "SHELL")

    let snap5 = env_unset_var(snap4, "PATH")

    let vars_pairs = env_vars_to_vec_pairs(snap5)
    let debug_txt = env_snapshot_debug(snap5)

    let rt = env_runtime_new(snap5)
    let rt_name = env_runtime_program_name(rt)

    let _ = snap0
    let _ = has_prog
    let _ = argc
    let _ = home_opt
    let _ = path_opt
    let _ = has_home
    let _ = has_shell
    let _ = vars_pairs
    let _ = debug_txt
    let _ = rt_name
.end
