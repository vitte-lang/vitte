space vitte/runtime/std/alloc/alloctests/benches/utils

# ============================================================
# Allocator benchmark measurement utilities
# - High resolution timing (ns)
# - Warmup + iterations
# - Aggregates: total, avg, min, max
# - Percentiles: p50 / p95 / p99
# - Optional GC / allocator hooks (no-op by default)
# ============================================================

form MeasureConfig
    name: string
    warmup: u64
    iterations: u64
.end

form MeasureStats
    name: string
    iterations: u64
    total_ns: u128
    avg_ns: u64
    min_ns: u64
    max_ns: u64
    p50_ns: u64
    p95_ns: u64
    p99_ns: u64
.end

# ------------------------------------------------------------
# Platform hooks (to be specialized per target)
# ------------------------------------------------------------

proc now_ns give u128
    # TODO: platform-specific high resolution clock
    give 0
.end

proc fence()
    # TODO: memory / compiler fence if required
.end

proc alloc_reset()
    # Optional allocator reset hook (noop by default)
.end

# ------------------------------------------------------------
# Internal helpers
# ------------------------------------------------------------

proc sort_u64(xs: List of u64)
    # Simple insertion sort (bench-safe, deterministic)
    let n = xs.len
    let i = 1
    loop while i < n
        let key = xs[i]
        let j = i
        loop while j > 0 and xs[j - 1] > key
            xs[j] = xs[j - 1]
            j = j - 1
        .end
        xs[j] = key
        i = i + 1
    .end
.end

proc percentile(sorted: List of u64, p: u64) give u64
    # p in [0,100]
    let n = sorted.len
    if n == 0
        give 0
    .end
    let idx = (n * p) / 100
    if idx >= n
        give sorted[n - 1]
    .end
    give sorted[idx]
.end

# ------------------------------------------------------------
# Core measurement API
# ------------------------------------------------------------

proc measure(cfg: MeasureConfig, f) give MeasureStats
    # Warmup
    let w = 0
    loop while w < cfg.warmup
        alloc_reset()
        fence()
        do f()
        fence()
        w = w + 1
    .end

    let samples: List of u64 = []
    let it = 0
    let total: u128 = 0
    let min_v: u64 = 18446744073709551615
    let max_v: u64 = 0

    loop while it < cfg.iterations
        alloc_reset()
        fence()
        let t0 = now_ns()
        do f()
        fence()
        let t1 = now_ns()
        let dt: u64 = (t1 - t0) as u64

        samples.push(dt)
        total = total + dt
        if dt < min_v
            min_v = dt
        .end
        if dt > max_v
            max_v = dt
        .end

        it = it + 1
    .end

    sort_u64(samples)

    let avg: u64 =
        if cfg.iterations == 0
            0
        else
            (total / cfg.iterations) as u64
        .end

    give MeasureStats(
        name: cfg.name,
        iterations: cfg.iterations,
        total_ns: total,
        avg_ns: avg,
        min_ns: min_v,
        max_ns: max_v,
        p50_ns: percentile(samples, 50),
        p95_ns: percentile(samples, 95),
        p99_ns: percentile(samples, 99)
    )
.end
