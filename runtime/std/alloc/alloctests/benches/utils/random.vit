space vitte/runtime/std/alloc/alloctests/benches/utils

# ============================================================
# Deterministic pseudo-random utilities for allocator benches
# - Stable across platforms
# - No libc / OS dependency
# - Suitable for reproducible benchmarks
# ============================================================

form Rng
    state: u64
.end

# ------------------------------------------------------------
# Constructors
# ------------------------------------------------------------

proc rng_seed(seed: u64) give Rng
    give Rng(state: seed)
.end

proc rng_default give Rng
    # Fixed non-zero seed for reproducibility
    give Rng(state: 0x853c49e6748fea9b)
.end

# ------------------------------------------------------------
# Core algorithm: xorshift64*
# ------------------------------------------------------------

proc next_u64(r: Rng) give u64
    let x = r.state
    let x = x ^ (x >> 12)
    let x = x ^ (x << 25)
    let x = x ^ (x >> 27)
    r.state = x
    give x * 2685821657736338717
.end

# ------------------------------------------------------------
# Derived distributions
# ------------------------------------------------------------

proc next_u32(r: Rng) give u32
    give (next_u64(r) >> 32) as u32
.end

proc next_bool(r: Rng) give bool
    give (next_u64(r) & 1) == 1
.end

proc next_range(r: Rng, min: usize, max: usize) give usize
    # uniform in [min, max)
    if max <= min
        give min
    .end
    let span = max - min
    give min + ((next_u64(r) as usize) % span)
.end

# ------------------------------------------------------------
# Bench helpers
# ------------------------------------------------------------

proc shuffle[T](r: Rng, xs: List of T)
    # Fisherâ€“Yates shuffle
    let n = xs.len
    if n <= 1
        give
    .end
    let i = n - 1
    loop while i > 0
        let j = next_range(r, 0, i + 1)
        let tmp = xs[i]
        xs[i] = xs[j]
        xs[j] = tmp
        i = i - 1
    .end
.end

proc fill_random_bytes(r: Rng, buf: List of u8)
    let i = 0
    let n = buf.len
    loop while i < n
        let v = next_u64(r)
        let k = 0
        loop while k < 8 and i < n
            buf[i] = (v >> (k * 8)) as u8
            i = i + 1
            k = k + 1
        .end
    .end
.end

# ------------------------------------------------------------
# Tests (bench-local, deterministic)
# ------------------------------------------------------------

proc test_rng_stability give bool
    let r = rng_seed(1)
    let a = next_u64(r)
    let b = next_u64(r)
    give a != b
.end
