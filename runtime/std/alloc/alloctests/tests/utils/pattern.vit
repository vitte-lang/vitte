space vitte/runtime/std/alloc/alloctests/tests/utils

# ============================================================
# Allocation patterns for allocator tests
# - Reusable workloads for correctness tests
# - Deterministic, allocator-agnostic
# ============================================================

# ------------------------------------------------------------
# Simple patterns
# ------------------------------------------------------------

proc pattern_alloc_free(count: usize, size: usize)
    let i = 0
    loop while i < count
        let buf: List of u8 = []
        let j = 0
        loop while j < size
            buf.push(0)
            j = j + 1
        .end
        # buf dropped here
        i = i + 1
    .end
.end

proc pattern_batch_alloc(count: usize, size: usize) give List of List of u8
    let blocks: List of List of u8 = []
    let i = 0
    loop while i < count
        let buf: List of u8 = []
        let j = 0
        loop while j < size
            buf.push(0)
            j = j + 1
        .end
        blocks.push(buf)
        i = i + 1
    .end
    give blocks
.end

# ------------------------------------------------------------
# Churn / fragmentation patterns
# ------------------------------------------------------------

proc pattern_churn(count: usize, size_min: usize, size_max: usize)
    let r = 0x12345678_u64
    let blocks: List of List of u8 = []

    # Initial alloc
    let i = 0
    loop while i < count
        let size = size_min + (r % (size_max - size_min + 1))
        let buf: List of u8 = []
        let j = 0
        loop while j < size
            buf.push(0)
            j = j + 1
        .end
        blocks.push(buf)
        i = i + 1
    .end

    # Churn
    let k = 0
    loop while k < count * 2
        let idx = k % blocks.len
        blocks[idx] = []   # free
        let size2 = size_min + ((r + k) % (size_max - size_min + 1))
        let buf2: List of u8 = []
        let j2 = 0
        loop while j2 < size2
            buf2.push(0)
            j2 = j2 + 1
        .end
        blocks[idx] = buf2
        k = k + 1
    .end
.end

# ------------------------------------------------------------
# Realloc-like pattern (grow/shrink)
# ------------------------------------------------------------

proc pattern_grow_shrink(start: usize, grow_to: usize)
    let buf: List of u8 = []
    let i = 0
    loop while i < start
        buf.push(0)
        i = i + 1
    .end

    let j = start
    loop while j < grow_to
        buf.push(0)
        j = j + 1
    .end

    let k = 0
    loop while k < grow_to - start
        buf.pop()
        k = k + 1
    .end
.end

# ------------------------------------------------------------
# Test self-check
# ------------------------------------------------------------

proc test_pattern_basic give bool
    pattern_alloc_free(10, 32)
    let xs = pattern_batch_alloc(5, 16)
    if xs.len != 5
        panic("pattern_batch_alloc failed")
    .end
    pattern_churn(8, 8, 64)
    pattern_grow_shrink(16, 128)
    give true
.end
