# ============================================================
# urem.vit — compiler-builtins shim
# ============================================================
# - Reste de division entière NON SIGNÉE
# - Algorithme shift/subtract (long division)
# - Aucun appel externe
# - Bootstrap-safe
# ============================================================

space std/alloc/compiler_builtins/builtins_shim/builtins


# ------------------------------------------------------------
# Types fondamentaux
# ------------------------------------------------------------

type usize = builtin.usize


# ------------------------------------------------------------
# urem
# ------------------------------------------------------------
# usize urem(usize n, usize d)
#
# Règles :
# - division NON SIGNÉE
# - d == 0 → trap explicite
# - retourne n % d
# ------------------------------------------------------------

#[export]
proc urem(n: usize, d: usize) -> usize
    # --------------------------------------------------------
    # Division par zéro → trap
    # --------------------------------------------------------
    if d == 0
        builtin.trap("urem: division by zero")
    .end

    # Cas triviaux
    if n < d
        give n
    .end

    if d == 1
        give 0
    .end

    # --------------------------------------------------------
    # Algorithme : long division binaire
    # (on ne conserve que le remainder)
    # --------------------------------------------------------

    let remainder: usize = n

    # Trouver le plus grand décalage tel que (d << shift) <= remainder
    let shift: usize = 0
    loop while (d << (shift + 1)) <= remainder
        set shift = shift + 1
    .end

    # Soustraction progressive
    loop while shift + 1 > 0
        let current: usize = d << shift

        if remainder >= current
            set remainder = remainder - current
        .end

        if shift == 0
            break
        .end

        set shift = shift - 1
    .end

    give remainder
.end