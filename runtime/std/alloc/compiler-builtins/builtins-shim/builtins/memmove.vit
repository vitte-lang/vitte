# ============================================================
# memmove.vit — compiler-builtins shim
# ============================================================
# - Implémentation sûre de memmove (overlap-safe)
# - Copie byte par byte
# - ABI-compatible C
# - Aucun appel externe
# ============================================================

space std/alloc/compiler_builtins/builtins_shim/builtins


# ------------------------------------------------------------
# Types fondamentaux (shim minimal)
# ------------------------------------------------------------

type usize = builtin.usize
type u8    = builtin.u8
type ptr[T] = builtin.ptr[T]


# ------------------------------------------------------------
# memmove
# ------------------------------------------------------------
# void* memmove(void* dst, const void* src, size_t n)
#
# Règles :
# - si dst == src → no-op
# - si dst < src → copie avant → arrière
# - si dst > src → copie arrière → avant
# ------------------------------------------------------------

#[export]
proc memmove(dst: ptr[u8], src: ptr[u8], n: usize) -> ptr[u8]
    # Cas trivial
    if n == 0
        give dst
    .end

    if dst == src
        give dst
    .end

    # Conversion en adresses entières
    let dst_addr: usize = builtin.ptr_to_usize(dst)
    let src_addr: usize = builtin.ptr_to_usize(src)

    # --------------------------------------------------------
    # Copie AVANT → ARRIÈRE (zones non chevauchantes ou dst < src)
    # --------------------------------------------------------
    if dst_addr < src_addr
        let i: usize = 0
        loop while i < n
            let byte: u8 = builtin.load_u8(src, i)
            builtin.store_u8(dst, i, byte)
            set i = i + 1
        .end

        give dst
    .end

    # --------------------------------------------------------
    # Copie ARRIÈRE → AVANT (zones chevauchantes)
    # --------------------------------------------------------
    let i: usize = n
    loop while i > 0
        set i = i - 1
        let byte: u8 = builtin.load_u8(src, i)
        builtin.store_u8(dst, i, byte)
    .end

    give dst
.end