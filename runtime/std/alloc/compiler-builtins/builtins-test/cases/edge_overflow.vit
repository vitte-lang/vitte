# ============================================================
# edge_overflow.vit — compiler-builtins edge tests
# ============================================================
# Tests de robustesse sur :
# - bornes usize
# - invariants arithmétiques
# - comportements aux limites
# - overflow implicite (contrôlé)
# ============================================================

space std/alloc/compiler_builtins/builtins_test/cases


# ------------------------------------------------------------
# Imports
# ------------------------------------------------------------

pull std/alloc/compiler_builtins
pull std/test/assert


# ------------------------------------------------------------
# Helpers
# ------------------------------------------------------------

proc assert_div_invariants(n: usize, d: usize)
    let q = udiv(n, d)
    let r = urem(n, d)

    # Invariants mathématiques
    assert.eq(q * d + r, n)
    assert.lt(r, d)
.end


# ------------------------------------------------------------
# Bornes de usize
# ------------------------------------------------------------

#[test]
proc overflow_usize_bounds()
    let max: usize = usize.max()
    let zero: usize = 0
    let one: usize = 1

    # max / 1
    assert.eq(udiv(max, one), max)
    assert.eq(urem(max, one), zero)

    # max / max
    assert.eq(udiv(max, max), one)
    assert.eq(urem(max, max), zero)

    # (max - 1) / max
    assert.eq(udiv(max - 1, max), zero)
    assert.eq(urem(max - 1, max), max - 1)
.end


# ------------------------------------------------------------
# Frontières puissances de deux
# ------------------------------------------------------------

#[test]
proc overflow_powers_of_two_edges()
    let max: usize = usize.max()

    let p: usize = 1 << (usize.bits() - 1)   # MSB

    assert.eq(udiv(p, 2), p >> 1)
    assert.eq(urem(p, 2), 0)

    assert_div_invariants(p - 1, 2)
    assert_div_invariants(p + 1, 2)

    assert_div_invariants(max, p)
.end


# ------------------------------------------------------------
# Valeurs proches du wrap
# ------------------------------------------------------------

#[test]
proc overflow_near_wrap()
    let max: usize = usize.max()

    # Ces opérations doivent rester cohérentes,
    # même si l’arithmétique wrappe en interne
    assert_div_invariants(max, 3)
    assert_div_invariants(max - 1, 3)
    assert_div_invariants(max - 2, 3)
.end


# ------------------------------------------------------------
# Boucle stress sur plage haute
# ------------------------------------------------------------

#[test]
proc overflow_high_range_stress()
    let max: usize = usize.max()
    let n: usize = max - 256

    loop while n < max
        let d: usize = 1
        loop while d < 16
            assert_div_invariants(n, d)
            set d = d + 1
        .end
        set n = n + 1
    .end
.end


# ------------------------------------------------------------
# Division par zéro (overflow logique)
# ------------------------------------------------------------

#[test]
#[should_trap]
proc overflow_div_by_zero_udiv()
    udiv(usize.max(), 0)
.end


#[test]
#[should_trap]
proc overflow_div_by_zero_urem()
    urem(usize.max(), 0)
.end