<<< ========================================================= ) ( Vitte — Grammar (surface syntax) ) ( ========================================================= >>>

program ::= WS? { toplevel WS? } ;

<<< ——————————————————— ) ( Top-level ) ( ——————————————————— >>>

toplevel ::= space_decl
          | pull_decl
          | use_decl
          | share_decl
          | const_decl
          | global_decl
          | type_alias_decl
          | form_decl
          | pick_decl
          | proc_decl
          | entry_decl
          | macro_decl
          ;

space_decl ::= "space" WS1 module_path ;
pull_decl  ::= "pull"  WS1 module_path [ WS1 "as" WS1 ident ] ;
use_decl   ::= "use" WS1 use_path [ use_group | use_glob ] [ WS1 "as" WS1 ident ] ;
use_glob   ::= "." "*" ;
use_group  ::= "." "{" WS? ( "*" | ident_list [ WS? "," WS? "*" ]? ) WS? "}" ;
share_decl ::= "share" WS1 ( "all" | ident_list ) ;
const_decl ::= "const" WS1 ident [ WS? ":" WS? type_expr ] WS? "=" WS? expr ;
global_decl ::= let_global_decl | make_global_decl ;
let_global_decl ::= "let" WS1 ident
                [ WS? ":" WS? type_expr ]
                WS? "=" WS? expr ;
make_global_decl ::= "make" WS1 ident
                [ WS1 "as" WS1 type_expr ]
                WS? "=" WS? expr ;

module_path ::= relative? path_parts ;
use_path    ::= relative? path_parts ;
relative    ::= { "." } ;
path_parts  ::= ident { ("/" | ".") ident } ;
ident_list  ::= ident { WS? "," WS? ident } ;

<<< ——————————————————— ) ( Comments ) ( ——————————————————— >>>

comment ::= zone_comment | line_comment ;

zone_comment ::= "<<<" WS? [ ident ] WS? zone_body ">>>" ;
zone_body ::= { ~">>>" } ;

line_comment ::= "#" { ~NEWLINE } ;

<<< ——————————————————— ) ( Attributes ) ( ——————————————————— >>>

attribute ::= "#[" ident [ "(" WS? attr_args? WS? ")" ] "]" ;
attr_args ::= attr_arg { WS? "," WS? attr_arg } ;
attr_arg ::= ident | string_lit | int_lit ;

<<< ——————————————————— ) ( Types ) ( ——————————————————— >>>

type_alias_decl ::= "type" WS1 ident type_params? WS? "=" WS? type_expr ;

form_decl ::= ("form" | "trait") WS1 ident type_params? WS?
             ( "{" WS? field_list? WS? "}" | legacy_form ) ;

legacy_form ::= { field_decl WS? } ".end" ;

field_decl ::= "field" WS1 ident WS1 "as" WS1 type_expr ;
field_list ::= field_item { WS? "," WS? field_item } ;
field_item ::= ident WS? ":" WS? type_expr ;

pick_decl ::= "pick" WS1 ident type_params? WS?
             ( "{" WS? case_list? WS? "}" | legacy_pick ) ;

legacy_pick ::= { case_decl WS? } ".end" ;

case_list ::= case_item { WS? "," WS? case_item } ;
case_item ::= [ "case" WS1 ] ident [ "(" WS? case_payload_brace WS? ")" ] ;

case_decl ::= "case" WS1 ident [ "(" WS? case_payload_legacy WS? ")" ] ;
case_payload_brace ::= case_field_brace { WS? "," WS? case_field_brace } ;
case_payload_legacy ::= case_field_legacy { WS? "," WS? case_field_legacy } ;
case_field_brace ::= ident WS? ":" WS? type_expr ;
case_field_legacy ::= ident WS1 "as" WS1 type_expr ;

<<< ——————————————————— ) ( Procedures ) ( ——————————————————— >>>

proc_decl ::= { attribute WS? }
             "proc" WS1 ident type_params?
             "(" WS? param_list? WS? ")"
             WS? [ "->" WS? type_expr ]
             WS? block? ;

macro_decl ::= "macro" WS1 ident
               "(" WS? param_names? WS? ")"
               WS? block ;

param_list ::= param { WS? "," WS? param } ;
param ::= ident [ WS? ":" WS? type_expr ] ;
param_names ::= ident { WS? "," WS? ident } ;

type_params ::= "[" WS? ident_list WS? "]" ;

<<< ——————————————————— ) ( Entry point ) ( ——————————————————— >>>

entry_decl ::= "entry" WS1 ident WS1 "at" WS1 module_path WS? block ;

<<< ——————————————————— ) ( Block ) ( ——————————————————— >>>

block ::= "{" WS? { stmt WS? } "}" ;

<<< ——————————————————— ) ( Statements ) ( ——————————————————— >>>

stmt ::= let_stmt
       | asm_stmt
       | unsafe_stmt
       | make_stmt
       | set_stmt
       | give_stmt
       | emit_stmt
       | if_stmt
       | loop_stmt
       | for_stmt
       | break_stmt
       | continue_stmt
       | select_stmt
       | match_stmt
       | when_match_stmt
       | return_stmt
       | expr_stmt
       ;

let_stmt  ::= "let"  WS1 ident [ WS? ":" WS? type_expr ] WS? "=" WS? expr ;
make_stmt ::= "make" WS1 ident [ WS1 "as" WS1 type_expr ] WS? "=" WS? expr ;
set_stmt  ::= "set"  WS1 ident WS? "=" WS? expr ;

give_stmt ::= "give" WS1 expr ;
emit_stmt ::= "emit" WS1 expr ;
asm_stmt ::= "asm" WS? "(" WS? string_lit WS? ")" ;
unsafe_stmt ::= "unsafe" WS? block ;
return_stmt ::= "return" [ WS1 expr ] ;

if_stmt ::= "if" WS1 expr WS? block
            [ WS? ("else" | "otherwise") WS? ( block | if_stmt ) ] ;

loop_stmt ::= "loop" WS? block ;
for_stmt ::= "for" WS1 ident WS1 "in" WS1 expr WS? block ;

break_stmt ::= "break" ;
continue_stmt ::= "continue" ;

select_stmt ::= "select" WS1 expr WS?
                { when_stmt WS? }
                [ WS? "otherwise" WS? block ] ;
match_stmt ::= "match" WS1 expr WS?
               "{" WS? { "case" WS1 pattern WS? block WS? } [ WS? ("else" | "otherwise") WS? block ] "}" ;

when_stmt ::= "when" WS1 pattern WS? block ;
when_match_stmt ::= "when" WS1 expr WS1 "is" WS1 pattern WS? block ;

expr_stmt ::= expr ;

<<< ——————————————————— ) ( Expressions ) ( ——————————————————— >>>

expr ::= assign_expr ;

assign_expr ::= or_expr [ WS? "=" WS? assign_expr ] ;

or_expr  ::= and_expr { WS? ("or" | "||") WS? and_expr } ;
and_expr ::= bit_or_expr { WS? ("and" | "&&") WS? bit_or_expr } ;

bit_or_expr  ::= bit_xor_expr { WS? "|" WS? bit_xor_expr } ;
bit_xor_expr ::= bit_and_expr { WS? "^" WS? bit_and_expr } ;
bit_and_expr ::= eq_expr { WS? "&" WS? eq_expr } ;

eq_expr  ::= rel_expr { WS? ("==" | "!=") WS? rel_expr } ;
rel_expr ::= shift_expr { WS? ("<" | "<=" | ">" | ">=") WS? shift_expr } ;

shift_expr ::= add_expr { WS? ("<<" | ">>") WS? add_expr } ;
add_expr ::= mul_expr { WS? ("+" | "-") WS? mul_expr } ;
mul_expr ::= cast_expr { WS? ("*" | "/" | "%") WS? cast_expr } ;

cast_expr ::= unary_expr { WS? ("as" WS? type_expr | "is" WS? pattern) } ;

unary_expr ::= ("not" | "!" | "-" | "&" | "*") WS? unary_expr | postfix_expr ;

postfix_expr ::= primary { postfix } ;
postfix ::= call_suffix | member_suffix | index_suffix ;
call_suffix ::= "(" WS? arg_list? WS? ")" ;
member_suffix ::= "." ( ident | "*" ) ;
index_suffix ::= "[" WS? expr WS? "]" ;

primary ::= literal
          | if_expr
          | proc_expr
          | ident
          | list_lit
          | "(" WS? expr WS? ")"
          ;

if_expr ::= "if" WS1 expr WS? block [ WS? ("else" | "otherwise") WS? ( block | if_expr ) ] ;
proc_expr ::= "proc" WS? "(" WS? param_list? WS? ")" WS? [ "->" WS? type_expr ] WS? block ;

arg_list ::= expr { WS? "," WS? expr } ;

<<< ——————————————————— ) ( Patterns ) ( ——————————————————— >>>

pattern ::= pattern_head [ "(" WS? pattern_args? WS? ")" ] ;

pattern_head ::= pattern_qualified_ident ;
pattern_args ::= pattern { WS? "," WS? pattern } ;

pattern_qualified_ident ::= pattern_ident { "." pattern_ident } ;
pattern_ident ::= ident | keyword_ident ;

qualified_ident ::= ident { "." ident } ;

<<< ——————————————————— ) ( Types ) ( ——————————————————— >>>

type_expr ::= pointer_type | slice_type | proc_type | type_primary ;

pointer_type ::= "*" WS? type_expr ;
slice_type ::= "[" WS? type_expr WS? "]" ;

proc_type ::= "proc" WS? "(" WS? type_list? WS? ")" WS?
              [ "->" WS? type_expr ] ;

type_list ::= type_param { WS? "," WS? type_param } ;
type_param ::= ident WS? ":" WS? type_expr | type_expr ;

type_primary ::= qualified_ident [ "[" WS? type_list? WS? "]" ]
               | "bool" | "string" | "int"
               | "i32" | "i64" | "i128" | "u32" | "u64" | "u128" ;

<<< ——————————————————— ) ( Literals ) ( ——————————————————— >>>

literal ::= bool_lit | int_lit | float_lit | char_lit | string_lit | list_lit ;

list_lit ::= "[" WS? arg_list? WS? "]" ;

bool_lit ::= "true" | "false" ;

int_lit ::= [ "-" ] DIGIT { DIGIT | "_" } [ suffix ]
          | [ "-" ] "0x" HEXDIGIT { HEXDIGIT | "_" } ;

float_lit ::= [ "-" ] DIGIT { DIGIT | "_" } "." DIGIT { DIGIT | "_" } ;

char_lit ::= "'" { char_char } "'" ;
char_char ::= "\\" | ~"'" ;

string_lit ::= "\"" { string_char } "\"" | raw_string_lit ;
string_char ::= "\\\"" | "\\\\" | ~"\"" ;
raw_string_lit ::= "\"\"\"" { raw_string_char } "\"\"\"" ;
raw_string_char ::= ~"\"\"\"" ;

<<< ——————————————————— ) ( Lexical ) ( ——————————————————— >>>

ident ::= (LETTER | "_") { LETTER | DIGIT | "_" } ;
keyword_ident ::= "bool" | "string" | "int" | "and" | "or" | "not" | "all" ;
suffix ::= LETTER { LETTER } ;

WS ::= { " " | "\t" | NEWLINE } ;
WS1 ::= ( " " | "\t" | NEWLINE ) { " " | "\t" | NEWLINE } ;

NEWLINE ::= "\n" | "\r\n" ;

LETTER ::= "a"…"z" | "A"…"Z" ;
DIGIT ::= "0"…"9" ;
HEXDIGIT ::= DIGIT | "a"…"f" | "A"…"F" ;
