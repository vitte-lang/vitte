# ============================================================
# vitte_driver_impl :: utils :: log
# Internal logging utilities
# ============================================================

space vitte/driver_impl/utils

pull vitte/driver/diagnostics
pull vitte/driver/options

# ------------------------------------------------------------
# LogLevel
# ------------------------------------------------------------

pick LogLevel
    Error
    Warn
    Info
    Debug
    Trace
.end

proc LogLevel::as_string(self: LogLevel)
    gives String

    match self
        Error => "error"
        Warn  => "warn"
        Info  => "info"
        Debug => "debug"
        Trace => "trace"
    .end
.end

# ------------------------------------------------------------
# LoggerConfig
# ------------------------------------------------------------

form LoggerConfig
    level: LogLevel
    colored: Bool
    prefix: Bool
.end

proc LoggerConfig::default()
    gives LoggerConfig

    give LoggerConfig {
        level: Info,
        colored: true,
        prefix: true,
    }
.end

# ------------------------------------------------------------
# Global logger state (simple & explicit)
# ------------------------------------------------------------

form Logger
    config: LoggerConfig
.end

# Single global logger instance (driver_impl scope)
let mut GLOBAL_LOGGER: Logger? = None

# ------------------------------------------------------------
# Initialization
# ------------------------------------------------------------

proc init_logger_from_options(opts: &DriverOptions)

    let mut cfg = LoggerConfig::default()

    if opts.flags.verbose
        cfg.level = Debug
    .end

    if opts.flags.trace
        cfg.level = Trace
    .end

    GLOBAL_LOGGER = Some(Logger { config: cfg })
.end

# ------------------------------------------------------------
# Core logging
# ------------------------------------------------------------

proc log(level: LogLevel, msg: String)

    match GLOBAL_LOGGER
        None => ()
        Some(logger) =>
            if level_priority(level) > level_priority(logger.config.level)
                return
            .end

            let mut out = ""

            if logger.config.prefix
                out = out + "[" + level.as_string() + "] "
            .end

            out = out + msg

            print_line(format_message(level, out, logger.config.colored))
    .end
.end

proc level_priority(l: LogLevel)
    gives Int

    match l
        Error => 0
        Warn  => 1
        Info  => 2
        Debug => 3
        Trace => 4
    .end
.end

# ------------------------------------------------------------
# Formatting
# ------------------------------------------------------------

proc format_message(level: LogLevel, msg: String, colored: Bool)
    gives String

    if !colored
        give msg
    .end

    match level
        Error => give color_red(msg)
        Warn  => give color_yellow(msg)
        Info  => give color_blue(msg)
        Debug => give color_green(msg)
        Trace => give color_gray(msg)
    .end
.end

# ------------------------------------------------------------
# Convenience helpers
# ------------------------------------------------------------

proc log_error(msg: String)
    log(Error, msg)
.end

proc log_warn(msg: String)
    log(Warn, msg)
.end

proc log_info(msg: String)
    log(Info, msg)
.end

proc log_debug(msg: String)
    log(Debug, msg)
.end

proc log_trace(msg: String)
    log(Trace, msg)
.end

# ------------------------------------------------------------
# Diagnostics bridge
# ------------------------------------------------------------

proc log_driver_error(diag: &DiagnosticContext)

    for e in diag.errors()
        log_error(e.message())
    .end

    for w in diag.warnings()
        log_warn(w.message())
    .end
.end

# ------------------------------------------------------------
# Color helpers (simple ANSI)
# ------------------------------------------------------------

proc color_red(s: String)    gives String give "\x1b[31m" + s + "\x1b[0m" .end
proc color_yellow(s: String) gives String give "\x1b[33m" + s + "\x1b[0m" .end
proc color_blue(s: String)   gives String give "\x1b[34m" + s + "\x1b[0m" .end
proc color_green(s: String)  gives String give "\x1b[32m" + s + "\x1b[0m" .end
proc color_gray(s: String)   gives String give "\x1b[90m" + s + "\x1b[0m" .end

# ------------------------------------------------------------
# Notes
# ------------------------------------------------------------
#
# - Logging is:
#     * optional
#     * explicit (no implicit global init)
#
# - init_logger_from_options() must be called
#   once early in driver startup.
#
# - Designed to be:
#     * bootstrap-friendly
#     * deterministic
#     * easy to replace later
#
# - Future extensions:
#     * file logging
#     * timestamps
#     * structured logs
#     * JSON output
#
