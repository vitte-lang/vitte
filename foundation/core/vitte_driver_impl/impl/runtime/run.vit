# ============================================================
# vitte_driver_impl :: runtime :: run
# Runtime execution support
# ============================================================

space vitte/driver_impl/runtime

pull vitte/driver/context
pull vitte/driver/diagnostics
pull vitte/driver/options
pull vitte/driver/targets

pull vitte/driver/utils
pull vitte/driver/utils/process
pull vitte/driver/utils/fs

# ------------------------------------------------------------
# RunConfig
# ------------------------------------------------------------

form RunConfig
    program: String
    args: List<String>
    env: Map<String, String>
    cwd: String?
    inherit_stdio: Bool
    dry_run: Bool
.end

proc RunConfig::from_context(ctx: &DriverContext)
    gives Result<RunConfig, DriverError>

    let bin = ctx.session.output_binary_path()

    if !exists(bin)
        give Error(
            DriverError::InternalError(
                "run",
                "output binary does not exist"
            )
        )
    .end

    give Ok(
        RunConfig {
            program: bin,
            args: ctx.options.run_args(),
            env: ctx.options.run_env(),
            cwd: ctx.options.run_cwd(),
            inherit_stdio: true,
            dry_run: ctx.options.flags.dry_run,
        }
    )
.end

# ------------------------------------------------------------
# Entry point
# ------------------------------------------------------------

proc run_impl(ctx: &mut DriverContext)
    gives Result<Int, DriverError>

    let cfg = RunConfig::from_context(ctx)?

    if ctx.options.flags.verbose || cfg.dry_run
        ctx.diagnostics.note(
            format(
                "run: {} {}",
                cfg.program,
                cfg.args.join(" ")
            )
        )
    .end

    if cfg.dry_run
        give Ok(0)
    .end

    let mut cmd = Command::new(cfg.program)

    for a in cfg.args
        cmd.arg(a)
    .end

    for (k, v) in cfg.env
        cmd.env(k, v)
    .end

    match cfg.cwd
        Some(dir) => cmd.cwd(dir)
        None => ()
    .end

    if cfg.inherit_stdio
        # default behavior: inherit stdio
        let status = cmd.run()
        give Ok(status.code)
    else
        let out = cmd.run_capture()?
        if !out.status.success
            ctx.diagnostics.error(out.stderr)
            give Ok(out.status.code)
        .end
        ctx.diagnostics.note(out.stdout)
        give Ok(out.status.code)
    .end
.end

# ------------------------------------------------------------
# Convenience wrapper
# ------------------------------------------------------------

proc run_impl_checked(ctx: &mut DriverContext)
    gives Bool

    match run_impl(ctx)
        Ok(code) =>
            if code != 0
                ctx.emit_error(
                    format("program exited with code {}", code)
                )
                false
            else
                true
            .end
        Error(e) =>
            ctx.emit_error(e.message())
            false
    .end
.end

# ------------------------------------------------------------
# Notes
# ------------------------------------------------------------
#
# - This module:
#     * runs already-linked binaries
#     * never performs compilation
#     * integrates with driver diagnostics
#
# - Layering:
#     vitte_driver/runtime/run.vit        (API)
#     vitte_driver_impl/runtime/run.vit   (execution)
#
# - Future extensions:
#     * timeout support
#     * debugger integration
#     * sandbox / seccomp
#     * WASI runtime
#
