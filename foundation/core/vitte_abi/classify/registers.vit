# ============================================================
# Vitte â€” ABI / Classification
# File: classify/registers.vit
#
# Role:
#   Provide a unified, ABI-agnostic register classification
#   used by calling conventions (sysv / win64 / aarch64).
#
# This module:
#   - Defines register classes (GP / FP / Vector)
#   - Maps AbiType -> preferred register class
#   - Encodes ABI-specific constraints where needed
#
# Design goals:
#   - Deterministic
#   - Minimal policy, no placement logic
#   - Reusable by args/ret implementations
#
# ============================================================

space foundation/core/vitte_abi/classify/registers

pull foundation/core/vitte_abi/types
pull foundation/core/vitte_abi/layout


# ============================================================
# Register classes
# ============================================================

pick RegClass
    GP          # General-purpose integer registers
    FP          # Floating-point registers
    SIMD        # Vector / SIMD registers
    MEMORY      # Must be passed/returned in memory
.end


# ============================================================
# Register usage intent
# ============================================================

pick RegUse
    Arg         # Used for argument passing
    Ret         # Used for return values
.end


# ============================================================
# Classification result
# ============================================================

form RegClassResult
    class: RegClass
    size: Int
    align: Int
.end


# ============================================================
# Public API
# ============================================================

# Classify an ABI type for register usage.
# This function does NOT decide which register index is used;
# it only decides the *class*.
proc classify(
    ty: types::AbiType,
    use: RegUse
)
gives RegClassResult
.end
    let layout = layout::type_layout(ty)

    # --------------------------------------------------------
    # Scalar floating-point
    # --------------------------------------------------------
    match ty
    when types::AbiType::F32
        give RegClassResult {
            class: RegClass::FP,
            size: layout.size,
            align: layout.align,
        }
    when types::AbiType::F64
        give RegClassResult {
            class: RegClass::FP,
            size: layout.size,
            align: layout.align,
        }

    # --------------------------------------------------------
    # Vector / SIMD types
    # --------------------------------------------------------
    when types::AbiType::Vector(_, _)
        give RegClassResult {
            class: RegClass::SIMD,
            size: layout.size,
            align: layout.align,
        }

    # --------------------------------------------------------
    # Integer / pointer-like scalars
    # --------------------------------------------------------
    when types::AbiType::I8
        give gp(layout)
    when types::AbiType::I16
        give gp(layout)
    when types::AbiType::I32
        give gp(layout)
    when types::AbiType::I64
        give gp(layout)
    when types::AbiType::U8
        give gp(layout)
    when types::AbiType::U16
        give gp(layout)
    when types::AbiType::U32
        give gp(layout)
    when types::AbiType::U64
        give gp(layout)
    when types::AbiType::Ptr(_)
        give gp(layout)

    # --------------------------------------------------------
    # Aggregates
    # --------------------------------------------------------
    when types::AbiType::Struct(_)
        give classify_aggregate(layout, use)
    when types::AbiType::Array(_, _)
        give classify_aggregate(layout, use)

    # --------------------------------------------------------
    # Fallback
    # --------------------------------------------------------
    otherwise
        give RegClassResult {
            class: RegClass::MEMORY,
            size: layout.size,
            align: layout.align,
        }
    end
.end


# ============================================================
# Aggregate classification
# ============================================================

# Conservative aggregate classification:
# - Small aggregates may be register-passed (ABI-dependent)
# - Large aggregates always go to memory
#
# Fine-grained ABI rules (SysV classes, HFA/HVA, etc.)
# are implemented in calling/* and reuse this result.
proc classify_aggregate(
    layout: layout::TypeLayout,
    use: RegUse
)
gives RegClassResult
.end
    # Default conservative threshold
    if layout.size <= 8
        give RegClassResult {
            class: RegClass::GP,
            size: layout.size,
            align: layout.align,
        }
    end

    if layout.size <= 16
        give RegClassResult {
            class: RegClass::GP,
            size: layout.size,
            align: layout.align,
        }
    end

    give RegClassResult {
        class: RegClass::MEMORY,
        size: layout.size,
        align: layout.align,
    }
.end


# ============================================================
# Helpers
# ============================================================

proc gp(layout: layout::TypeLayout)
gives RegClassResult
.end
    give RegClassResult {
        class: RegClass::GP,
        size: layout.size,
        align: layout.align,
    }
.end
