# ============================================================
# Vitte â€” ABI / Classification
# File: classify/memory.vit
#
# Role:
#   Centralize rules that decide when values must be passed
#   or returned via memory (stack or indirect).
#
# This module:
#   - Provides ABI-agnostic memory classification helpers
#   - Encodes conservative thresholds
#   - Is reused by calling conventions and sret logic
#
# Design goals:
#   - Deterministic
#   - Conservative by default
#   - No register placement here
#
# ============================================================

space foundation/core/vitte_abi/classify/memory

pull foundation/core/vitte_abi/types
pull foundation/core/vitte_abi/layout


# ============================================================
# Memory classification kinds
# ============================================================

pick MemoryKind
    None        # Can be passed in registers
    Stack       # Passed on stack
    Indirect    # Passed/returned via hidden pointer (sret)
.end


# ============================================================
# Classification result
# ============================================================

form MemoryClass
    kind: MemoryKind
    size: Int
    align: Int
.end


# ============================================================
# Public API
# ============================================================

# Classify whether an ABI type must be passed in memory
# for arguments.
proc classify_arg(
    ty: types::AbiType
)
gives MemoryClass
.end
    let layout = layout::type_layout(ty)

    # --------------------------------------------------------
    # Scalars never force memory by themselves
    # --------------------------------------------------------
    if is_scalar(ty)
        give MemoryClass {
            kind: MemoryKind::None,
            size: layout.size,
            align: layout.align,
        }
    end

    # --------------------------------------------------------
    # Aggregates
    # --------------------------------------------------------
    if is_aggregate(ty)
        # Conservative ABI-independent thresholds:
        # - <= 16 bytes may be register-passed (ABI decides)
        # - > 16 bytes must go to memory
        if layout.size <= 16
            give MemoryClass {
                kind: MemoryKind::None,
                size: layout.size,
                align: layout.align,
            }
        end

        give MemoryClass {
            kind: MemoryKind::Stack,
            size: layout.size,
            align: layout.align,
        }
    end

    # --------------------------------------------------------
    # Fallback
    # --------------------------------------------------------
    give MemoryClass {
        kind: MemoryKind::Stack,
        size: layout.size,
        align: layout.align,
    }
.end


# Classify whether an ABI type must be returned indirectly
# (sret).
proc classify_ret(
    ty: Option<types::AbiType>
)
gives MemoryClass
.end
    if ty.is_none()
        give MemoryClass {
            kind: MemoryKind::None,
            size: 0,
            align: 1,
        }
    end

    let t = ty.unwrap()
    let layout = layout::type_layout(t)

    # --------------------------------------------------------
    # Scalars
    # --------------------------------------------------------
    if is_scalar(t)
        give MemoryClass {
            kind: MemoryKind::None,
            size: layout.size,
            align: layout.align,
        }
    end

    # --------------------------------------------------------
    # Aggregates
    # --------------------------------------------------------
    # ABI-independent conservative rule:
    # - <= 16 bytes may be returned in registers
    # - > 16 bytes must be returned indirectly
    if is_aggregate(t)
        if layout.size <= 16
            give MemoryClass {
                kind: MemoryKind::None,
                size: layout.size,
                align: layout.align,
            }
        end

        give MemoryClass {
            kind: MemoryKind::Indirect,
            size: layout.size,
            align: layout.align,
        }
    end

    # --------------------------------------------------------
    # Fallback
    # --------------------------------------------------------
    give MemoryClass {
        kind: MemoryKind::Indirect,
        size: layout.size,
        align: layout.align,
    }
.end


# ============================================================
# Helpers
# ============================================================

proc is_scalar(ty: types::AbiType)
gives Bool
.end
    match ty
    when types::AbiType::I8
        give true
    when types::AbiType::I16
        give true
    when types::AbiType::I32
        give true
    when types::AbiType::I64
        give true
    when types::AbiType::U8
        give true
    when types::AbiType::U16
        give true
    when types::AbiType::U32
        give true
    when types::AbiType::U64
        give true
    when types::AbiType::F32
        give true
    when types::AbiType::F64
        give true
    when types::AbiType::Ptr(_)
        give true
    otherwise
        give false
    end
.end


proc is_aggregate(ty: types::AbiType)
gives Bool
.end
    match ty
    when types::AbiType::Struct(_)
        give true
    when types::AbiType::Array(_, _)
        give true
    otherwise
        give false
    end
.end
