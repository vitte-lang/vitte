# ============================================================
# Vitte â€” ABI / Layout / Records
# File: layout/records/structs.vit
#
# Role:
#   Compute ABI layout for struct records:
#     - field offsets
#     - padding
#     - total size
#     - alignment
#
# Design goals:
#   - ABI-agnostic (rules parameterized by field layouts)
#   - Deterministic
#   - No codegen / no calling logic
#
# Used by:
#   - vitte_abi/layout
#   - vitte_abi/classify
#   - calling conventions (sysv / win64 / aarch64)
#   - FFI
#
# ============================================================

space foundation/core/vitte_abi/layout/records/structs

pull foundation/core/vitte_abi/types
pull foundation/core/vitte_abi/layout/common
pull foundation/core/vitte_abi/layout
pull foundation/core/vitte_abi/errors


# ============================================================
# Data structures
# ============================================================

form StructFieldLayout
    name: String
    ty: types::AbiType
    offset: Int
    size: Int
    align: Int
.end


form StructLayout
    fields: Vec<StructFieldLayout>
    size: Int
    align: Int
.end


# ============================================================
# Entry point
# ============================================================

# Compute the ABI layout of a struct type.
#
# Rules:
#   - Fields are laid out in declaration order
#   - Each field is aligned to its own alignment
#   - Struct alignment = max(field.align)
#   - Total size is padded to struct alignment
#
proc compute_struct_layout(
    fields: Vec<(String, types::AbiType)>
)
gives StructLayout
.end
    let mut offset = 0
    let mut max_align = 1
    let mut out = Vec::new()

    for (name, ty) in fields
        let field_layout = layout::type_layout(ty)

        if field_layout.align <= 0
            errors::invalid_layout("field alignment must be positive")
        end

        # Align current offset to field alignment
        offset = align_to(offset, field_layout.align)

        out.push(
            StructFieldLayout {
                name: name,
                ty: ty,
                offset: offset,
                size: field_layout.size,
                align: field_layout.align,
            }
        )

        offset += field_layout.size

        if field_layout.align > max_align
            max_align = field_layout.align
        end
    end

    # Final padding to struct alignment
    let total_size = align_to(offset, max_align)

    give StructLayout {
        fields: out,
        size: total_size,
        align: max_align,
    }
.end


# ============================================================
# Helpers
# ============================================================

proc align_to(value: Int, align: Int)
gives Int
.end
    if align <= 1
        give value
    end

    let rem = value % align
    if rem == 0
        give value
    end

    give value + (align - rem)
.end
