# ============================================================
# Vitte â€” ABI / Layout
# File: layout/types.vit
#
# Role:
#   Compute ABI layout (size + alignment) for all ABI types.
#
# This file:
#   - Is the single entry point for type layout
#   - Dispatches to records / vectors when needed
#   - Encodes scalar & pointer rules
#
# Used by:
#   - vitte_abi/classify
#   - vitte_abi/calling (args / ret)
#   - vitte_symbol_mangling (size-based decisions)
#   - FFI / codegen
#
# ============================================================

space foundation/core/vitte_abi/layout

pull foundation/core/vitte_abi/types
pull foundation/core/vitte_abi/layout/common
pull foundation/core/vitte_abi/layout/records
pull foundation/core/vitte_abi/layout/vectors
pull foundation/core/vitte_abi/errors


# ============================================================
# Core layout descriptor
# ============================================================

form TypeLayout
    size: Int
    align: Int
.end


# ============================================================
# Entry point
# ============================================================

# Compute ABI layout for a given ABI type.
#
# Invariants:
#   - size > 0 for non-void types
#   - align is a power-of-two >= 1
#   - Deterministic and ABI-agnostic
#
proc type_layout(
    ty: types::AbiType
)
gives TypeLayout
.end
    match ty

    # --------------------------------------------------------
    # Void (should rarely reach here)
    # --------------------------------------------------------
    when types::AbiType::Void
        give TypeLayout { size: 0, align: 1 }

    # --------------------------------------------------------
    # Integer scalars
    # --------------------------------------------------------
    when types::AbiType::I8
        give scalar(1)
    when types::AbiType::U8
        give scalar(1)

    when types::AbiType::I16
        give scalar(2)
    when types::AbiType::U16
        give scalar(2)

    when types::AbiType::I32
        give scalar(4)
    when types::AbiType::U32
        give scalar(4)

    when types::AbiType::I64
        give scalar(8)
    when types::AbiType::U64
        give scalar(8)

    # --------------------------------------------------------
    # Floating-point scalars
    # --------------------------------------------------------
    when types::AbiType::F32
        give scalar(4)
    when types::AbiType::F64
        give scalar(8)

    # --------------------------------------------------------
    # Pointer
    # --------------------------------------------------------
    when types::AbiType::Ptr(_)
        # Pointer size/alignment is ABI-defined.
        # At this level we assume 64-bit targets.
        give TypeLayout {
            size: 8,
            align: 8,
        }

    # --------------------------------------------------------
    # SIMD / vector types
    # --------------------------------------------------------
    when types::AbiType::Vector(elem_ty, lanes)
        let v = vectors::simd::compute_simd_layout(elem_ty, lanes)
        give TypeLayout {
            size: v.size,
            align: v.align,
        }

    # --------------------------------------------------------
    # Struct records
    # --------------------------------------------------------
    when types::AbiType::Struct(fields)
        let s = records::structs::compute_struct_layout(fields)
        give TypeLayout {
            size: s.size,
            align: s.align,
        }

    # --------------------------------------------------------
    # Union records
    # --------------------------------------------------------
    when types::AbiType::Union(fields)
        let u = records::unions::compute_union_layout(fields)
        give TypeLayout {
            size: u.size,
            align: u.align,
        }

    # --------------------------------------------------------
    # Arrays
    # --------------------------------------------------------
    when types::AbiType::Array(elem_ty, count)
        if count <= 0
            errors::invalid_layout("array element count must be positive")
        end

        let elem = type_layout(elem_ty)

        let size = elem.size * count
        let align = elem.align

        give TypeLayout {
            size: size,
            align: align,
        }

    # --------------------------------------------------------
    # Fallback
    # --------------------------------------------------------
    otherwise
        errors::invalid_layout("unsupported ABI type in layout")
    end
.end


# ============================================================
# Helpers
# ============================================================

proc scalar(size: Int)
gives TypeLayout
.end
    if size <= 0
        errors::invalid_layout("scalar size must be positive")
    end

    give TypeLayout {
        size: size,
        align: size,
    }
.end
