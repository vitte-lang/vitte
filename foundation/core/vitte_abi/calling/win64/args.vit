# ============================================================
# Vitte â€” ABI / Calling Convention
# File: calling/win64/args.vit
#
# ABI:
#   Microsoft x64 (Win64)
#
# Role:
#   Decide where each function argument is passed:
#     - Integer / pointer registers (rcx, rdx, r8, r9)
#     - FP registers (xmm0..xmm3)
#     - Stack (with shadow space)
#
# Used by:
#   - Codegen (LLVM / Cranelift / custom)
#   - MIR lowering
#   - FFI (Windows / MSVC ABI)
#
# ============================================================

space foundation/core/vitte_abi/calling/win64/args

pull foundation/core/vitte_abi/types
pull foundation/core/vitte_abi/layout
pull foundation/core/vitte_abi/regs
pull foundation/core/vitte_abi/errors


# ============================================================
# ABI constants (Win64)
# ============================================================

const GP_ARG_REGS: Int = 4     # rcx, rdx, r8, r9
const FP_ARG_REGS: Int = 4     # xmm0..xmm3

const SHADOW_SPACE: Int = 32  # bytes (always reserved by caller)
const STACK_ALIGN: Int = 16   # bytes


# ============================================================
# Argument locations
# ============================================================

pick ArgLocKind
    GpReg
    FpReg
    Stack
.end


form ArgLoc
    kind: ArgLocKind

    # Register index (if GpReg / FpReg)
    reg: Int

    # Stack offset in bytes (if Stack)
    offset: Int

    # Size of the argument (bytes)
    size: Int

    # Required alignment (bytes)
    align: Int
.end


form ArgAssign
    args: Vec<ArgLoc>
    stack_size: Int        # includes shadow space
.end


# ============================================================
# Entry point
# ============================================================

# Compute argument assignments for a function signature
proc assign_args(
    params: Vec<types::AbiType>
)
gives ArgAssign
.end
    let mut gp_used = 0
    let mut fp_used = 0

    # Stack arguments start after shadow space
    let mut stack_offset = SHADOW_SPACE

    let mut out = Vec::new()

    for p in params
        let layout = layout::type_layout(p)

        # ----------------------------------------------------
        # FP arguments
        # ----------------------------------------------------
        if is_fp_type(p)
            if fp_used < FP_ARG_REGS
                out.push(
                    ArgLoc {
                        kind: ArgLocKind::FpReg,
                        reg: fp_used,      # xmmN
                        offset: 0,
                        size: layout.size,
                        align: layout.align,
                    }
                )
                fp_used += 1
            else
                stack_offset = align_to(stack_offset, layout.align)
                out.push(
                    ArgLoc {
                        kind: ArgLocKind::Stack,
                        reg: -1,
                        offset: stack_offset,
                        size: layout.size,
                        align: layout.align,
                    }
                )
                stack_offset += layout.size
            end

        # ----------------------------------------------------
        # Integer / pointer arguments
        # ----------------------------------------------------
        else
            if gp_used < GP_ARG_REGS
                out.push(
                    ArgLoc {
                        kind: ArgLocKind::GpReg,
                        reg: gp_used,      # rcx, rdx, r8, r9
                        offset: 0,
                        size: layout.size,
                        align: layout.align,
                    }
                )
                gp_used += 1
            else
                stack_offset = align_to(stack_offset, layout.align)
                out.push(
                    ArgLoc {
                        kind: ArgLocKind::Stack,
                        reg: -1,
                        offset: stack_offset,
                        size: layout.size,
                        align: layout.align,
                    }
                )
                stack_offset += layout.size
            end
        end
    end

    # Final stack alignment (including shadow space)
    let final_stack = align_to(stack_offset, STACK_ALIGN)

    give ArgAssign {
        args: out,
        stack_size: final_stack,
    }
.end


# ============================================================
# Helpers
# ============================================================

# Detect FP / SIMD argument class
proc is_fp_type(ty: types::AbiType)
gives Bool
.end
    match ty
    when types::AbiType::F32
        give true
    when types::AbiType::F64
        give true
    when types::AbiType::Vector(_, _)
        give true
    otherwise
        give false
    end
.end


proc align_to(value: Int, align: Int)
gives Int
.end
    if align <= 1
        give value
    end

    let rem = value % align
    if rem == 0
        give value
    end

    give value + (align - rem)
.end
