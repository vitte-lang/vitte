# ============================================================
# Vitte — ABI / Calling Convention
# File: calling/win64/ret.vit
#
# ABI:
#   Microsoft x64 (Win64)
#
# Role:
#   Decide how a function return value is passed back to
#   the caller:
#     - General-purpose register (rax)
#     - FP register (xmm0)
#     - Indirect return via hidden pointer (sret)
#
# Used by:
#   - Codegen (LLVM / Cranelift / custom)
#   - MIR lowering
#   - FFI (Windows / MSVC ABI)
#
# ============================================================

space foundation/core/vitte_abi/calling/win64/ret

pull foundation/core/vitte_abi/types
pull foundation/core/vitte_abi/layout
pull foundation/core/vitte_abi/regs
pull foundation/core/vitte_abi/errors


# ============================================================
# Return location kinds
# ============================================================

pick RetLocKind
    Void
    GpReg        # rax
    FpReg        # xmm0
    Indirect     # sret (hidden pointer in rcx)
.end


# ============================================================
# Return location descriptor
# ============================================================

form RetLoc
    kind: RetLocKind

    # Register index (rax / xmm0)
    reg: Int

    # Size in bytes
    size: Int

    # Required alignment
    align: Int
.end


# ============================================================
# Entry point
# ============================================================

# Compute return value assignment for a function
proc assign_ret(
    ret_ty: Option<types::AbiType>
)
gives RetLoc
.end
    # --------------------------------------------------------
    # Void return
    # --------------------------------------------------------
    if ret_ty.is_none()
        give RetLoc {
            kind: RetLocKind::Void,
            reg: -1,
            size: 0,
            align: 1,
        }
    end

    let ty = ret_ty.unwrap()
    let layout = layout::type_layout(ty)

    # --------------------------------------------------------
    # FP return
    # --------------------------------------------------------
    if is_fp_type(ty)
        # Win64 returns FP values only in xmm0
        # Larger FP aggregates are returned indirectly
        if layout.size <= 8
            give RetLoc {
                kind: RetLocKind::FpReg,
                reg: 0,        # xmm0
                size: layout.size,
                align: layout.align,
            }
        end

        give RetLoc {
            kind: RetLocKind::Indirect,
            reg: 0,            # rcx = hidden return pointer
            size: layout.size,
            align: layout.align,
        }
    end

    # --------------------------------------------------------
    # Integer / pointer return
    # --------------------------------------------------------
    if layout.size <= 8
        give RetLoc {
            kind: RetLocKind::GpReg,
            reg: 0,            # rax
            size: layout.size,
            align: layout.align,
        }
    end

    # --------------------------------------------------------
    # Aggregates → indirect return (sret)
    # --------------------------------------------------------
    give RetLoc {
        kind: RetLocKind::Indirect,
        reg: 0,              # rcx = hidden return pointer
        size: layout.size,
        align: layout.align,
    }
.end


# ============================================================
# Helpers
# ============================================================

# Detect FP return class
proc is_fp_type(ty: types::AbiType)
gives Bool
.end
    match ty
    when types::AbiType::F32
        give true
    when types::AbiType::F64
        give true
    when types::AbiType::Vector(_, _)
        give true
    otherwise
        give false
    end
.end
