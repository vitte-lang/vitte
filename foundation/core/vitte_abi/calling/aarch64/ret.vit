# ============================================================
# Vitte — ABI / Calling Convention
# File: calling/aarch64/ret.vit
#
# ABI:
#   AAPCS64 (Procedure Call Standard for the Arm 64-bit Architecture)
#
# Role:
#   Decide how a function return value is passed back to the caller:
#     - General-purpose registers (x0, x1)
#     - FP/SIMD registers (v0, v1)
#     - Indirect return via hidden pointer (sret)
#
# Used by:
#   - Codegen (LLVM / Cranelift / custom)
#   - MIR lowering
#   - FFI (C / system)
#
# ============================================================

space foundation/core/vitte_abi/calling/aarch64/ret

pull foundation/core/vitte_abi/types
pull foundation/core/vitte_abi/layout
pull foundation/core/vitte_abi/regs
pull foundation/core/vitte_abi/errors


# ============================================================
# Return location kinds
# ============================================================

pick RetLocKind
    Void
    GpReg
    FpReg
    GpRegPair
    FpRegPair
    Indirect     # sret (hidden pointer)
.end


# ============================================================
# Return location descriptor
# ============================================================

form RetLoc
    kind: RetLocKind

    # Primary register index (x0 / v0)
    reg0: Int

    # Secondary register index (x1 / v1), if applicable
    reg1: Int

    # Size in bytes
    size: Int

    # Required alignment
    align: Int
.end


# ============================================================
# Entry point
# ============================================================

# Compute return value assignment for a function
proc assign_ret(
    ret_ty: Option<types::AbiType>
)
gives RetLoc
.end
    # --------------------------------------------------------
    # Void return
    # --------------------------------------------------------
    if ret_ty.is_none()
        give RetLoc {
            kind: RetLocKind::Void,
            reg0: -1,
            reg1: -1,
            size: 0,
            align: 1,
        }
    end

    let ty = ret_ty.unwrap()
    let layout = layout::type_layout(ty)

    # --------------------------------------------------------
    # FP / SIMD returns
    # --------------------------------------------------------
    if is_fp_type(ty)
        if layout.size <= 8
            give RetLoc {
                kind: RetLocKind::FpReg,
                reg0: 0,     # v0
                reg1: -1,
                size: layout.size,
                align: layout.align,
            }
        else if layout.size <= 16
            give RetLoc {
                kind: RetLocKind::FpRegPair,
                reg0: 0,     # v0
                reg1: 1,     # v1
                size: layout.size,
                align: layout.align,
            }
        else
            # Large SIMD aggregates returned indirectly
            give RetLoc {
                kind: RetLocKind::Indirect,
                reg0: 0,     # x0 holds sret pointer
                reg1: -1,
                size: layout.size,
                align: layout.align,
            }
        end
    end

    # --------------------------------------------------------
    # Integer / pointer / small aggregate returns
    # --------------------------------------------------------
    if layout.size <= 8
        give RetLoc {
            kind: RetLocKind::GpReg,
            reg0: 0,     # x0
            reg1: -1,
            size: layout.size,
            align: layout.align,
        }
    end

    if layout.size <= 16
        give RetLoc {
            kind: RetLocKind::GpRegPair,
            reg0: 0,     # x0
            reg1: 1,     # x1
            size: layout.size,
            align: layout.align,
        }
    end

    # --------------------------------------------------------
    # Large aggregates → indirect return (sret)
    # --------------------------------------------------------
    give RetLoc {
        kind: RetLocKind::Indirect,
        reg0: 0,         # x0 = hidden return pointer
        reg1: -1,
        size: layout.size,
        align: layout.align,
    }
.end


# ============================================================
# Helpers
# ============================================================

# Detect FP / SIMD return class
proc is_fp_type(ty: types::AbiType)
gives Bool
.end
    match ty
    when types::AbiType::F32
        give true
    when types::AbiType::F64
        give true
    when types::AbiType::Vector(_, _)
        give true
    otherwise
        give false
    end
.end
