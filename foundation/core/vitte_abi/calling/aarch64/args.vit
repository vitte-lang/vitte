# ============================================================
# Vitte â€” ABI / Calling Convention
# File: calling/aarch64/args.vit
#
# ABI:
#   AAPCS64 (Procedure Call Standard for the Arm 64-bit Architecture)
#
# Role:
#   Decide where each function argument is passed:
#     - General-purpose registers (x0..x7)
#     - FP/SIMD registers (v0..v7)
#     - Stack (with proper alignment)
#
# Used by:
#   - Codegen (LLVM / Cranelift / custom)
#   - MIR lowering
#   - FFI (C / system)
#
# ============================================================

space foundation/core/vitte_abi/calling/aarch64/args

pull foundation/core/vitte_abi/types
pull foundation/core/vitte_abi/layout
pull foundation/core/vitte_abi/regs
pull foundation/core/vitte_abi/errors


# ============================================================
# ABI constants (AAPCS64)
# ============================================================

const GP_ARG_REGS: Int = 8    # x0..x7
const FP_ARG_REGS: Int = 8    # v0..v7

const STACK_ALIGN: Int = 16  # bytes


# ============================================================
# Argument locations
# ============================================================

pick ArgLocKind
    GpReg
    FpReg
    Stack
.end


form ArgLoc
    kind: ArgLocKind

    # Register index (if GpReg / FpReg)
    reg: Int

    # Stack offset in bytes (if Stack)
    offset: Int

    # Size of the argument (bytes)
    size: Int

    # Required alignment (bytes)
    align: Int
.end


form ArgAssign
    args: Vec<ArgLoc>
    stack_size: Int
.end


# ============================================================
# Entry point
# ============================================================

# Compute argument assignments for a function signature
proc assign_args(
    params: Vec<types::AbiType>
)
gives ArgAssign
.end
    let mut gp_used = 0
    let mut fp_used = 0
    let mut stack_offset = 0

    let mut out = Vec::new()

    for p in params
        let layout = layout::type_layout(p)

        # Decide class
        if is_fp_type(p)
            # -------------------------------
            # FP / SIMD argument
            # -------------------------------
            if fp_used < FP_ARG_REGS
                out.push(
                    ArgLoc {
                        kind: ArgLocKind::FpReg,
                        reg: fp_used,
                        offset: 0,
                        size: layout.size,
                        align: layout.align,
                    }
                )
                fp_used += 1
            else
                # Spill to stack
                stack_offset = align_to(stack_offset, layout.align)
                out.push(
                    ArgLoc {
                        kind: ArgLocKind::Stack,
                        reg: -1,
                        offset: stack_offset,
                        size: layout.size,
                        align: layout.align,
                    }
                )
                stack_offset += layout.size
            end

        else
            # -------------------------------
            # Integer / pointer argument
            # -------------------------------
            if gp_used < GP_ARG_REGS
                out.push(
                    ArgLoc {
                        kind: ArgLocKind::GpReg,
                        reg: gp_used,
                        offset: 0,
                        size: layout.size,
                        align: layout.align,
                    }
                )
                gp_used += 1
            else
                # Spill to stack
                stack_offset = align_to(stack_offset, layout.align)
                out.push(
                    ArgLoc {
                        kind: ArgLocKind::Stack,
                        reg: -1,
                        offset: stack_offset,
                        size: layout.size,
                        align: layout.align,
                    }
                )
                stack_offset += layout.size
            end
        end
    end

    # Final stack alignment
    let final_stack = align_to(stack_offset, STACK_ALIGN)

    give ArgAssign {
        args: out,
        stack_size: final_stack,
    }
.end


# ============================================================
# Helpers
# ============================================================

# Detect FP / SIMD argument class
proc is_fp_type(ty: types::AbiType)
gives Bool
.end
    match ty
    when types::AbiType::F32
        give true
    when types::AbiType::F64
        give true
    when types::AbiType::Vector(_, _)
        give true
    otherwise
        give false
    end
.end


proc align_to(value: Int, align: Int)
gives Int
.end
    if align <= 1
        give value
    end

    let rem = value % align
    if rem == 0
        give value
    end

    give value + (align - rem)
.end
