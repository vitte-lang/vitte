# ============================================================
# Vitte â€” ABI / Calling Convention
# File: calling/sysv/args.vit
#
# ABI:
#   System V AMD64 ABI
#
# Role:
#   Decide where each function argument is passed:
#     - Integer registers (rdi, rsi, rdx, rcx, r8, r9)
#     - SSE registers (xmm0..xmm7)
#     - Stack (with proper alignment)
#
# Used by:
#   - Codegen (LLVM / Cranelift / custom)
#   - MIR lowering
#   - FFI (C / system)
#
# ============================================================

space foundation/core/vitte_abi/calling/sysv/args

pull foundation/core/vitte_abi/types
pull foundation/core/vitte_abi/layout
pull foundation/core/vitte_abi/regs
pull foundation/core/vitte_abi/errors


# ============================================================
# ABI constants (System V AMD64)
# ============================================================

const GP_ARG_REGS: Int = 6     # rdi, rsi, rdx, rcx, r8, r9
const FP_ARG_REGS: Int = 8     # xmm0..xmm7

const STACK_ALIGN: Int = 16   # bytes


# ============================================================
# Argument locations
# ============================================================

pick ArgLocKind
    GpReg
    FpReg
    Stack
.end


form ArgLoc
    kind: ArgLocKind

    # Register index (if GpReg / FpReg)
    reg: Int

    # Stack offset in bytes (if Stack)
    offset: Int

    # Size of the argument (bytes)
    size: Int

    # Required alignment (bytes)
    align: Int
.end


form ArgAssign
    args: Vec<ArgLoc>
    stack_size: Int
.end


# ============================================================
# Entry point
# ============================================================

# Compute argument assignments for a function signature
proc assign_args(
    params: Vec<types::AbiType>
)
gives ArgAssign
.end
    let mut gp_used = 0
    let mut fp_used = 0
    let mut stack_offset = 0

    let mut out = Vec::new()

    for p in params
        let layout = layout::type_layout(p)

        # ----------------------------------------------------
        # FP / SSE arguments
        # ----------------------------------------------------
        if is_fp_type(p)
            if fp_used < FP_ARG_REGS
                out.push(
                    ArgLoc {
                        kind: ArgLocKind::FpReg,
                        reg: fp_used,      # xmmN
                        offset: 0,
                        size: layout.size,
                        align: layout.align,
                    }
                )
                fp_used += 1
            else
                # Spill to stack
                stack_offset = align_to(stack_offset, layout.align)
                out.push(
                    ArgLoc {
                        kind: ArgLocKind::Stack,
                        reg: -1,
                        offset: stack_offset,
                        size: layout.size,
                        align: layout.align,
                    }
                )
                stack_offset += layout.size
            end

        # ----------------------------------------------------
        # Integer / pointer arguments
        # ----------------------------------------------------
        else
            if gp_used < GP_ARG_REGS
                out.push(
                    ArgLoc {
                        kind: ArgLocKind::GpReg,
                        reg: gp_used,      # rdi..r9
                        offset: 0,
                        size: layout.size,
                        align: layout.align,
                    }
                )
                gp_used += 1
            else
                # Spill to stack
                stack_offset = align_to(stack_offset, layout.align)
                out.push(
                    ArgLoc {
                        kind: ArgLocKind::Stack,
                        reg: -1,
                        offset: stack_offset,
                        size: layout.size,
                        align: layout.align,
                    }
                )
                stack_offset += layout.size
            end
        end
    end

    # Final stack alignment
    let final_stack = align_to(stack_offset, STACK_ALIGN)

    give ArgAssign {
        args: out,
        stack_size: final_stack,
    }
.end


# ============================================================
# Helpers
# ============================================================

# Detect FP / SSE argument class
proc is_fp_type(ty: types::AbiType)
gives Bool
.end
    match ty
    when types::AbiType::F32
        give true
    when types::AbiType::F64
        give true
    when types::AbiType::Vector(_, _)
        give true
    otherwise
        give false
    end
.end


proc align_to(value: Int, align: Int)
gives Int
.end
    if align <= 1
        give value
    end

    let rem = value % align
    if rem == 0
        give value
    end

    give value + (align - rem)
.end
