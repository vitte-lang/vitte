# ============================================================
# Vitte — ABI / Calling Convention
# File: calling/sysv/ret.vit
#
# ABI:
#   System V AMD64 ABI
#
# Role:
#   Decide how a function return value is passed back to
#   the caller:
#     - General-purpose registers (rax, rdx)
#     - SSE registers (xmm0, xmm1)
#     - Indirect return via hidden pointer (sret)
#
# Used by:
#   - Codegen (LLVM / Cranelift / custom)
#   - MIR lowering
#   - FFI (C / system)
#
# ============================================================

space foundation/core/vitte_abi/calling/sysv/ret

pull foundation/core/vitte_abi/types
pull foundation/core/vitte_abi/layout
pull foundation/core/vitte_abi/regs
pull foundation/core/vitte_abi/errors


# ============================================================
# Return location kinds
# ============================================================

pick RetLocKind
    Void
    GpReg          # rax
    GpRegPair      # rax, rdx
    FpReg          # xmm0
    FpRegPair      # xmm0, xmm1
    Indirect       # sret (hidden pointer in rdi)
.end


# ============================================================
# Return location descriptor
# ============================================================

form RetLoc
    kind: RetLocKind

    # Primary register index
    reg0: Int

    # Secondary register index (if applicable)
    reg1: Int

    # Size in bytes
    size: Int

    # Required alignment
    align: Int
.end


# ============================================================
# Entry point
# ============================================================

# Compute return value assignment for a function
proc assign_ret(
    ret_ty: Option<types::AbiType>
)
gives RetLoc
.end
    # --------------------------------------------------------
    # Void return
    # --------------------------------------------------------
    if ret_ty.is_none()
        give RetLoc {
            kind: RetLocKind::Void,
            reg0: -1,
            reg1: -1,
            size: 0,
            align: 1,
        }
    end

    let ty = ret_ty.unwrap()
    let layout = layout::type_layout(ty)

    # --------------------------------------------------------
    # FP / SSE returns
    # --------------------------------------------------------
    if is_fp_type(ty)
        if layout.size <= 8
            give RetLoc {
                kind: RetLocKind::FpReg,
                reg0: 0,      # xmm0
                reg1: -1,
                size: layout.size,
                align: layout.align,
            }
        else if layout.size <= 16
            give RetLoc {
                kind: RetLocKind::FpRegPair,
                reg0: 0,      # xmm0
                reg1: 1,      # xmm1
                size: layout.size,
                align: layout.align,
            }
        else
            # Large FP aggregates returned indirectly
            give RetLoc {
                kind: RetLocKind::Indirect,
                reg0: 0,      # rdi holds sret pointer
                reg1: -1,
                size: layout.size,
                align: layout.align,
            }
        end
    end

    # --------------------------------------------------------
    # Integer / pointer / small aggregate returns
    # --------------------------------------------------------
    if layout.size <= 8
        give RetLoc {
            kind: RetLocKind::GpReg,
            reg0: 0,      # rax
            reg1: -1,
            size: layout.size,
            align: layout.align,
        }
    end

    if layout.size <= 16
        give RetLoc {
            kind: RetLocKind::GpRegPair,
            reg0: 0,      # rax
            reg1: 1,      # rdx
            size: layout.size,
            align: layout.align,
        }
    end

    # --------------------------------------------------------
    # Large aggregates → indirect return (sret)
    # --------------------------------------------------------
    give RetLoc {
        kind: RetLocKind::Indirect,
        reg0: 0,          # rdi = hidden return pointer
        reg1: -1,
        size: layout.size,
        align: layout.align,
    }
.end


# ============================================================
# Helpers
# ============================================================

# Detect FP / SSE return class
proc is_fp_type(ty: types::AbiType)
gives Bool
.end
    match ty
    when types::AbiType::F32
        give true
    when types::AbiType::F64
        give true
    when types::AbiType::Vector(_, _)
        give true
    otherwise
        give false
    end
.end
