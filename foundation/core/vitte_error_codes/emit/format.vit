# ============================================================
# vitte_error_codes :: emit :: format
# Diagnostic formatting utilities
# ============================================================

space vitte/error_codes/emit

pull vitte/error_codes/categories
pull vitte/driver/diagnostics
pull vitte/driver/context

# ------------------------------------------------------------
# Output formats
# ------------------------------------------------------------

pick DiagnosticFormat
    Plain       # human-readable, single-line
    Compact     # minimal, CI-friendly
    Rich        # multi-line with context
.end

# ------------------------------------------------------------
# Formatting options
# ------------------------------------------------------------

form FormatOptions
    format: DiagnosticFormat
    show_code: Bool
    show_category: Bool
    show_severity: Bool
    show_span: Bool
    color: Bool
.end

proc FormatOptions::plain()
    gives FormatOptions

    give FormatOptions {
        format: Plain,
        show_code: true,
        show_category: false,
        show_severity: true,
        show_span: false,
        color: false,
    }
.end

proc FormatOptions::compact()
    gives FormatOptions

    give FormatOptions {
        format: Compact,
        show_code: true,
        show_category: false,
        show_severity: false,
        show_span: false,
        color: false,
    }
.end

proc FormatOptions::rich()
    gives FormatOptions

    give FormatOptions {
        format: Rich,
        show_code: true,
        show_category: true,
        show_severity: true,
        show_span: true,
        color: true,
    }
.end

# ------------------------------------------------------------
# Entry points
# ------------------------------------------------------------

proc format_diagnostic(
    diag: &Diagnostic,
    ctx: &DriverContext,
    opts: &FormatOptions
)
    gives String

    match opts.format
        Plain   => format_plain(diag, ctx, opts)
        Compact => format_compact(diag, ctx, opts)
        Rich    => format_rich(diag, ctx, opts)
    .end
.end

proc format_diagnostics(
    diags: &DiagnosticContext,
    ctx: &DriverContext,
    opts: &FormatOptions
)
    gives String

    let mut out = ""

    for d in diags.all()
        out = out + format_diagnostic(d, ctx, opts) + "\n"
    .end

    give out
.end

# ------------------------------------------------------------
# Plain format
# ------------------------------------------------------------

proc format_plain(
    diag: &Diagnostic,
    ctx: &DriverContext,
    opts: &FormatOptions
)
    gives String

    let mut s = ""

    if opts.show_severity
        s = s + severity_prefix(diag.severity())
    .end

    if opts.show_code && diag.code().is_some()
        s = s + "[" + diag.code().unwrap() + "] "
    .end

    s = s + diag.message()

    if opts.show_span && diag.span().is_some()
        s = s + " (" + format_span(diag.span().unwrap(), ctx) + ")"
    .end

    give s
.end

# ------------------------------------------------------------
# Compact format (CI)
# ------------------------------------------------------------

proc format_compact(
    diag: &Diagnostic,
    ctx: &DriverContext,
    opts: &FormatOptions
)
    gives String

    let mut s = ""

    if diag.code().is_some()
        s = s + diag.code().unwrap() + ":"
    .end

    s = s + diag.message()

    give s
.end

# ------------------------------------------------------------
# Rich format
# ------------------------------------------------------------

proc format_rich(
    diag: &Diagnostic,
    ctx: &DriverContext,
    opts: &FormatOptions
)
    gives String

    let mut s = ""

    # Header
    s = s + format_rich_header(diag, opts) + "\n"

    # Message
    s = s + "  " + diag.message() + "\n"

    # Span
    if opts.show_span && diag.span().is_some()
        s = s + format_rich_span(diag.span().unwrap(), ctx)
    .end

    give s
.end

proc format_rich_header(
    diag: &Diagnostic,
    opts: &FormatOptions
)
    gives String

    let mut h = ""

    if opts.show_severity
        h = h + color_severity(diag.severity(), opts.color) + " "
    .end

    if opts.show_code && diag.code().is_some()
        h = h + "[" + diag.code().unwrap() + "] "
    .end

    if opts.show_category && diag.category().is_some()
        h = h + "<" + diag.category().unwrap() + "> "
    .end

    give h
.end

proc format_rich_span(span: Span, ctx: &DriverContext)
    gives String

    let loc = ctx.session.location_of(span)

    let mut s = ""
    s = s + "  --> " + loc.file + ":" + loc.line.to_string() + ":" + loc.column.to_string() + "\n"

    # Source excerpt (best-effort)
    let line = ctx.session.read_line(loc.file, loc.line)

    if line.is_some()
        s = s + "  | " + line.unwrap() + "\n"
        s = s + "  | " + caret_line(loc.column) + "\n"
    .end

    give s
.end

# ------------------------------------------------------------
# Helpers
# ------------------------------------------------------------

proc severity_prefix(sev: DiagnosticSeverity)
    gives String

    match sev
        Error   => "error: "
        Warning => "warning: "
        Note    => "note: "
        Help    => "help: "
    .end
.end

proc color_severity(sev: DiagnosticSeverity, color: Bool)
    gives String

    let label =
        match sev
            Error   => "error"
            Warning => "warning"
            Note    => "note"
            Help    => "help"
        .end

    if !color
        give label
    .end

    match sev
        Error   => "\x1b[31m" + label + "\x1b[0m"
        Warning => "\x1b[33m" + label + "\x1b[0m"
        Note    => "\x1b[34m" + label + "\x1b[0m"
        Help    => "\x1b[32m" + label + "\x1b[0m"
    .end
.end

proc format_span(span: Span, ctx: &DriverContext)
    gives String

    let loc = ctx.session.location_of(span)
    give loc.file + ":" + loc.line.to_string() + ":" + loc.column.to_string()
.end

proc caret_line(column: UInt)
    gives String

    let mut s = ""
    let mut i: UInt = 1

    while i < column
        s = s + " "
        i = i + 1
    .end

    s = s + "^"
    give s
.end

# ------------------------------------------------------------
# Notes
# ------------------------------------------------------------
#
# - This module performs PURE formatting.
# - No printing, no IO, no global state.
#
# - Output styles:
#     * Plain   -> default CLI
#     * Compact -> CI / tools
#     * Rich    -> interactive terminals
#
# - Deterministic output for tests.
#
# - Color is optional and controlled by options.
#
