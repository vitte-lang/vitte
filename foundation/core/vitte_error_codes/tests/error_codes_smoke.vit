# ============================================================
# vitte_error_codes :: tests :: error_codes_smoke
# Global smoke tests for error codes system
# ============================================================

space vitte/error_codes/tests

pull vitte/error_codes/categories
pull vitte/error_codes/registry
pull vitte/driver/diagnostics

# ------------------------------------------------------------
# Helpers
# ------------------------------------------------------------

proc assert(cond: Bool, msg: String)
    if !cond
        panic(msg)
    .end
.end

proc assert_non_empty(s: String, msg: String)
    assert(!s.is_empty(), msg)
.end

# ------------------------------------------------------------
# Category tests
# ------------------------------------------------------------

proc test_lex_codes()
    let code = lex_error_code(LexErrorCode::InvalidUtf8)
    assert_non_empty(code, "lex error code empty")
    assert(error_category(code) == "lex", "lex category mismatch")
.end

proc test_parse_codes()
    let code = parse_error_code(ParseErrorCode::UnexpectedToken)
    assert_non_empty(code, "parse error code empty")
    assert(error_category(code) == "parse", "parse category mismatch")
.end

proc test_type_codes()
    let code = type_error_code(TypeErrorCode::TypeMismatch)
    assert_non_empty(code, "type error code empty")
    assert(error_category(code) == "type", "type category mismatch")
.end

proc test_mir_codes()
    let code = mir_error_code(MirErrorCode::BuildFailed)
    assert_non_empty(code, "mir error code empty")
    assert(error_category(code) == "mir", "mir category mismatch")
.end

proc test_ssa_codes()
    let code = ssa_error_code(SsaErrorCode::ConstructionFailed)
    assert_non_empty(code, "ssa error code empty")
    assert(error_category(code) == "ssa", "ssa category mismatch")
.end

proc test_codegen_codes()
    let code = codegen_error_code(CodegenError::EmitFailed)
    assert_non_empty(code, "codegen error code empty")
    assert(error_category(code) == "codegen", "codegen category mismatch")
.end

proc test_driver_codes()
    let code = driver_error_code(DriverErrorCode::PipelineFailed)
    assert_non_empty(code, "driver error code empty")
    assert(error_category(code) == "driver", "driver category mismatch")
.end

# ------------------------------------------------------------
# Registry tests
# ------------------------------------------------------------

proc test_registry_lookup()
    let code = "TY001"
    let entry = lookup_error(code)

    assert(entry.is_some(), "registry lookup failed")
    assert(entry.unwrap().category == "type", "registry category incorrect")
    assert(entry.unwrap().severity == Error, "registry severity incorrect")
.end

proc test_unknown_code_defaults()
    let sev = error_severity("ZZ999")
    let cat = error_category("ZZ999")

    assert(sev == Error, "unknown code severity must be Error")
    assert(cat == "internal", "unknown code category must be internal")
.end

# ------------------------------------------------------------
# Entry point
# ------------------------------------------------------------

proc main()
    test_lex_codes()
    test_parse_codes()
    test_type_codes()
    test_mir_codes()
    test_ssa_codes()
    test_codegen_codes()
    test_driver_codes()

    test_registry_lookup()
    test_unknown_code_defaults()

    ret 0
.end

# ------------------------------------------------------------
# Notes
# ------------------------------------------------------------
#
# - This is a SMOKE test:
#     * fast
#     * deterministic
#     * zero IO
#
# - It validates:
#     * category helpers
#     * registry consistency
#     * default behavior for unknown codes
#
# - Any failure here indicates a structural regression.
#
