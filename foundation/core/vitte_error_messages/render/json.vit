# ============================================================
# vitte_error_messages :: render :: json
# ------------------------------------------------------------
# Rendu JSON des messages d’erreur.
# - Stable (clés fixes)
# - Sans formatage terminal
# - Adapté CLI / LSP / tooling
# ============================================================

space vitte_error_messages/render/json

pull vitte_error_codes/context
pull vitte_error_messages/locales
pull vitte_error_messages/links

# ------------------------------------------------------------
# Helpers JSON (simples, sans dépendance)
# ------------------------------------------------------------

proc escape_json(s : string) gives string
  let mut out = ""
  for ch in s.chars()
    if ch == '"'
      out = out + "\\\""
    elif ch == '\\'
      out = out + "\\\\"
    elif ch == '\n'
      out = out + "\\n"
    elif ch == '\r'
      out = out + "\\r"
    elif ch == '\t'
      out = out + "\\t"
    else
      out = out + ch.to_string()
    end
  end
  give out
.end

proc json_kv(key : string, value : string) gives string
  give "\"" + escape_json(key) + "\":\"" + escape_json(value) + "\""
.end

# ------------------------------------------------------------
# Rendu principal
# ------------------------------------------------------------

proc render(ctx : context/ErrorContext) gives string
  # Message localisé (fallback implicite)
  let mut message = ctx.message
  let loc_msg = locales.find(ctx.code)
  if loc_msg.is_some()
    message = loc_msg.unwrap().text
  end

  # Lien de documentation (optionnel)
  let mut doc_url = ""
  let link = links.find_by_code(ctx.code)
  if link.is_some()
    doc_url = link.unwrap().url
  end

  let mut out = "{"

  # Champs principaux
  out = out + json_kv("code", ctx.code) + ","
  out = out + json_kv("phase", ctx.phase.to_string()) + ","
  out = out + json_kv("message", message)

  # Localisation
  if ctx.span.is_some()
    let s = ctx.span.unwrap()
    out = out + ",\"location\":{"
    out = out + json_kv("file", s.file) + ","
    out = out + "\"line\":" + s.line.to_string() + ","
    out = out + "\"column\":" + s.column.to_string()
    out = out + "}"
  end

  # Notes
  if ctx.notes.len() > 0
    out = out + ",\"notes\":["
    let mut first = true
    for n in ctx.notes
      if not first
        out = out + ","
      end
      first = false
      out = out + "\"" + escape_json(n.message) + "\""
    end
    out = out + "]"
  end

  # Documentation
  if doc_url != ""
    out = out + ",\"doc\":" + "\"" + escape_json(doc_url) + "\""
  end

  out = out + "}"
  give out
.end

# ------------------------------------------------------------
# API courte
# ------------------------------------------------------------

proc short(
  code : string,
  phase : context/ErrorPhase,
  message : string
) gives string
  let ctx = context/new_context(code, phase, message)
  give render(ctx)
.end
