# ============================================================
# vitte_driver :: pipeline :: compile
# Main compilation pipeline
# ============================================================

space vitte/driver/pipeline

pull vitte/driver/context
pull vitte/driver/diagnostics
pull vitte/driver/options
pull vitte/driver/targets

pull vitte/core/const_eval

# Frontend / middle-end / backend entry points
# (implemented elsewhere)
pull vitte/driver/frontend/parse
pull vitte/driver/frontend/lower
pull vitte/driver/frontend/type_check

pull vitte/driver/middle/const_fold
pull vitte/driver/middle/optimize

pull vitte/driver/backend/codegen
pull vitte/driver/backend/link

# ------------------------------------------------------------
# CompileResult
# ------------------------------------------------------------

pick CompileResult
    Success
    Failed
.end

# ------------------------------------------------------------
# Entry point
# ------------------------------------------------------------

proc compile(ctx: &mut DriverContext)
    gives CompileResult

    # --------------------------------------------------------
    # Parse
    # --------------------------------------------------------
    ctx.enter_phase(Parse)
    match parse(ctx)
        Ok(_) => ()
        Error(e) =>
            ctx.emit_error(e.message())
            give Failed
    .end

    if ctx.has_errors()
        give Failed

    # --------------------------------------------------------
    # Lower (AST -> HIR)
    # --------------------------------------------------------
    ctx.enter_phase(Lower)
    match lower(ctx)
        Ok(_) => ()
        Error(e) =>
            ctx.emit_error(e.message())
            give Failed
    .end

    if ctx.has_errors()
        give Failed

    # --------------------------------------------------------
    # Type checking
    # --------------------------------------------------------
    ctx.enter_phase(TypeCheck)
    match type_check(ctx)
        Ok(_) => ()
        Error(e) =>
            ctx.emit_error(e.message())
            give Failed
    .end

    if ctx.has_errors()
        give Failed

    # --------------------------------------------------------
    # Constant evaluation / folding
    # --------------------------------------------------------
    ctx.enter_phase(ConstEval)
    match const_fold(ctx)
        Ok(_) => ()
        Error(e) =>
            ctx.emit_error(e.message())
            give Failed
    .end

    if ctx.has_errors()
        give Failed

    # --------------------------------------------------------
    # Optimization (optional)
    # --------------------------------------------------------
    ctx.enter_phase(Optimize)
    if ctx.options.flags.is_optimized()
        match optimize(ctx)
            Ok(_) => ()
            Error(e) =>
                ctx.emit_error(e.message())
                give Failed
        .end
    .end

    if ctx.has_errors()
        give Failed

    # --------------------------------------------------------
    # Code generation
    # --------------------------------------------------------
    ctx.enter_phase(Codegen)
    match codegen(ctx)
        Ok(_) => ()
        Error(e) =>
            ctx.emit_error(e.message())
            give Failed
    .end

    if ctx.has_errors()
        give Failed

    # --------------------------------------------------------
    # Linking (if required)
    # --------------------------------------------------------
    if ctx.options.flags.should_emit(EmitKind::Bin)
        ctx.enter_phase(Link)
        match link(ctx)
            Ok(_) => ()
            Error(e) =>
                ctx.emit_error(e.message())
                give Failed
        .end
    .end

    if ctx.has_errors()
        give Failed

    give Success
.end

# ------------------------------------------------------------
# Convenience wrappers
# ------------------------------------------------------------

proc compile_or_panic(ctx: &mut DriverContext)
    match compile(ctx)
        Success => ()
        Failed =>
            panic("compilation failed")
    .end
.end
