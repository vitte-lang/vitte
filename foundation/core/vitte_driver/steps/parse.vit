# ============================================================
# vitte_driver :: steps :: parse
# Source loading and parsing step
# ============================================================

space vitte/driver/steps

pull vitte/driver/context
pull vitte/driver/diagnostics
pull vitte/driver/options
pull vitte/driver/targets

# Frontend subsystems (defined elsewhere)
pull vitte/frontend/loader
pull vitte/frontend/lexer
pull vitte/frontend/parser
pull vitte/frontend/ast
pull vitte/frontend/module_graph

# ------------------------------------------------------------
# ParseConfig
# ------------------------------------------------------------

form ParseConfig
    allow_tabs: Bool
    allow_legacy_syntax: Bool
    recover_errors: Bool
    max_errors: UInt
.end

proc ParseConfig::from_context(ctx: &DriverContext)
    gives ParseConfig

    give ParseConfig {
        allow_tabs: true,
        allow_legacy_syntax: ctx.options.flags.experimental,
        recover_errors: true,
        max_errors: 50,
    }
.end

# ------------------------------------------------------------
# Entry point
# ------------------------------------------------------------

proc parse(ctx: &mut DriverContext)
    gives Result<(), DriverError>

    ctx.enter_phase(Parse)

    let cfg = ParseConfig::from_context(ctx)

    # --------------------------------------------------------
    # Load entry sources
    # --------------------------------------------------------
    let sources = match loader::load_roots(ctx.options, ctx.session)
        Ok(s) => s
        Error(e) =>
            give Error(
                DriverError::IoError(
                    e.path,
                    e.message()
                )
            )
    .end

    if sources.is_empty()
        give Error(
            DriverError::InternalCompilerError(
                "no input sources provided"
            )
        )

    # --------------------------------------------------------
    # Initialize module graph
    # --------------------------------------------------------
    let mut graph = module_graph::new()

    # --------------------------------------------------------
    # Parse loop
    # --------------------------------------------------------
    for src in sources

        ctx.on_file_loaded()

        let text = match loader::read_to_string(src.path)
            Ok(t) => t
            Error(e) =>
                ctx.emit_error(
                    DriverError::IoError(src.path, e.message()).message()
                )
                continue
        .end

        # ----------------------------------------------------
        # Lexing
        # ----------------------------------------------------
        let tokens = match lexer::lex(
            text,
            src.path,
            cfg.allow_tabs
        )
            Ok(toks) => toks
            Error(e) =>
                ctx.emit_error(
                    DriverError::ParseError(
                        src.path,
                        e.line,
                        e.column,
                        e.message()
                    ).message()
                )
                continue
        .end

        # ----------------------------------------------------
        # Parsing
        # ----------------------------------------------------
        let ast = match parser::parse(
            tokens,
            cfg.allow_legacy_syntax,
            cfg.recover_errors
        )
            Ok(a) => a
            Error(e) =>
                ctx.emit_error(
                    DriverError::ParseError(
                        src.path,
                        e.line,
                        e.column,
                        e.message()
                    ).message()
                )
                continue
        .end

        ctx.on_module_parsed()

        # ----------------------------------------------------
        # Register module
        # ----------------------------------------------------
        match graph.add_module(ast)
            Ok(_) => ()
            Error(e) =>
                ctx.emit_error(
                    DriverError::DuplicateModule(
                        e.module_name
                    ).message()
                )
        .end

        if ctx.stats.errors >= cfg.max_errors
            break
    .end

    # --------------------------------------------------------
    # Resolve imports / build graph
    # --------------------------------------------------------
    match graph.resolve()
        Ok(_) => ()
        Error(e) =>
            ctx.emit_error(
                DriverError::CircularDependency(
                    e.module
                ).message()
            )
    .end

    # --------------------------------------------------------
    # Commit AST + graph to session
    # --------------------------------------------------------
    ctx.session.set_ast(graph)

    if ctx.has_errors()
        give Error(
            DriverError::InternalCompilerError(
                "parsing failed with errors"
            )
        )

    give Ok(())
.end

# ------------------------------------------------------------
# Convenience wrapper
# ------------------------------------------------------------

proc parse_or_panic(ctx: &mut DriverContext)
    match parse(ctx)
        Ok(_) => ()
        Error(e) =>
            panic(e.message())
    .end
.end

# ------------------------------------------------------------
# Notes
# ------------------------------------------------------------
#
# - This step:
#     * loads files
#     * lexes
#     * parses
#     * builds module graph
#
# - It does NOT:
#     * type-check
#     * expand macros
#     * lower IR
#
# - Diagnostics are emitted eagerly but parsing continues
#   until `max_errors` is reached.
#
# - Output:
#     * AST
#     * resolved module graph
#
