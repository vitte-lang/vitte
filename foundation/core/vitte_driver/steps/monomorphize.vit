# ============================================================
# vitte_driver :: steps :: monomorphize
# Generic specialization (monomorphization) step
# ============================================================

space vitte/driver/steps

pull vitte/driver/context
pull vitte/driver/diagnostics
pull vitte/driver/options
pull vitte/driver/targets

# IR subsystems (defined elsewhere)
pull vitte/hir
pull vitte/mir
pull vitte/mono           # monomorphization engine
pull vitte/mono/plan
pull vitte/mono/cache
pull vitte/mono/verify

# ------------------------------------------------------------
# MonoPolicy
# ------------------------------------------------------------

pick MonoPolicy
    Lazy            # specialize on demand
    Eager           # specialize all reachable generics
.end

# ------------------------------------------------------------
# MonomorphizeConfig
# ------------------------------------------------------------

form MonomorphizeConfig
    policy: MonoPolicy
    max_instances: UInt
    debug_dump: Bool
    verify: Bool
.end

proc MonomorphizeConfig::from_context(ctx: &DriverContext)
    gives MonomorphizeConfig

    give MonomorphizeConfig {
        policy:
            if ctx.options.flags.experimental
                then Eager
                else Lazy,

        max_instances: 10_000,

        debug_dump:
            ctx.options.flags.debug_info == DebugInfo::Full,

        verify:
            ctx.options.flags.debug_info != DebugInfo::None,
    }
.end

# ------------------------------------------------------------
# Entry point
# ------------------------------------------------------------

proc monomorphize(ctx: &mut DriverContext)
    gives Result<(), DriverError>

    ctx.enter_phase(Lower)

    let cfg = MonomorphizeConfig::from_context(ctx)

    # --------------------------------------------------------
    # Collect generic instantiations
    # --------------------------------------------------------
    let plan = match mono::plan::collect(
        ctx.session.hir(),
        cfg.policy
    )
        Ok(p) => p
        Error(e) =>
            give Error(
                DriverError::BackendError(
                    "monomorphize-plan",
                    e.message()
                )
            )
    .end

    if plan.count() > cfg.max_instances
        give Error(
            DriverError::BackendError(
                "monomorphize",
                format(
                    "too many generic instantiations ({} > {})",
                    plan.count(),
                    cfg.max_instances
                )
            )
        )

    # --------------------------------------------------------
    # Apply monomorphization
    # --------------------------------------------------------
    let mut cache = mono::cache::new()

    match mono::apply(
        ctx.session,
        &plan,
        &mut cache
    )
        Ok(_) => ()
        Error(e) =>
            give Error(
                DriverError::BackendError(
                    "monomorphize-apply",
                    e.message()
                )
            )
    .end

    # --------------------------------------------------------
    # Optional verification
    # --------------------------------------------------------
    if cfg.verify
        match mono::verify::session(ctx.session)
            Ok(_) => ()
            Error(e) =>
                give Error(
                    DriverError::InternalCompilerError(
                        format(
                            "monomorphization verification failed: {}",
                            e.message()
                        )
                    )
                )
        .end
    .end

    # --------------------------------------------------------
    # Debug dump (optional)
    # --------------------------------------------------------
    if cfg.debug_dump
        ctx.diagnostics.note(
            format(
                "monomorphized {} instances",
                plan.count()
            )
        )
        mono::dump::session(ctx.session)
    .end

    give Ok(())
.end

# ------------------------------------------------------------
# Convenience wrapper
# ------------------------------------------------------------

proc monomorphize_or_panic(ctx: &mut DriverContext)
    match monomorphize(ctx)
        Ok(_) => ()
        Error(e) =>
            panic(e.message())
    .end
.end

# ------------------------------------------------------------
# Notes
# ------------------------------------------------------------
#
# - This step assumes:
#     * HIR is fully type-checked
#     * generics are explicit and well-formed
#
# - It produces:
#     * monomorphic HIR/MIR
#     * no remaining type parameters
#
# - Typical ordering:
#     parse -> lower -> type_check
#     -> monomorphize
#     -> build_mir
#     -> const_fold / optimize
#     -> codegen
#
# - Extensions:
#     * incremental mono cache
#     * cross-crate specialization
#     * profile-guided eager mono
#
