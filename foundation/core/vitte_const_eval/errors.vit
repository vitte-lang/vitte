# ============================================================
# vitte_const_eval :: errors
# Diagnostics for constant evaluation
# ============================================================

space vitte/core/const_eval

pull vitte/core/const_eval/value
pull vitte/core/const_eval/op

# ------------------------------------------------------------
# ConstEvalError
# ------------------------------------------------------------

pick ConstEvalError

    # --------------------------------------------------------
    # Structural / dispatcher
    # --------------------------------------------------------

    UnsupportedConstExpr
    UnsupportedUnaryOp(UnaryOp)
    UnsupportedBinaryOp(BinaryOp)

    # --------------------------------------------------------
    # Type system
    # --------------------------------------------------------

    TypeMismatchUnary(
        op: String,
        value: ConstValue
    )

    TypeMismatchBinary(
        op: String,
        lhs: ConstValue,
        rhs: ConstValue
    )

    InvalidUnaryOperation(
        op: String,
        value: ConstValue
    )

    InvalidBinaryOperation(
        op: String,
        lhs: ConstValue,
        rhs: ConstValue
    )

    # --------------------------------------------------------
    # Arithmetic
    # --------------------------------------------------------

    DivisionByZero
    RemainderByZero

    IntegerOverflow
    IntegerUnderflow
    FloatOverflow
    FloatNaN
    FloatInfinite

    # --------------------------------------------------------
    # Policy / context
    # --------------------------------------------------------

    StepLimitExceeded
    DepthLimitExceeded
    ExprSizeLimitExceeded

    FloatNotAllowed
    BitwiseNotAllowed
    PointerNotAllowed
    DivisionByZeroNotAllowed

    # --------------------------------------------------------
    # Values / literals
    # --------------------------------------------------------

    InvalidConstValue
    InvalidLiteral
    NonConstValue

    # --------------------------------------------------------
    # Future-proof (const fn, memory, etc.)
    # --------------------------------------------------------

    UnsupportedIntrinsic(String)
    UnsupportedCast(String)
    UnsupportedConstFn(String)

    MemoryAccessNotAllowed
    PointerArithmeticNotAllowed

.end

# ------------------------------------------------------------
# Human-readable diagnostics
# ------------------------------------------------------------

proc ConstEvalError::message(self: &ConstEvalError)
    gives String

    match self

        # Structural
        UnsupportedConstExpr =>
            "unsupported constant expression"

        UnsupportedUnaryOp(op) =>
            format("unsupported unary operator `{}` in constant expression", op)

        UnsupportedBinaryOp(op) =>
            format("unsupported binary operator `{}` in constant expression", op)

        # Type system
        TypeMismatchUnary(op, v) =>
            format(
                "type mismatch for unary operator `{}` on value `{}`",
                op,
                v
            )

        TypeMismatchBinary(op, l, r) =>
            format(
                "type mismatch for binary operator `{}` between `{}` and `{}`",
                op,
                l,
                r
            )

        InvalidUnaryOperation(op, v) =>
            format(
                "invalid unary operation `{}` on value `{}`",
                op,
                v
            )

        InvalidBinaryOperation(op, l, r) =>
            format(
                "invalid binary operation `{}` between `{}` and `{}`",
                op,
                l,
                r
            )

        # Arithmetic
        DivisionByZero =>
            "division by zero in constant expression"

        RemainderByZero =>
            "remainder by zero in constant expression"

        IntegerOverflow =>
            "integer overflow during constant evaluation"

        IntegerUnderflow =>
            "integer underflow during constant evaluation"

        FloatOverflow =>
            "floating-point overflow during constant evaluation"

        FloatNaN =>
            "floating-point NaN produced during constant evaluation"

        FloatInfinite =>
            "floating-point infinity produced during constant evaluation"

        # Policy
        StepLimitExceeded =>
            "constant evaluation step limit exceeded"

        DepthLimitExceeded =>
            "constant evaluation recursion depth exceeded"

        ExprSizeLimitExceeded =>
            "constant expression too large to evaluate"

        FloatNotAllowed =>
            "floating-point operations are not allowed in this constant context"

        BitwiseNotAllowed =>
            "bitwise operations are not allowed in this constant context"

        PointerNotAllowed =>
            "pointer operations are not allowed in constant expressions"

        DivisionByZeroNotAllowed =>
            "division by zero is forbidden in this constant context"

        # Values
        InvalidConstValue =>
            "invalid constant value"

        InvalidLiteral =>
            "invalid literal in constant expression"

        NonConstValue =>
            "non-constant value used in constant expression"

        # Future
        UnsupportedIntrinsic(name) =>
            format("unsupported const intrinsic `{}`", name)

        UnsupportedCast(desc) =>
            format("unsupported constant cast `{}`", desc)

        UnsupportedConstFn(name) =>
            format("unsupported constant function `{}`", name)

        MemoryAccessNotAllowed =>
            "memory access is not allowed during constant evaluation"

        PointerArithmeticNotAllowed =>
            "pointer arithmetic is not allowed during constant evaluation"
    .end
.end

# ------------------------------------------------------------
# Severity classification (optional)
# ------------------------------------------------------------

pick ConstEvalSeverity
    Error
    Warning
.end

proc ConstEvalError::severity(self: &ConstEvalError)
    gives ConstEvalSeverity

    match self
        # everything here is a hard error for now
        otherwise => Error
    .end
.end
