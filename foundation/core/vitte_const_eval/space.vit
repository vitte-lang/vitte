# ============================================================
# vitte_const_eval :: space
# Root namespace for constant evaluation subsystem
# ============================================================

space vitte/core/const_eval

# ------------------------------------------------------------
# Submodules
# ------------------------------------------------------------

pull vitte/core/const_eval/value
pull vitte/core/const_eval/errors
pull vitte/core/const_eval/context
pull vitte/core/const_eval/op
pull vitte/core/const_eval/eval

# ------------------------------------------------------------
# Public API re-exports
# ------------------------------------------------------------

# Core types
share ConstValue
share ConstEvalError
share ConstEvalContext
share ConstEvalMode
share ConstEvalLimits
share ConstEvalFlags

# Operators
share UnaryOp
share BinaryOp

# Evaluation entry points
share eval_expr
share eval_unary
share eval_binary

# ------------------------------------------------------------
# High-level convenience helpers
# ------------------------------------------------------------

# Evaluate a constant expression in strict mode
proc const_eval(expr: ConstExpr)
    gives Result<ConstValue, ConstEvalError>

    let mut ctx = ConstEvalContext::strict()
    give eval_expr(&mut ctx, expr)
.end

# Evaluate a constant expression in relaxed mode
proc const_eval_relaxed(expr: ConstExpr)
    gives Result<ConstValue, ConstEvalError>

    let mut ctx = ConstEvalContext::relaxed()
    give eval_expr(&mut ctx, expr)
.end

share const_eval
share const_eval_relaxed

# ------------------------------------------------------------
# Versioning / feature flags (future-proof)
# ------------------------------------------------------------

const CONST_EVAL_VERSION: UInt = 1

# ------------------------------------------------------------
# Notes
# ------------------------------------------------------------
#
# - This module intentionally contains NO evaluation logic.
# - It defines the public surface consumed by:
#     * HIR constant folding
#     * MIR simplification
#     * type-level computations
#     * array length evaluation
#
# - Internal modules may evolve without breaking this API.
#
