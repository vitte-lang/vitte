# ============================================================
# vitte_const_eval :: eval :: unary
# Constant evaluation of unary expressions
# ============================================================

space vitte/core/const_eval/eval

pull vitte/core/const_eval/value
pull vitte/core/const_eval/error
pull vitte/core/const_eval/op
pull vitte/core/const_eval/context

# ------------------------------------------------------------
# Entry point
# ------------------------------------------------------------

proc eval_unary(ctx: &ConstEvalContext,
                op: UnaryOp,
                value: ConstValue)
     gives Result<ConstValue, ConstEvalError>

    select op
        when Plus      give eval_plus(value)
        when Minus     give eval_minus(ctx, value)
        when Not       give eval_not(value)
        when BitNot    give eval_bitnot(value)
        otherwise
            give Error(ConstEvalError::UnsupportedUnaryOp(op))
    .end
.end

# ------------------------------------------------------------
# Arithmetic
# ------------------------------------------------------------

# Unary +
# Semantically a no-op, but enforces numeric type
proc eval_plus(v: ConstValue)
    gives Result<ConstValue, ConstEvalError>

    match v
        Int(_)   => give Ok(v)
        UInt(_)  => give Ok(v)
        Float(_) => give Ok(v)
        otherwise =>
            give Error(ConstEvalError::TypeMismatchUnary("+", v))
    .end
.end

# Unary -
# Checked if context requires it
proc eval_minus(ctx: &ConstEvalContext, v: ConstValue)
    gives Result<ConstValue, ConstEvalError>

    match v
        Int(x) =>
            if ctx.checked_arith
                give checked_neg_i128(x)
            else
                give Ok(Int(-x))

        UInt(x) =>
            # Negating unsigned is forbidden at const-eval
            give Error(ConstEvalError::InvalidUnaryOperation("-", v))

        Float(x) =>
            give Ok(Float(-x))

        otherwise =>
            give Error(ConstEvalError::TypeMismatchUnary("-", v))
    .end
.end

# ------------------------------------------------------------
# Logical
# ------------------------------------------------------------

# Logical !
proc eval_not(v: ConstValue)
    gives Result<ConstValue, ConstEvalError>

    match v
        Bool(x) => give Ok(Bool(!x))
        otherwise =>
            give Error(ConstEvalError::TypeMismatchUnary("!", v))
    .end
.end

# ------------------------------------------------------------
# Bitwise
# ------------------------------------------------------------

# Bitwise ~
proc eval_bitnot(v: ConstValue)
    gives Result<ConstValue, ConstEvalError>

    match v
        Int(x)   => give Ok(Int(~x))
        UInt(x)  => give Ok(UInt(~x))
        otherwise =>
            give Error(ConstEvalError::TypeMismatchUnary("~", v))
    .end
.end

# ------------------------------------------------------------
# Helpers (future extensions)
# ------------------------------------------------------------

# Reserved for:
# - pointer deref const-eval
# - address-of restrictions
# - vector / SIMD lanes
# - const fn intrinsics
#
# proc eval_deref(...)
# proc eval_addr_of(...)
