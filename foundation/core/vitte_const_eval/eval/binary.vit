# ============================================================
# vitte_const_eval :: eval :: binary
# Constant evaluation of binary expressions
# ============================================================

space vitte/core/const_eval/eval

pull vitte/core/const_eval/value
pull vitte/core/const_eval/error
pull vitte/core/const_eval/op
pull vitte/core/const_eval/context

# ------------------------------------------------------------
# Entry point
# ------------------------------------------------------------

proc eval_binary(ctx: &ConstEvalContext,
                 op: BinaryOp,
                 lhs: ConstValue,
                 rhs: ConstValue)
     gives Result<ConstValue, ConstEvalError>

    select op
        when Add        give eval_add(ctx, lhs, rhs)
        when Sub        give eval_sub(ctx, lhs, rhs)
        when Mul        give eval_mul(ctx, lhs, rhs)
        when Div        give eval_div(ctx, lhs, rhs)
        when Rem        give eval_rem(ctx, lhs, rhs)

        when BitAnd     give eval_bitand(ctx, lhs, rhs)
        when BitOr      give eval_bitor(ctx, lhs, rhs)
        when BitXor     give eval_bitxor(ctx, lhs, rhs)
        when Shl        give eval_shl(ctx, lhs, rhs)
        when Shr        give eval_shr(ctx, lhs, rhs)

        when Eq         give eval_eq(lhs, rhs)
        when Ne         give eval_ne(lhs, rhs)
        when Lt         give eval_lt(lhs, rhs)
        when Le         give eval_le(lhs, rhs)
        when Gt         give eval_gt(lhs, rhs)
        when Ge         give eval_ge(lhs, rhs)

        when And        give eval_logical_and(lhs, rhs)
        when Or         give eval_logical_or(lhs, rhs)

        otherwise
            give Error(ConstEvalError::UnsupportedBinaryOp(op))
    .end
.end

# ------------------------------------------------------------
# Arithmetic
# ------------------------------------------------------------

proc eval_add(ctx: &ConstEvalContext, a: ConstValue, b: ConstValue)
    gives Result<ConstValue, ConstEvalError>

    match (a, b)
        (Int(x), Int(y)) =>
            if ctx.checked_arith
                give checked_add_i128(x, y)
            else
                give Ok(Int(x + y))
        (UInt(x), UInt(y)) =>
            if ctx.checked_arith
                give checked_add_u128(x, y)
            else
                give Ok(UInt(x + y))
        (Float(x), Float(y)) =>
            give Ok(Float(x + y))
        otherwise =>
            give Error(ConstEvalError::TypeMismatchBinary("+", a, b))
    .end
.end

proc eval_sub(ctx: &ConstEvalContext, a: ConstValue, b: ConstValue)
    gives Result<ConstValue, ConstEvalError>

    match (a, b)
        (Int(x), Int(y)) =>
            if ctx.checked_arith
                give checked_sub_i128(x, y)
            else
                give Ok(Int(x - y))
        (UInt(x), UInt(y)) =>
            if ctx.checked_arith
                give checked_sub_u128(x, y)
            else
                give Ok(UInt(x - y))
        (Float(x), Float(y)) =>
            give Ok(Float(x - y))
        otherwise =>
            give Error(ConstEvalError::TypeMismatchBinary("-", a, b))
    .end
.end

proc eval_mul(ctx: &ConstEvalContext, a: ConstValue, b: ConstValue)
    gives Result<ConstValue, ConstEvalError>

    match (a, b)
        (Int(x), Int(y)) =>
            if ctx.checked_arith
                give checked_mul_i128(x, y)
            else
                give Ok(Int(x * y))
        (UInt(x), UInt(y)) =>
            if ctx.checked_arith
                give checked_mul_u128(x, y)
            else
                give Ok(UInt(x * y))
        (Float(x), Float(y)) =>
            give Ok(Float(x * y))
        otherwise =>
            give Error(ConstEvalError::TypeMismatchBinary("*", a, b))
    .end
.end

proc eval_div(ctx: &ConstEvalContext, a: ConstValue, b: ConstValue)
    gives Result<ConstValue, ConstEvalError>

    match (a, b)
        (_, Int(0)) | (_, UInt(0)) | (_, Float(0.0)) =>
            give Error(ConstEvalError::DivisionByZero)
        (Int(x), Int(y)) =>
            give Ok(Int(x / y))
        (UInt(x), UInt(y)) =>
            give Ok(UInt(x / y))
        (Float(x), Float(y)) =>
            give Ok(Float(x / y))
        otherwise =>
            give Error(ConstEvalError::TypeMismatchBinary("/", a, b))
    .end
.end

proc eval_rem(_: &ConstEvalContext, a: ConstValue, b: ConstValue)
    gives Result<ConstValue, ConstEvalError>

    match (a, b)
        (_, Int(0)) | (_, UInt(0)) =>
            give Error(ConstEvalError::DivisionByZero)
        (Int(x), Int(y)) =>
            give Ok(Int(x % y))
        (UInt(x), UInt(y)) =>
            give Ok(UInt(x % y))
        otherwise =>
            give Error(ConstEvalError::TypeMismatchBinary("%", a, b))
    .end
.end

# ------------------------------------------------------------
# Bitwise
# ------------------------------------------------------------

proc eval_bitand(_: &ConstEvalContext, a: ConstValue, b: ConstValue)
    gives Result<ConstValue, ConstEvalError>

    match (a, b)
        (Int(x), Int(y))   => give Ok(Int(x & y))
        (UInt(x), UInt(y)) => give Ok(UInt(x & y))
        otherwise =>
            give Error(ConstEvalError::TypeMismatchBinary("&", a, b))
    .end
.end

proc eval_bitor(_: &ConstEvalContext, a: ConstValue, b: ConstValue)
    gives Result<ConstValue, ConstEvalError>

    match (a, b)
        (Int(x), Int(y))   => give Ok(Int(x | y))
        (UInt(x), UInt(y)) => give Ok(UInt(x | y))
        otherwise =>
            give Error(ConstEvalError::TypeMismatchBinary("|", a, b))
    .end
.end

proc eval_bitxor(_: &ConstEvalContext, a: ConstValue, b: ConstValue)
    gives Result<ConstValue, ConstEvalError>

    match (a, b)
        (Int(x), Int(y))   => give Ok(Int(x ^ y))
        (UInt(x), UInt(y)) => give Ok(UInt(x ^ y))
        otherwise =>
            give Error(ConstEvalError::TypeMismatchBinary("^", a, b))
    .end
.end

proc eval_shl(_: &ConstEvalContext, a: ConstValue, b: ConstValue)
    gives Result<ConstValue, ConstEvalError>

    match (a, b)
        (Int(x), UInt(s))   => give Ok(Int(x << s))
        (UInt(x), UInt(s))  => give Ok(UInt(x << s))
        otherwise =>
            give Error(ConstEvalError::TypeMismatchBinary("<<", a, b))
    .end
.end

proc eval_shr(_: &ConstEvalContext, a: ConstValue, b: ConstValue)
    gives Result<ConstValue, ConstEvalError>

    match (a, b)
        (Int(x), UInt(s))   => give Ok(Int(x >> s))
        (UInt(x), UInt(s))  => give Ok(UInt(x >> s))
        otherwise =>
            give Error(ConstEvalError::TypeMismatchBinary(">>", a, b))
    .end
.end

# ------------------------------------------------------------
# Comparisons
# ------------------------------------------------------------

proc eval_eq(a: ConstValue, b: ConstValue)
    gives Result<ConstValue, ConstEvalError>
    give Ok(Bool(a == b))
.end

proc eval_ne(a: ConstValue, b: ConstValue)
    gives Result<ConstValue, ConstEvalError>
    give Ok(Bool(a != b))
.end

proc eval_lt(a: ConstValue, b: ConstValue)
    gives Result<ConstValue, ConstEvalError>
    give compare("<", a, b)
.end

proc eval_le(a: ConstValue, b: ConstValue)
    gives Result<ConstValue, ConstEvalError>
    give compare("<=", a, b)
.end

proc eval_gt(a: ConstValue, b: ConstValue)
    gives Result<ConstValue, ConstEvalError>
    give compare(">", a, b)
.end

proc eval_ge(a: ConstValue, b: ConstValue)
    gives Result<ConstValue, ConstEvalError>
    give compare(">=", a, b)
.end

proc compare(op: String, a: ConstValue, b: ConstValue)
    gives Result<ConstValue, ConstEvalError>

    match (a, b)
        (Int(x), Int(y))     => give Ok(Bool(apply_cmp(op, x, y)))
        (UInt(x), UInt(y))   => give Ok(Bool(apply_cmp(op, x, y)))
        (Float(x), Float(y)) => give Ok(Bool(apply_cmp(op, x, y)))
        otherwise =>
            give Error(ConstEvalError::TypeMismatchBinary(op, a, b))
    .end
.end

# ------------------------------------------------------------
# Logical
# ------------------------------------------------------------

proc eval_logical_and(a: ConstValue, b: ConstValue)
    gives Result<ConstValue, ConstEvalError>

    match (a, b)
        (Bool(x), Bool(y)) => give Ok(Bool(x && y))
        otherwise =>
            give Error(ConstEvalError::TypeMismatchBinary("&&", a, b))
    .end
.end

proc eval_logical_or(a: ConstValue, b: ConstValue)
    gives Result<ConstValue, ConstEvalError>

    match (a, b)
        (Bool(x), Bool(y)) => give Ok(Bool(x || y))
        otherwise =>
            give Error(ConstEvalError::TypeMismatchBinary("||", a, b))
    .end
.end
