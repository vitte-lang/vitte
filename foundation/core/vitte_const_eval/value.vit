# ============================================================
# vitte_const_eval :: value
# Constant value representation and helpers
# ============================================================

space vitte/core/const_eval

pull vitte/core/const_eval/errors

# ------------------------------------------------------------
# ConstValue
# ------------------------------------------------------------

# Canonical representation for compile-time values.
# No allocation, no references, no side effects.
pick ConstValue
    Int(i128)
    UInt(u128)
    Float(f64)
    Bool(Bool)
    Char(u32)        # Unicode scalar value
    Unit             # ()
    # Future:
    # Ptr(ConstPtr)
    # Array(ConstArray)
    # Struct(ConstStruct)
.end

# ------------------------------------------------------------
# Basic predicates
# ------------------------------------------------------------

proc ConstValue::is_numeric(self: &ConstValue)
    gives Bool
    match self
        Int(_)   => true
        UInt(_)  => true
        Float(_) => true
        otherwise => false
    .end
.end

proc ConstValue::is_integer(self: &ConstValue)
    gives Bool
    match self
        Int(_)  => true
        UInt(_) => true
        otherwise => false
    .end
.end

proc ConstValue::is_signed(self: &ConstValue)
    gives Bool
    match self
        Int(_) => true
        otherwise => false
    .end
.end

proc ConstValue::is_bool(self: &ConstValue)
    gives Bool
    match self
        Bool(_) => true
        otherwise => false
    .end
.end

# ------------------------------------------------------------
# Accessors (checked)
# ------------------------------------------------------------

proc ConstValue::as_i128(self: &ConstValue)
    gives Result<i128, ConstEvalError>
    match self
        Int(x) => give Ok(x)
        otherwise => give Error(ConstEvalError::InvalidConstValue)
    .end
.end

proc ConstValue::as_u128(self: &ConstValue)
    gives Result<u128, ConstEvalError>
    match self
        UInt(x) => give Ok(x)
        otherwise => give Error(ConstEvalError::InvalidConstValue)
    .end
.end

proc ConstValue::as_f64(self: &ConstValue)
    gives Result<f64, ConstEvalError>
    match self
        Float(x) => give Ok(x)
        otherwise => give Error(ConstEvalError::InvalidConstValue)
    .end
.end

proc ConstValue::as_bool(self: &ConstValue)
    gives Result<Bool, ConstEvalError>
    match self
        Bool(x) => give Ok(x)
        otherwise => give Error(ConstEvalError::InvalidConstValue)
    .end
.end

# ------------------------------------------------------------
# Equality (strong, type-aware)
# ------------------------------------------------------------

# No implicit conversions:
# Int(1) != UInt(1) != Float(1.0)
proc ConstValue::eq(self: &ConstValue, other: &ConstValue)
    gives Bool

    match (self, other)
        (Int(a),   Int(b))   => a == b
        (UInt(a),  UInt(b))  => a == b
        (Float(a), Float(b)) => a == b
        (Bool(a),  Bool(b))  => a == b
        (Char(a),  Char(b))  => a == b
        (Unit,     Unit)     => true
        otherwise            => false
    .end
.end

proc ConstValue::ne(self: &ConstValue, other: &ConstValue)
    gives Bool
    give !self.eq(other)
.end

# ------------------------------------------------------------
# Ordering (only for comparable kinds)
# ------------------------------------------------------------

proc ConstValue::cmp(self: &ConstValue, other: &ConstValue)
    gives Result<Int, ConstEvalError>
    # returns -1, 0, 1

    match (self, other)
        (Int(a), Int(b)) =>
            give Ok(if a < b then -1 else if a > b then 1 else 0)

        (UInt(a), UInt(b)) =>
            give Ok(if a < b then -1 else if a > b then 1 else 0)

        (Float(a), Float(b)) =>
            give Ok(if a < b then -1 else if a > b then 1 else 0)

        (Char(a), Char(b)) =>
            give Ok(if a < b then -1 else if a > b then 1 else 0)

        otherwise =>
            give Error(ConstEvalError::InvalidBinaryOperation(
                "compare",
                *self,
                *other
            ))
    .end
.end

# ------------------------------------------------------------
# Display / formatting
# ------------------------------------------------------------

proc ConstValue::to_string(self: &ConstValue)
    gives String

    match self
        Int(x)   => format("{}", x)
        UInt(x)  => format("{}u", x)
        Float(x) => format("{}", x)
        Bool(x)  => if x then "true" else "false"
        Char(c)  => format("'{}'", char_from_u32(c))
        Unit     => "()"
    .end
.end

# ------------------------------------------------------------
# Numeric helpers (no policy here)
# ------------------------------------------------------------

proc add_int(a: i128, b: i128)
    gives i128
    a + b
.end

proc add_uint(a: u128, b: u128)
    gives u128
    a + b
.end

proc sub_int(a: i128, b: i128)
    gives i128
    a - b
.end

proc mul_int(a: i128, b: i128)
    gives i128
    a * b
.end

proc div_int(a: i128, b: i128)
    gives i128
    a / b
.end

# ------------------------------------------------------------
# Checked arithmetic helpers
# ------------------------------------------------------------

proc checked_add_i128(a: i128, b: i128)
    gives Result<ConstValue, ConstEvalError>

    let r = a + b
    if (b > 0 && r < a) || (b < 0 && r > a)
        give Error(ConstEvalError::IntegerOverflow)

    give Ok(ConstValue::Int(r))
.end

proc checked_sub_i128(a: i128, b: i128)
    gives Result<ConstValue, ConstEvalError>

    let r = a - b
    if (b < 0 && r < a) || (b > 0 && r > a)
        give Error(ConstEvalError::IntegerUnderflow)

    give Ok(ConstValue::Int(r))
.end

proc checked_mul_i128(a: i128, b: i128)
    gives Result<ConstValue, ConstEvalError>

    if a == 0 || b == 0
        give Ok(ConstValue::Int(0))

    let r = a * b
    if r / b != a
        give Error(ConstEvalError::IntegerOverflow)

    give Ok(ConstValue::Int(r))
.end

proc checked_neg_i128(a: i128)
    gives Result<ConstValue, ConstEvalError>

    if a == MIN_I128
        give Error(ConstEvalError::IntegerOverflow)

    give Ok(ConstValue::Int(-a))
.end

proc checked_add_u128(a: u128, b: u128)
    gives Result<ConstValue, ConstEvalError>

    let r = a + b
    if r < a
        give Error(ConstEvalError::IntegerOverflow)

    give Ok(ConstValue::UInt(r))
.end

proc checked_sub_u128(a: u128, b: u128)
    gives Result<ConstValue, ConstEvalError>

    if b > a
        give Error(ConstEvalError::IntegerUnderflow)

    give Ok(ConstValue::UInt(a - b))
.end

proc checked_mul_u128(a: u128, b: u128)
    gives Result<ConstValue, ConstEvalError>

    if a == 0 || b == 0
        give Ok(ConstValue::UInt(0))

    let r = a * b
    if r / b != a
        give Error(ConstEvalError::IntegerOverflow)

    give Ok(ConstValue::UInt(r))
.end

# ------------------------------------------------------------
# Constants
# ------------------------------------------------------------

const MIN_I128: i128 = -170141183460469231731687303715884105728
