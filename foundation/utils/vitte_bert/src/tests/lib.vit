// Tests for data structures

#[test]
fn test_stack_push_pop() {
    let mut stack = Stack::new();
    stack.push(42);
    stack.push(100);
    assert_eq!(stack.pop(), Some(100));
    assert_eq!(stack.pop(), Some(42));
    assert!(stack.is_empty());
}

#[test]
fn test_queue_fifo() {
    let mut queue = Queue::new();
    queue.enqueue(1);
    queue.enqueue(2);
    queue.enqueue(3);
    assert_eq!(queue.dequeue(), Some(1));
    assert_eq!(queue.dequeue(), Some(2));
}

#[test]
fn test_bitvector_set_get() {
    let mut bv = BitVector::new(16);
    bv.set(5, true);
    bv.set(10, true);
    assert!(bv.get(5));
    assert!(bv.get(10));
    assert!(!bv.get(3));
}

#[test]
fn test_symbol_creation() {
    let sym = Symbol::new(42, "test_symbol".to_string());
    assert_eq!(sym.id, 42);
    assert_eq!(sym.get_name(), "test_symbol");
}

#[test]
fn test_index_map() {
    let mut map = IndexMap::new();
    map.insert("key1", 100);
    map.insert("key2", 200);
    assert_eq!(map.len(), 2);
}

#[test]
fn test_stack_len() {
    let mut stack = Stack::new();
    stack.push(1);
    stack.push(2);
    stack.push(3);
    assert_eq!(stack.len(), 3);
}

#[test]
fn test_queue_empty() {
    let queue: Queue<i32> = Queue::new();
    assert!(queue.is_empty());
}

#[test]
fn test_bitvector_large() {
    let mut bv = BitVector::new(128);
    bv.set(127, true);
    assert!(bv.get(127));
}
