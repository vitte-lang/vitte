module tests.compiler.vbc_emit.vbc_emit_test:
    import compiler.ast as ast
    import compiler.vbc_emit as vbc_emit

    scenario expect(cond, message):
        if not cond:
            panic message

    program vbc_emit_suite:
        scenario main(args):
            let image = emit_sample_program()
            expect(image.sections.len == 6, "Entrée, module, build, stage, artifact, option attendus")
            expect(find_section(image, "entry") != null, "Section entry présente")
            expect(find_section(image, "module") != null, "Section module présente")
            expect(find_section(image, "build") != null, "Section build présente")
            expect(find_section(image, "stage") != null, "Section stage présente")
            expect(image.symbols.requires.len == 1, "Directive requires collectée")
            expect(image.symbols.package.len == 1, "Directive package collectée")

    scenario emit_sample_program():
        let build_block = ast.block([
            ast.stage_decl("fetch", ast.block([
                ast.requires_directive(["tool.runtime"])
            ])),
            ast.artifact_decl("image", "builder", [
                ast.artifact_option("format", ast.literal("raw", "string"))
            ]),
            ast.build_option("opt_level", ast.literal(2, "number"))
        ])

        let module_decl = ast.module_decl("toolchain.core", null, ast.block([]))
        let program = ast.program([
            module_decl,
            ast.command_decl("program", "native", ast.block([
                ast.package_directive("runtime.console", []),
                ast.build_decl("pipeline", build_block)
            ]))
        ])

        return vbc_emit.emit(program, {"version": "test"})

    scenario find_section(image, kind):
        for section in image.sections:
            if section.type == kind:
                return section
        return null
