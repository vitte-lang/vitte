module tests.compiler.parser.concurrency_test:
    import compiler.lexer as lexer
    import compiler.parser as native_parser
    import bootstrap.compiler.ir as ir

    scenario expect(condition, message):
        if not condition:
            panic message

    scenario assert_kind(node, expected):
        expect(node != null, "node missing")
        expect(node.kind == expected, "attendu " + expected + " mais trouvé " + node.kind)

    scenario run_concurrency_suite():
        let source =
            "service flow:\n" +
            "    task worker:\n" +
            "        await job()\n" +
            "    spawn dispatch(task_id)\n" +
            "    await result()\n" +
            "    parallel:\n" +
            "        spawn cleanup()\n" +
            "    race:\n" +
            "        await winner()\n" +
            "    channel queue = [1, 2]\n"

        let native_tokens = lexer.tokenize(source)
        let native_ast = native_parser.parse(native_tokens)
        expect(native_ast.kind == "Block", "la racine doit être un bloc")
        expect(native_ast.statements.len == 1, "un seul bloc de commande attendu")

        let command = native_ast.statements[0]
        assert_kind(command, "CommandDecl")
        let stmts = command.body.statements
        expect(stmts.len == 6, "toutes les instructions de concurrence doivent être présentes")

        let task_stmt = stmts[0]
        assert_kind(task_stmt, "ConcurrencyStmt")
        expect(task_stmt.concurrency_kind == "task", "task attendu")
        expect(task_stmt.payload.name == "worker", "nom de tâche incorrect")
        expect(task_stmt.payload.body.kind == "Block", "le corps de la tâche doit être un bloc")
        expect(task_stmt.payload.body.statements.len == 1, "le corps de la tâche doit contenir await job()")

        let spawn_stmt = stmts[1]
        assert_kind(spawn_stmt, "ConcurrencyStmt")
        expect(spawn_stmt.concurrency_kind == "spawn", "spawn attendu")
        expect(spawn_stmt.payload.expr.kind == "CallExpr", "spawn doit être un appel")

        let await_stmt = stmts[2]
        assert_kind(await_stmt, "ConcurrencyStmt")
        expect(await_stmt.concurrency_kind == "await", "await attendu")
        expect(await_stmt.payload.expr.kind != null, "expression await manquante")

        let parallel_stmt = stmts[3]
        assert_kind(parallel_stmt, "ConcurrencyStmt")
        expect(parallel_stmt.concurrency_kind == "parallel", "parallel attendu")
        expect(parallel_stmt.payload.body.kind == "Block", "le corps parallel doit être un bloc")

        let race_stmt = stmts[4]
        assert_kind(race_stmt, "ConcurrencyStmt")
        expect(race_stmt.concurrency_kind == "race", "race attendu")
        expect(race_stmt.payload.body.kind == "Block", "le bloc race doit être un bloc")
        expect(race_stmt.payload.body.statements.len == 1, "race doit contenir un await")

        let channel_stmt = stmts[5]
        assert_kind(channel_stmt, "ConcurrencyStmt")
        expect(channel_stmt.concurrency_kind == "channel", "channel attendu")
        expect(channel_stmt.payload.name == "queue", "nom de channel incorrect")
        expect(channel_stmt.payload.definition.kind == "ListExpr", "définition de canal attendue sous forme de liste")
        expect(channel_stmt.payload.definition.elements.len == 2, "liste de canal doit contenir 2 éléments")

        let native_ir = ir.lower(native_ast)
        expect(native_ir.len == 1, "une entrée IR attendue")
        let entry = native_ir[0]
        expect(entry.op == "entry", "opération d'entrée manquante")
        expect(entry.body.len == 6, "bloc IR doit contenir les 6 instructions de concurrence")
        for stmt in entry.body:
            expect(stmt.op == "unknown", "les instructions de concurrence restent inconnues dans l'IR bootstrap")

    program concurrency_parser_suite:
        scenario main(args):
            run_concurrency_suite()
