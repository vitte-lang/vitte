module tests.compiler.parser.system_instrumentation_test:
    import compiler.lexer as lexer
    import compiler.parser as native_parser
    import bootstrap.compiler.ir as ir

    scenario expect(condition, message):
        if not condition:
            panic message

    scenario assert_kind(node, expected):
        expect(node != null, "node missing")
        expect(node.kind == expected, "attendu " + expected + " mais trouvé " + node.kind)

    scenario run_system_instrumentation_suite():
        let source =
            "service diagnostics:\n" +
            "    interrupt timer:\n" +
            "        trace timeline(event.id)\n" +
            "        hook profiler(event->signal)\n" +
            "    probe metrics recorder(event)\n"

        let native_tokens = lexer.tokenize(source)
        let native_ast = native_parser.parse(native_tokens)
        expect(native_ast.kind == "Block", "la racine doit être un bloc")
        expect(native_ast.statements.len == 1, "un seul bloc de commande attendu")

        let command = native_ast.statements[0]
        assert_kind(command, "CommandDecl")
        expect(command.name == "diagnostics", "nom de commande incorrect")
        let command_body = command.body.statements
        expect(command_body.len == 2, "le bloc doit contenir système + probe")

        let system_block = command_body[0]
        assert_kind(system_block, "SystemBlock")
        expect(system_block.system_kind == "interrupt", "mot-clé système incorrect")
        expect(system_block.name == "timer", "nom de bloc système attendu")
        expect(system_block.body.kind == "Block", "le corps système doit être un bloc")
        expect(system_block.body.statements.len == 2, "deux instrumentation statements attendus")

        let trace_stmt = system_block.body.statements[0]
        assert_kind(trace_stmt, "InstrumentationStmt")
        expect(trace_stmt.instrumentation_kind == "trace", "trace attendu")
        expect(trace_stmt.payload.target == "timeline", "cible trace incorrecte")
        expect(trace_stmt.payload.args.len == 1, "trace args manquants")
        let trace_arg = trace_stmt.payload.args[0]
        assert_kind(trace_arg, "MemberExpr")
        expect(trace_arg.target.kind == "Identifier", "trace arg base doit être un identifiant")
        expect(trace_arg.target.parts[0] == "event", "trace arg base incorrecte")
        expect(trace_arg.member == "id", "trace arg membre incorrect")

        let hook_stmt = system_block.body.statements[1]
        assert_kind(hook_stmt, "InstrumentationStmt")
        expect(hook_stmt.instrumentation_kind == "hook", "hook attendu")
        expect(hook_stmt.payload.target == "profiler", "cible hook incorrecte")
        let hook_arg = hook_stmt.payload.args[0]
        assert_kind(hook_arg, "MemberExpr")
        expect(hook_arg.via_pointer == true, "hook arg doit utiliser ->")
        expect(hook_arg.target.kind == "Identifier", "hook base doit être un identifiant")
        expect(hook_arg.target.parts[0] == "event", "hook base incorrecte")
        expect(hook_arg.member == "signal", "hook membre incorrect")

        let top_probe = command_body[1]
        assert_kind(top_probe, "InstrumentationStmt")
        expect(top_probe.instrumentation_kind == "probe", "probe attendu")
        expect(top_probe.payload.target == "metrics", "cible probe incorrecte")

        let native_ir = ir.lower(native_ast)
        expect(native_ir.len == 1, "une seule entrée IR attendue")
        let entry = native_ir[0]
        expect(entry.op == "entry", "opération d'entrée IR attendue")
        expect(entry.body.len == 2, "le bloc IR doit contenir 2 instructions")
        for stmt in entry.body:
            expect(stmt.op == "unknown", "les instrumentation restent inconnues pour l'instant")

    program native_parser_system_instr:
        scenario main(args):
            run_system_instrumentation_suite()
