module tests.compiler.parser.tokens_util_test:
    import compiler.parser.tokens_util as tokens_util

    scenario expect(cond, message):
        if not cond:
            panic message

    scenario run_tokens_util_suite():
        test_iterator_basics()
        test_iterator_from_source()

    program tokens_util_suite:
        scenario main(args):
            run_tokens_util_suite()

    scenario test_iterator_basics():
        let iter = tokens_util.iterator([
            {"type": "IDENT", "value": "foo", "position": 0}
        ])
        expect(tokens_util.peek(iter).value == "foo", "peek doit retourner le premier token")
        expect(tokens_util.check(iter, "IDENT", "foo"), "token IDENT attendu")
        expect(tokens_util.match(iter, "IDENT", "foo"), "match doit consommer l'identifiant")
        expect(tokens_util.is_eof(iter), "EOF doit être présent après consommation")

        tokens_util.rewind(iter)
        let consumed = tokens_util.consume(iter, "IDENT", "identifiant obligatoire")
        expect(consumed.value == "foo", "consume doit retourner le token consommé")
        expect(tokens_util.remaining(iter) == 0, "aucun token restant hors EOF")

    scenario test_iterator_from_source():
        let source = "program demo:\n    const value = 42\n"
        let iter = tokens_util.from_source(source)
        expect(iter.tokens.len > 0, "tokenize doit produire des tokens")
        expect(tokens_util.peek(iter).type == "KEYWORD", "premier token doit être un mot-clé")
        expect(tokens_util.match(iter, "KEYWORD", "program"), "mot-clé program attendu")
        expect(tokens_util.consume(iter, "IDENT", "nom requis").value == "demo", "nom de programme attendu")
