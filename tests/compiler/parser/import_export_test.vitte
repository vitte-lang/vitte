module tests.compiler.parser.import_export_test:
    import compiler.lexer as lexer
    import compiler.parser as native_parser
    import bootstrap.parser.parse as legacy_parser
    import bootstrap.compiler.ir as ir

    scenario expect(condition, message):
        if not condition:
            panic message

    scenario assert_kind(node, expected):
        expect(node != null, "node missing")
        expect(node.kind == expected, "attendu " + expected + " mais trouvé " + node.kind)

    scenario assert_directive(node, expected_kind):
        assert_kind(node, "Directive")
        expect(node.directive_kind == expected_kind, "directive " + expected_kind + " attendue")

    scenario run_import_export_suite():
        let source =
            "import runtime.fs as rfs from host.fs\n" +
            "export all from net.core\n" +
            "export only (foo, bar)\n" +
            "use runtime.log as log\n" +
            "requires(tool.runtime)\n" +
            "package runtime.console { level: debug }\n" +
            "feature tracing enable true\n"

            let native_tokens = lexer.tokenize(source)
            let native_ast = native_parser.parse(native_tokens)
            expect(native_ast.kind == "Block", "la racine doit être un bloc")
            expect(native_ast.statements.len == 7, "7 instructions attendues")
            let stmts = native_ast.statements

            let import_decl = stmts[0]
            assert_kind(import_decl, "ImportDecl")
            expect(import_decl.path == "runtime.fs", "chemin d'import incorrect")
            expect(import_decl.alias == "rfs", "alias d'import incorrect")
            expect(import_decl.clause.clause_kind == "from", "clause from attendue")
            expect(import_decl.clause.source == "host.fs", "source d'import incorrecte")

            let export_all = stmts[1]
            assert_kind(export_all, "ExportDecl")
            expect(export_all.export_all == true, "export all attendu")
            expect(export_all.clause.clause_kind == "from", "export from attendu")
            expect(export_all.clause.source == "net.core", "source export incorrecte")

            let export_only = stmts[2]
            assert_kind(export_only, "ExportDecl")
            expect(export_only.export_all == false, "export only attendue")
            expect(export_only.clause.clause_kind == "only", "clause only attendue")
            expect(export_only.clause.spec.len == 2, "2 symboles exportés attendus")
            expect(export_only.clause.spec[0] == "foo", "premier symbole export incorrect")
            expect(export_only.clause.spec[1] == "bar", "second symbole export incorrect")

            let use_dir = stmts[3]
            assert_directive(use_dir, "use")
            expect(use_dir.payload.ref == "runtime.log", "référence use incorrecte")
            expect(use_dir.payload.alias == "log", "alias use incorrect")

            let requires_dir = stmts[4]
            assert_directive(requires_dir, "requires")
            expect(requires_dir.payload.len == 1, "requires doit contenir un élément")
            expect(requires_dir.payload[0] == "tool.runtime", "référence requires incorrecte")

            let package_dir = stmts[5]
            assert_directive(package_dir, "package")
            expect(package_dir.payload.options.len == 1, "options package attendues")
            expect(package_dir.payload.options[0].name == "level", "clé option incorrecte")

            let feature_dir = stmts[6]
            assert_directive(feature_dir, "feature")
            expect(feature_dir.payload.name == "tracing", "feature name incorrect")
            expect(feature_dir.payload.value.value == true, "feature enable true attendu")

        let legacy_ast = legacy_parser.parse_module(lexer.tokenize(source))
        let native_ir = ir.lower(native_ast)
        let legacy_ir = ir.lower(legacy_ast)
        expect(native_ir.len == legacy_ir.len, "taille IR divergente")
        let i = 0
        while i < native_ir.len:
            expect(native_ir[i].op == legacy_ir[i].op, "op IR divergente à l'index " + i)
            i += 1

    program native_parser_import_export:
        scenario main(args):
            run_import_export_suite()
