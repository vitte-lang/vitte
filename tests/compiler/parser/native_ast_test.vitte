module tests.compiler.parser.native_ast_test:
    import compiler.lexer as lexer
    import compiler.parser as native_parser
    import bootstrap.parser.parse as legacy_parser
    import bootstrap.compiler.ir as ir

    scenario expect(condition, message):
        if not condition:
            panic message

    scenario assert_kind(node, expected):
        expect(node != null, "node missing")
        expect(node.kind == expected, "attendu " + expected + " mais trouvé " + node.kind)

    scenario run_fixture(source):
        let native_tokens = lexer.tokenize(source)
        let native_ast = native_parser.parse(native_tokens)

        expect(native_ast.kind == "Block", "la racine doit être un bloc")
        expect(native_ast.statements.len == 1, "un seul item racine attendu")

        let command = native_ast.statements[0]
        assert_kind(command, "CommandDecl")
        expect(command.command_kind == "service", "le mot-clé commande doit être conservé")

        let body_statements = command.body.statements
        expect(body_statements.len == 2, "le bloc doit contenir module + build")

        let module_decl = body_statements[0]
        assert_kind(module_decl, "ModuleDecl")
        expect(module_decl.name == "toolchain.core", "nom de module incorrect")

        let build_decl = body_statements[1]
        assert_kind(build_decl, "BuildDecl")
        expect(build_decl.name == "pipeline", "nom de build incorrect")

        let build_body = build_decl.body
        expect(build_body.kind == "Block", "le corps du build doit rester un bloc")
        expect(build_body.statements.len == 3, "stage, artifact et option attendus")

        let stage_decl = build_body.statements[0]
        assert_kind(stage_decl, "StageDecl")
        expect(stage_decl.body.kind == "Block", "le stage doit contenir un bloc")

        let artifact_decl = build_body.statements[1]
        assert_kind(artifact_decl, "ArtifactDecl")
        expect(artifact_decl.options.len == 1, "une option d'artifact attendue")
        assert_kind(artifact_decl.options[0], "BuildOption")

        let option_stmt = build_body.statements[2]
        assert_kind(option_stmt, "BuildOption")
        expect(option_stmt.name == "retries", "option de build renvoyée")

        let legacy_ast = legacy_parser.parse_module(lexer.tokenize(source))
        let native_ir = ir.lower(native_ast)
        let legacy_ir = ir.lower(legacy_ast)

        expect(native_ir.len == legacy_ir.len, "taille IR divergente")
        expect(native_ir[0].op == legacy_ir[0].op, "entrée principale incohérente")

        let native_body = native_ir[0].body
        let legacy_body = legacy_ir[0].body
        expect(native_body.len == legacy_body.len, "taille IR imbriquée divergente")
        expect(native_body[0].op == legacy_body[0].op, "module IR incohérent")
        expect(native_body[1].op == legacy_body[1].op, "build IR incohérent")

    scenario run_native_parser_suite():
        let source =
            "service native:\n" +
            "    module toolchain.core:\n" +
            "        feature debug enable true\n" +
            "    build pipeline:\n" +
            "        stage fetch:\n" +
            "            requires(tool.runtime)\n" +
            "        artifact image from builder {\n" +
            "            format: raw\n" +
            "        }\n" +
            "        option retries = 3\n"
        run_fixture(source)

    program native_parser_ast:
        scenario main(args):
            run_native_parser_suite()
