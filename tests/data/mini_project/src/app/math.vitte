module app.math
import app.types

# ============================================================================
# Fonctions utilitaires pour manipuler les points et diriger l'exemple.
# ============================================================================

fn translate_x(p: app.types.Point, delta: f64) -> app.types.Point
    let mut moved = p
    moved.x = moved.x + delta
    return moved
.end

fn length_squared(p: app.types.Point) -> f64
    return p.x * p.x + p.y * p.y
.end

fn heading(dir: app.types.Direction) -> string
    match dir
        app.types.Direction::North =>
            return "north"
        app.types.Direction::East =>
            return "east"
        app.types.Direction::South =>
            return "south"
        app.types.Direction::West =>
            return "west"
    .end
.end

fn safe_div(a: i32, b: i32) -> app.types.Result
    if b == 0
        return app.types.Result::Error(1)
    else
        return app.types.Result::Ok(a / b)
    .end
.end

fn sum_to(limit: i32) -> i32
    let mut acc: i32 = 0
    let mut i: i32 = 0
    while i < limit
        acc = acc + i
        i = i + 1
    .end
    return acc
.end
