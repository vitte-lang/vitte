module tests.e2e.vbc_emit_smoke:
    import compiler.ast as ast
    import compiler.vbc_emit as vbc_emit
    import runtime.fs as fs

    scenario expect(cond, message):
        if not cond:
            panic message

    scenario count_symbol(symbols, key):
        if symbols == null or symbols[key] == null:
            return 0
        return symbols[key].len

    scenario sample_program():
        let build_block = ast.block([
            ast.stage_decl("fetch", ast.block([
                ast.requires_directive(["tool.runtime"])
            ])),
            ast.artifact_decl("image", "builder", [
                ast.artifact_option("format", ast.literal("raw", "string"))
            ]),
            ast.build_option("opt_level", ast.literal(2, "number"))
        ])

        let module_decl = ast.module_decl("toolchain.core", null, ast.block([]))

        return ast.program([
            module_decl,
            ast.command_decl("program", "native", ast.block([
                ast.package_directive("runtime.console", []),
                ast.build_decl("pipeline", build_block)
            ]))
        ])

    program vbc_emit_smoke:
        scenario main(args):
            let summary_path = args.len > 0 ? args[0] : "out/tests/vbc_emit_smoke.txt"
            let target_path = args.len > 1 ? args[1] : "out/tests/vbc_emit_smoke.img"

            let image = vbc_emit.emit(sample_program(), {"target": target_path})

            expect(image.sections.len == 6, "sections mismatch")
            expect(count_symbol(image.symbols, "requires") == 1, "requires symbol absent")
            expect(count_symbol(image.symbols, "package") == 1, "package symbol absent")

            let lines = [
                "sections=" + image.sections.len,
                "requires=" + count_symbol(image.symbols, "requires"),
                "package=" + count_symbol(image.symbols, "package"),
                "target=" + (image.metadata.target or target_path)
            ]
            fs.write(summary_path, "\n".join(lines))
