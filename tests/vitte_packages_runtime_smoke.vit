space tests/vitte_packages_runtime_smoke

use vitte/collections as v_col
use vitte/array as v_array
use vitte/stats as v_stats
use vitte/ml as v_ml
use vitte/runtime as v_rt
use vitte/plot as v_plot
use vitte/async as v_async
use vitte/serialize as v_serialize
use vitte/cli as v_cli
use vitte/http as v_http
use vitte/db as v_db
use vitte/graph as v_graph
use vitte/ecs as v_ecs
use vitte/sql as v_sql
use vitte/cache as v_cache
use vitte/auth as v_auth
use vitte/tls as v_tls
use vitte/http_client as v_http_client
use vitte/requests as v_requests
use vitte/channel as v_channel
use vitte/actor as v_actor
use vitte/retry as v_retry
use vitte/circuit_breaker as v_circuit_breaker
use vitte/rate_limit as v_rate_limit
use vitte/queue as v_queue
use vitte/stream as v_stream
use vitte/codec as v_codec
use vitte/kv as v_kv
use vitte/lsp as v_lsp
use vitte/timeout as v_timeout
use vitte/bulkhead as v_bulkhead
use vitte/outbox as v_outbox
use vitte/saga as v_saga
use vitte/schema_registry as v_schema_registry
use vitte/tenant as v_tenant
use vitte/health as v_health
use vitte/pagination as v_pagination
use vitte/search as v_search
use vitte/alerts as v_alerts
use vitte/slo as v_slo
use vitte/fixtures as v_fixtures
use vitte/mock_http as v_mock_http
use vitte/observability as v_observability
use vitte/contracts as v_contracts
use vitte/jobs as v_jobs
use vitte/policy as v_policy
use vitte/idempotency as v_idempotency

proc main_job() -> int {
  give 0
}

entry main at tests/packages_runtime {
  let xs = [1.0, 2.0, 3.0]
  let ys = [1.0, 2.0, 3.5]

  let arr = v_array.ndarray_1d(3)
  let m = v_stats.mean(xs)
  let var = v_stats.variance(xs)
  let _ = v_stats.linear_regression(xs, ys)
  let pred = v_ml.perceptron_predict([0.5, 0.5, 0.5], xs, 0.0)
  let step = v_ml.logistic_regression_step(0.1, 1.0, 1.0, 0.01)

  let rope = v_col.rope_append(v_col.rope_new(), "ok")
  let txt = v_col.rope_to_string(rope)

  let svg = v_plot.plot_line("demo")
  let png = v_plot.export_png(svg)

  let code = v_rt.run(main_job)
  let task_state = v_async.run_with_retry(main_job, 1)

  let opts = v_serialize.default_options()
  let encoded = v_serialize.encode(v_serialize.SerializeFormat.Json, "k", "v", opts)
  let parsed_true = v_serialize.parse_bool("true", false)

  let parsed_cli = v_cli.parse(["vitte", "serve", "--help"])
  let cli_usage = v_cli.usage(v_cli.spec("vitte", "0.1", "compiler"))

  let req = v_http.get("/health")
  let resp = v_http.handle(req)

  let s0 = v_db.open("memory://test")
  let s1 = v_db.begin_tx(s0)
  let rows = v_db.exec(s1, "INSERT demo")

  let g0 = v_graph.graph_new(3, true)
  let g1 = v_graph.add_edge(g0, 0, 1, 5)
  let g2 = v_graph.add_edge(g1, 1, 2, 8)
  let has_0_1 = v_graph.has_edge(g2, 0, 1)
  let deg_1 = v_graph.degree_out(g2, 1)

  let w0 = v_ecs.world_new()
  let w1 = v_ecs.spawn(w0)
  let e0 = v_ecs.last_spawned_id(w1)
  let w2 = v_ecs.add_position(w1, e0, 10, 20)
  let w3 = v_ecs.add_velocity(w2, e0, 2, -1)
  let w4 = v_ecs.step(w3)
  let px = v_ecs.position_x(w4, e0)
  let py = v_ecs.position_y(w4, e0)
  let alive = v_ecs.is_alive(w4, e0)

  let sql_conn0 = v_sql.connect("postgres://demo")
  let sql_conn1 = v_sql.begin(sql_conn0)
  let sql_q_read = v_sql.query("SELECT 1")
  let sql_q_write = v_sql.query_with_params("INSERT demo VALUES (?)", 1)
  let sql_rows = v_sql.execute(sql_conn1, sql_q_write)
  let sql_one = v_sql.fetch_one(sql_conn1, sql_q_read)
  let sql_plan = v_sql.explain(sql_q_read)

  let c0 = v_cache.cache_new(2)
  let c1 = v_cache.put(c0, "a", "1", 3)
  let c2 = v_cache.put(c1, "b", "2", 2)
  let c3 = v_cache.touch(c2, "a")
  let c4 = v_cache.tick(c3, 1)
  let c5 = v_cache.put(c4, "c", "3", 2)
  let cache_a = v_cache.get(c5, "a", "")
  let cache_b = v_cache.contains(c5, "b")
  let cache_size = v_cache.size(c5)

  let principal = v_auth.authenticate("alice", "pw")
  let auth_session = v_auth.issue_token(principal, 60)
  let auth_ok = v_auth.validate(auth_session, 10) == v_auth.AuthError.None
  let auth_user_ok = v_auth.can_access(auth_session, v_auth.AuthRole.User, 10)
  let auth_admin_ok = v_auth.can_access(auth_session, v_auth.AuthRole.Admin, 10)
  let auth_revoked = v_auth.revoke(auth_session)
  let auth_after_revoke = v_auth.validate(auth_revoked, 10) == v_auth.AuthError.MissingToken

  let tls_cfg = v_tls.default_config()
  let tls0 = v_tls.open("api.local", tls_cfg)
  let tls1 = v_tls.handshake(tls0, true)
  let tls2 = v_tls.send(tls1, "hello")
  let tls3 = v_tls.recv(tls2, "cipher_data")
  let tls_secure = v_tls.is_secure(tls3)
  let tls_out = v_tls.bytes_out(tls3)
  let tls_in = v_tls.bytes_in(tls3)

  let hc_req0 = v_http_client.get("https://api/health")
  let hc_req1 = v_http_client.with_timeout(hc_req0, 900)
  let hc_resp = v_http_client.perform(hc_req1)
  let hc_ok = v_http_client.is_ok(hc_resp)

  let req_opts0 = v_requests.options("https://api")
  let req_opts1 = v_requests.with_token(req_opts0, "token")
  let req_status = v_requests.fetch_status(req_opts1, "/health")
  let req_text = v_requests.fetch_text(req_opts1, "/health")
  let req_retry = v_requests.run_with_retry(v_requests.with_retries(req_opts1, 1), "/busy")
  let req_attempts = v_requests.result_attempts(req_retry)

  let ch0 = v_channel.channel_bounded(2)
  let ch1 = v_channel.send(ch0, "m1")
  let ch2 = v_channel.send(ch1, "m2")
  let ch3 = v_channel.send(ch2, "m3")
  let ch_head = v_channel.peek(ch3)
  let ch4 = v_channel.pop(ch3)
  let ch_len = v_channel.len(ch4)
  let ch_drop = v_channel.dropped(ch3)

  let a0 = v_actor.actor_new(1, "worker")
  let a1 = v_actor.send(a0, "job1")
  let a2 = v_actor.send(a1, "job2")
  let a3 = v_actor.step(a2)
  let a4 = v_actor.fail(a3)
  let actor_proc = v_actor.processed_count(a3)
  let actor_running = v_actor.is_running(a3)
  let actor_decision = v_actor.supervision_decision(a4, 0)

  let q0 = v_queue.queue_new(2)
  let q1 = v_queue.enqueue(q0, "job-a")
  let q2 = v_queue.enqueue(q1, "job-b")
  let q3 = v_queue.dequeue(q2)
  let q4 = v_queue.nack(q3, 0)
  let q5 = v_queue.dequeue(q4)
  let q6 = v_queue.ack(q5, 1)
  let q7 = v_queue.dequeue(q6)
  let q8 = v_queue.nack(q7, 0)
  let queue_can_dequeue = v_queue.can_dequeue(q8)
  let queue_peek = v_queue.peek(q4)
  let queue_attempt_dead = v_queue.attempts_of(q8, 0)
  let q9 = v_queue.requeue_dead(q8, 0)
  let q10 = v_queue.purge_done(q9)
  let queue_total = v_queue.total_count(q10)
  let queue_stats = v_queue.stats(q10)
  let queue_dlq = v_queue.dlq(q8)
  let queue_pending = v_queue.pending_count(q8)
  let queue_inflight = v_queue.inflight_count(q8)
  let queue_done = v_queue.done_count(q8)

  let st0 = v_stream.stream_new(5, 2, 3)
  let st1 = v_stream.push(st0, "ev1", 1)
  let st2 = v_stream.push(st1, "ev2", 2)
  let st3 = v_stream.push(st2, "ev3", 6)
  let stream_backpressure = v_stream.backpressure(st3)
  let st4 = v_stream.push(st3, "ev4", 7)
  let stream_batch = v_stream.batch(st4)
  let stream_window = v_stream.window(st4, 10)
  let st5 = v_stream.drain_batch(st4)
  let stream_available = v_stream.available(st5)
  let stream_oldest = v_stream.oldest_tick(st4)
  let stream_newest = v_stream.newest_tick(st4)
  let stream_lag = v_stream.lag_ticks(st4, 10)
  let stream_window_count = v_stream.window_count(st4, 10)
  let stream_overflow = v_stream.overflow_count(st4)
  let st6 = v_stream.flush(st5)
  let stream_stats = v_stream.stats(st6)

  let codec_json = v_codec.encode(v_codec.CodecFormat.Json, "k", "v")
  let codec_mp = v_codec.encode(v_codec.CodecFormat.MsgPack, "k", "v")
  let codec_bin = v_codec.encode(v_codec.CodecFormat.Binary, "k", "v")
  let codec_detect_json = v_codec.detect(codec_json.data)
  let codec_detect_mp = v_codec.detect(codec_mp.data)
  let codec_detect_bin = v_codec.detect(codec_bin.data)
  let codec_decode = v_codec.decode(codec_bin)
  let codec_pair = v_codec.decode_pair(codec_json)
  let codec_conv = v_codec.convert(codec_mp, v_codec.CodecFormat.Json)
  let codec_ext = v_codec.format_extension(v_codec.CodecFormat.Binary)
  let codec_textual = v_codec.is_textual(v_codec.CodecFormat.Json)
  let codec_fp = v_codec.fingerprint(codec_conv)
  let codec_can = v_codec.can_decode(codec_mp)
  let codec_rt = v_codec.roundtrip(v_codec.CodecFormat.Json, "x", "y")
  let codec_name = v_codec.format_name(v_codec.CodecFormat.MsgPack)

  let kv0 = v_kv.kv_new()
  let kv1 = v_kv.put(kv0, "cfg:a", "1", 3)
  let kv2 = v_kv.put(kv1, "cfg:b", "2", 0)
  let kv3 = v_kv.tick(kv2, 2)
  let kv_has_a = v_kv.has(kv3, "cfg:a")
  let kv_scan = v_kv.scan(kv3, "cfg:")
  let kv_keys = v_kv.keys(kv3, "cfg:")
  let kv4 = v_kv.tick(kv3, 2)
  let kv_get_a = v_kv.get(kv4, "cfg:a", "")
  let kv_get_b = v_kv.get(kv4, "cfg:b", "")
  let kv_ttl_b = v_kv.ttl_left(kv4, "cfg:b")
  let kv5 = v_kv.touch(kv4, "cfg:b", 5)
  let kv6 = v_kv.delete(kv5, "cfg:b")
  let kv7 = v_kv.expire(kv6)
  let kv_size = v_kv.size(kv7)
  let kv_stats = v_kv.stats(kv7)

  let lsp0 = v_lsp.index_new()
  let lsp1 = v_lsp.index(lsp0, "file:///main.vit", "todo panic", 1)
  let lsp2 = v_lsp.index(lsp1, "file:///empty.vit", "", 1)
  let lsp_main_diags = v_lsp.diagnostics(lsp2, "file:///main.vit")
  let lsp_empty_diags = v_lsp.diagnostics(lsp2, "file:///empty.vit")
  let lsp_fix = v_lsp.quick_fix(lsp_main_diags[1])
  let lsp_diag_count = v_lsp.diagnostics_count(lsp2, "file:///main.vit")
  let lsp_error_count = v_lsp.error_count(lsp2, "file:///main.vit")
  let lsp_has_errors = v_lsp.has_errors(lsp2, "file:///main.vit")
  let lsp_fixed_text = v_lsp.apply_quick_fix("todo panic", lsp_main_diags[0].code)
  let lsp_summary = v_lsp.summary(lsp2, "file:///main.vit")
  let lsp_docs = v_lsp.doc_count(lsp2)

  let t0 = v_timeout.timeout_new(100, 50)
  let t1 = v_timeout.with_deadline(t0, 130)
  let timeout_ok = !v_timeout.expired(t1, 120)
  let timeout_expired = v_timeout.expired(t1, 130)
  let timeout_remaining = v_timeout.remaining_ms(t1, 120)
  let timeout_elapsed = v_timeout.elapsed_ms(t1, 120)
  let timeout_started = v_timeout.started_at(t1)
  let timeout_deadline = v_timeout.deadline_at(t1)
  let timeout_budget = v_timeout.budget(t1)
  let timeout_within = v_timeout.within(t1, 120)
  let t1_clamped = v_timeout.clamp_deadline(t1, 110, 125)
  let t1_shifted = v_timeout.shift(t1, 10)
  let timeout_can_spend = v_timeout.can_spend(t1, 120, 5)
  let timeout_cannot_spend = v_timeout.can_spend(t1, 120, 20)
  let timeout_overspent = v_timeout.overspent(t1, 70)
  let t1_budget = v_timeout.with_budget(t1, 60)
  let t1_extended = v_timeout.extend(t1_budget, 10)
  let timeout_overrun = v_timeout.deadline_overrun(t1_extended, 180)
  let timeout_active = v_timeout.is_active(t1)
  let timeout_guard = v_timeout.guard(t1, 40)
  let timeout_with_active = v_timeout.with_active(t1, false)
  let t2 = v_timeout.stop(t1)
  let timeout_stopped_expired = v_timeout.expired(t2, 121)
  let timeout_stopped = v_timeout.is_stopped(t2)
  let t2_active = v_timeout.ensure_active(t2)
  let t3 = v_timeout.restart(t2, 200, 20)
  let timeout_restart_remaining = v_timeout.remaining_ms(t3, 210)
  let timeout_stats = v_timeout.stats(t3, 210)

  let bh0 = v_bulkhead.bulkhead_new(2)
  let bh1 = v_bulkhead.acquire(bh0)
  let bh2 = v_bulkhead.acquire(bh1)
  let bh3 = v_bulkhead.acquire(bh2)
  let bh4 = v_bulkhead.release(bh3)
  let bh5 = v_bulkhead.close_gate(bh4)
  let bh6 = v_bulkhead.open_gate(bh5)
  let bh7 = v_bulkhead.acquire(bh5)
  let bh8 = v_bulkhead.drain_queue(bh4)
  let bh9 = v_bulkhead.resize(bh8, 1)
  let bh10 = v_bulkhead.reset_stats(bh9)
  let bulkhead_avail_full = v_bulkhead.available(bh2)
  let bulkhead_avail_after = v_bulkhead.available(bh4)
  let bulkhead_can_accept = v_bulkhead.can_accept(bh6)
  let bulkhead_open = v_bulkhead.is_open(bh6)
  let bulkhead_qdepth = v_bulkhead.queue_depth(bh3)
  let bulkhead_rejected = v_bulkhead.rejected_count(bh7)
  let bulkhead_has_queue = v_bulkhead.has_queue(bh3)
  let bulkhead_util = v_bulkhead.utilization_percent(bh2)
  let bulkhead_stats = v_bulkhead.stats(bh10)

  let idem0 = v_idempotency.store_new()
  let idem1 = v_idempotency.store_result(idem0, "k1", "R1", 10, 1)
  let idem_put_absent = v_idempotency.put_if_absent(idem1, "k1", "R2", 10, 2)
  let idem2 = v_idempotency.touch_key(idem_put_absent, "k1", 20, 3)
  let idem_rec = v_idempotency.get_record(idem2, "k1", 4)
  let idem_has = v_idempotency.has_key(idem2, "k1", 4)
  let idem_check = v_idempotency.check_key(idem2, "k1", 4)
  let idem_ttl = v_idempotency.ttl_left(idem2, "k1", 4)
  let idem_keys = v_idempotency.keys(idem2, 4)
  let idem_replay = v_idempotency.replay_result(idem2, "k1", 4)
  let idem_count = v_idempotency.count(idem2, 4)
  let idem3 = v_idempotency.remove_key(idem2, "k1", 4)
  let idem_empty = v_idempotency.is_empty(idem3, 4)
  let idem_stats = v_idempotency.stats(idem2, 4)

  let ct0 = v_contracts.contract_load("user-api", "1.0.0", "sha-a", ["id", "name"])
  let ct1 = v_contracts.add_required_field(ct0, "email")
  let ct2 = v_contracts.with_hash(ct1, "sha-b")
  let ct_name = v_contracts.contract_name(ct2)
  let ct_version = v_contracts.contract_version(ct2)
  let ct_hash = v_contracts.contract_hash(ct2)
  let ct_fields = v_contracts.field_count(ct2)
  let ct_has_email = v_contracts.has_required_field(ct2, "email")
  let ct_ok = v_contracts.contract_verify(ct2, "{\"id\":1,\"name\":\"n\",\"email\":\"e\"}")
  let ct_non_empty = v_contracts.verify_payload_non_empty(ct2, "{\"id\":1,\"name\":\"n\",\"email\":\"e\"}")
  let ct_missing = v_contracts.first_missing_field(ct2, "{\"id\":1,\"name\":\"n\"}")
  let ct_same = v_contracts.same_identity(ct0, ct1)
  let ct_diff = v_contracts.diff(ct0, ct2)
  let ct_breaking = v_contracts.is_breaking(ct0, ct2)
  let ct_summary = v_contracts.contract_summary(ct2)

  let jb0 = v_jobs.queue_new(2)
  let jb1 = v_jobs.enqueue(jb0, "job-a")
  let jb2 = v_jobs.enqueue(jb1, "job-b")
  let jb3 = v_jobs.dequeue(jb2)
  let jb4 = v_jobs.nack(jb3, 0)
  let jb5 = v_jobs.dequeue(jb4)
  let jb6 = v_jobs.ack(jb5, 1)
  let jb7 = v_jobs.dequeue(jb6)
  let jb8 = v_jobs.nack(jb7, 0)
  let jb9 = v_jobs.requeue_dead(jb8, 0)
  let jb10 = v_jobs.clear_done(jb9)
  let jb11 = v_jobs.clear_dlq(jb10)
  let jobs_pending = v_jobs.pending_count(jb8)
  let jobs_inflight = v_jobs.inflight_count(jb8)
  let jobs_done = v_jobs.done_count(jb8)
  let jobs_dlq = v_jobs.dlq_count(jb8)
  let jobs_total = v_jobs.total_count(jb8)
  let jobs_has_pending = v_jobs.has_pending(jb8)
  let jobs_has_inflight = v_jobs.has_inflight(jb8)
  let jobs_has_done = v_jobs.has_done(jb8)
  let jobs_has_dlq = v_jobs.has_dlq(jb8)
  let jobs_next_pending = v_jobs.next_pending_id(jb8)
  let jobs_attempt_0 = v_jobs.attempts_of(jb8, 0)
  let jobs_state_0 = v_jobs.state_of(jb8, 0)
  let jobs_state_1 = v_jobs.state_of(jb8, 1)
  let jobs_state_missing = v_jobs.state_of(jb8, 999)
  let jobs_stats = v_jobs.stats(jb8)

  let pl0 = v_policy.policy_load(false)
  let pl1 = v_policy.add_rule(pl0, "alice", "read", "invoice", v_policy.Effect.Allow, "reader")
  let pl2 = v_policy.add_rule(pl1, "alice", "delete", "invoice", v_policy.Effect.Deny, "forbidden-delete")
  let pl3 = v_policy.add_rule(pl2, "*", "list", "*", v_policy.Effect.Allow, "browse")
  let pl_rules = v_policy.rule_count(pl3)
  let pl_mode = v_policy.default_mode(pl3)
  let pl_subject_rules = v_policy.subject_rule_count(pl3, "alice")
  let pl_has = v_policy.has_rule(pl3, "alice", "read", "invoice")
  let pl_first = v_policy.first_match(pl3, "alice", "delete", "invoice")
  let pl_allow = v_policy.allow(pl3, "alice", "read", "invoice")
  let pl_deny = v_policy.allow(pl3, "alice", "delete", "invoice")
  let pl_decision = v_policy.decision(pl3, "alice", "delete", "invoice")
  let pl_reason = v_policy.deny_reason(pl3, "alice", "delete", "invoice")
  let pl_explain = v_policy.explain(pl3, "alice", "delete", "invoice")
  let pl4 = v_policy.remove_rule(pl3, 1)
  let pl5 = v_policy.set_default_allow(pl4, true)
  let pl_default_deny = v_policy.is_default_deny(pl3)
  let pl_allow_default = v_policy.allow(pl5, "alice", "delete", "invoice")
  let pl_stats = v_policy.stats(pl3)

  let ov_span0 = v_observability.trace_start("runtime", 100)
  let ov_span1 = v_observability.with_trace_id(ov_span0, "tr-custom")
  let ov_span2 = v_observability.trace_end(ov_span1, 140)
  let ov_span3 = v_observability.trace_reopen(ov_span2, 150)
  let ov_span4 = v_observability.trace_end(ov_span3, 180)
  let ov_span5 = v_observability.trace_start_with_id("io", "trace-1", 200)
  let ov_span_open = v_observability.trace_is_open(ov_span0)
  let ov_span_closed = v_observability.trace_is_closed(ov_span2)
  let ov_span_name = v_observability.trace_name(ov_span4)
  let ov_duration = v_observability.trace_duration(ov_span2)
  let ov_trace_summary = v_observability.trace_summary(ov_span4)
  let ov_ctr0 = v_observability.counter_new("jobs")
  let ov_ctr1 = v_observability.counter_with_trace(ov_ctr0, ov_span2.trace_id)
  let ov_ctr2 = v_observability.counter_inc(ov_ctr1, 3)
  let ov_ctr3 = v_observability.counter_inc(ov_ctr2, 2)
  let ov_ctr_merge = v_observability.counter_merge(ov_ctr2, ov_ctr3)
  let ov_ctr_reset = v_observability.counter_reset(ov_ctr3)
  let ov_ctr_value = v_observability.counter_value(ov_ctr3)
  let ov_ctr_zero = v_observability.counter_is_zero(ov_ctr_reset)
  let ov_hist0 = v_observability.histogram_new("lat")
  let ov_hist1 = v_observability.histogram_with_trace(ov_hist0, ov_span2.trace_id)
  let ov_hist2 = v_observability.histogram_observe(ov_hist1, 8)
  let ov_hist3 = v_observability.histogram_observe(ov_hist2, 12)
  let ov_hist4 = v_observability.histogram_observe(ov_hist1, 20)
  let ov_hist_merge = v_observability.histogram_merge(ov_hist3, ov_hist4)
  let ov_hist_empty = v_observability.histogram_empty(ov_hist0)
  let ov_hist_min = v_observability.histogram_min(ov_hist3)
  let ov_hist_max = v_observability.histogram_max(ov_hist3)
  let ov_hist_range = v_observability.histogram_range(ov_hist3)
  let ov_hist_avg = v_observability.histogram_avg(ov_hist3)
  let ov_metrics = v_observability.metrics_summary(ov_ctr3, ov_hist3)

  let ob0 = v_outbox.outbox_new()
  let ob1 = v_outbox.enqueue_event(ob0, "user.created", "{\"id\":1}")
  let ob2 = v_outbox.enqueue_event(ob1, "user.updated", "{\"id\":1,\"name\":\"n\"}")
  let ob3 = v_outbox.flush_batch(ob2, 1)
  let ob4 = v_outbox.mark_sent(ob3, 0)
  let ob5 = v_outbox.retry_event(ob4, 1)
  let ob6 = v_outbox.prune_sent(ob5)
  let ob7 = v_outbox.mark_all_sent(ob5)
  let ob8 = v_outbox.clear(ob5)
  let outbox_pending = v_outbox.pending_count(ob4)
  let outbox_flushed = v_outbox.flushed_count(ob3)
  let outbox_flushed_pending = v_outbox.flushed_pending_count(ob3)
  let outbox_payload = v_outbox.replay_payload(ob4, 1)
  let outbox_payload_size = v_outbox.payload_size(ob5, 1)
  let outbox_events = v_outbox.event_count(ob4)
  let outbox_sent = v_outbox.sent_count(ob4)
  let outbox_event_1 = v_outbox.get_event(ob5, 1)
  let outbox_ids = v_outbox.event_ids(ob5)
  let outbox_pending_ids = v_outbox.pending_ids(ob5)
  let outbox_has_0 = v_outbox.has_event(ob4, 0)
  let outbox_attempt_1 = v_outbox.attempt_of(ob5, 1)
  let outbox_max_attempts = v_outbox.max_attempts(ob5)
  let outbox_first_created = v_outbox.first_by_topic(ob5, "user.created")
  let outbox_next = v_outbox.next_pending(ob5)
  let outbox_topic_created = v_outbox.topic_count(ob5, "user.created")
  let outbox_status_0 = v_outbox.status(ob5, 0)
  let outbox_status_1 = v_outbox.status(ob5, 1)
  let outbox_events_after_prune = v_outbox.event_count(ob6)
  let outbox_empty_after_clear = v_outbox.is_empty(ob8)
  let outbox_sent_ids = v_outbox.sent_ids(ob4)
  let outbox_flushed_ids = v_outbox.flushed_ids(ob3)
  let outbox_pending_by_topic = v_outbox.pending_by_topic(ob4, "user.updated")
  let outbox_oldest_pending = v_outbox.oldest_pending_id(ob4)
  let ob9 = v_outbox.retry_all_pending(ob4)
  let outbox_can_flush = v_outbox.can_flush(ob4)
  let outbox_drained = v_outbox.is_drained(ob7)
  let outbox_summary = v_outbox.event_summary(ob4, 1)
  let outbox_invariants = v_outbox.verify_invariants(ob9)
  let outbox_stats = v_outbox.stats(ob6)

  let sg0 = v_saga.saga_new("payment-1")
  let sg1 = v_saga.step_add(sg0, "reserve_stock")
  let sg2 = v_saga.step_add(sg1, "charge_card")
  let sg3 = v_saga.run(sg2, 1)
  let sg3_fail_alias = v_saga.fail(sg2, 1)
  let sg4 = v_saga.compensate(sg3)
  let sg5 = v_saga.resume(sg4)
  let sg6 = v_saga.reset(sg4)
  let sg7 = v_saga.add_steps(v_saga.saga_new("payment-2"), ["reserve", "charge", "emit"])
  let sg8 = v_saga.mark_done(sg2, "charge_card")
  let sg9 = v_saga.mark_compensated(sg8, "charge_card")
  let saga_step0 = v_saga.get_step(sg3, 0)
  let saga_step_missing = v_saga.get_step(sg3, 9)
  let saga_has_charge = v_saga.has_step(sg3, "charge_card")
  let saga_next_pending = v_saga.next_pending_step(sg3)
  let saga_can_run_failed = v_saga.can_run(sg3)
  let saga_failed_index = v_saga.failed_index(sg3)
  let saga_progress = v_saga.progress_percent(sg3)
  let saga_is_failed = v_saga.is_failed(sg3)
  let saga_is_succeeded = v_saga.is_succeeded(sg5)
  let saga_is_compensated = v_saga.is_compensated(sg4)
  let saga_steps = v_saga.step_count(sg4)
  let saga_compensated = v_saga.compensated_count(sg4)
  let saga_done = v_saga.done_count(sg3)
  let saga_pending = v_saga.pending_count(sg3)
  let saga_failed_name = v_saga.failed_step(sg3)
  let saga_step_idx = v_saga.step_index(sg3, "charge_card")
  let saga_step_done_reserve = v_saga.step_done(sg3, "reserve_stock")
  let saga_step_comp_charge = v_saga.step_compensated(sg4, "charge_card")
  let saga_all_done = v_saga.all_done(sg5)
  let saga_all_compensated = v_saga.all_compensated(sg4)
  let saga_can_compensate = v_saga.can_compensate(sg3)
  let saga_can_resume = v_saga.can_resume(sg4)
  let sg10 = v_saga.rename_step(sg7, "emit", "publish")
  let sg11 = v_saga.append_step_suffix(sg10, "_v1")
  let saga_failure_ratio = v_saga.failure_ratio_percent(sg3)
  let saga_invariants = v_saga.verify_invariants(sg4)
  let saga_terminal = v_saga.is_terminal(sg4)
  let saga_state_name = v_saga.state_name(sg4)
  let saga_stats = v_saga.stats(sg5)

  let sr0 = v_schema_registry.registry_new()
  let sr1 = v_schema_registry.register(sr0, "user", 1, "fp1", ["id", "name"])
  let sr2 = v_schema_registry.register(sr1, "user", 2, "fp2", ["id", "name", "email"])
  let sr3 = v_schema_registry.deactivate(sr2, "user", 2)
  let sr4 = v_schema_registry.reactivate(sr3, "user", 2)
  let sr5 = v_schema_registry.remove(sr4, "user", 2)
  let sr_base = v_schema_registry.latest(sr1, "user")
  let sr_latest = v_schema_registry.latest(sr2, "user")
  let schema_compat = v_schema_registry.compatible(sr_base, sr_latest)
  let schema_compat_bidir = v_schema_registry.compatible_bidirectional(sr_base, sr_latest)
  let schema_diff = v_schema_registry.diff(sr_base, sr_latest)
  let schema_breaking = v_schema_registry.is_breaking(sr_latest, sr_base)
  let schema_count = v_schema_registry.count(sr2, "user")
  let schema_subject_total = v_schema_registry.subject_total_count(sr3, "user")
  let schema_active_count = v_schema_registry.active_count(sr3)
  let schema_inactive_count = v_schema_registry.inactive_count(sr3)
  let schema_subject_exists_user = v_schema_registry.subject_exists(sr3, "user")
  let schema_subject_exists_order = v_schema_registry.subject_exists(sr3, "order")
  let schema_v1 = v_schema_registry.get(sr2, "user", 1)
  let schema_has_v2 = v_schema_registry.has(sr2, "user", 2)
  let schema_has_v2_after = v_schema_registry.has(sr3, "user", 2)
  let schema_has_v2_reactivated = v_schema_registry.has(sr4, "user", 2)
  let schema_has_v2_removed = v_schema_registry.has(sr5, "user", 2)
  let schema_latest_version = v_schema_registry.latest_version(sr2, "user")
  let schema_fields = v_schema_registry.field_count(sr_latest)
  let schema_has_email = v_schema_registry.has_field(sr_latest, "email")
  let schema_subjects = v_schema_registry.subjects(sr2)
  let schema_versions = v_schema_registry.versions(sr2, "user")
  let schema_fingerprints = v_schema_registry.fingerprints(sr2, "user")
  let schema_level = v_schema_registry.compatibility_level(sr_base, sr_latest)
  let schema_total = v_schema_registry.total_count(sr2)
  let sr6 = v_schema_registry.register_next(sr2, "user", "fp3", ["id", "name", "email", "age"])
  let schema_subject_count = v_schema_registry.subject_count(sr6)
  let schema_next_version = v_schema_registry.next_version(sr2, "user")
  let schema_latest_fingerprint = v_schema_registry.latest_fingerprint(sr6, "user")
  let schema_first_inactive = v_schema_registry.first_inactive_version(sr3, "user")
  let schema_order_empty = v_schema_registry.is_subject_empty(sr2, "order")
  let schema_active_ratio = v_schema_registry.active_ratio_percent(sr3)
  let schema_record_summary = v_schema_registry.record_summary(sr_latest)
  let schema_subject_stats = v_schema_registry.subject_stats(sr3, "user")
  let schema_invariants = v_schema_registry.verify_invariants(sr6)
  let schema_stats = v_schema_registry.stats(sr2)

  let tenant_ctx = v_tenant.tenant_ctx("t1", "eu", "pro")
  let tenant_default = v_tenant.default_ctx()
  let tenant_tid = v_tenant.tenant_id_of(tenant_ctx)
  let tenant_key = v_tenant.scope_key(tenant_ctx, "invoice:1")
  let tenant_scope_prefix = v_tenant.has_scope_prefix(tenant_ctx, tenant_key)
  let tenant_iso_ok = v_tenant.enforce_isolation(tenant_ctx, "t1")
  let tenant_iso_bad = v_tenant.enforce_isolation(tenant_ctx, "t2")
  let tenant_current = v_tenant.current([tenant_ctx])
  let tenant_off = v_tenant.deactivate(tenant_ctx)
  let tenant_on = v_tenant.activate(tenant_off)
  let tenant_regioned = v_tenant.with_region(tenant_on, "us")
  let tenant_planned = v_tenant.with_plan(tenant_regioned, "enterprise")
  let tenant_active = v_tenant.is_active(tenant_planned)
  let tenant_valid = v_tenant.is_valid(tenant_planned)
  let tenant_region_key = v_tenant.region_key(tenant_planned, "invoice:1")
  let tenant_plan_ok = v_tenant.plan_allows(tenant_planned, "pro")
  let tenant_is_enterprise = v_tenant.is_enterprise(tenant_planned)
  let tenant_can_access_region = v_tenant.can_access_region(tenant_planned, "us")
  let tenant_cannot_access_region = v_tenant.can_access_region(tenant_off, "us")
  let tenant_same_region = v_tenant.same_region(tenant_regioned, tenant_planned)
  let tenant_stack1 = v_tenant.stack_push([], tenant_ctx)
  let tenant_stack2 = v_tenant.stack_push(tenant_stack1, tenant_planned)
  let tenant_stack_depth = v_tenant.stack_depth(tenant_stack2)
  let tenant_stack_empty = v_tenant.stack_is_empty([])
  let tenant_stack_has_t1 = v_tenant.stack_contains(tenant_stack2, "t1")
  let tenant_top = v_tenant.current(tenant_stack2)
  let tenant_stack_replaced = v_tenant.stack_replace_top(tenant_stack2, tenant_ctx)
  let tenant_stack3 = v_tenant.stack_pop(tenant_stack2)
  let tenant_normalized = v_tenant.normalize(v_tenant.tenant_ctx("t2", "", ""), "eu", "free")
  let tenant_region_name = v_tenant.region_of(tenant_planned)
  let tenant_plan_name = v_tenant.plan_of(tenant_planned)
  let tenant_prefix = v_tenant.scope_prefix(tenant_ctx)
  let tenant_extracted = v_tenant.extract_tenant_id(tenant_key)
  let tenant_matches_scope = v_tenant.matches_scope(tenant_ctx, tenant_key)
  let tenant_is_default = v_tenant.is_default_ctx(tenant_default)
  let tenant_can_promote = v_tenant.can_promote_to(tenant_ctx, "enterprise")
  let tenant_promoted = v_tenant.promote(tenant_ctx, "enterprise")
  let tenant_demoted = v_tenant.demote(tenant_promoted, "pro")
  let tenant_masked = v_tenant.masked_tenant_id(tenant_ctx)
  let tenant_stack_ids = v_tenant.stack_ids(tenant_stack2)
  let tenant_stack_valid = v_tenant.verify_stack(tenant_stack2)
  let tenant_stack_valid_distinct = v_tenant.verify_stack([tenant_ctx, v_tenant.tenant_ctx("t2", "us", "free")])
  let tenant_summary_key = v_tenant.summary_key(tenant_planned, "invoice:1")
  let tenant_stats = v_tenant.stats(tenant_planned)
  let tenant_same = v_tenant.same_tenant(tenant_ctx, tenant_current)

  let h_ok = v_health.input(true, true, true, true, true, true)
  let h_bad = v_health.input(true, false, true, false, false, true)
  let health_deps_ok = v_health.deps_ok(h_ok)
  let health_operational = v_health.check_operational(h_ok)
  let health_code_live = v_health.status_code_live(h_bad)
  let health_code_ready = v_health.status_code_ready(h_bad)
  let health_code_startup = v_health.status_code_startup(h_bad)
  let health_failing = v_health.failing_components(h_bad)
  let health_fail_count = v_health.failing_count(h_bad)
  let health_score_bad = v_health.score_percent(h_bad)
  let health_text_bad = v_health.status_text(h_bad)
  let health_text_ok = v_health.status_text(h_ok)
  let health_db_ok = v_health.component_ok(h_ok, "db")
  let health_unknown = v_health.component_ok(h_ok, "unknown")
  let health_ready_blockers = v_health.ready_blockers(h_bad)
  let health_startup_blockers = v_health.startup_blockers(h_bad)
  let health_code_operational = v_health.status_code_operational(h_bad)
  let health_is_down = v_health.is_down(h_bad)
  let health_is_degraded = v_health.is_degraded(h_bad)
  let health_severity_bad = v_health.severity(h_bad)
  let health_summary = v_health.summary(h_bad)
  let health_invariants = v_health.verify_invariants(h_ok)
  let h_down = v_health.input(true, true, true, true, true, false)
  let health_severity_down = v_health.severity(h_down)
  let health_json = v_health.report_json(h_ok)

  let pg = v_pagination.page(0, 2, 5)
  let pagination_has_next = v_pagination.has_next(pg)
  let pagination_has_prev = v_pagination.has_prev(pg)
  let pagination_prev = v_pagination.prev_cursor(pg)
  let pagination_next = v_pagination.next_cursor(pg)
  let pagination_window = v_pagination.window(pg)
  let pagination_count = v_pagination.page_count(5, 2)
  let pagination_first = v_pagination.first_page(2, 5)
  let pagination_last = v_pagination.last_page(2, 5)
  let pagination_idx_last = v_pagination.page_index(pagination_last)
  let pagination_remaining = v_pagination.remaining(pg)
  let pagination_shifted = v_pagination.shift(pg, 3)
  let pagination_wide = v_pagination.with_limit(pg, 3)
  let pagination_valid = v_pagination.is_valid(pg)
  let pagination_stats = v_pagination.stats(pg)

  let se0 = v_search.index_new()
  let se1 = v_search.index_add(se0, "d1", "hello world")
  let se2 = v_search.index_add(se1, "d2", "vitte world")
  let search_contains = v_search.contains("hello world", "hello")
  let search_hits = v_search.query(se2, "world")
  let search_score = v_search.score(search_hits[0], "world")
  let search_docs = v_search.doc_count(se2)
  let search_active = v_search.active_count(se2)
  let search_has_d1 = v_search.has_doc(se2, "d1")
  let search_doc = v_search.get_doc(se2, "d1")
  let se2_hinted = v_search.set_score_hint(se2, "d1", 5)
  let search_best = v_search.best_match(se2_hinted, "world")
  let se3 = v_search.index_remove(se2, "d2")
  let se4 = v_search.reactivate(se3, "d2")
  let search_hits_after = v_search.query(se3, "vitte")
  let search_count_vitte = v_search.query_count(se4, "vitte")
  let search_ids_vitte = v_search.query_ids(se4, "vitte")
  let search_stats = v_search.stats(se2)
  let search_cleared = v_search.clear(se4)

  let retry_policy0 = v_retry.policy(3, 50, 200)
  let retry_policy1 = v_retry.with_jitter(retry_policy0, v_retry.RetryJitter.Full)
  let retry_policy2 = v_retry.with_retry_4xx(retry_policy1, true)
  let retry_delay_plan = v_retry.delay_plan(retry_policy1, 3)
  let retry_status = v_retry.run_with_retry([500, 429, 200], retry_policy1)
  let retry_attempts = v_retry.attempts_used([500, 429, 200], retry_policy1)
  let retry_first = v_retry.first_retryable([200, 404, 503], retry_policy1)
  let retry_404_default = v_retry.should_retry(404, 0, retry_policy1)
  let retry_404_enabled = v_retry.should_retry(404, 0, retry_policy2)
  let retry_success = v_retry.run_succeeds([500, 200], retry_policy1)
  let retry_left = v_retry.attempts_left(retry_policy1, retry_attempts)
  let retry_class = v_retry.classify_status(429)
  let retry_jitter = v_retry.jitter_name(retry_policy1)
  let retry_stop = v_retry.should_stop(200, 0, retry_policy1)
  let retry_stats = v_retry.policy_stats(retry_policy2)

  let breaker0 = v_circuit_breaker.breaker_new(2, 3)
  let breaker1 = v_circuit_breaker.record_failure(breaker0, 1)
  let breaker2 = v_circuit_breaker.record_failure(breaker1, 2)
  let breaker_remaining = v_circuit_breaker.cooldown_remaining(breaker2, 2)
  let breaker_opened_for = v_circuit_breaker.opened_for(breaker2, 4)
  let breaker_probe = v_circuit_breaker.can_probe(breaker2, 5)
  let breaker4 = v_circuit_breaker.on_tick(breaker2, 6)
  let breaker5 = v_circuit_breaker.record_success(breaker4)
  let breaker_forced = v_circuit_breaker.force_close(v_circuit_breaker.force_open(breaker5, 7))
  let breaker_ratio = v_circuit_breaker.trip_ratio_percent(breaker2)
  let breaker_stats = v_circuit_breaker.stats(breaker2, 2)

  let limiter0 = v_rate_limit.limiter_new(3, 10)
  let limiter1 = v_rate_limit.consume(limiter0, 0, 2)
  let limiter2 = v_rate_limit.consume_if_allowed(limiter1, 0, 1)
  let limiter3 = v_rate_limit.consume_if_allowed(limiter1, 0, 2)
  let limiter_refill = v_rate_limit.refill(limiter2, 11)
  let limiter_reset = v_rate_limit.force_reset(limiter1, 5)
  let limiter_small = v_rate_limit.with_capacity(limiter1, 1)
  let limiter_used = v_rate_limit.used_now(limiter1, 0)
  let limiter_cap = v_rate_limit.capacity(limiter1)
  let limiter_util = v_rate_limit.utilization_percent(limiter1, 0)
  let limiter_elapsed = v_rate_limit.window_elapsed(limiter1, 4)
  let limiter_window_left = v_rate_limit.window_remaining(limiter1, 4)
  let limiter_exhausted = v_rate_limit.is_exhausted(limiter2, 0)
  let limiter_stats = v_rate_limit.stats(limiter1, 0)

  let al0 = v_alerts.rule_new("latency_p95", 100, 60)
  let alert_eval = v_alerts.evaluate(al0, 120, 1)
  let al1 = v_alerts.trigger(al0, 120, 1)
  let al2 = v_alerts.silence(al1, 10)
  let alert_silenced = v_alerts.silenced(al2, 5)
  let alert_eval_silenced = v_alerts.evaluate(al2, 150, 5)
  let al3 = v_alerts.trigger(al2, 20, 5)
  let al4 = v_alerts.trigger(al2, 120, 11)
  let al0_tuned = v_alerts.with_threshold(v_alerts.with_window(al0, 30), 90)
  let alert_can = v_alerts.can_trigger(al2, 5)
  let alert_delta = v_alerts.threshold_delta(al0, 120)
  let alert_breach = v_alerts.breach_ratio_percent(al0, 120)
  let alert_should_page_1 = v_alerts.should_page(al0, 120, 1, 1)
  let alert_should_page_3 = v_alerts.should_page(al0, 120, 1, 3)
  let alert_idle = v_alerts.is_idle(al0)
  let alert_silenced_state = v_alerts.is_silenced_state(al2)
  let al7 = v_alerts.silence_for(al0, 3, 4)
  let al8 = v_alerts.unsilence_if_due(al7, 8)
  let alert_firing = v_alerts.is_firing(al1)
  let alert_state_name = v_alerts.state_name(al1)
  let al5 = v_alerts.unsilence(al2)
  let al6 = v_alerts.recover(al5, 80, 12)
  let al_reset = v_alerts.reset(al4)
  let alert_stats = v_alerts.stats(al6)

  let slo0 = v_slo.slo_new(80)
  let slo1 = v_slo.sli_record(slo0, true)
  let slo2 = v_slo.sli_record(slo1, true)
  let slo3 = v_slo.sli_record(slo2, true)
  let slo4 = v_slo.sli_record(slo3, true)
  let slo5 = v_slo.sli_record(slo4, false)
  let slo_allowed = v_slo.allowed_bad(slo5)
  let slo_ok = v_slo.slo_eval(slo5)
  let slo_budget = v_slo.budget_left(slo5)
  let slo_target = v_slo.target(slo5)
  let slo_budget_pct = v_slo.error_budget_percent(slo5)
  let slo_total_budget = v_slo.total_budget(slo5)
  let slo_over_budget = v_slo.bad_over_budget(slo5)
  let slo_budget_used = v_slo.budget_used_percent(slo5)
  let slo_burn = v_slo.burn_rate(slo5)
  let slo_success = v_slo.success_count(slo5)
  let slo_success_rate = v_slo.success_rate(slo5)
  let slo_error_rate = v_slo.error_rate(slo5)
  let slo_health = v_slo.health(slo5)
  let slo_within_79 = v_slo.within_target(slo5, 79)
  let slo_within_81 = v_slo.within_target(slo5, 81)
  let slo8 = v_slo.record_failure(v_slo.record_success(v_slo.slo_new(90)))
  let slo_projected = v_slo.projected_burn(slo5, 5, 3)
  let slo6 = v_slo.record_many(v_slo.reset(slo5), 4, 1)
  let slo7 = v_slo.merge(slo5, slo6)
  let slo_stats = v_slo.stats(slo7)

  let fx0 = v_fixtures.fixture_load("users", ["u1", "u2"])
  let fx1 = v_fixtures.seed(fx0, 1)
  let fixtures_snap = v_fixtures.snapshot(fx1)
  let fx2 = v_fixtures.reset(fx1)
  let fixtures_snap_reset = v_fixtures.snapshot(fx2)
  let fx3 = v_fixtures.append_row(fx2, "u3")
  let fx4 = v_fixtures.remove_row(fx3, "u2")
  let fx1_once = v_fixtures.seed_once(fx0)
  let fx5 = v_fixtures.append_row(fx4, "u3")
  let fx6 = v_fixtures.dedupe(fx5)
  let fx7 = v_fixtures.replace_row(fx6, "u3", "u4")
  let fx8 = v_fixtures.clear_current(fx7)
  let fixtures_rows = v_fixtures.row_count(fx4)
  let fixtures_base_rows = v_fixtures.base_count(fx4)
  let fixtures_has_u3 = v_fixtures.contains_row(fx4, "u3")
  let fixtures_diff = v_fixtures.diff_count(fx4)
  let fixtures_dups = v_fixtures.duplicate_count(fx5)
  let fixtures_first = v_fixtures.first_row(fx7, "x")
  let fixtures_last = v_fixtures.last_row(fx7, "x")
  let fixtures_row_1 = v_fixtures.row_at(fx7, 1, "x")
  let fixtures_row_missing = v_fixtures.row_at(fx7, 3, "x")
  let fixtures_empty = v_fixtures.is_empty(fx8)
  let fixtures_checksum = v_fixtures.checksum(fx4)
  let fixtures_stats = v_fixtures.stats(fx4)

  let mh0 = v_mock_http.mock_new()
  let mh1 = v_mock_http.mock_add(mh0, "GET", "/health", 200, "{\"ok\":true}")
  let mock_match_ok = v_mock_http.mock_match(mh1, "GET", "/health")
  let mock_exists = v_mock_http.mock_exists(mh1, "GET", "/health")
  let mock_body = v_mock_http.mock_body(mh1, "GET", "/health", "x")
  let mock_body_missing = v_mock_http.mock_body(mh1, "POST", "/health", "x")
  let mock_reply = v_mock_http.mock_reply(mh1, "GET", "/health")
  let mock_miss = v_mock_http.mock_reply(mh1, "POST", "/health")
  let mh2 = v_mock_http.mock_clear(mh1)
  let mock_empty = v_mock_http.mock_is_empty(mh2)
  let mock_after_clear = v_mock_http.mock_match(mh2, "GET", "/health")
  let mh3 = v_mock_http.mock_add(mh2, "post", "/echo", 201, "{\"ok\":1}")
  let mock_methods = v_mock_http.mock_methods(mh3)
  let mock_method_count = v_mock_http.mock_count_method(mh3, "POST")
  let mock_route0 = v_mock_http.mock_route_at(mh3, 0)
  let mock_route_bad = v_mock_http.mock_route_at(mh3, 5)
  let mock_count = v_mock_http.mock_count(mh3)
  let mock_paths = v_mock_http.mock_list_paths(mh3, "POST")
  let mock_status = v_mock_http.mock_status(mh3, "post", "/echo")
  let mock_verify = v_mock_http.mock_verify(mh3, "POST", "/echo", 201)
  let mh5 = v_mock_http.mock_update_status(mh3, "POST", "/echo", 202)
  let mh6 = v_mock_http.mock_update_body(mh5, "POST", "/echo", "{\"ok\":2}")
  let mock_status_updated = v_mock_http.mock_status(mh6, "POST", "/echo")
  let mock_body_updated = v_mock_http.mock_body(mh6, "POST", "/echo", "")
  let mh4 = v_mock_http.mock_remove(mh3, "POST", "/echo")
  let mock_count_after = v_mock_http.mock_count(mh4)
  let mock_stats = v_mock_http.mock_stats(mh3)

  if pred && m >= 0.0 && var >= 0.0 && step >= -1.0 &&
     v_array.len(arr) == 3 && txt == "ok" &&
     code == 0 &&
     v_async.is_terminal(task_state) &&
     encoded.len > 0 && parsed_true &&
     parsed_cli.has_help && parsed_cli.command == "vitte" && cli_usage.len > 0 &&
     v_http.is_success(resp) &&
     v_db.can_write(s1) && rows == 1 &&
     has_0_1 && deg_1 == 1 &&
     px == 12 && py == 19 && alive &&
     sql_rows == 2 && sql_one.len > 0 && sql_plan == "scan" &&
     cache_a == "" && cache_b && cache_size == 2 &&
     auth_ok && auth_user_ok && !auth_admin_ok && auth_after_revoke &&
     tls_secure && tls_out > 0 && tls_in > 0 &&
     hc_ok &&
     req_status == 200 && req_text.len > 0 && req_attempts == 2 &&
     ch_head == "m2" && ch_len == 1 && ch_drop == 1 &&
     actor_proc == 1 && actor_running && actor_decision == "stop" &&
     queue_pending == 0 && queue_inflight == 0 && queue_done == 1 && queue_dlq.len == 1 &&
     !queue_can_dequeue && queue_peek.id == 0 && queue_attempt_dead == 2 &&
     queue_total == 1 && queue_stats.len > 0 &&
     stream_backpressure && st4.dropped == 1 && stream_batch.len == 2 && stream_window.len == 2 && stream_available == 2 &&
     stream_oldest == 2 && stream_newest == 7 && stream_lag == 8 && stream_window_count == 2 &&
     stream_overflow == 1 && st6.buffer.len == 0 && stream_stats.len > 0 &&
     codec_detect_json == v_codec.CodecFormat.Json &&
     codec_detect_mp == v_codec.CodecFormat.MsgPack &&
     codec_detect_bin == v_codec.CodecFormat.Binary &&
     codec_decode.len > 0 && codec_can && codec_rt && codec_name == "msgpack" &&
     codec_pair.ok && codec_pair.key == "k" && codec_pair.value == "v" &&
     v_codec.detect(codec_conv.data) == v_codec.CodecFormat.Json &&
     codec_ext == ".bin" && codec_textual && codec_fp.len > 0 &&
     kv_has_a && kv_scan.len == 2 && kv_keys.len == 2 &&
     kv_get_a == "" && kv_get_b == "2" && kv_ttl_b == -1 && kv_size == 0 && kv_stats.len > 0 &&
     lsp_main_diags.len == 2 && lsp_empty_diags.len == 1 && lsp_fix.len > 0 && lsp_docs == 2 &&
     lsp_diag_count == 2 && lsp_error_count == 1 && lsp_has_errors &&
     lsp_fixed_text.len > 0 && lsp_summary.len > 0 &&
     timeout_ok && timeout_expired && timeout_remaining == 10 && timeout_elapsed == 20 &&
     timeout_started == 100 && timeout_deadline == 130 && timeout_budget == 30 &&
     timeout_within && t1_clamped.deadline_ms == 125 && t1_clamped.budget_ms == 25 &&
     t1_shifted.started_ms == 110 && t1_shifted.deadline_ms == 140 &&
     timeout_can_spend && !timeout_cannot_spend && timeout_overspent == 40 &&
     timeout_overrun == 10 && timeout_active && timeout_guard &&
     v_timeout.is_stopped(timeout_with_active) && timeout_stopped_expired && timeout_stopped &&
     t2_active.active && timeout_restart_remaining == 10 && timeout_stats.len > 0 &&
     bulkhead_avail_full == 0 && bulkhead_avail_after == 1 && bulkhead_can_accept &&
     bulkhead_open && bulkhead_qdepth == 1 && bulkhead_rejected == 1 &&
     bulkhead_has_queue && bulkhead_util == 100 && bh8.queued == 0 &&
     bh9.capacity == 1 && bh10.rejected == 0 && bulkhead_stats.len > 0 &&
     idem_rec.active && idem_has && !idem_check && idem_ttl == 19 &&
     idem_keys.len == 1 && idem_keys[0] == "k1" && idem_replay == "R1" &&
     idem_count == 1 && idem_empty && idem_stats.len > 0 &&
     ct_name == "user-api" && ct_version == "1.0.0" && ct_hash == "sha-b" &&
     ct_fields == 3 && ct_has_email && ct_ok.ok && ct_non_empty.ok &&
     ct_missing == "email" && ct_same && ct_diff == "breaking:schema" &&
     ct_breaking && ct_summary.len > 0 &&
     jobs_pending == 0 && jobs_inflight == 0 && jobs_done == 1 && jobs_dlq == 1 &&
     jobs_total == 2 && !jobs_has_pending && !jobs_has_inflight &&
     jobs_has_done && jobs_has_dlq && jobs_next_pending == -1 &&
     jobs_attempt_0 == 2 && jobs_state_0 == "failed" &&
     jobs_state_1 == "done" && jobs_state_missing == "missing" &&
     v_jobs.total_count(jb9) == 2 && v_jobs.done_count(jb10) == 0 &&
     v_jobs.dlq_count(jb11) == 0 && jobs_stats.len > 0 &&
     pl_rules == 3 && pl_mode == "deny" && pl_subject_rules == 2 && pl_has &&
     pl_first.effect == v_policy.Effect.Deny && pl_allow && !pl_deny &&
     pl_decision == "deny" && pl_reason == "forbidden-delete" &&
     pl_explain == "deny:forbidden-delete" && pl_default_deny &&
     pl_allow_default && pl_stats.len > 0 &&
     ov_span_open && ov_span_closed && ov_span_name == "runtime" &&
     ov_duration == 40 && ov_span5.trace_id == "trace-1" &&
     ov_ctr_value == 5 && ov_ctr_merge.value == 8 && ov_ctr_zero &&
     ov_hist_empty && ov_hist_min == 8 && ov_hist_max == 12 &&
     ov_hist_range == 4 && ov_hist_avg == 10 && ov_hist_merge.count == 3 &&
     ov_trace_summary.len > 0 && ov_metrics.len > 0 &&
     outbox_pending == 1 && outbox_flushed == 1 && outbox_flushed_pending == 1 && outbox_payload.len > 0 &&
     outbox_payload_size > 0 && outbox_events == 2 && outbox_sent == 1 && outbox_has_0 &&
     outbox_event_1.topic == "user.updated" && outbox_ids.len == 2 && outbox_pending_ids.len == 1 &&
     outbox_ids[0] == 0 && outbox_ids[1] == 1 && outbox_pending_ids[0] == 1 &&
     outbox_attempt_1 == 1 && outbox_max_attempts == 1 && outbox_first_created.id == 0 &&
     outbox_next.id == 1 && outbox_topic_created == 1 &&
     outbox_status_0 == "sent" && outbox_status_1 == "pending" &&
     outbox_events_after_prune == 1 && v_outbox.sent_count(ob7) == 2 &&
     v_outbox.pending_count(ob7) == 0 && outbox_empty_after_clear &&
     outbox_sent_ids.len == 1 && outbox_sent_ids[0] == 0 &&
     outbox_flushed_ids.len == 1 && outbox_flushed_ids[0] == 0 &&
     outbox_pending_by_topic == 1 && outbox_oldest_pending == 1 &&
     v_outbox.attempt_of(ob9, 1) == 1 && outbox_can_flush && outbox_drained &&
     outbox_summary.len > 0 && outbox_invariants && outbox_stats.len > 0 &&
     sg3.state == v_saga.SagaState.Failed && sg3_fail_alias.state == v_saga.SagaState.Failed &&
     sg4.state == v_saga.SagaState.Compensated && saga_step0.done && saga_step_missing.name == "" &&
     saga_has_charge && saga_next_pending == "charge_card" && saga_can_run_failed &&
     saga_failed_index == 1 && saga_progress == 50 &&
     saga_is_failed && saga_is_succeeded && saga_is_compensated &&
     saga_steps == 2 && saga_compensated == 1 && saga_done == 1 && saga_pending == 1 &&
     v_saga.done_count(sg8) == 2 && v_saga.compensated_count(sg9) == 1 &&
     saga_step_done_reserve && !saga_step_comp_charge &&
     saga_all_done && saga_all_compensated &&
     saga_can_compensate && saga_can_resume &&
     v_saga.has_step(sg10, "publish") && v_saga.step_index(sg11, "publish_v1") == 2 &&
     saga_failure_ratio == 50 && saga_invariants &&
     saga_failed_name == "charge_card" && saga_step_idx == 1 && saga_terminal &&
     saga_state_name == "compensated" && sg5.state == v_saga.SagaState.Succeeded &&
     sg6.state == v_saga.SagaState.Draft && v_saga.step_count(sg7) == 3 && saga_stats.len > 0 &&
     sr_latest.version == 2 && schema_compat && !schema_compat_bidir &&
     schema_diff == "compatible-change" && schema_breaking && schema_count == 2 &&
     schema_v1.active && schema_has_v2 && !schema_has_v2_after &&
     schema_has_v2_reactivated && !schema_has_v2_removed &&
     schema_subject_total == 2 && schema_active_count == 1 && schema_inactive_count == 1 &&
     schema_subject_exists_user && !schema_subject_exists_order &&
     schema_latest_version == 2 && schema_fields == 3 && schema_has_email &&
     schema_subjects.len == 1 && schema_versions.len == 2 && schema_fingerprints.len == 2 &&
     schema_level == "backward-compatible" && schema_total == 2 &&
     v_schema_registry.total_count(sr5) == 1 &&
     schema_subject_count == 1 && schema_next_version == 3 &&
     schema_latest_fingerprint == "fp3" && schema_first_inactive == 2 &&
     schema_order_empty && schema_active_ratio == 50 &&
     schema_record_summary.len > 0 && schema_subject_stats.len > 0 &&
     schema_invariants && schema_stats.len > 0 &&
     tenant_default.plan == "free" && !tenant_default.active && tenant_tid == "t1" &&
     tenant_key.len > 0 && tenant_scope_prefix &&
     tenant_iso_ok && !tenant_iso_bad && tenant_current.active && !tenant_off.active && tenant_same &&
     tenant_active && tenant_valid && tenant_region_key.len > 0 && tenant_plan_ok &&
     tenant_is_enterprise && tenant_can_access_region && !tenant_cannot_access_region &&
     tenant_same_region && tenant_top.tenant_id == "t1" &&
     tenant_stack_depth == 2 && tenant_stack_empty && tenant_stack_has_t1 &&
     tenant_stack3.len == 1 && v_tenant.current(tenant_stack_replaced).plan == "pro" &&
     v_tenant.is_valid(tenant_normalized) && tenant_region_name == "us" &&
     tenant_plan_name == "enterprise" &&
     tenant_prefix == "t1:" && tenant_extracted == "t1" && tenant_matches_scope &&
     tenant_is_default && tenant_can_promote &&
     tenant_promoted.plan == "enterprise" && tenant_demoted.plan == "pro" &&
     tenant_masked == "***" && tenant_stack_ids.len == 2 &&
     !tenant_stack_valid && tenant_stack_valid_distinct &&
     tenant_summary_key.len > 0 && tenant_stats.len > 0 &&
     health_deps_ok && health_operational && health_code_live == 200 &&
     health_code_ready == 503 && health_code_startup == 503 &&
     health_failing.len == 3 && health_fail_count == 3 &&
     health_score_bad == 50 && health_text_bad == "degraded" &&
     health_text_ok == "ok" && health_db_ok && !health_unknown &&
     health_ready_blockers.len == 2 && health_startup_blockers.len == 1 &&
     health_code_operational == 503 && !health_is_down && health_is_degraded &&
     health_severity_bad == "warning" && health_summary.len > 0 &&
     health_invariants && health_severity_down == "critical" &&
     health_json.len > 0 &&
     pagination_has_next && !pagination_has_prev && pagination_prev == -1 &&
     pagination_next == 2 && pagination_window.size == 2 && pagination_count == 3 &&
     pagination_first.offset == 0 && pagination_last.offset == 3 && pagination_idx_last == 1 &&
     pagination_remaining == 3 && pagination_shifted.offset == 3 &&
     pagination_wide.limit == 3 && pagination_valid && pagination_stats.len > 0 &&
     search_contains && search_hits.len == 2 && search_score > 0 && search_hits_after.len == 0 &&
     search_docs == 2 && search_active == 2 && search_has_d1 && search_doc.id == "d1" &&
     search_best.id == "d1" && search_count_vitte == 1 && search_ids_vitte.len == 1 &&
     search_ids_vitte[0] == "d2" && search_stats.len > 0 && v_search.doc_count(search_cleared) == 0 &&
     retry_status == 200 && retry_attempts == 2 && retry_first == 503 &&
     !retry_404_default && retry_404_enabled && retry_success &&
     retry_left == 1 && retry_class == "throttle" && retry_jitter == "full" &&
     retry_stop && retry_delay_plan.len == 3 && retry_delay_plan[0] == 50 &&
     retry_delay_plan[1] == 99 && retry_delay_plan[2] == 198 && retry_stats.len > 0 &&
     !v_circuit_breaker.allow(breaker2, 2) && v_circuit_breaker.allow(breaker4, 6) &&
     breaker_remaining == 3 && breaker_probe && breaker_opened_for == 2 &&
     breaker_ratio == 100 && v_circuit_breaker.is_closed(breaker5) &&
     v_circuit_breaker.state(breaker5) == v_circuit_breaker.BreakerState.Closed &&
     v_circuit_breaker.is_closed(breaker_forced) && breaker_stats.len > 0 &&
     v_rate_limit.allow(limiter0, 0, 2) && !v_rate_limit.allow(limiter1, 0, 2) &&
     v_rate_limit.remaining(limiter1, 0) == 1 && v_rate_limit.reset_at(limiter1, 0) == 10 &&
     limiter_used == 2 && limiter_cap == 3 && limiter_util == 66 &&
     limiter_elapsed == 4 && limiter_window_left == 6 &&
     limiter2.used == 3 && limiter3.used == 2 && limiter_exhausted &&
     limiter_refill.used == 0 && limiter_refill.window_start == 11 &&
     limiter_reset.used == 0 && limiter_reset.window_start == 5 &&
     limiter_small.capacity == 1 && limiter_small.used == 1 && limiter_stats.len > 0 &&
     alert_eval && al1.state == v_alerts.AlertState.Firing && al1.fired_count == 1 &&
     al0_tuned.threshold == 90 && al0_tuned.window_ticks == 30 &&
     !alert_can && alert_delta == 20 && alert_breach == 120 &&
     alert_should_page_1 && !alert_should_page_3 &&
     alert_idle && alert_silenced_state && alert_firing && alert_state_name == "firing" &&
     alert_silenced && !alert_eval_silenced && al3.state == v_alerts.AlertState.Silenced &&
     al4.state == v_alerts.AlertState.Firing && al6.state == v_alerts.AlertState.Idle &&
     al8.state == v_alerts.AlertState.Idle && al_reset.fired_count == 0 && alert_stats.len > 0 &&
     slo_target == 80 && slo_budget_pct == 20 && slo_total_budget == 1 &&
     slo_allowed == 1 && slo_ok && slo_budget == 0 && slo_over_budget == 0 &&
     slo_budget_used == 100 && slo_burn >= 100 && slo_projected >= 200 &&
     slo_success == 4 && slo_success_rate == 80 && slo_error_rate == 20 &&
     slo_within_79 && !slo_within_81 && slo8.total == 2 && slo8.bad == 1 &&
     slo_health == "exhausted" && slo6.total == 5 && slo7.total == 10 && slo_stats.len > 0 &&
     fx1.current_rows.len == 4 && fx1_once.current_rows.len == 4 &&
     fx2.current_rows.len == 2 && fixtures_snap.len > 0 && fixtures_snap_reset.len > 0 &&
     fixtures_rows == 2 && fixtures_base_rows == 2 && fixtures_has_u3 && fixtures_diff == 0 &&
     fixtures_dups == 1 && fixtures_first == "u1" && fixtures_last == "u4" &&
     fixtures_row_1 == "u4" && fixtures_row_missing == "x" && fixtures_empty &&
     fixtures_checksum > 0 && fixtures_stats.len > 0 &&
     mock_match_ok && mock_exists && mock_body == "{\"ok\":true}" && mock_body_missing == "x" &&
     mock_reply.matched && mock_reply.status == 200 &&
     !mock_miss.matched && mock_miss.status == 404 && mock_empty && !mock_after_clear &&
     mock_methods.len == 1 && mock_method_count == 1 &&
     mock_route0.path == "/echo" && mock_route_bad.status == 404 &&
     mock_count == 1 && mock_paths.len == 1 && mock_status == 201 &&
     mock_verify && mock_status_updated == 202 && mock_body_updated == "{\"ok\":2}" &&
     mock_count_after == 0 && mock_stats.len > 0 {
    return 0
  }
  return 1
}
