module vitte.tests.main

import vitte.compiler.pipeline_incremental as incr
import vitte.compiler.vm as vm

# -----------------------------------------------------------------------------
# Helpers simples d'assertion
# -----------------------------------------------------------------------------

fn value_as_i64(vm.VmValue v) -> i64:
    if v.kind == vm.VmValueKind::VmValueKindInt:
        return v.int_value
    .end
    return 0i64
.end

fn expect_return_value(String name, Option<vm.VmValue> opt, i64 expected) -> Bool:
    if opt.is_none():
        return false
    .end
    let v = opt.unwrap()
    if v.kind != vm.VmValueKind::VmValueKindInt:
        return false
    .end
    return value_as_i64(v) == expected
.end

# -----------------------------------------------------------------------------
# Tests unitaires
# -----------------------------------------------------------------------------

fn test_parse_and_ast() -> Bool:
    let src = "module tests.parse\n"
    let src = src + "pub fn main() -> i64:\n"
    let src = src + "    return 1\n"
    let src = src + ".end\n"

    let res = incr.incremental_compile_and_run("tests_parse.vitte", src)
    let ok_module = res.parse.module.name == "tests.parse"
    let ok_fn = (res.ast.functions.len() == 1usize) and (res.ast.functions[0usize].name == "main")
    return ok_module and ok_fn
.end

fn test_const_return() -> Bool:
    let src = "module tests.const\n"
    let src = src + "pub fn main() -> i64:\n"
    let src = src + "    return 3\n"
    let src = src + ".end\n"

    let res = incr.incremental_compile_and_run("tests_const.vitte", src)
    let ok_bc = res.bytecode.code.len() >= 2usize
    let ok_ret = expect_return_value("const", res.return_value, 3i64)
    return ok_bc and ok_ret
.end

fn test_add_return() -> Bool:
    let src = "module tests.add\n"
    let src = src + "pub fn main() -> i64:\n"
    let src = src + "    return 4 + 5\n"
    let src = src + ".end\n"

    let res = incr.incremental_compile_and_run("tests_add.vitte", src)
    let ops = res.bytecode.code
    let has_binop = (ops.len() >= 3usize) and (ops[2usize].opcode == vm.VmOpcode::VmOpcodeAdd)
    let ok_ret = expect_return_value("add", res.return_value, 9i64)
    return has_binop and ok_ret
.end

fn test_bytecode_shape() -> Bool:
    let src = "module tests.shape\n"
    let src = src + "pub fn main() -> i64:\n"
    let src = src + "    return 1 + 2\n"
    let src = src + ".end\n"

    let res = incr.incremental_compile_and_run("tests_shape.vitte", src)
    let ops = res.bytecode.code
    if ops.is_empty():
        return false
    .end
    let first_op = ops[0usize].opcode
    let last_op = ops[ops.len() - 1usize].opcode
    return (first_op == vm.VmOpcode::VmOpcodeConst) and (last_op == vm.VmOpcode::VmOpcodeRet)
.end

# -----------------------------------------------------------------------------
# Point d'entrÃ©e test
# -----------------------------------------------------------------------------

pub fn main() -> i32:
    let ok = true
    ok = ok and test_parse_and_ast()
    ok = ok and test_const_return()
    ok = ok and test_add_return()
    ok = ok and test_bytecode_shape()

    if ok:
        return 0
    .end
    return 1
.end

