module jmath.complex

# ============================================================================
# jmath.complex – nombres complexes (struct + opérations + utilitaires)
#
# Objectifs :
#   - Type Complex + API complète : arithmétique, normes, conj, inv, div robustes
#   - Conversions : polar/cartésien, normalisation angle
#   - Fonctions : exp/log/pow, trig/hyperboliques (versions “min” + hooks)
#   - Utilitaires : parsing minimal (sans I/O), approx_eq, erreurs
#   - Tests smoke
#
# Dépendances :
#   - Aucune obligatoire (tout en fallback interne)
#   - Optionnel : jmath.precise_math, jmath.algorithms.fast_math, jmath.algorithms.cordic
#     (ici non importés pour rester autonome)
#
# Conventions :
#   - Pas d’accolades, blocs en `.end`
#   - Pas d’I/O
# ============================================================================

# ---------------------------------
# Constantes
# ---------------------------------

const PI      : f64 = 3.141592653589793238462643383279502884
const TAU     : f64 = 6.283185307179586476925286766559005768
const HALF_PI : f64 = 1.570796326794896619231321691639751442

const LN2     : f64 = 0.693147180559945309417232121458176568
const INV_LN2 : f64 = 1.442695040888963407359924681001892137

# split π for reduction helper (double-double light)
const PI_HI : f64 = 3.141592653589793116
const PI_LO : f64 = 1.224646799147353207e-16

# ---------------------------------
# Types
# ---------------------------------

struct Complex
  re : f64
  im : f64
.end

struct Polar
  r : f64
  theta : f64
.end

struct ComplexErr
  ok : bool
  value : Complex
.end

enum ParseErrKind
  Empty
  InvalidChar
  InvalidNumber
  MissingI
  TrailingGarbage
.end

struct ParseResult
  ok : bool
  value : Complex
  err : ParseErrKind
.end

struct ParseF64
  ok : bool
  value : f64
.end

# ---------------------------------
# Base utils
# ---------------------------------

fn abs_f64(x: f64) -> f64
  if x < 0.0
    ret -x
  .end
  ret x
.end

fn max_f64(a: f64, b: f64) -> f64
  if a > b
    ret a
  .end
  ret b
.end

fn min_f64(a: f64, b: f64) -> f64
  if a < b
    ret a
  .end
  ret b
.end

fn clamp_f64(x: f64, lo: f64, hi: f64) -> f64
  if x < lo ret lo .end
  if x > hi ret hi .end
  ret x
.end

fn copysign_f64(mag: f64, sgn: f64) -> f64
  if sgn < 0.0
    ret -abs_f64(mag)
  .end
  ret abs_f64(mag)
.end

fn is_nan_like(x: f64) -> bool
  ret x != x
.end

fn is_finite(x: f64) -> bool
  if x > 1e308 ret false .end
  if x < -1e308 ret false .end
  ret true
.end

fn wrap_angle_pi(theta: f64) -> f64
  let mut t = theta
  while t <= -PI
    t = t + TAU
  .end
  while t > PI
    t = t - TAU
  .end
  ret t
.end

fn wrap_angle_0_tau(theta: f64) -> f64
  let mut t = theta
  while t < 0.0
    t = t + TAU
  .end
  while t >= TAU
    t = t - TAU
  .end
  ret t
.end

fn floor_f64(x: f64) -> f64
  let i = x as i64
  let fi = i as f64
  if fi > x
    ret (i - 1) as f64
  .end
  ret fi
.end

# ---------------------------------
# Robust sqrt + hypot
# ---------------------------------

fn sqrt_newton(x: f64) -> f64
  if x <= 0.0
    if x == 0.0
      ret 0.0
    .end
    ret 0.0
  .end

  let mut y = x
  if y > 1.0
    y = y * 0.5
  .end
  if y < 1.0
    y = 1.0
  .end

  let mut i = 0
  while i < 14
    y = 0.5 * (y + x / y)
    i = i + 1
  .end
  ret y
.end

fn hypot_robust(a: f64, b: f64) -> f64
  let aa = abs_f64(a)
  let bb = abs_f64(b)
  let m = max_f64(aa, bb)
  if m == 0.0
    ret 0.0
  .end
  let ra = aa / m
  let rb = bb / m
  ret m * sqrt_newton(ra*ra + rb*rb)
.end

# ---------------------------------
# atan/atan2 (fallback internal)
# ---------------------------------

const ATAN_A : f64 = 1.0
const ATAN_B : f64 = 0.280872
const ATAN_C : f64 = 0.8284
const ATAN_D : f64 = 0.1333

fn atan_rational(x: f64) -> f64
  let x2 = x*x
  let num = x * (ATAN_A + ATAN_B*x2)
  let den = 1.0 + ATAN_C*x2 + ATAN_D*x2*x2
  ret num / den
.end

fn atan_fallback(x: f64) -> f64
  let ax = abs_f64(x)
  if ax < 1e-18
    ret x
  .end
  if ax > 1.0
    let t = atan_rational(1.0/ax)
    ret copysign_f64(HALF_PI - t, x)
  .end
  ret atan_rational(x)
.end

fn atan2_fallback(y: f64, x: f64) -> f64
  if x > 0.0
    ret atan_fallback(y / x)
  .end
  if x < 0.0
    if y >= 0.0
      ret atan_fallback(y / x) + PI
    .end
    ret atan_fallback(y / x) - PI
  .end
  if y > 0.0 ret HALF_PI .end
  if y < 0.0 ret -HALF_PI .end
  ret 0.0
.end

# ---------------------------------
# sin/cos minimal (for exp/polar)
# ---------------------------------

fn reduce_angle_half_pi(theta: f64) -> (f64, i32)
  let inv = 2.0 / PI
  let kf = floor_f64(theta * inv + 0.5)
  let k = kf as i32

  let kf64 = k as f64
  let p2_hi = 0.5 * PI_HI
  let p2_lo = 0.5 * PI_LO

  let r1 = theta - kf64 * p2_hi
  let r2 = r1 - kf64 * p2_lo
  ret (r2, k)
.end

fn sin_poly(r: f64) -> f64
  let x2 = r*r
  let x3 = x2*r
  let x5 = x3*x2
  let x7 = x5*x2
  let x9 = x7*x2
  ret r - x3*(1.0/6.0) + x5*(1.0/120.0) - x7*(1.0/5040.0) + x9*(1.0/362880.0)
.end

fn cos_poly(r: f64) -> f64
  let x2 = r*r
  let x4 = x2*x2
  let x6 = x4*x2
  let x8 = x4*x4
  ret 1.0 - 0.5*x2 + x4*(1.0/24.0) - x6*(1.0/720.0) + x8*(1.0/40320.0)
.end

fn sincos_min(theta: f64) -> (f64, f64)
  let rr = reduce_angle_half_pi(theta)
  let mut r = rr.0
  let k = rr.1

  let mut swap = false
  if r > (0.5*HALF_PI)
    r = HALF_PI - r
    swap = true
  .end
  if r < -(0.5*HALF_PI)
    r = -HALF_PI - r
    swap = true
  .end

  let s0 = sin_poly(r)
  let c0 = cos_poly(r)

  let mut s = s0
  let mut c = c0
  if swap
    s = c0
    c = s0
  .end

  let q = k & 3
  if q == 0 ret (s, c) .end
  if q == 1 ret (c, -s) .end
  if q == 2 ret (-s, -c) .end
  ret (-c, s)
.end

fn sin_min(theta: f64) -> f64
  ret sincos_min(theta).0
.end

fn cos_min(theta: f64) -> f64
  ret sincos_min(theta).1
.end

# ---------------------------------
# exp/log minimal (for complex exp/log)
# ---------------------------------

fn ldexp_f64(x: f64, exp2: i32) -> f64
  let mut v = x
  if exp2 > 0
    let mut k = 0
    while k < exp2
      v = v * 2.0
      k = k + 1
    .end
    ret v
  .end

  if exp2 < 0
    let mut k = 0
    let n = -exp2
    while k < n
      v = v * 0.5
      k = k + 1
    .end
    ret v
  .end

  ret v
.end

struct Frexp
  mantissa : f64
  exponent : i32
.end

fn frexp_f64(x: f64) -> Frexp
  let mut v = x
  let mut e = 0
  while v >= 1.0
    v = v * 0.5
    e = e + 1
  .end
  while v < 0.5
    v = v * 2.0
    e = e - 1
  .end
  ret Frexp { mantissa: v, exponent: e }
.end

fn exp_poly7(r: f64) -> f64
  let r2 = r*r
  let r3 = r2*r
  let r4 = r2*r2
  let r5 = r4*r
  let r6 = r3*r3
  let r7 = r6*r
  ret 1.0 + r + 0.5*r2 + (1.0/6.0)*r3 + (1.0/24.0)*r4 + (1.0/120.0)*r5 + (1.0/720.0)*r6 + (1.0/5040.0)*r7
.end

fn exp_min(x: f64) -> f64
  let xc = clamp_f64(x, -700.0, 700.0)
  let kf = floor_f64(xc * INV_LN2 + 0.5)
  let k = kf as i32
  let r = xc - (k as f64) * LN2
  ret ldexp_f64(exp_poly7(r), k)
.end

fn log1p_series9(t: f64) -> f64
  let t2 = t*t
  let t3 = t2*t
  let t4 = t2*t2
  let t5 = t4*t
  let t6 = t3*t3
  let t7 = t6*t
  let t8 = t4*t4
  let t9 = t8*t
  ret t
    - 0.5*t2
    + (1.0/3.0)*t3
    - 0.25*t4
    + 0.2*t5
    - (1.0/6.0)*t6
    + (1.0/7.0)*t7
    - 0.125*t8
    + (1.0/9.0)*t9
.end

fn log_min(x: f64) -> f64
  if x <= 0.0
    ret -1e300
  .end
  let fr = frexp_f64(x)
  let t = fr.mantissa - 1.0
  ret log1p_series9(t) + (fr.exponent as f64) * LN2
.end

# ---------------------------------
# Constructors
# ---------------------------------

fn complex(re: f64, im: f64) -> Complex
  ret Complex { re: re, im: im }
.end

fn zero() -> Complex
  ret Complex { re: 0.0, im: 0.0 }
.end

fn one() -> Complex
  ret Complex { re: 1.0, im: 0.0 }
.end

fn i_unit() -> Complex
  ret Complex { re: 0.0, im: 1.0 }
.end

# ---------------------------------
# Basic ops
# ---------------------------------

fn add(a: Complex, b: Complex) -> Complex
  ret Complex { re: a.re + b.re, im: a.im + b.im }
.end

fn sub(a: Complex, b: Complex) -> Complex
  ret Complex { re: a.re - b.re, im: a.im - b.im }
.end

fn neg(a: Complex) -> Complex
  ret Complex { re: -a.re, im: -a.im }
.end

fn conj(a: Complex) -> Complex
  ret Complex { re: a.re, im: -a.im }
.end

fn mul(a: Complex, b: Complex) -> Complex
  ret Complex { re: a.re*b.re - a.im*b.im, im: a.re*b.im + a.im*b.re }
.end

fn mul_real(a: Complex, s: f64) -> Complex
  ret Complex { re: a.re*s, im: a.im*s }
.end

fn div(a: Complex, b: Complex) -> ComplexErr
  # robust division with ratio trick
  let br = b.re
  let bi = b.im
  if br == 0.0 && bi == 0.0
    ret ComplexErr { ok: false, value: zero() }
  .end

  let abr = abs_f64(br)
  let abi = abs_f64(bi)

  if abr >= abi
    let r = bi / br
    let denom = br + bi * r
    let re = (a.re + a.im * r) / denom
    let im = (a.im - a.re * r) / denom
    ret ComplexErr { ok: true, value: Complex { re: re, im: im } }
  .end

  let r = br / bi
  let denom = bi + br * r
  let re = (a.re * r + a.im) / denom
  let im = (a.im * r - a.re) / denom
  ret ComplexErr { ok: true, value: Complex { re: re, im: im } }
.end

fn inv(a: Complex) -> ComplexErr
  ret div(one(), a)
.end

# ---------------------------------
# Norms & angles
# ---------------------------------

fn abs(a: Complex) -> f64
  ret hypot_robust(a.re, a.im)
.end

fn norm2(a: Complex) -> f64
  ret a.re*a.re + a.im*a.im
.end

fn arg(a: Complex) -> f64
  ret atan2_fallback(a.im, a.re)
.end

fn normalize(a: Complex) -> ComplexErr
  let r = abs(a)
  if r == 0.0
    ret ComplexErr { ok: false, value: zero() }
  .end
  ret ComplexErr { ok: true, value: Complex { re: a.re / r, im: a.im / r } }
.end

# ---------------------------------
# Polar conversions
# ---------------------------------

fn to_polar(a: Complex) -> Polar
  ret Polar { r: abs(a), theta: arg(a) }
.end

fn from_polar(p: Polar) -> Complex
  let sc = sincos_min(p.theta)
  ret Complex { re: p.r * sc.1, im: p.r * sc.0 }
.end

fn normalize_polar(mut p: Polar) -> Polar
  if p.r < 0.0
    p.r = -p.r
    p.theta = wrap_angle_pi(p.theta + PI)
    ret p
  .end
  p.theta = wrap_angle_pi(p.theta)
  ret p
.end

# ---------------------------------
# Complex exp/log/pow
# ---------------------------------

fn exp(a: Complex) -> Complex
  # exp(x+iy)=exp(x)*(cos(y)+i sin(y))
  let ex = exp_min(a.re)
  let sc = sincos_min(a.im)
  ret Complex { re: ex * sc.1, im: ex * sc.0 }
.end

fn log(a: Complex) -> ComplexErr
  # log(z)=ln|z| + i arg(z)
  let r = abs(a)
  if r == 0.0
    ret ComplexErr { ok: false, value: zero() }
  .end
  ret ComplexErr { ok: true, value: Complex { re: log_min(r), im: arg(a) } }
.end

fn pow(a: Complex, b: Complex) -> ComplexErr
  # a^b = exp(b * log(a))
  let la = log(a)
  if !la.ok
    ret ComplexErr { ok: false, value: zero() }
  .end
  let t = mul(b, la.value)
  ret ComplexErr { ok: true, value: exp(t) }
.end

fn pow_real(a: Complex, p: f64) -> ComplexErr
  ret pow(a, Complex { re: p, im: 0.0 })
.end

# ---------------------------------
# Trig/hyperbolic (minimal)
# ---------------------------------

fn sinh_min(x: f64) -> f64
  let ex = exp_min(x)
  let em = exp_min(-x)
  ret 0.5 * (ex - em)
.end

fn cosh_min(x: f64) -> f64
  let ex = exp_min(x)
  let em = exp_min(-x)
  ret 0.5 * (ex + em)
.end

fn sin(a: Complex) -> Complex
  let sx = sin_min(a.re)
  let cx = cos_min(a.re)
  let shy = sinh_min(a.im)
  let chy = cosh_min(a.im)
  ret Complex { re: sx * chy, im: cx * shy }
.end

fn cos(a: Complex) -> Complex
  let sx = sin_min(a.re)
  let cx = cos_min(a.re)
  let shy = sinh_min(a.im)
  let chy = cosh_min(a.im)
  ret Complex { re: cx * chy, im: -sx * shy }
.end

fn tan(a: Complex) -> ComplexErr
  ret div(sin(a), cos(a))
.end

fn sinh(a: Complex) -> Complex
  # sinh(x+iy)=sinh(x)cos(y)+i cosh(x)sin(y)
  let shx = sinh_min(a.re)
  let chx = cosh_min(a.re)
  let sy = sin_min(a.im)
  let cy = cos_min(a.im)
  ret Complex { re: shx * cy, im: chx * sy }
.end

fn cosh(a: Complex) -> Complex
  # cosh(x+iy)=cosh(x)cos(y)+i sinh(x)sin(y)
  let shx = sinh_min(a.re)
  let chx = cosh_min(a.re)
  let sy = sin_min(a.im)
  let cy = cos_min(a.im)
  ret Complex { re: chx * cy, im: shx * sy }
.end

fn tanh(a: Complex) -> ComplexErr
  ret div(sinh(a), cosh(a))
.end

# ---------------------------------
# Comparisons / approx
# ---------------------------------

fn approx_eq(a: Complex, b: Complex, eps: f64) -> bool
  ret abs_f64(a.re - b.re) <= eps && abs_f64(a.im - b.im) <= eps
.end

fn approx_eq_rel(a: Complex, b: Complex, eps_abs: f64, eps_rel: f64) -> bool
  let dre = abs_f64(a.re - b.re)
  let dim = abs_f64(a.im - b.im)

  let sre = max_f64(abs_f64(a.re), abs_f64(b.re))
  let sim = max_f64(abs_f64(a.im), abs_f64(b.im))

  let ok_re = dre <= max_f64(eps_abs, eps_rel * sre)
  let ok_im = dim <= max_f64(eps_abs, eps_rel * sim)
  ret ok_re && ok_im
.end

# ---------------------------------
# Parsing minimal (sans espaces)
# ---------------------------------
# Formats acceptés (sans espaces) :
#   "a+bi", "a-bi", "bi", "-bi", "a", "i", "-i"
#   a,b : decimal simple (pas d'exponent, pas d'underscores)
#
# Note : strip_spaces est un passthrough ; garder l'entrée sans espaces.

fn strip_spaces(s: &str) -> &str
  ret s
.end

fn find_last_pm(s: &str) -> i32
  let mut i = (s.len() as i32) - 1
  while i >= 1
    let ch = s[i]
    if ch == '+' || ch == '-'
      ret i
    .end
    i = i - 1
  .end
  ret -1
.end

fn parse_f64_min(s: &str) -> ParseF64
  if s.len() == 0
    ret ParseF64 { ok: false, value: 0.0 }
  .end

  let mut i = 0
  let mut sign = 1.0
  if s[0] == '+'
    i = 1
  .end
  if s[0] == '-'
    sign = -1.0
    i = 1
  .end

  let mut intv : i64 = 0
  let mut saw_digit = false
  while i < (s.len() as i32)
    let ch = s[i]
    if ch >= '0' && ch <= '9'
      saw_digit = true
      intv = intv * 10 + ((ch as i32) - ('0' as i32)) as i64
      i = i + 1
      continue
    .end
    break
  .end

  let mut frac = 0.0
  let mut scale = 1.0
  if i < (s.len() as i32) && s[i] == '.'
    i = i + 1
    while i < (s.len() as i32)
      let ch = s[i]
      if ch >= '0' && ch <= '9'
        saw_digit = true
        frac = frac * 10.0 + ((ch as i32) - ('0' as i32)) as f64
        scale = scale * 10.0
        i = i + 1
        continue
      .end
      ret ParseF64 { ok: false, value: 0.0 }
    .end
  .end

  if !saw_digit
    ret ParseF64 { ok: false, value: 0.0 }
  .end

  let v = (intv as f64) + (frac / scale)
  ret ParseF64 { ok: true, value: sign * v }
.end

fn parse(s: &str) -> ParseResult
  if s.len() == 0
    ret ParseResult { ok: false, value: zero(), err: ParseErrKind.Empty }
  .end

  let t = strip_spaces(s)
  if t.len() == 0
    ret ParseResult { ok: false, value: zero(), err: ParseErrKind.Empty }
  .end

  if t == "i" || t == "+i"
    ret ParseResult { ok: true, value: Complex { re: 0.0, im: 1.0 }, err: ParseErrKind.Empty }
  .end
  if t == "-i"
    ret ParseResult { ok: true, value: Complex { re: 0.0, im: -1.0 }, err: ParseErrKind.Empty }
  .end

  let has_i = t.ends_with("i")
  if !has_i
    let pr = parse_f64_min(t)
    if !pr.ok
      ret ParseResult { ok: false, value: zero(), err: ParseErrKind.InvalidNumber }
    .end
    ret ParseResult { ok: true, value: Complex { re: pr.value, im: 0.0 }, err: ParseErrKind.Empty }
  .end

  let u = t.slice(0, (t.len() - 1) as i32)
  let idx = find_last_pm(u)

  if idx < 0
    if u.len() == 0 || u == "+"
      ret ParseResult { ok: true, value: Complex { re: 0.0, im: 1.0 }, err: ParseErrKind.Empty }
    .end
    if u == "-"
      ret ParseResult { ok: true, value: Complex { re: 0.0, im: -1.0 }, err: ParseErrKind.Empty }
    .end
    let pi = parse_f64_min(u)
    if !pi.ok
      ret ParseResult { ok: false, value: zero(), err: ParseErrKind.InvalidNumber }
    .end
    ret ParseResult { ok: true, value: Complex { re: 0.0, im: pi.value }, err: ParseErrKind.Empty }
  .end

  let left = u.slice(0, idx)
  let right = u.slice(idx, u.len() as i32)

  let pr = parse_f64_min(left)
  if !pr.ok
    ret ParseResult { ok: false, value: zero(), err: ParseErrKind.InvalidNumber }
  .end

  if right == "+"
    ret ParseResult { ok: true, value: Complex { re: pr.value, im: 1.0 }, err: ParseErrKind.Empty }
  .end
  if right == "-"
    ret ParseResult { ok: true, value: Complex { re: pr.value, im: -1.0 }, err: ParseErrKind.Empty }
  .end

  let pi2 = parse_f64_min(right)
  if !pi2.ok
    ret ParseResult { ok: false, value: zero(), err: ParseErrKind.InvalidNumber }
  .end

  ret ParseResult { ok: true, value: Complex { re: pr.value, im: pi2.value }, err: ParseErrKind.Empty }
.end

# ---------------------------------
# Tests
# ---------------------------------

fn test_basic_arith()
  let a = complex(1.0, 2.0)
  let b = complex(3.0, -4.0)

  let s = add(a, b)
  if s.re != 4.0 || s.im != -2.0
    panic("add failed")
  .end

  let p = mul(a, b) # (1+2i)(3-4i)=11+2i
  if abs_f64(p.re - 11.0) > 1e-12 || abs_f64(p.im - 2.0) > 1e-12
    panic("mul failed")
  .end

  let d = div(a, b)
  if !d.ok
    panic("div failed")
  .end
.end

fn test_abs_arg()
  let z = complex(3.0, 4.0)
  let r = abs(z)
  if abs_f64(r - 5.0) > 1e-10
    panic("abs failed")
  .end

  let th = arg(z)
  if abs_f64(th - atan2_fallback(4.0, 3.0)) > 1e-12
    panic("arg failed")
  .end
.end

fn test_exp_log_roundtrip()
  let z = complex(0.2, -0.7)
  let ez = exp(z)
  let lz = log(ez)
  if !lz.ok
    panic("log failed")
  .end

  # approx roundtrip (fallback exp/log)
  if abs_f64(lz.value.re - z.re) > 2e-2 || abs_f64(lz.value.im - z.im) > 2e-2
    panic("exp/log roundtrip too large")
  .end
.end

fn test_parse()
  let p1 = parse("1+2i")
  if !p1.ok || p1.value.re != 1.0 || p1.value.im != 2.0
    panic("parse 1+2i")
  .end

  let p2 = parse("-i")
  if !p2.ok || p2.value.re != 0.0 || p2.value.im != -1.0
    panic("parse -i")
  .end

  let p3 = parse("2")
  if !p3.ok || p3.value.re != 2.0 || p3.value.im != 0.0
    panic("parse 2")
  .end

  let p4 = parse("3.5-4i")
  if !p4.ok || abs_f64(p4.value.re - 3.5) > 1e-12 || abs_f64(p4.value.im + 4.0) > 1e-12
    panic("parse 3.5-4i")
  .end
.end

fn run_all_tests()
  test_basic_arith()
  test_abs_arg()
  test_exp_log_roundtrip()
  test_parse()
.end

.end
