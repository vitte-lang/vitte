module jmath.complex.exp_log

# ============================================================================
# complex.exp_log – exp/log/pow pour nombres complexes (robuste + complet)
#
# Contenu :
#   - exp(z), expm1(z)
#   - log(z), log1p(z), log_base(z,b)
#   - pow(z,w), pow_real(z,p), sqrt(z), cbrt(z)
#   - polar helpers : to_polar, from_polar, normalize_polar
#   - utilitaires : hypot robuste, atan2 fallback, sin/cos min, exp/log réels min
#   - tests smoke + cas limites
#
# Design :
#   - Autonome : pas d’import obligatoire
#   - Fallbacks "min" pour sin/cos/exp/log réels (suffisant pour runtime sans libm)
#   - Division/scale robustes sur exp/log et sqrt/pow
#
# Conventions :
#   - Pas d’accolades, blocs en `.end`
#   - Pas d’I/O
# ============================================================================

# ---------------------------------
# Constantes
# ---------------------------------

const PI      : f64 = 3.141592653589793238462643383279502884
const TAU     : f64 = 6.283185307179586476925286766559005768
const HALF_PI : f64 = 1.570796326794896619231321691639751442

const LN2     : f64 = 0.693147180559945309417232121458176568
const INV_LN2 : f64 = 1.442695040888963407359924681001892137

# ---------------------------------
# Types
# ---------------------------------

struct Complex
  re : f64
  im : f64
.end

struct Polar
  r : f64
  theta : f64
.end

struct ComplexErr
  ok : bool
  value : Complex
.end

# ---------------------------------
# Base utils
# ---------------------------------

fn abs_f64(x: f64) -> f64
  if x < 0.0 ret -x .end
  ret x
.end

fn max_f64(a: f64, b: f64) -> f64
  if a > b ret a .end
  ret b
.end

fn min_f64(a: f64, b: f64) -> f64
  if a < b ret a .end
  ret b
.end

fn clamp_f64(x: f64, lo: f64, hi: f64) -> f64
  if x < lo ret lo .end
  if x > hi ret hi .end
  ret x
.end

fn copysign_f64(mag: f64, sgn: f64) -> f64
  if sgn < 0.0 ret -abs_f64(mag) .end
  ret abs_f64(mag)
.end

fn is_nan_like(x: f64) -> bool
  ret x != x
.end

fn is_finite(x: f64) -> bool
  if x > 1e308 ret false .end
  if x < -1e308 ret false .end
  ret true
.end

fn wrap_angle_pi(theta: f64) -> f64
  let mut t = theta
  while t <= -PI
    t = t + TAU
  .end
  while t > PI
    t = t - TAU
  .end
  ret t
.end

# ---------------------------------
# Robust sqrt + hypot
# ---------------------------------

fn sqrt_newton(x: f64) -> f64
  if x <= 0.0
    if x == 0.0 ret 0.0 .end
    ret 0.0
  .end

  let mut y = x
  if y > 1.0 y = y * 0.5 .end
  if y < 1.0 y = 1.0 .end

  let mut i = 0
  while i < 14
    y = 0.5 * (y + x / y)
    i = i + 1
  .end
  ret y
.end

fn hypot_robust(a: f64, b: f64) -> f64
  let aa = abs_f64(a)
  let bb = abs_f64(b)
  let m = max_f64(aa, bb)
  if m == 0.0 ret 0.0 .end
  let ra = aa / m
  let rb = bb / m
  ret m * sqrt_newton(ra*ra + rb*rb)
.end

# ---------------------------------
# atan/atan2 (fallback)
# ---------------------------------

const ATAN_A : f64 = 1.0
const ATAN_B : f64 = 0.280872
const ATAN_C : f64 = 0.8284
const ATAN_D : f64 = 0.1333

fn atan_rational(x: f64) -> f64
  let x2 = x*x
  let num = x * (ATAN_A + ATAN_B*x2)
  let den = 1.0 + ATAN_C*x2 + ATAN_D*x2*x2
  ret num / den
.end

fn atan_fallback(x: f64) -> f64
  let ax = abs_f64(x)
  if ax < 1e-18 ret x .end
  if ax > 1.0
    let t = atan_rational(1.0/ax)
    ret copysign_f64(HALF_PI - t, x)
  .end
  ret atan_rational(x)
.end

fn atan2_fallback(y: f64, x: f64) -> f64
  if x > 0.0
    ret atan_fallback(y / x)
  .end
  if x < 0.0
    if y >= 0.0 ret atan_fallback(y / x) + PI .end
    ret atan_fallback(y / x) - PI
  .end
  if y > 0.0 ret HALF_PI .end
  if y < 0.0 ret -HALF_PI .end
  ret 0.0
.end

# ---------------------------------
# sin/cos minimal (needed for exp/polar)
# ---------------------------------

fn floor_f64(x: f64) -> f64
  let i = x as i64
  let fi = i as f64
  if fi > x
    ret (i - 1) as f64
  .end
  ret fi
.end

const PI_HI : f64 = 3.141592653589793116
const PI_LO : f64 = 1.224646799147353207e-16

fn reduce_angle_half_pi(theta: f64) -> (f64, i32)
  let inv = 2.0 / PI
  let kf = floor_f64(theta * inv + 0.5)
  let k = kf as i32
  let kf64 = k as f64
  let p2_hi = 0.5 * PI_HI
  let p2_lo = 0.5 * PI_LO
  let r1 = theta - kf64 * p2_hi
  let r2 = r1 - kf64 * p2_lo
  ret (r2, k)
.end

fn sin_poly(r: f64) -> f64
  let x = r
  let x2 = x*x
  let x3 = x2*x
  let x5 = x3*x2
  let x7 = x5*x2
  let x9 = x7*x2
  ret x - x3*(1.0/6.0) + x5*(1.0/120.0) - x7*(1.0/5040.0) + x9*(1.0/362880.0)
.end

fn cos_poly(r: f64) -> f64
  let x2 = r*r
  let x4 = x2*x2
  let x6 = x4*x2
  let x8 = x4*x4
  ret 1.0 - 0.5*x2 + x4*(1.0/24.0) - x6*(1.0/720.0) + x8*(1.0/40320.0)
.end

fn sincos_min(theta: f64) -> (f64, f64)
  let rr = reduce_angle_half_pi(theta)
  let mut r = rr.0
  let k = rr.1

  let mut swap = false
  if r > (0.5*HALF_PI)
    r = HALF_PI - r
    swap = true
  .end
  if r < -(0.5*HALF_PI)
    r = -HALF_PI - r
    swap = true
  .end

  let s0 = sin_poly(r)
  let c0 = cos_poly(r)

  let mut s = s0
  let mut c = c0
  if swap
    s = c0
    c = s0
  .end

  let q = k & 3
  if q == 0 ret (s, c) .end
  if q == 1 ret (c, -s) .end
  if q == 2 ret (-s, -c) .end
  ret (-c, s)
.end

fn sin_min(theta: f64) -> f64
  ret sincos_min(theta).0
.end

fn cos_min(theta: f64) -> f64
  ret sincos_min(theta).1
.end

# ---------------------------------
# Real exp/log minimal (used by complex exp/log)
# ---------------------------------

fn ldexp_f64(x: f64, exp2: i32) -> f64
  let mut v = x
  if exp2 > 0
    let mut k = 0
    while k < exp2
      v = v * 2.0
      k = k + 1
    .end
    ret v
  .end
  if exp2 < 0
    let mut k = 0
    let n = -exp2
    while k < n
      v = v * 0.5
      k = k + 1
    .end
    ret v
  .end
  ret v
.end

struct Frexp
  mantissa : f64
  exponent : i32
.end

fn frexp_f64(x: f64) -> Frexp
  let mut v = x
  let mut e = 0
  while v >= 1.0
    v = v * 0.5
    e = e + 1
  .end
  while v < 0.5
    v = v * 2.0
    e = e - 1
  .end
  ret Frexp { mantissa: v, exponent: e }
.end

fn exp_poly7(r: f64) -> f64
  let r2 = r*r
  let r3 = r2*r
  let r4 = r2*r2
  let r5 = r4*r
  let r6 = r3*r3
  let r7 = r6*r
  ret 1.0 + r + 0.5*r2 + (1.0/6.0)*r3 + (1.0/24.0)*r4 + (1.0/120.0)*r5 + (1.0/720.0)*r6 + (1.0/5040.0)*r7
.end

fn exp_min(x: f64) -> f64
  let xc = clamp_f64(x, -700.0, 700.0)
  let kf = floor_f64(xc * INV_LN2 + 0.5)
  let k = kf as i32
  let r = xc - (k as f64) * LN2
  ret ldexp_f64(exp_poly7(r), k)
.end

fn log1p_series9(t: f64) -> f64
  let t2 = t*t
  let t3 = t2*t
  let t4 = t2*t2
  let t5 = t4*t
  let t6 = t3*t3
  let t7 = t6*t
  let t8 = t4*t4
  let t9 = t8*t
  ret t
    - 0.5*t2
    + (1.0/3.0)*t3
    - 0.25*t4
    + 0.2*t5
    - (1.0/6.0)*t6
    + (1.0/7.0)*t7
    - 0.125*t8
    + (1.0/9.0)*t9
.end

fn log_min(x: f64) -> f64
  if x <= 0.0 ret -1e300 .end
  let fr = frexp_f64(x)
  let t = fr.mantissa - 1.0
  ret log1p_series9(t) + (fr.exponent as f64) * LN2
.end

fn expm1_min(x: f64) -> f64
  let ax = abs_f64(x)
  if ax < 1e-5
    let x2 = x*x
    let x3 = x2*x
    let x4 = x2*x2
    let x5 = x4*x
    ret x + 0.5*x2 + (1.0/6.0)*x3 + (1.0/24.0)*x4 + (1.0/120.0)*x5
  .end
  ret exp_min(x) - 1.0
.end

fn log1p_min(x: f64) -> f64
  if x <= -1.0 ret -1e300 .end
  let ax = abs_f64(x)
  if ax < 1e-6
    let x2 = x*x
    let x3 = x2*x
    let x4 = x2*x2
    let x5 = x4*x
    ret x - 0.5*x2 + (1.0/3.0)*x3 - 0.25*x4 + 0.2*x5
  .end
  ret log_min(1.0 + x)
.end

# ---------------------------------
# Constructors / helpers
# ---------------------------------

fn complex(re: f64, im: f64) -> Complex
  ret Complex { re: re, im: im }
.end

fn zero() -> Complex
  ret Complex { re: 0.0, im: 0.0 }
.end

fn one() -> Complex
  ret Complex { re: 1.0, im: 0.0 }
.end

fn i_unit() -> Complex
  ret Complex { re: 0.0, im: 1.0 }
.end

fn add(a: Complex, b: Complex) -> Complex
  ret Complex { re: a.re + b.re, im: a.im + b.im }
.end

fn sub(a: Complex, b: Complex) -> Complex
  ret Complex { re: a.re - b.re, im: a.im - b.im }
.end

fn neg(a: Complex) -> Complex
  ret Complex { re: -a.re, im: -a.im }
.end

fn mul(a: Complex, b: Complex) -> Complex
  ret Complex { re: a.re*b.re - a.im*b.im, im: a.re*b.im + a.im*b.re }
.end

fn mul_real(a: Complex, s: f64) -> Complex
  ret Complex { re: a.re*s, im: a.im*s }
.end

fn conj(a: Complex) -> Complex
  ret Complex { re: a.re, im: -a.im }
.end

fn div(a: Complex, b: Complex) -> ComplexErr
  # robust division
  let br = b.re
  let bi = b.im
  if br == 0.0 && bi == 0.0
    ret ComplexErr { ok: false, value: zero() }
  .end

  let abr = abs_f64(br)
  let abi = abs_f64(bi)

  if abr >= abi
    let r = bi / br
    let denom = br + bi*r
    let re = (a.re + a.im*r) / denom
    let im = (a.im - a.re*r) / denom
    ret ComplexErr { ok: true, value: Complex { re: re, im: im } }
  .end

  let r = br / bi
  let denom = bi + br*r
  let re = (a.re*r + a.im) / denom
  let im = (a.im*r - a.re) / denom
  ret ComplexErr { ok: true, value: Complex { re: re, im: im } }
.end

fn inv(a: Complex) -> ComplexErr
  ret div(one(), a)
.end

fn abs(a: Complex) -> f64
  ret hypot_robust(a.re, a.im)
.end

fn arg(a: Complex) -> f64
  ret atan2_fallback(a.im, a.re)
.end

fn to_polar(a: Complex) -> Polar
  ret Polar { r: abs(a), theta: arg(a) }
.end

fn from_polar(p: Polar) -> Complex
  let sc = sincos_min(p.theta)
  ret Complex { re: p.r * sc.1, im: p.r * sc.0 }
.end

fn normalize_polar(mut p: Polar) -> Polar
  if p.r < 0.0
    p.r = -p.r
    p.theta = wrap_angle_pi(p.theta + PI)
    ret p
  .end
  p.theta = wrap_angle_pi(p.theta)
  ret p
.end

# ---------------------------------
# Complex exp / expm1
# ---------------------------------

fn exp(z: Complex) -> Complex
  # exp(x+iy) = exp(x)(cos y + i sin y)
  let ex = exp_min(z.re)
  let sc = sincos_min(z.im)
  ret Complex { re: ex * sc.1, im: ex * sc.0 }
.end

fn expm1(z: Complex) -> Complex
  # expm1(x+iy) = exp(x)(cos y + i sin y) - 1
  # do expm1 on real part for precision near 0:
  let exm1 = expm1_min(z.re)
  let ex = exm1 + 1.0
  let sc = sincos_min(z.im)
  # (ex*(c + i s) - 1) = (ex*c - 1) + i(ex*s)
  ret Complex { re: ex * sc.1 - 1.0, im: ex * sc.0 }
.end

# ---------------------------------
# Complex log / log1p
# ---------------------------------

fn log(z: Complex) -> ComplexErr
  # log(z) = ln|z| + i arg(z)
  let r = abs(z)
  if r == 0.0
    ret ComplexErr { ok: false, value: zero() }
  .end
  ret ComplexErr { ok: true, value: Complex { re: log_min(r), im: arg(z) } }
.end

fn log1p(z: Complex) -> ComplexErr
  # log(1+z)
  let w = add(one(), z)
  ret log(w)
.end

fn log_base(z: Complex, base: Complex) -> ComplexErr
  # log_base(z) = log(z) / log(base)
  let lz = log(z)
  if !lz.ok ret ComplexErr { ok: false, value: zero() } .end
  let lb = log(base)
  if !lb.ok ret ComplexErr { ok: false, value: zero() } .end
  let q = div(lz.value, lb.value)
  if !q.ok ret ComplexErr { ok: false, value: zero() } .end
  ret q
.end

# ---------------------------------
# Complex pow + roots
# ---------------------------------

fn pow(z: Complex, w: Complex) -> ComplexErr
  # z^w = exp(w*log(z))
  let lz = log(z)
  if !lz.ok
    ret ComplexErr { ok: false, value: zero() }
  .end
  let t = mul(w, lz.value)
  ret ComplexErr { ok: true, value: exp(t) }
.end

fn pow_real(z: Complex, p: f64) -> ComplexErr
  ret pow(z, Complex { re: p, im: 0.0 })
.end

fn sqrt(z: Complex) -> Complex
  # principal sqrt:
  # r = |z|
  # u = sqrt((r + x)/2)
  # v = sign(y)*sqrt((r - x)/2)
  let r = abs(z)
  if r == 0.0
    ret zero()
  .end
  let u = sqrt_newton(0.5 * (r + z.re))
  let v = copysign_f64(sqrt_newton(0.5 * (r - z.re)), z.im)
  ret Complex { re: u, im: v }
.end

fn cbrt(z: Complex) -> Complex
  # principal cube root using polar:
  # z = r e^{iθ} => cbrt = r^{1/3} e^{iθ/3}
  let p = to_polar(z)
  let r13 = exp_min((1.0/3.0) * log_min(p.r))
  let th = p.theta / 3.0
  ret from_polar(Polar { r: r13, theta: th })
.end

# ---------------------------------
# Extra: exp/log properties helpers
# ---------------------------------

fn exp2(z: Complex) -> Complex
  # exp2(z) = 2^z = exp(z * ln2)
  ret exp(mul_real(z, LN2))
.end

fn log2(z: Complex) -> ComplexErr
  let lz = log(z)
  if !lz.ok ret ComplexErr { ok: false, value: zero() } .end
  # divide by ln2
  ret ComplexErr { ok: true, value: Complex { re: lz.value.re / LN2, im: lz.value.im / LN2 } }
.end

fn exp10(z: Complex) -> Complex
  # 10^z = exp(z * ln(10))
  let ln10 = log_min(10.0)
  ret exp(mul_real(z, ln10))
.end

fn log10(z: Complex) -> ComplexErr
  let lz = log(z)
  if !lz.ok ret ComplexErr { ok: false, value: zero() } .end
  let ln10 = log_min(10.0)
  ret ComplexErr { ok: true, value: Complex { re: lz.value.re / ln10, im: lz.value.im / ln10 } }
.end

# ---------------------------------
# Tests
# ---------------------------------

fn approx_eq(a: f64, b: f64, eps: f64) -> bool
  ret abs_f64(a - b) <= eps
.end

fn approx_eq_c(a: Complex, b: Complex, eps: f64) -> bool
  ret approx_eq(a.re, b.re, eps) && approx_eq(a.im, b.im, eps)
.end

fn test_exp_basic()
  let z = complex(0.0, 0.0)
  let e = exp(z)
  if !approx_eq_c(e, one(), 1e-6) panic("exp(0) failed") .end
.end

fn test_log_basic()
  let z = complex(1.0, 0.0)
  let l = log(z)
  if !l.ok panic("log(1) failed") .end
  if abs_f64(l.value.re) > 1e-6 || abs_f64(l.value.im) > 1e-6
    panic("log(1) wrong")
  .end
.end

fn test_exp_log_roundtrip()
  let z = complex(0.2, -0.7)
  let ez = exp(z)
  let lz = log(ez)
  if !lz.ok panic("log(exp(z)) failed") .end
  # tol assez large (fallback min)
  if abs_f64(lz.value.re - z.re) > 3e-2 || abs_f64(lz.value.im - z.im) > 3e-2
    panic("roundtrip too large")
  .end
.end

fn test_pow()
  let z = complex(2.0, 0.0)
  let w = complex(3.0, 0.0)
  let p = pow(z, w)
  if !p.ok panic("pow failed") .end
  if abs_f64(p.value.re - 8.0) > 5e-2 || abs_f64(p.value.im) > 5e-2
    panic("pow(2,3) wrong")
  .end
.end

fn test_sqrt()
  let z = complex(3.0, 4.0)
  let w = sqrt(z)
  # w^2 should be z (approx)
  let ww = mul(w, w)
  if abs_f64(ww.re - z.re) > 2e-6 || abs_f64(ww.im - z.im) > 2e-6
    # fallback sin/cos not involved; should be good
    panic("sqrt check failed")
  .end
.end

fn run_all_tests()
  test_exp_basic()
  test_log_basic()
  test_exp_log_roundtrip()
  test_pow()
  test_sqrt()
.end

.end
