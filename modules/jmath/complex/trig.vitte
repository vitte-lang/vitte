module jmath.complex.trig

# ============================================================================
# complex.trig – trig/hyperboliques complexes (ultra)
# - Impl autonome : Complex + exp/log/sqrt + trig/hyp + inverses
# - Pas d’accolades, blocs `.end`
# ============================================================================

const PI      : f64 = 3.141592653589793238462643383279502884
const TAU     : f64 = 6.283185307179586476925286766559005768
const HALF_PI : f64 = 1.570796326794896619231321691639751442

const LN2     : f64 = 0.693147180559945309417232121458176568
const INV_LN2 : f64 = 1.442695040888963407359924681001892137

struct Complex
  re : f64
  im : f64
.end

struct ComplexErr
  ok : bool
  value : Complex
.end

struct Polar
  r : f64
  theta : f64
.end

# ---------------------------------
# Base utils
# ---------------------------------

fn abs_f64(x: f64) -> f64
  if x < 0.0 ret -x .end
  ret x
.end

fn max_f64(a: f64, b: f64) -> f64
  if a > b ret a .end
  ret b
.end

fn min_f64(a: f64, b: f64) -> f64
  if a < b ret a .end
  ret b
.end

fn clamp_f64(x: f64, lo: f64, hi: f64) -> f64
  if x < lo ret lo .end
  if x > hi ret hi .end
  ret x
.end

fn copysign_f64(mag: f64, sgn: f64) -> f64
  if sgn < 0.0 ret -abs_f64(mag) .end
  ret abs_f64(mag)
.end

fn is_nan_like(x: f64) -> bool
  ret x != x
.end

fn wrap_angle_pi(theta: f64) -> f64
  let mut t = theta
  while t <= -PI
    t = t + TAU
  .end
  while t > PI
    t = t - TAU
  .end
  ret t
.end

# ---------------------------------
# Robust sqrt + hypot
# ---------------------------------

fn sqrt_newton(x: f64) -> f64
  if x <= 0.0
    if x == 0.0 ret 0.0 .end
    ret 0.0
  .end
  let mut y = x
  if y > 1.0 y = y * 0.5 .end
  if y < 1.0 y = 1.0 .end
  let mut i = 0
  while i < 14
    y = 0.5 * (y + x / y)
    i = i + 1
  .end
  ret y
.end

fn hypot_robust(a: f64, b: f64) -> f64
  let aa = abs_f64(a)
  let bb = abs_f64(b)
  let m = max_f64(aa, bb)
  if m == 0.0 ret 0.0 .end
  let ra = aa / m
  let rb = bb / m
  ret m * sqrt_newton(ra*ra + rb*rb)
.end

# ---------------------------------
# atan/atan2 fallback
# ---------------------------------

const ATAN_A : f64 = 1.0
const ATAN_B : f64 = 0.280872
const ATAN_C : f64 = 0.8284
const ATAN_D : f64 = 0.1333

fn atan_rational(x: f64) -> f64
  let x2 = x*x
  let num = x * (ATAN_A + ATAN_B*x2)
  let den = 1.0 + ATAN_C*x2 + ATAN_D*x2*x2
  ret num / den
.end

fn atan_fallback(x: f64) -> f64
  let ax = abs_f64(x)
  if ax < 1e-18 ret x .end
  if ax > 1.0
    let t = atan_rational(1.0/ax)
    ret copysign_f64(HALF_PI - t, x)
  .end
  ret atan_rational(x)
.end

fn atan2_fallback(y: f64, x: f64) -> f64
  if x > 0.0 ret atan_fallback(y / x) .end
  if x < 0.0
    if y >= 0.0 ret atan_fallback(y / x) + PI .end
    ret atan_fallback(y / x) - PI
  .end
  if y > 0.0 ret HALF_PI .end
  if y < 0.0 ret -HALF_PI .end
  ret 0.0
.end

# ---------------------------------
# sin/cos minimal (real)
# ---------------------------------

fn floor_f64(x: f64) -> f64
  let i = x as i64
  let fi = i as f64
  if fi > x ret (i - 1) as f64 .end
  ret fi
.end

const PI_HI : f64 = 3.141592653589793116
const PI_LO : f64 = 1.224646799147353207e-16

fn reduce_angle_half_pi(theta: f64) -> (f64, i32)
  let inv = 2.0 / PI
  let kf = floor_f64(theta * inv + 0.5)
  let k = kf as i32
  let kf64 = k as f64
  let p2_hi = 0.5 * PI_HI
  let p2_lo = 0.5 * PI_LO
  let r1 = theta - kf64 * p2_hi
  let r2 = r1 - kf64 * p2_lo
  ret (r2, k)
.end

fn sin_poly(r: f64) -> f64
  let x = r
  let x2 = x*x
  let x3 = x2*x
  let x5 = x3*x2
  let x7 = x5*x2
  let x9 = x7*x2
  ret x - x3*(1.0/6.0) + x5*(1.0/120.0) - x7*(1.0/5040.0) + x9*(1.0/362880.0)
.end

fn cos_poly(r: f64) -> f64
  let x2 = r*r
  let x4 = x2*x2
  let x6 = x4*x2
  let x8 = x4*x4
  ret 1.0 - 0.5*x2 + x4*(1.0/24.0) - x6*(1.0/720.0) + x8*(1.0/40320.0)
.end

fn sincos_min(theta: f64) -> (f64, f64)
  let rr = reduce_angle_half_pi(theta)
  let mut r = rr.0
  let k = rr.1

  let mut swap = false
  if r > (0.5*HALF_PI)
    r = HALF_PI - r
    swap = true
  .end
  if r < -(0.5*HALF_PI)
    r = -HALF_PI - r
    swap = true
  .end

  let s0 = sin_poly(r)
  let c0 = cos_poly(r)

  let mut s = s0
  let mut c = c0
  if swap
    s = c0
    c = s0
  .end

  let q = k & 3
  if q == 0 ret (s, c) .end
  if q == 1 ret (c, -s) .end
  if q == 2 ret (-s, -c) .end
  ret (-c, s)
.end

fn sin_min(theta: f64) -> f64 ret sincos_min(theta).0 .end
fn cos_min(theta: f64) -> f64 ret sincos_min(theta).1 .end

# ---------------------------------
# exp/log minimal (real)
# ---------------------------------

fn exp_poly7(r: f64) -> f64
  let r2 = r*r
  let r3 = r2*r
  let r4 = r2*r2
  let r5 = r4*r
  let r6 = r3*r3
  let r7 = r6*r
  ret 1.0 + r + 0.5*r2 + (1.0/6.0)*r3 + (1.0/24.0)*r4 + (1.0/120.0)*r5 + (1.0/720.0)*r6 + (1.0/5040.0)*r7
.end

fn ldexp_f64(x: f64, exp2: i32) -> f64
  let mut v = x
  if exp2 > 0
    let mut k = 0
    while k < exp2
      v = v * 2.0
      k = k + 1
    .end
    ret v
  .end
  if exp2 < 0
    let mut k = 0
    let n = -exp2
    while k < n
      v = v * 0.5
      k = k + 1
    .end
    ret v
  .end
  ret v
.end

fn exp_min(x: f64) -> f64
  let xc = clamp_f64(x, -700.0, 700.0)
  let kf = floor_f64(xc * INV_LN2 + 0.5)
  let k = kf as i32
  let r = xc - (k as f64) * LN2
  ret ldexp_f64(exp_poly7(r), k)
.end

struct Frexp
  mantissa : f64
  exponent : i32
.end

fn frexp_f64(x: f64) -> Frexp
  if x == 0.0 ret Frexp { mantissa: 0.0, exponent: 0 } .end
  let mut v = x
  let mut e = 0
  while v >= 1.0
    v = v * 0.5
    e = e + 1
  .end
  while v < 0.5
    v = v * 2.0
    e = e - 1
  .end
  ret Frexp { mantissa: v, exponent: e }
.end

fn log1p_series9(t: f64) -> f64
  let t2 = t*t
  let t3 = t2*t
  let t4 = t2*t2
  let t5 = t4*t
  let t6 = t3*t3
  let t7 = t6*t
  let t8 = t4*t4
  let t9 = t8*t
  ret t
    - 0.5*t2
    + (1.0/3.0)*t3
    - 0.25*t4
    + 0.2*t5
    - (1.0/6.0)*t6
    + (1.0/7.0)*t7
    - 0.125*t8
    + (1.0/9.0)*t9
.end

fn log_min(x: f64) -> f64
  if x <= 0.0 ret -1e300 .end
  let fr = frexp_f64(x)
  let t = fr.mantissa - 1.0
  ret log1p_series9(t) + (fr.exponent as f64) * LN2
.end

# ---------------------------------
# Complex core
# ---------------------------------

fn c(re: f64, im: f64) -> Complex ret Complex { re: re, im: im } .end
fn zero() -> Complex ret c(0.0, 0.0) .end
fn one() -> Complex ret c(1.0, 0.0) .end
fn i_unit() -> Complex ret c(0.0, 1.0) .end

fn add(a: Complex, b: Complex) -> Complex ret c(a.re + b.re, a.im + b.im) .end
fn sub(a: Complex, b: Complex) -> Complex ret c(a.re - b.re, a.im - b.im) .end
fn neg(a: Complex) -> Complex ret c(-a.re, -a.im) .end

fn mul(a: Complex, b: Complex) -> Complex
  ret c(a.re*b.re - a.im*b.im, a.re*b.im + a.im*b.re)
.end

fn mul_real(a: Complex, s: f64) -> Complex ret c(a.re*s, a.im*s) .end
fn conj(a: Complex) -> Complex ret c(a.re, -a.im) .end

fn abs_c(a: Complex) -> f64 ret hypot_robust(a.re, a.im) .end
fn arg_c(a: Complex) -> f64 ret atan2_fallback(a.im, a.re) .end

fn div(a: Complex, b: Complex) -> ComplexErr
  let br = b.re
  let bi = b.im
  if br == 0.0 && bi == 0.0
    ret ComplexErr { ok: false, value: zero() }
  .end

  let abr = abs_f64(br)
  let abi = abs_f64(bi)

  if abr >= abi
    let r = bi / br
    let denom = br + bi*r
    let re = (a.re + a.im*r) / denom
    let im = (a.im - a.re*r) / denom
    ret ComplexErr { ok: true, value: c(re, im) }
  .end

  let r = br / bi
  let denom = bi + br*r
  let re = (a.re*r + a.im) / denom
  let im = (a.im*r - a.re) / denom
  ret ComplexErr { ok: true, value: c(re, im) }
.end

fn inv(a: Complex) -> ComplexErr ret div(one(), a) .end

fn sqrt_c(z: Complex) -> Complex
  # principal sqrt
  let r = abs_c(z)
  if r == 0.0 ret zero() .end
  let u = sqrt_newton(0.5 * (r + z.re))
  let v = copysign_f64(sqrt_newton(0.5 * (r - z.re)), z.im)
  ret c(u, v)
.end

fn exp_c(z: Complex) -> Complex
  let ex = exp_min(z.re)
  let sc = sincos_min(z.im)
  # e^(x+iy)=e^x(cos y + i sin y)
  ret c(ex * sc.1, ex * sc.0)
.end

fn log_c(z: Complex) -> ComplexErr
  let r = abs_c(z)
  if r == 0.0 ret ComplexErr { ok: false, value: zero() } .end
  ret ComplexErr { ok: true, value: c(log_min(r), arg_c(z)) }
.end

fn log1p_c(z: Complex) -> ComplexErr
  ret log_c(add(one(), z))
.end

fn polar(z: Complex) -> Polar
  ret Polar { r: abs_c(z), theta: wrap_angle_pi(arg_c(z)) }
.end

fn from_polar(r: f64, theta: f64) -> Complex
  let sc = sincos_min(theta)
  ret c(r * sc.1, r * sc.0)
.end

# ---------------------------------
# Hyperbolic (complex)
# ---------------------------------

fn sinh_real(x: f64) -> f64
  let ex = exp_min(x)
  let em = exp_min(-x)
  ret 0.5 * (ex - em)
.end

fn cosh_real(x: f64) -> f64
  let ex = exp_min(x)
  let em = exp_min(-x)
  ret 0.5 * (ex + em)
.end

fn sinh(z: Complex) -> Complex
  let ez = exp_c(z)
  let emz = exp_c(neg(z))
  ret mul_real(sub(ez, emz), 0.5)
.end

fn cosh(z: Complex) -> Complex
  let ez = exp_c(z)
  let emz = exp_c(neg(z))
  ret mul_real(add(ez, emz), 0.5)
.end

fn tanh(z: Complex) -> ComplexErr
  let sh = sinh(z)
  let ch = cosh(z)
  ret div(sh, ch)
.end

fn coth(z: Complex) -> ComplexErr
  let th = tanh(z)
  if !th.ok ret th .end
  ret inv(th.value)
.end

fn sech(z: Complex) -> ComplexErr ret inv(cosh(z)) .end
fn csch(z: Complex) -> ComplexErr ret inv(sinh(z)) .end

fn asinh(z: Complex) -> ComplexErr
  let z2 = mul(z, z)
  let t = add(z2, one())
  let s = sqrt_c(t)
  let w = add(z, s)
  ret log_c(w)
.end

fn acosh(z: Complex) -> ComplexErr
  let sp = sqrt_c(add(z, one()))
  let sm = sqrt_c(sub(z, one()))
  let w = add(z, mul(sp, sm))
  ret log_c(w)
.end

fn atanh(z: Complex) -> ComplexErr
  let lp = log_c(add(one(), z))
  if !lp.ok ret lp .end
  let lm = log_c(sub(one(), z))
  if !lm.ok ret lm .end
  ret ComplexErr { ok: true, value: mul_real(sub(lp.value, lm.value), 0.5) }
.end

fn acoth(z: Complex) -> ComplexErr
  let iz = inv(z)
  if !iz.ok ret iz .end
  ret atanh(iz.value)
.end

fn asech(z: Complex) -> ComplexErr
  let iz = inv(z)
  if !iz.ok ret iz .end
  ret acosh(iz.value)
.end

fn acsch(z: Complex) -> ComplexErr
  let iz = inv(z)
  if !iz.ok ret iz .end
  ret asinh(iz.value)
.end

# ---------------------------------
# Trig (complex)
# ---------------------------------

fn sin(z: Complex) -> Complex
  # sin(x+iy)=sin x cosh y + i cos x sinh y
  let sx = sin_min(z.re)
  let cx = cos_min(z.re)
  let shy = sinh_real(z.im)
  let chy = cosh_real(z.im)
  ret c(sx*chy, cx*shy)
.end

fn cos(z: Complex) -> Complex
  # cos(x+iy)=cos x cosh y - i sin x sinh y
  let sx = sin_min(z.re)
  let cx = cos_min(z.re)
  let shy = sinh_real(z.im)
  let chy = cosh_real(z.im)
  ret c(cx*chy, -sx*shy)
.end

fn tan(z: Complex) -> ComplexErr
  ret div(sin(z), cos(z))
.end

fn cot(z: Complex) -> ComplexErr
  let t = tan(z)
  if !t.ok ret t .end
  ret inv(t.value)
.end

fn sec(z: Complex) -> ComplexErr ret inv(cos(z)) .end
fn csc(z: Complex) -> ComplexErr ret inv(sin(z)) .end

# ---------------------------------
# Inverses trig (complex)
# ---------------------------------

fn asin(z: Complex) -> ComplexErr
  # -i log( i z + sqrt(1 - z^2) )
  let iz = mul(i_unit(), z)
  let z2 = mul(z, z)
  let one_minus = sub(one(), z2)
  let s = sqrt_c(one_minus)
  let w = add(iz, s)
  let lw = log_c(w)
  if !lw.ok ret lw .end
  # -i*(a+ib)= b + i*(-a)
  ret ComplexErr { ok: true, value: c(lw.value.im, -lw.value.re) }
.end

fn acos(z: Complex) -> ComplexErr
  let a = asin(z)
  if !a.ok ret a .end
  ret ComplexErr { ok: true, value: sub(c(HALF_PI, 0.0), a.value) }
.end

fn atan(z: Complex) -> ComplexErr
  # (i/2) [log(1 - i z) - log(1 + i z)]
  let iz = mul(i_unit(), z)
  let a = log_c(sub(one(), iz))
  if !a.ok ret a .end
  let b = log_c(add(one(), iz))
  if !b.ok ret b .end
  let d = sub(a.value, b.value)
  # (i/2)*(dr + i di) = (-di/2) + i(dr/2)
  ret ComplexErr { ok: true, value: c(-0.5*d.im, 0.5*d.re) }
.end

fn acot(z: Complex) -> ComplexErr
  let iz = inv(z)
  if !iz.ok ret iz .end
  ret atan(iz.value)
.end

fn asec(z: Complex) -> ComplexErr
  let iz = inv(z)
  if !iz.ok ret iz .end
  ret acos(iz.value)
.end

fn acsc(z: Complex) -> ComplexErr
  let iz = inv(z)
  if !iz.ok ret iz .end
  ret asin(iz.value)
.end

# ---------------------------------
# Extra identities
# ---------------------------------

fn sinpi(z: Complex) -> Complex ret sin(mul_real(z, PI)) .end
fn cospi(z: Complex) -> Complex ret cos(mul_real(z, PI)) .end
fn tanpi(z: Complex) -> ComplexErr ret tan(mul_real(z, PI)) .end

# ---------------------------------
# Tests
# ---------------------------------

fn approx_eq(a: f64, b: f64, eps: f64) -> bool
  ret abs_f64(a - b) <= eps
.end

fn approx_eq_c(a: Complex, b: Complex, eps: f64) -> bool
  ret approx_eq(a.re, b.re, eps) && approx_eq(a.im, b.im, eps)
.end

fn test_trig_real_axis()
  let z = c(0.3, 0.0)
  let s = sin(z)
  let c0 = cos(z)
  if abs_f64(s.im) > 1e-9 panic("sin real axis imag") .end
  if abs_f64(c0.im) > 1e-9 panic("cos real axis imag") .end
  if abs_f64(s.re - sin_min(0.3)) > 5e-6 panic("sin mismatch") .end
  if abs_f64(c0.re - cos_min(0.3)) > 5e-6 panic("cos mismatch") .end
.end

fn test_asin_sin_roundtrip()
  let z = c(0.2, -0.4)
  let a = asin(z)
  if !a.ok panic("asin failed") .end
  let s = sin(a.value)
  if abs_c(sub(s, z)) > 2e-2
    panic("asin/sin roundtrip too large")
  .end
.end

fn test_atan_tan_roundtrip()
  let z = c(0.1, 0.2)
  let a = atan(z)
  if !a.ok panic("atan failed") .end
  let t = tan(a.value)
  if !t.ok panic("tan failed") .end
  if abs_c(sub(t.value, z)) > 3e-2
    panic("atan/tan roundtrip too large")
  .end
.end

fn run_all_tests()
  test_trig_real_axis()
  test_asin_sin_roundtrip()
  test_atan_tan_roundtrip()
.end

.end
