module jmath.constants.ieee754

# ============================================================================
# constants.ieee754 – IEEE-754 (f32/f64) ultra complet max
# NOTE IMPORTANT:
#   f32_to_bits/f32_from_bits/f64_to_bits/f64_from_bits doivent être de vrais
#   bitcasts. Si ton `as` n’est pas un bitcast, branche des intrinsics VM.
# ============================================================================

enum FpClass
  Nan
  Inf
  Zero
  Subnormal
  Normal
.end

struct F32Parts
  sign : i32
  exp  : i32
  frac : u32
.end

struct F64Parts
  sign : i32
  exp  : i32
  frac : u64
.end

struct FrexpF32
  mantissa : f32
  exponent : i32
.end

struct FrexpF64
  mantissa : f64
  exponent : i32
.end

struct UlpCmp
  ok : bool
  distance : u64
.end

# ---------------------------------
# Layout f32
# ---------------------------------

const F32_SIGN_MASK : u32 = 0x80000000
const F32_EXP_MASK  : u32 = 0x7F800000
const F32_FRAC_MASK : u32 = 0x007FFFFF

const F32_EXP_SHIFT : i32 = 23
const F32_FRAC_BITS : i32 = 23
const F32_EXP_BIAS  : i32 = 127
const F32_EXP_MAX   : i32 = 255

const F32_POS_ZERO_BITS : u32 = 0x00000000
const F32_NEG_ZERO_BITS : u32 = 0x80000000
const F32_POS_INF_BITS  : u32 = 0x7F800000
const F32_NEG_INF_BITS  : u32 = 0xFF800000

const F32_QNAN_BITS     : u32 = 0x7FC00000
const F32_SNAN_BITS     : u32 = 0x7FA00001

const F32_MIN_SUB_BITS    : u32 = 0x00000001
const F32_MIN_NORMAL_BITS : u32 = 0x00800000
const F32_MAX_FINITE_BITS : u32 = 0x7F7FFFFF

const F32_EPSILON      : f32 = 1.1920928955078125e-7
const F32_MIN_POSITIVE : f32 = 1.401298464324817e-45
const F32_MIN_NORMAL   : f32 = 1.1754943508222875e-38
const F32_MAX          : f32 = 3.4028234663852886e38

# ---------------------------------
# Layout f64
# ---------------------------------

const F64_SIGN_MASK : u64 = 0x8000000000000000
const F64_EXP_MASK  : u64 = 0x7FF0000000000000
const F64_FRAC_MASK : u64 = 0x000FFFFFFFFFFFFF

const F64_EXP_SHIFT : i32 = 52
const F64_FRAC_BITS : i32 = 52
const F64_EXP_BIAS  : i32 = 1023
const F64_EXP_MAX   : i32 = 2047

const F64_POS_ZERO_BITS : u64 = 0x0000000000000000
const F64_NEG_ZERO_BITS : u64 = 0x8000000000000000
const F64_POS_INF_BITS  : u64 = 0x7FF0000000000000
const F64_NEG_INF_BITS  : u64 = 0xFFF0000000000000

const F64_QNAN_BITS     : u64 = 0x7FF8000000000000
const F64_SNAN_BITS     : u64 = 0x7FF4000000000001

const F64_MIN_SUB_BITS    : u64 = 0x0000000000000001
const F64_MIN_NORMAL_BITS : u64 = 0x0010000000000000
const F64_MAX_FINITE_BITS : u64 = 0x7FEFFFFFFFFFFFFF

const F64_EPSILON      : f64 = 2.220446049250313080847263336181640625e-16
const F64_MIN_POSITIVE : f64 = 4.940656458412465441765687928682213723e-324
const F64_MIN_NORMAL   : f64 = 2.225073858507201383090232717332404064e-308
const F64_MAX          : f64 = 1.797693134862315708145274237317043568e308

# ---------------------------------
# Utils
# ---------------------------------

fn is_nan_f32(x: f32) -> bool ret x != x .end
fn is_nan_f64(x: f64) -> bool ret x != x .end

# ---------------------------------
# Bitcast API (à brancher sur intrinsics)
# ---------------------------------

fn f32_to_bits(x: f32) -> u32
  # TODO intrinsic bitcast
  ret x as u32
.end

fn f32_from_bits(u: u32) -> f32
  # TODO intrinsic bitcast
  ret u as f32
.end

fn f64_to_bits(x: f64) -> u64
  # TODO intrinsic bitcast
  ret x as u64
.end

fn f64_from_bits(u: u64) -> f64
  # TODO intrinsic bitcast
  ret u as f64
.end

# ---------------------------------
# Parts / fields
# ---------------------------------

fn f32_parts_bits(u: u32) -> F32Parts
  let sign = if (u & F32_SIGN_MASK) != 0 then 1 else 0 .end
  let expu = (u & F32_EXP_MASK) >> (F32_EXP_SHIFT as u32)
  let frac = (u & F32_FRAC_MASK)
  ret F32Parts { sign: sign, exp: expu as i32, frac: frac }
.end

fn f64_parts_bits(u: u64) -> F64Parts
  let sign = if (u & F64_SIGN_MASK) != 0 then 1 else 0 .end
  let expu = (u & F64_EXP_MASK) >> (F64_EXP_SHIFT as u64)
  let frac = (u & F64_FRAC_MASK)
  ret F64Parts { sign: sign, exp: expu as i32, frac: frac }
.end

fn f32_exp_bits(u: u32) -> i32
  ret (((u & F32_EXP_MASK) >> (F32_EXP_SHIFT as u32)) as i32)
.end

fn f64_exp_bits(u: u64) -> i32
  ret (((u & F64_EXP_MASK) >> (F64_EXP_SHIFT as u64)) as i32)
.end

fn f32_unbiased_exp_bits(u: u32) -> i32
  let e = f32_exp_bits(u)
  if e == 0 ret 1 - F32_EXP_BIAS .end
  if e == F32_EXP_MAX ret 0 .end
  ret e - F32_EXP_BIAS
.end

fn f64_unbiased_exp_bits(u: u64) -> i32
  let e = f64_exp_bits(u)
  if e == 0 ret 1 - F64_EXP_BIAS .end
  if e == F64_EXP_MAX ret 0 .end
  ret e - F64_EXP_BIAS
.end

# ---------------------------------
# Classification
# ---------------------------------

fn f32_class_bits(u: u32) -> FpClass
  let e = (u & F32_EXP_MASK)
  let f = (u & F32_FRAC_MASK)
  if e == F32_EXP_MASK
    if f != 0 ret FpClass.Nan .end
    ret FpClass.Inf
  .end
  if e == 0
    if f == 0 ret FpClass.Zero .end
    ret FpClass.Subnormal
  .end
  ret FpClass.Normal
.end

fn f64_class_bits(u: u64) -> FpClass
  let e = (u & F64_EXP_MASK)
  let f = (u & F64_FRAC_MASK)
  if e == F64_EXP_MASK
    if f != 0 ret FpClass.Nan .end
    ret FpClass.Inf
  .end
  if e == 0
    if f == 0 ret FpClass.Zero .end
    ret FpClass.Subnormal
  .end
  ret FpClass.Normal
.end

fn f32_class(x: f32) -> FpClass ret f32_class_bits(f32_to_bits(x)) .end
fn f64_class(x: f64) -> FpClass ret f64_class_bits(f64_to_bits(x)) .end

fn f32_is_nan(x: f32) -> bool ret f32_class(x) == FpClass.Nan .end
fn f64_is_nan(x: f64) -> bool ret f64_class(x) == FpClass.Nan .end

fn f32_is_inf(x: f32) -> bool ret f32_class(x) == FpClass.Inf .end
fn f64_is_inf(x: f64) -> bool ret f64_class(x) == FpClass.Inf .end

fn f32_is_finite(x: f32) -> bool
  let c = f32_class(x)
  ret c == FpClass.Zero || c == FpClass.Subnormal || c == FpClass.Normal
.end

fn f64_is_finite(x: f64) -> bool
  let c = f64_class(x)
  ret c == FpClass.Zero || c == FpClass.Subnormal || c == FpClass.Normal
.end

fn f32_is_zero(x: f32) -> bool
  let u = f32_to_bits(x)
  ret (u & 0x7FFFFFFF) == 0
.end

fn f64_is_zero(x: f64) -> bool
  let u = f64_to_bits(x)
  ret (u & 0x7FFFFFFFFFFFFFFF) == 0
.end

fn f32_is_neg_zero(x: f32) -> bool ret f32_to_bits(x) == F32_NEG_ZERO_BITS .end
fn f64_is_neg_zero(x: f64) -> bool ret f64_to_bits(x) == F64_NEG_ZERO_BITS .end

fn f32_is_subnormal(x: f32) -> bool ret f32_class(x) == FpClass.Subnormal .end
fn f64_is_subnormal(x: f64) -> bool ret f64_class(x) == FpClass.Subnormal .end

fn f32_is_normal(x: f32) -> bool ret f32_class(x) == FpClass.Normal .end
fn f64_is_normal(x: f64) -> bool ret f64_class(x) == FpClass.Normal .end

# ---------------------------------
# NaN tools
# ---------------------------------

fn f32_is_qnan_bits(u: u32) -> bool
  if (u & F32_EXP_MASK) != F32_EXP_MASK ret false .end
  let f = u & F32_FRAC_MASK
  if f == 0 ret false .end
  ret (f & 0x00400000) != 0
.end

fn f32_is_snan_bits(u: u32) -> bool
  if (u & F32_EXP_MASK) != F32_EXP_MASK ret false .end
  let f = u & F32_FRAC_MASK
  if f == 0 ret false .end
  ret (f & 0x00400000) == 0
.end

fn f64_is_qnan_bits(u: u64) -> bool
  if (u & F64_EXP_MASK) != F64_EXP_MASK ret false .end
  let f = u & F64_FRAC_MASK
  if f == 0 ret false .end
  ret (f & 0x0008000000000000) != 0
.end

fn f64_is_snan_bits(u: u64) -> bool
  if (u & F64_EXP_MASK) != F64_EXP_MASK ret false .end
  let f = u & F64_FRAC_MASK
  if f == 0 ret false .end
  ret (f & 0x0008000000000000) == 0
.end

fn f32_nan_payload_bits(u: u32) -> u32
  if (u & F32_EXP_MASK) != F32_EXP_MASK ret 0 .end
  let f = u & F32_FRAC_MASK
  ret f & 0x003FFFFF
.end

fn f64_nan_payload_bits(u: u64) -> u64
  if (u & F64_EXP_MASK) != F64_EXP_MASK ret 0 .end
  let f = u & F64_FRAC_MASK
  ret f & 0x0007FFFFFFFFFFFF
.end

fn f32_make_qnan(payload: u32, sign: bool) -> f32
  let p = payload & 0x003FFFFF
  let s = if sign then F32_SIGN_MASK else 0 .end
  let u = s | F32_EXP_MASK | 0x00400000 | p
  ret f32_from_bits(u)
.end

fn f64_make_qnan(payload: u64, sign: bool) -> f64
  let p = payload & 0x0007FFFFFFFFFFFF
  let s = if sign then F64_SIGN_MASK else 0 .end
  let u = s | F64_EXP_MASK | 0x0008000000000000 | p
  ret f64_from_bits(u)
.end

fn f32_make_snan(payload: u32, sign: bool) -> f32
  let p = payload & 0x003FFFFF
  let s = if sign then F32_SIGN_MASK else 0 .end
  let u = s | F32_EXP_MASK | (p | 1)
  ret f32_from_bits(u & ~0x00400000)
.end

fn f64_make_snan(payload: u64, sign: bool) -> f64
  let p = payload & 0x0007FFFFFFFFFFFF
  let s = if sign then F64_SIGN_MASK else 0 .end
  let u = s | F64_EXP_MASK | (p | 1)
  ret f64_from_bits(u & ~0x0008000000000000)
.end

# ---------------------------------
# Signed-zero & sign helpers
# ---------------------------------

fn f32_signbit(x: f32) -> bool ret (f32_to_bits(x) & F32_SIGN_MASK) != 0 .end
fn f64_signbit(x: f64) -> bool ret (f64_to_bits(x) & F64_SIGN_MASK) != 0 .end

fn f32_abs(x: f32) -> f32 ret f32_from_bits(f32_to_bits(x) & 0x7FFFFFFF) .end
fn f64_abs(x: f64) -> f64 ret f64_from_bits(f64_to_bits(x) & 0x7FFFFFFFFFFFFFFF) .end

fn f32_negate(x: f32) -> f32 ret f32_from_bits(f32_to_bits(x) ^ F32_SIGN_MASK) .end
fn f64_negate(x: f64) -> f64 ret f64_from_bits(f64_to_bits(x) ^ F64_SIGN_MASK) .end

fn f32_copysign(mag: f32, sign_src: f32) -> f32
  let um = f32_to_bits(mag) & 0x7FFFFFFF
  let us = f32_to_bits(sign_src) & F32_SIGN_MASK
  ret f32_from_bits(um | us)
.end

fn f64_copysign(mag: f64, sign_src: f64) -> f64
  let um = f64_to_bits(mag) & 0x7FFFFFFFFFFFFFFF
  let us = f64_to_bits(sign_src) & F64_SIGN_MASK
  ret f64_from_bits(um | us)
.end

# ---------------------------------
# nextafter / nextup / nextdown
# ---------------------------------

fn f32_nextafter(x: f32, toward: f32) -> f32
  if is_nan_f32(x) || is_nan_f32(toward) ret x + toward .end
  if x == toward ret toward .end

  if x == 0.0
    if toward < 0.0 ret f32_from_bits(F32_MIN_SUB_BITS | F32_SIGN_MASK) .end
    ret f32_from_bits(F32_MIN_SUB_BITS)
  .end

  let ux = f32_to_bits(x)
  let sx = (ux & F32_SIGN_MASK) != 0
  let inc = if toward > x then true else false .end

  let mut uy = ux
  if inc
    if sx uy = uy - 1 .end
    if !sx uy = uy + 1 .end
  .end
  if !inc
    if sx uy = uy + 1 .end
    if !sx uy = uy - 1 .end
  .end
  ret f32_from_bits(uy)
.end

fn f64_nextafter(x: f64, toward: f64) -> f64
  if is_nan_f64(x) || is_nan_f64(toward) ret x + toward .end
  if x == toward ret toward .end

  if x == 0.0
    if toward < 0.0 ret f64_from_bits(F64_MIN_SUB_BITS | F64_SIGN_MASK) .end
    ret f64_from_bits(F64_MIN_SUB_BITS)
  .end

  let ux = f64_to_bits(x)
  let sx = (ux & F64_SIGN_MASK) != 0
  let inc = if toward > x then true else false .end

  let mut uy = ux
  if inc
    if sx uy = uy - 1 .end
    if !sx uy = uy + 1 .end
  .end
  if !inc
    if sx uy = uy + 1 .end
    if !sx uy = uy - 1 .end
  .end
  ret f64_from_bits(uy)
.end

fn f32_nextup(x: f32) -> f32 ret f32_nextafter(x, f32_from_bits(F32_POS_INF_BITS)) .end
fn f32_nextdown(x: f32) -> f32 ret f32_nextafter(x, f32_from_bits(F32_NEG_INF_BITS)) .end

fn f64_nextup(x: f64) -> f64 ret f64_nextafter(x, f64_from_bits(F64_POS_INF_BITS)) .end
fn f64_nextdown(x: f64) -> f64 ret f64_nextafter(x, f64_from_bits(F64_NEG_INF_BITS)) .end

# ---------------------------------
# ULP helpers + totalOrder key
# ---------------------------------

fn f32_total_order_key_bits(u: u32) -> u32
  if (u & F32_SIGN_MASK) != 0 ret ~u .end
  ret u ^ F32_SIGN_MASK
.end

fn f64_total_order_key_bits(u: u64) -> u64
  if (u & F64_SIGN_MASK) != 0 ret ~u .end
  ret u ^ F64_SIGN_MASK
.end

fn f32_ulp_distance(a: f32, b: f32) -> UlpCmp
  if f32_is_nan(a) || f32_is_nan(b) ret UlpCmp { ok: false, distance: 0 } .end
  let ka = f32_total_order_key_bits(f32_to_bits(a))
  let kb = f32_total_order_key_bits(f32_to_bits(b))
  let d = if ka >= kb then (ka - kb) as u64 else (kb - ka) as u64 .end
  ret UlpCmp { ok: true, distance: d }
.end

fn f64_ulp_distance(a: f64, b: f64) -> UlpCmp
  if f64_is_nan(a) || f64_is_nan(b) ret UlpCmp { ok: false, distance: 0 } .end
  let ka = f64_total_order_key_bits(f64_to_bits(a))
  let kb = f64_total_order_key_bits(f64_to_bits(b))
  let d = if ka >= kb then (ka - kb) else (kb - ka) .end
  ret UlpCmp { ok: true, distance: d }
.end

fn f32_almost_equal_ulps(a: f32, b: f32, max_ulps: u64) -> bool
  let d = f32_ulp_distance(a, b)
  if !d.ok ret false .end
  ret d.distance <= max_ulps
.end

fn f64_almost_equal_ulps(a: f64, b: f64, max_ulps: u64) -> bool
  let d = f64_ulp_distance(a, b)
  if !d.ok ret false .end
  ret d.distance <= max_ulps
.end

fn f32_ulp(x: f32) -> f32
  let nx = f32_nextup(x)
  if nx == x ret 0.0 .end
  ret nx - x
.end

fn f64_ulp(x: f64) -> f64
  let nx = f64_nextup(x)
  if nx == x ret 0.0 .end
  ret nx - x
.end

# ---------------------------------
# frexp/ldexp/scale_pow2 (bits)
# ---------------------------------

fn f32_scale_pow2_bits(ux: u32, k: i32) -> u32
  let cls = f32_class_bits(ux)
  if cls != FpClass.Normal ret ux .end
  let sign = ux & F32_SIGN_MASK
  let frac = ux & F32_FRAC_MASK
  let e = f32_exp_bits(ux)
  let mut ne = e + k
  if ne <= 0 ret sign | 0 .end
  if ne >= F32_EXP_MAX ret sign | F32_EXP_MASK .end
  let ue = (ne as u32) << (F32_EXP_SHIFT as u32)
  ret sign | ue | frac
.end

fn f64_scale_pow2_bits(ux: u64, k: i32) -> u64
  let cls = f64_class_bits(ux)
  if cls != FpClass.Normal ret ux .end
  let sign = ux & F64_SIGN_MASK
  let frac = ux & F64_FRAC_MASK
  let e = f64_exp_bits(ux)
  let mut ne = e + k
  if ne <= 0 ret sign | 0 .end
  if ne >= F64_EXP_MAX ret sign | F64_EXP_MASK .end
  let ue = (ne as u64) << (F64_EXP_SHIFT as u64)
  ret sign | ue | frac
.end

fn f32_ldexp(x: f32, k: i32) -> f32 ret f32_from_bits(f32_scale_pow2_bits(f32_to_bits(x), k)) .end
fn f64_ldexp(x: f64, k: i32) -> f64 ret f64_from_bits(f64_scale_pow2_bits(f64_to_bits(x), k)) .end

fn f32_frexp(x: f32) -> FrexpF32
  let u = f32_to_bits(x)
  let cls = f32_class_bits(u)
  if cls == FpClass.Zero ret FrexpF32 { mantissa: x, exponent: 0 } .end
  if cls == FpClass.Inf || cls == FpClass.Nan ret FrexpF32 { mantissa: x, exponent: 0 } .end

  let parts = f32_parts_bits(u)
  let mut e = parts.exp
  let mut frac = parts.frac

  if e == 0
    let mut shift = 0
    while (frac & 0x00400000) == 0
      frac = frac << 1
      shift = shift + 1
      if shift > 23 break .end
    .end
    e = 1 - shift
  .end

  let exp_unbiased = e - F32_EXP_BIAS
  let mant_u = (u & F32_SIGN_MASK) | (((F32_EXP_BIAS - 1) as u32) << 23) | (u & F32_FRAC_MASK)
  let mant = f32_from_bits(mant_u)
  ret FrexpF32 { mantissa: mant, exponent: exp_unbiased + 1 }
.end

fn f64_frexp(x: f64) -> FrexpF64
  let u = f64_to_bits(x)
  let cls = f64_class_bits(u)
  if cls == FpClass.Zero ret FrexpF64 { mantissa: x, exponent: 0 } .end
  if cls == FpClass.Inf || cls == FpClass.Nan ret FrexpF64 { mantissa: x, exponent: 0 } .end

  let parts = f64_parts_bits(u)
  let mut e = parts.exp
  let mut frac = parts.frac

  if e == 0
    let mut shift = 0
    while (frac & 0x0008000000000000) == 0
      frac = frac << 1
      shift = shift + 1
      if shift > 52 break .end
    .end
    e = 1 - shift
  .end

  let exp_unbiased = e - F64_EXP_BIAS
  let mant_u = (u & F64_SIGN_MASK) | (((F64_EXP_BIAS - 1) as u64) << 52) | (u & F64_FRAC_MASK)
  let mant = f64_from_bits(mant_u)
  ret FrexpF64 { mantissa: mant, exponent: exp_unbiased + 1 }
.end

# ---------------------------------
# Constructors (bits)
# ---------------------------------

fn f32_pos_inf() -> f32 ret f32_from_bits(F32_POS_INF_BITS) .end
fn f32_neg_inf() -> f32 ret f32_from_bits(F32_NEG_INF_BITS) .end

fn f64_pos_inf() -> f64 ret f64_from_bits(F64_POS_INF_BITS) .end
fn f64_neg_inf() -> f64 ret f64_from_bits(F64_NEG_INF_BITS) .end

fn f32_qnan() -> f32 ret f32_from_bits(F32_QNAN_BITS) .end
fn f64_qnan() -> f64 ret f64_from_bits(F64_QNAN_BITS) .end

fn f32_snan() -> f32 ret f32_from_bits(F32_SNAN_BITS) .end
fn f64_snan() -> f64 ret f64_from_bits(F64_SNAN_BITS) .end

fn f32_neg_zero() -> f32 ret f32_from_bits(F32_NEG_ZERO_BITS) .end
fn f64_neg_zero() -> f64 ret f64_from_bits(F64_NEG_ZERO_BITS) .end

# ---------------------------------
# Tests smoke
# ---------------------------------

fn assert(cond: bool)
  if !cond panic("assert failed") .end
.end

fn test_bits_classes()
  assert(f32_class_bits(F32_POS_ZERO_BITS) == FpClass.Zero)
  assert(f32_class_bits(F32_MIN_SUB_BITS) == FpClass.Subnormal)
  assert(f32_class_bits(F32_MIN_NORMAL_BITS) == FpClass.Normal)
  assert(f32_class_bits(F32_POS_INF_BITS) == FpClass.Inf)
  assert(f32_class_bits(F32_QNAN_BITS) == FpClass.Nan)

  assert(f64_class_bits(F64_POS_ZERO_BITS) == FpClass.Zero)
  assert(f64_class_bits(F64_MIN_SUB_BITS) == FpClass.Subnormal)
  assert(f64_class_bits(F64_MIN_NORMAL_BITS) == FpClass.Normal)
  assert(f64_class_bits(F64_POS_INF_BITS) == FpClass.Inf)
  assert(f64_class_bits(F64_QNAN_BITS) == FpClass.Nan)
.end

fn test_nan_kind_bits()
  assert(f32_is_qnan_bits(F32_QNAN_BITS))
  assert(f64_is_qnan_bits(F64_QNAN_BITS))
.end

fn test_total_order_key_monotonic()
  let kpos0 = f64_total_order_key_bits(F64_POS_ZERO_BITS)
  let kneg0 = f64_total_order_key_bits(F64_NEG_ZERO_BITS)
  assert(kneg0 < kpos0)
.end

fn run_all_tests()
  test_bits_classes()
  test_nan_kind_bits()
  test_total_order_key_monotonic()
.end

.end
