module jmath.constants.physical

# ============================================================================
# constants.physical – constantes physiques (CODATA) + unités (ultra complet)
# ============================================================================

const CODATA_YEAR : i32 = 2022

# ---------------------------------
# Utilitaires
# ---------------------------------

fn abs_f64(x: f64) -> f64
  if x < 0.0 ret -x .end
  ret x
.end

fn clamp_f64(x: f64, lo: f64, hi: f64) -> f64
  if x < lo ret lo .end
  if x > hi ret hi .end
  ret x
.end

fn approx_eq(a: f64, b: f64, rel: f64, abs: f64) -> bool
  let d = abs_f64(a - b)
  if d <= abs ret true .end
  let mut m = abs_f64(a)
  let bb = abs_f64(b)
  if bb > m m = bb .end
  ret d <= rel * m
.end

# ---------------------------------
# Préfixes SI
# ---------------------------------

const YOCTO : f64 = 1e-24
const ZEPTO : f64 = 1e-21
const ATTO  : f64 = 1e-18
const FEMTO : f64 = 1e-15
const PICO  : f64 = 1e-12
const NANO  : f64 = 1e-9
const MICRO : f64 = 1e-6
const MILLI : f64 = 1e-3
const CENTI : f64 = 1e-2
const DECI  : f64 = 1e-1

const DECA  : f64 = 1e1
const HECTO : f64 = 1e2
const KILO  : f64 = 1e3
const MEGA  : f64 = 1e6
const GIGA  : f64 = 1e9
const TERA  : f64 = 1e12
const PETA  : f64 = 1e15
const EXA   : f64 = 1e18
const ZETTA : f64 = 1e21
const YOTTA : f64 = 1e24

# ---------------------------------
# Fondamentales SI (post-2019)
# ---------------------------------

const C : f64 = 299792458.0
const H : f64 = 6.62607015e-34
const HBAR : f64 = 1.054571817646156391e-34

const E_CHARGE : f64 = 1.602176634e-19
const K_B      : f64 = 1.380649e-23
const N_A      : f64 = 6.02214076e23

const G  : f64 = 6.67430e-11
const G0 : f64 = 9.80665

# ---------------------------------
# Électromagnétisme / quantique
# ---------------------------------

const EPS0 : f64 = 8.8541878128e-12
const MU0  : f64 = 1.25663706212e-6
const Z0   : f64 = 376.730313668

const ALPHA : f64 = 7.2973525693e-3

const R_INF : f64 = 10973731.568160
const A0    : f64 = 5.29177210903e-11

const F : f64 = 96485.33212
const R : f64 = 8.314462618

const G0_QUANT : f64 = 7.748091729e-5
const R_K : f64 = 25812.80745
const K_J : f64 = 483597.8484e9
const PHI0 : f64 = 2.067833848e-15

const MU_B : f64 = 9.2740100783e-24
const MU_N : f64 = 5.0507837461e-27

# ---------------------------------
# Masses (kg)
# ---------------------------------

const M_E  : f64 = 9.1093837015e-31
const M_P  : f64 = 1.67262192369e-27
const M_N  : f64 = 1.67492749804e-27

const U_DALTON : f64 = 1.66053906660e-27
const M_MU : f64 = 1.883531627e-28

# ---------------------------------
# Thermodynamique / rayonnement
# ---------------------------------

const SIGMA_SB : f64 = 5.670374419e-8
const B_WIEN   : f64 = 2.897771955e-3
const A_RAD    : f64 = 7.5657e-16

# ---------------------------------
# Optique / photo
# ---------------------------------

const LAMBDA_C_E : f64 = 2.42631023867e-12
const E_HARTREE  : f64 = 4.3597447222071e-18

# ---------------------------------
# Astronomie
# ---------------------------------

const AU : f64 = 149597870700.0

const JULIAN_YEAR : f64 = 31557600.0
const LIGHT_YEAR  : f64 = C * JULIAN_YEAR

const PARSEC : f64 = 3.0856775814913673e16

const M_SUN : f64 = 1.98847e30
const R_SUN : f64 = 6.957e8
const L_SUN : f64 = 3.828e26

const M_EARTH : f64 = 5.9722e24
const R_EARTH : f64 = 6.371e6

const DAY : f64 = 86400.0

# ---------------------------------
# Conversions énergie
# ---------------------------------

const J_PER_EV : f64 = E_CHARGE
const EV_PER_J : f64 = 1.0 / J_PER_EV

const J_PER_KEV : f64 = 1e3 * J_PER_EV
const J_PER_MEV : f64 = 1e6 * J_PER_EV
const J_PER_GEV : f64 = 1e9 * J_PER_EV

fn ev_to_j(ev: f64) -> f64 ret ev * J_PER_EV .end
fn j_to_ev(j: f64) -> f64 ret j * EV_PER_J .end

# ---------------------------------
# Conversions pression
# ---------------------------------

const PA_PER_BAR  : f64 = 1e5
const PA_PER_ATM  : f64 = 101325.0
const PA_PER_TORR : f64 = 133.32236842105263

fn bar_to_pa(bar: f64) -> f64 ret bar * PA_PER_BAR .end
fn pa_to_bar(pa: f64) -> f64 ret pa / PA_PER_BAR .end

fn atm_to_pa(atm: f64) -> f64 ret atm * PA_PER_ATM .end
fn pa_to_atm(pa: f64) -> f64 ret pa / PA_PER_ATM .end

fn torr_to_pa(torr: f64) -> f64 ret torr * PA_PER_TORR .end
fn pa_to_torr(pa: f64) -> f64 ret pa / PA_PER_TORR .end

# ---------------------------------
# Conversions température
# ---------------------------------

fn celsius_to_kelvin(tc: f64) -> f64 ret tc + 273.15 .end
fn kelvin_to_celsius(k: f64) -> f64 ret k - 273.15 .end

fn celsius_to_fahrenheit(tc: f64) -> f64 ret tc * (9.0/5.0) + 32.0 .end
fn fahrenheit_to_celsius(tf: f64) -> f64 ret (tf - 32.0) * (5.0/9.0) .end

fn fahrenheit_to_kelvin(tf: f64) -> f64 ret celsius_to_kelvin(fahrenheit_to_celsius(tf)) .end
fn kelvin_to_fahrenheit(k: f64) -> f64 ret celsius_to_fahrenheit(kelvin_to_celsius(k)) .end

# ---------------------------------
# Conversions longueur
# ---------------------------------

const M_PER_INCH : f64 = 0.0254
const M_PER_FOOT : f64 = 0.3048
const M_PER_YARD : f64 = 0.9144
const M_PER_MILE : f64 = 1609.344

const M_PER_ANGSTROM : f64 = 1e-10
const M_PER_NM : f64 = 1e-9
const M_PER_UM : f64 = 1e-6
const M_PER_MM : f64 = 1e-3
const M_PER_CM : f64 = 1e-2
const M_PER_KM : f64 = 1e3

fn inch_to_m(x: f64) -> f64 ret x * M_PER_INCH .end
fn m_to_inch(x: f64) -> f64 ret x / M_PER_INCH .end

fn foot_to_m(x: f64) -> f64 ret x * M_PER_FOOT .end
fn m_to_foot(x: f64) -> f64 ret x / M_PER_FOOT .end

fn mile_to_m(x: f64) -> f64 ret x * M_PER_MILE .end
fn m_to_mile(x: f64) -> f64 ret x / M_PER_MILE .end

# ---------------------------------
# Dérivées utiles
# ---------------------------------

fn planck_frequency_from_energy_j(Ej: f64) -> f64 ret Ej / H .end

fn photon_energy_from_wavelength(lambda_m: f64) -> f64
  if lambda_m == 0.0 ret 0.0 .end
  ret (H * C) / lambda_m
.end

fn photon_wavelength_from_energy(Ej: f64) -> f64
  if Ej == 0.0 ret 0.0 .end
  ret (H * C) / Ej
.end

fn thermal_voltage(T: f64) -> f64
  ret (K_B * T) / E_CHARGE
.end

fn de_broglie_wavelength(p_kg_m_s: f64) -> f64
  if p_kg_m_s == 0.0 ret 0.0 .end
  ret H / p_kg_m_s
.end

# ---------------------------------
# Tests smoke
# ---------------------------------

fn assert(cond: bool)
  if !cond panic("assert failed") .end
.end

fn test_core_exact()
  assert(C == 299792458.0)
  assert(H == 6.62607015e-34)
  assert(E_CHARGE == 1.602176634e-19)
  assert(K_B == 1.380649e-23)
  assert(N_A == 6.02214076e23)
.end

fn test_conversions()
  let k = celsius_to_kelvin(0.0)
  assert(abs_f64(k - 273.15) < 1e-12)

  let pa = atm_to_pa(1.0)
  assert(abs_f64(pa - 101325.0) < 1e-9)

  let j = ev_to_j(1.0)
  assert(abs_f64(j - E_CHARGE) < 1e-30)
.end

fn run_all_tests()
  test_core_exact()
  test_conversions()
.end

.end
