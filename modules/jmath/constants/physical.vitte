module jmath.constants.physical

# ============================================================================
# constants.physical – constantes physiques (CODATA) + unités (ultra complet)
#
# Objectifs :
#   - Constantes fondamentales (c, h, ħ, e, kB, NA, G, etc.)
#   - Constantes électromagnétiques (mu0, eps0, Z0, alpha, R_K, K_J)
#   - Constantes atomiques (a0, R_inf, m_e, m_p, m_n, u, etc.)
#   - Constantes thermodynamiques, radiométrie, rayonnement (sigma, b_Wien)
#   - Constantes astronomiques (au, parsec, ly, M_sun, R_earth, etc.)
#   - Système d’unités : prefixes SI, conversions (degC/degF/K), eV<->J,
#     bar/atm/torr/Pa, Å/nm/um/mm/m, etc.
#   - Helpers : clamp/approx_eq + safe operations
#
# Notes :
#   - Les valeurs changent rarement mais sont mises à jour par CODATA.
#   - Ici, on fige un set cohérent (post-2019 SI) :
#       * h, e, kB, NA, c exacts (définis)
#       * mu0 n’est plus exact (dérivé via alpha) — ici valeur usuelle.
#   - Si tu veux "versionning CODATA", ajoute :
#       const CODATA_YEAR : i32 = 2022
#       const CODATA_REV  : str = "CODATA 2022 recommended values"
#
# Conventions :
#   - Pas d’accolades, blocs en `.end`
#   - Pas d’I/O
# ============================================================================

# ---------------------------------
# Meta
# ---------------------------------

const CODATA_YEAR : i32 = 2022

# ---------------------------------
# Utilitaires
# ---------------------------------

fn abs_f64(x: f64) -> f64
  if x < 0.0 ret -x .end
  ret x
.end

fn clamp_f64(x: f64, lo: f64, hi: f64) -> f64
  if x < lo ret lo .end
  if x > hi ret hi .end
  ret x
.end

fn approx_eq(a: f64, b: f64, rel: f64, abs: f64) -> bool
  let d = abs_f64(a - b)
  if d <= abs ret true .end
  let m = abs_f64(a)
  if abs_f64(b) > m m = abs_f64(b) .end
  ret d <= rel * m
.end

# ---------------------------------
# Préfixes SI (multiplicateurs)
# ---------------------------------

const YOCTO : f64 = 1e-24
const ZEPTO : f64 = 1e-21
const ATTO  : f64 = 1e-18
const FEMTO : f64 = 1e-15
const PICO  : f64 = 1e-12
const NANO  : f64 = 1e-9
const MICRO : f64 = 1e-6
const MILLI : f64 = 1e-3
const CENTI : f64 = 1e-2
const DECI  : f64 = 1e-1

const DECA  : f64 = 1e1
const HECTO : f64 = 1e2
const KILO  : f64 = 1e3
const MEGA  : f64 = 1e6
const GIGA  : f64 = 1e9
const TERA  : f64 = 1e12
const PETA  : f64 = 1e15
const EXA   : f64 = 1e18
const ZETTA : f64 = 1e21
const YOTTA : f64 = 1e24

# ---------------------------------
# Constantes fondamentales SI
# ---------------------------------

# Vitesse de la lumière (exact)
const C : f64 = 299792458.0                 # m/s

# Constante de Planck (exact)
const H : f64 = 6.62607015e-34              # J·s

# Constante de Planck réduite
const HBAR : f64 = 1.054571817646156391e-34 # J·s  (h/2π)

# Charge élémentaire (exact)
const E_CHARGE : f64 = 1.602176634e-19      # C

# Constante de Boltzmann (exact)
const K_B : f64 = 1.380649e-23              # J/K

# Nombre d’Avogadro (exact)
const N_A : f64 = 6.02214076e23             # 1/mol

# Constante gravitationnelle (mesurée)
const G : f64 = 6.67430e-11                 # m^3·kg^-1·s^-2

# Accélération standard de la pesanteur
const G0 : f64 = 9.80665                    # m/s^2 (standard)

# ---------------------------------
# Électromagnétisme / quantique
# ---------------------------------

# Permittivité du vide
const EPS0 : f64 = 8.8541878128e-12         # F/m

# Perméabilité du vide (valeur usuelle)
const MU0  : f64 = 1.25663706212e-6         # N/A^2 = H/m

# Impédance du vide
const Z0   : f64 = 376.730313668            # ohm

# Constante de structure fine
const ALPHA : f64 = 7.2973525693e-3         # ~ 1/137

# Constante de Rydberg (m^-1)
const R_INF : f64 = 10973731.568160         # 1/m

# Rayon de Bohr
const A0 : f64 = 5.29177210903e-11          # m

# Constante de Faraday
const F : f64 = 96485.33212                 # C/mol

# Constante des gaz parfaits
const R : f64 = 8.314462618                 # J/(mol·K)

# Conductance quantique (2e^2/h)
const G0_QUANT : f64 = 7.748091729e-5        # S

# Constante de von Klitzing (h/e^2)
const R_K : f64 = 25812.80745               # ohm

# Constante de Josephson (2e/h)
const K_J : f64 = 483597.8484e9             # Hz/V

# Quantum de flux (h/2e)
const PHI0 : f64 = 2.067833848e-15          # Wb

# Magnéton de Bohr
const MU_B : f64 = 9.2740100783e-24         # J/T

# Magnéton nucléaire
const MU_N : f64 = 5.0507837461e-27         # J/T

# ---------------------------------
# Masses (kg)
# ---------------------------------

const M_E  : f64 = 9.1093837015e-31         # electron
const M_P  : f64 = 1.67262192369e-27        # proton
const M_N  : f64 = 1.67492749804e-27        # neutron

# Unité de masse atomique (dalton)
const U_DALTON : f64 = 1.66053906660e-27    # kg

# Masse du muon
const M_MU : f64 = 1.883531627e-28          # kg

# ---------------------------------
# Thermodynamique / rayonnement
# ---------------------------------

# Constante de Stefan–Boltzmann
const SIGMA_SB : f64 = 5.670374419e-8       # W·m^-2·K^-4

# Loi de déplacement de Wien
const B_WIEN : f64 = 2.897771955e-3         # m·K

# Constante des radiations (a = 4σ/c)
const A_RAD : f64 = 7.5657e-16              # J·m^-3·K^-4 (valeur usuelle)

# ---------------------------------
# Optique / photo
# ---------------------------------

# Longueur d’onde Compton de l’électron
const LAMBDA_C_E : f64 = 2.42631023867e-12  # m

# Énergie de Hartree
const E_HARTREE : f64 = 4.3597447222071e-18 # J

# ---------------------------------
# Astronomie (valeurs usuelles)
# ---------------------------------

# Unité astronomique (exact depuis 2012)
const AU : f64 = 149597870700.0             # m

# Année-lumière (julienne)
const JULIAN_YEAR : f64 = 31557600.0        # s
const LIGHT_YEAR  : f64 = C * JULIAN_YEAR   # m

# Parsec
const PARSEC : f64 = 3.0856775814913673e16  # m

# Masse solaire
const M_SUN : f64 = 1.98847e30              # kg

# Rayon solaire
const R_SUN : f64 = 6.957e8                 # m

# Luminosité solaire
const L_SUN : f64 = 3.828e26                # W

# Masse terrestre
const M_EARTH : f64 = 5.9722e24             # kg

# Rayon moyen terrestre
const R_EARTH : f64 = 6.371e6               # m

# Jour (SI)
const DAY : f64 = 86400.0                   # s

# ---------------------------------
# Conversions d’unités (énergie)
# ---------------------------------

# Joule <-> électron-volt
const J_PER_EV  : f64 = E_CHARGE
const EV_PER_J  : f64 = 1.0 / J_PER_EV

const J_PER_KEV : f64 = 1e3 * J_PER_EV
const J_PER_MEV : f64 = 1e6 * J_PER_EV
const J_PER_GEV : f64 = 1e9 * J_PER_EV

fn ev_to_j(ev: f64) -> f64
  ret ev * J_PER_EV
.end

fn j_to_ev(j: f64) -> f64
  ret j * EV_PER_J
.end

# ---------------------------------
# Conversions pression
# ---------------------------------

const PA_PER_BAR : f64 = 1e5
const PA_PER_ATM : f64 = 101325.0
const PA_PER_TORR: f64 = 133.32236842105263

fn bar_to_pa(bar: f64) -> f64
  ret bar * PA_PER_BAR
.end

fn pa_to_bar(pa: f64) -> f64
  ret pa / PA_PER_BAR
.end

fn atm_to_pa(atm: f64) -> f64
  ret atm * PA_PER_ATM
.end

fn pa_to_atm(pa: f64) -> f64
  ret pa / PA_PER_ATM
.end

fn torr_to_pa(torr: f64) -> f64
  ret torr * PA_PER_TORR
.end

fn pa_to_torr(pa: f64) -> f64
  ret pa / PA_PER_TORR
.end

# ---------------------------------
# Conversions température
# ---------------------------------

fn celsius_to_kelvin(tc: f64) -> f64
  ret tc + 273.15
.end

fn kelvin_to_celsius(k: f64) -> f64
  ret k - 273.15
.end

fn celsius_to_fahrenheit(tc: f64) -> f64
  ret tc * (9.0/5.0) + 32.0
.end

fn fahrenheit_to_celsius(tf: f64) -> f64
  ret (tf - 32.0) * (5.0/9.0)
.end

fn fahrenheit_to_kelvin(tf: f64) -> f64
  ret celsius_to_kelvin(fahrenheit_to_celsius(tf))
.end

fn kelvin_to_fahrenheit(k: f64) -> f64
  ret celsius_to_fahrenheit(kelvin_to_celsius(k))
.end

# ---------------------------------
# Conversions longueur
# ---------------------------------

const M_PER_INCH : f64 = 0.0254
const M_PER_FOOT : f64 = 0.3048
const M_PER_YARD : f64 = 0.9144
const M_PER_MILE : f64 = 1609.344

const M_PER_ANGSTROM : f64 = 1e-10
const M_PER_NM : f64 = 1e-9
const M_PER_UM : f64 = 1e-6
const M_PER_MM : f64 = 1e-3
const M_PER_CM : f64 = 1e-2
const M_PER_KM : f64 = 1e3

fn inch_to_m(x: f64) -> f64
  ret x * M_PER_INCH
.end

fn m_to_inch(x: f64) -> f64
  ret x / M_PER_INCH
.end

fn foot_to_m(x: f64) -> f64
  ret x * M_PER_FOOT
.end

fn m_to_foot(x: f64) -> f64
  ret x / M_PER_FOOT
.end

fn mile_to_m(x: f64) -> f64
  ret x * M_PER_MILE
.end

fn m_to_mile(x: f64) -> f64
  ret x / M_PER_MILE
.end

# ---------------------------------
# Dérivées utiles (calculées)
# ---------------------------------

fn planck_frequency_from_energy_j(Ej: f64) -> f64
  # f = E/h
  ret Ej / H
.end

fn photon_energy_from_wavelength(lambda_m: f64) -> f64
  # E = h c / λ
  if lambda_m == 0.0 ret 0.0 .end
  ret (H * C) / lambda_m
.end

fn photon_wavelength_from_energy(Ej: f64) -> f64
  # λ = h c / E
  if Ej == 0.0 ret 0.0 .end
  ret (H * C) / Ej
.end

fn thermal_voltage(T: f64) -> f64
  # Vt = kT / e
  ret (K_B * T) / E_CHARGE
.end

fn de_broglie_wavelength(p_kg_m_s: f64) -> f64
  # λ = h/p
  if p_kg_m_s == 0.0 ret 0.0 .end
  ret H / p_kg_m_s
.end

# ---------------------------------
# Tests smoke
# ---------------------------------

fn assert(cond: bool)
  if !cond panic("assert failed") .end
.end

fn test_core_exact()
  assert(C == 299792458.0)
  assert(H == 6.62607015e-34)
  assert(E_CHARGE == 1.602176634e-19)
  assert(K_B == 1.380649e-23)
  assert(N_A == 6.02214076e23)
.end

fn test_conversions()
  let k = celsius_to_kelvin(0.0)
  assert(abs_f64(k - 273.15) < 1e-12)

  let pa = atm_to_pa(1.0)
  assert(abs_f64(pa - 101325.0) < 1e-9)

  let j = ev_to_j(1.0)
  assert(abs_f64(j - E_CHARGE) < 1e-30)
.end

fn run_all_tests()
  test_core_exact()
  test_conversions()
.end

.end
