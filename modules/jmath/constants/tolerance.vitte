module jmath.real.tolerance

# ============================================================================
# tolerance.vitte — tolérances numériques (f32/f64) + comparaisons robustes
#
# Fournit :
#   - Tol (struct) : abs/rel/ulps + policy
#   - approx_eq / approx_ne / approx_lt/le/gt/ge (réels)
#   - near_zero / clamp_to_zero
#   - same_sign / sign helpers
#   - compare_total_order (via ieee754 totalOrder key) pour tris stables
#   - helpers ULP : distance, within_ulps
#   - presets : tight/normal/loose pour f64 et f32
#   - Tests smoke
#
# Dépendances :
#   - jmath.constants.ieee754
#
# Conventions :
#   - Pas d’accolades, blocs `.end`
#   - Pas d’I/O
# ============================================================================

import jmath.constants.ieee754 as ieee

# ---------------------------------
# Utils de base
# ---------------------------------

fn abs_f64(x: f64) -> f64
  if x < 0.0 ret -x .end
  ret x
.end

fn abs_f32(x: f32) -> f32
  if x < 0.0 ret -x .end
  ret x
.end

fn max_f64(a: f64, b: f64) -> f64
  if a > b ret a .end
  ret b
.end

fn max_f32(a: f32, b: f32) -> f32
  if a > b ret a .end
  ret b
.end

fn is_nan_f64(x: f64) -> bool ret x != x .end
fn is_nan_f32(x: f32) -> bool ret x != x .end

# ---------------------------------
# Policy / Tolerance
# ---------------------------------

enum TolPolicy
  AbsRel
  UlpsOnly
  AbsRelOrUlps
.end

struct TolF64
  abs  : f64
  rel  : f64
  ulps : u64
  policy : TolPolicy
.end

struct TolF32
  abs  : f32
  rel  : f32
  ulps : u64
  policy : TolPolicy
.end

fn tol_f64(abs: f64, rel: f64, ulps: u64) -> TolF64
  ret TolF64 { abs: abs, rel: rel, ulps: ulps, policy: TolPolicy.AbsRelOrUlps }
.end

fn tol_f32(abs: f32, rel: f32, ulps: u64) -> TolF32
  ret TolF32 { abs: abs, rel: rel, ulps: ulps, policy: TolPolicy.AbsRelOrUlps }
.end

fn tol_f64_absrel(abs: f64, rel: f64) -> TolF64
  ret TolF64 { abs: abs, rel: rel, ulps: 0, policy: TolPolicy.AbsRel }
.end

fn tol_f32_absrel(abs: f32, rel: f32) -> TolF32
  ret TolF32 { abs: abs, rel: rel, ulps: 0, policy: TolPolicy.AbsRel }
.end

fn tol_f64_ulps(ulps: u64) -> TolF64
  ret TolF64 { abs: 0.0, rel: 0.0, ulps: ulps, policy: TolPolicy.UlpsOnly }
.end

fn tol_f32_ulps(ulps: u64) -> TolF32
  ret TolF32 { abs: 0.0, rel: 0.0, ulps: ulps, policy: TolPolicy.UlpsOnly }
.end

# Presets (pratiques)
fn tol_f64_tight() -> TolF64  ret TolF64 { abs: 1e-12, rel: 1e-12, ulps: 8,   policy: TolPolicy.AbsRelOrUlps } .end
fn tol_f64_normal() -> TolF64 ret TolF64 { abs: 1e-9,  rel: 1e-9,  ulps: 64,  policy: TolPolicy.AbsRelOrUlps } .end
fn tol_f64_loose() -> TolF64  ret TolF64 { abs: 1e-6,  rel: 1e-6,  ulps: 512, policy: TolPolicy.AbsRelOrUlps } .end

fn tol_f32_tight() -> TolF32  ret TolF32 { abs: 1e-6, rel: 1e-6, ulps: 8,   policy: TolPolicy.AbsRelOrUlps } .end
fn tol_f32_normal() -> TolF32 ret TolF32 { abs: 1e-5, rel: 1e-5, ulps: 64,  policy: TolPolicy.AbsRelOrUlps } .end
fn tol_f32_loose() -> TolF32  ret TolF32 { abs: 1e-4, rel: 1e-4, ulps: 512, policy: TolPolicy.AbsRelOrUlps } .end

# ---------------------------------
# Abs/Rel compare
# ---------------------------------

fn approx_eq_absrel_f64(a: f64, b: f64, abs_eps: f64, rel_eps: f64) -> bool
  let d = abs_f64(a - b)
  if d <= abs_eps ret true .end
  let mut m = abs_f64(a)
  let bb = abs_f64(b)
  if bb > m m = bb .end
  if m == 0.0 ret d <= abs_eps .end
  ret d <= rel_eps * m
.end

fn approx_eq_absrel_f32(a: f32, b: f32, abs_eps: f32, rel_eps: f32) -> bool
  let d = abs_f32(a - b)
  if d <= abs_eps ret true .end
  let mut m = abs_f32(a)
  let bb = abs_f32(b)
  if bb > m m = bb .end
  if m == 0.0 ret d <= abs_eps .end
  ret d <= rel_eps * m
.end

# ---------------------------------
# ULP helpers
# ---------------------------------

fn within_ulps_f64(a: f64, b: f64, max_ulps: u64) -> bool
  ret ieee.f64_almost_equal_ulps(a, b, max_ulps)
.end

fn within_ulps_f32(a: f32, b: f32, max_ulps: u64) -> bool
  ret ieee.f32_almost_equal_ulps(a, b, max_ulps)
.end

fn ulp_distance_f64(a: f64, b: f64) -> ieee.UlpCmp
  ret ieee.f64_ulp_distance(a, b)
.end

fn ulp_distance_f32(a: f32, b: f32) -> ieee.UlpCmp
  ret ieee.f32_ulp_distance(a, b)
.end

# ---------------------------------
# Main predicates (Tol)
# ---------------------------------

fn approx_eq_f64(a: f64, b: f64, tol: TolF64) -> bool
  # NaN rules: NaN never equals
  if is_nan_f64(a) || is_nan_f64(b) ret false .end

  if tol.policy == TolPolicy.UlpsOnly
    ret within_ulps_f64(a, b, tol.ulps)
  .end

  let ok_ar = approx_eq_absrel_f64(a, b, tol.abs, tol.rel)

  if tol.policy == TolPolicy.AbsRel
    ret ok_ar
  .end

  if ok_ar ret true .end
  ret within_ulps_f64(a, b, tol.ulps)
.end

fn approx_eq_f32(a: f32, b: f32, tol: TolF32) -> bool
  if is_nan_f32(a) || is_nan_f32(b) ret false .end

  if tol.policy == TolPolicy.UlpsOnly
    ret within_ulps_f32(a, b, tol.ulps)
  .end

  let ok_ar = approx_eq_absrel_f32(a, b, tol.abs, tol.rel)

  if tol.policy == TolPolicy.AbsRel
    ret ok_ar
  .end

  if ok_ar ret true .end
  ret within_ulps_f32(a, b, tol.ulps)
.end

fn approx_ne_f64(a: f64, b: f64, tol: TolF64) -> bool
  ret !approx_eq_f64(a, b, tol)
.end

fn approx_ne_f32(a: f32, b: f32, tol: TolF32) -> bool
  ret !approx_eq_f32(a, b, tol)
.end

# ---------------------------------
# Ordering predicates with tolerance
# ---------------------------------
# Convention :
#   - approx_lt: a < b AND NOT approx_eq(a,b)
#   - approx_le: a < b OR  approx_eq(a,b)
# idem > >=

fn approx_lt_f64(a: f64, b: f64, tol: TolF64) -> bool
  if approx_eq_f64(a, b, tol) ret false .end
  ret a < b
.end

fn approx_le_f64(a: f64, b: f64, tol: TolF64) -> bool
  if approx_eq_f64(a, b, tol) ret true .end
  ret a < b
.end

fn approx_gt_f64(a: f64, b: f64, tol: TolF64) -> bool
  if approx_eq_f64(a, b, tol) ret false .end
  ret a > b
.end

fn approx_ge_f64(a: f64, b: f64, tol: TolF64) -> bool
  if approx_eq_f64(a, b, tol) ret true .end
  ret a > b
.end

fn approx_lt_f32(a: f32, b: f32, tol: TolF32) -> bool
  if approx_eq_f32(a, b, tol) ret false .end
  ret a < b
.end

fn approx_le_f32(a: f32, b: f32, tol: TolF32) -> bool
  if approx_eq_f32(a, b, tol) ret true .end
  ret a < b
.end

fn approx_gt_f32(a: f32, b: f32, tol: TolF32) -> bool
  if approx_eq_f32(a, b, tol) ret false .end
  ret a > b
.end

fn approx_ge_f32(a: f32, b: f32, tol: TolF32) -> bool
  if approx_eq_f32(a, b, tol) ret true .end
  ret a > b
.end

# ---------------------------------
# Near-zero helpers
# ---------------------------------

fn near_zero_f64(x: f64, abs_eps: f64) -> bool
  if is_nan_f64(x) ret false .end
  ret abs_f64(x) <= abs_eps
.end

fn near_zero_f32(x: f32, abs_eps: f32) -> bool
  if is_nan_f32(x) ret false .end
  ret abs_f32(x) <= abs_eps
.end

fn clamp_to_zero_f64(x: f64, abs_eps: f64) -> f64
  if near_zero_f64(x, abs_eps) ret 0.0 .end
  ret x
.end

fn clamp_to_zero_f32(x: f32, abs_eps: f32) -> f32
  if near_zero_f32(x, abs_eps) ret 0.0 .end
  ret x
.end

# ---------------------------------
# Sign helpers
# ---------------------------------

fn same_sign_f64(a: f64, b: f64) -> bool
  # treat +0 and -0 as same sign
  if a == 0.0 || b == 0.0 ret true .end
  ret (a > 0.0 && b > 0.0) || (a < 0.0 && b < 0.0)
.end

fn same_sign_f32(a: f32, b: f32) -> bool
  if a == 0.0 || b == 0.0 ret true .end
  ret (a > 0.0 && b > 0.0) || (a < 0.0 && b < 0.0)
.end

# ---------------------------------
# Total order compare (IEEE) for stable sorting
# ---------------------------------
# Returns:
#   -1 if a < b, 0 if a == b (bitwise totalOrder), +1 if a > b
# NaN is ordered per totalOrder mapping (consistent for Maps/Sorts).

fn compare_total_order_f64(a: f64, b: f64) -> i32
  let ka = ieee.f64_total_order_key_bits(ieee.f64_to_bits(a))
  let kb = ieee.f64_total_order_key_bits(ieee.f64_to_bits(b))
  if ka < kb ret -1 .end
  if ka > kb ret 1 .end
  ret 0
.end

fn compare_total_order_f32(a: f32, b: f32) -> i32
  let ka = ieee.f32_total_order_key_bits(ieee.f32_to_bits(a))
  let kb = ieee.f32_total_order_key_bits(ieee.f32_to_bits(b))
  if ka < kb ret -1 .end
  if ka > kb ret 1 .end
  ret 0
.end

# ---------------------------------
# Tests smoke
# ---------------------------------

fn assert(cond: bool)
  if !cond panic("assert failed") .end
.end

fn test_absrel()
  let t = tol_f64_absrel(1e-9, 1e-9)
  assert(approx_eq_f64(1.0, 1.0 + 5e-10, t))
  assert(!approx_eq_f64(1.0, 1.0 + 1e-6, t))
.end

fn test_ulps()
  let t = tol_f64_ulps(8)
  let a = 1.0
  let b = ieee.f64_nextup(a)
  assert(approx_eq_f64(a, b, t))
.end

fn test_total_order_zero()
  let a = 0.0
  let b = ieee.f64_neg_zero()
  let c = compare_total_order_f64(b, a)
  # -0 should be ordered before +0
  assert(c < 0)
.end

fn run_all_tests()
  test_absrel()
  test_ulps()
  test_total_order_zero()
.end

.end
