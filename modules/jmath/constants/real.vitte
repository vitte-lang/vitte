module jmath.real.real

# ============================================================================
# real.vitte — utilitaires numériques généraux pour réels (f32 / f64)
#
# Fournit :
#   - fonctions de base (abs, min/max, clamp, saturate, signum)
#   - NaN / Inf / finitude (via ieee754)
#   - interpolation (lerp, inv_lerp, remap)
#   - courbes (smoothstep, smootherstep)
#   - comparaisons approchées (abs / rel / combinée)
#   - helpers ULP (via ieee754)
#   - helpers angulaires (wrap)
#   - statistiques simples (mean, midpoint)
#
# Dépendances :
#   - jmath.constants.ieee754
#
# Pas d’I/O, blocs `.end`
# ============================================================================

import jmath.constants.ieee754 as ieee

const PI  : f64 = 3.141592653589793238462643383279502884
const TAU : f64 = 6.283185307179586476925286766559005768

# ---------------------------------
# Basics
# ---------------------------------

fn abs_f64(x: f64) -> f64
  if x < 0.0 ret -x .end
  ret x
.end

fn abs_f32(x: f32) -> f32
  if x < 0.0 ret -x .end
  ret x
.end

fn min_f64(a: f64, b: f64) -> f64
  if a < b ret a .end
  ret b
.end

fn max_f64(a: f64, b: f64) -> f64
  if a > b ret a .end
  ret b
.end

fn min_f32(a: f32, b: f32) -> f32
  if a < b ret a .end
  ret b
.end

fn max_f32(a: f32, b: f32) -> f32
  if a > b ret a .end
  ret b
.end

fn clamp_f64(x: f64, lo: f64, hi: f64) -> f64
  if x < lo ret lo .end
  if x > hi ret hi .end
  ret x
.end

fn clamp_f32(x: f32, lo: f32, hi: f32) -> f32
  if x < lo ret lo .end
  if x > hi ret hi .end
  ret x
.end

fn saturate_f64(x: f64) -> f64
  ret clamp_f64(x, 0.0, 1.0)
.end

fn saturate_f32(x: f32) -> f32
  ret clamp_f32(x, 0.0, 1.0)
.end

fn signum_f64(x: f64) -> f64
  if x > 0.0 ret 1.0 .end
  if x < 0.0 ret -1.0 .end
  ret 0.0
.end

fn signum_f32(x: f32) -> f32
  if x > 0.0 ret 1.0 .end
  if x < 0.0 ret -1.0 .end
  ret 0.0
.end

# ---------------------------------
# NaN / Inf / Finite (delegation ieee)
# ---------------------------------

fn is_nan_f64(x: f64) -> bool ret x != x .end
fn is_nan_f32(x: f32) -> bool ret x != x .end

fn is_inf_f64(x: f64) -> bool ret ieee.f64_is_inf(x) .end
fn is_inf_f32(x: f32) -> bool ret ieee.f32_is_inf(x) .end

fn is_finite_f64(x: f64) -> bool ret ieee.f64_is_finite(x) .end
fn is_finite_f32(x: f32) -> bool ret ieee.f32_is_finite(x) .end

# ---------------------------------
# Interpolation / Mapping
# ---------------------------------

fn lerp_f64(a: f64, b: f64, t: f64) -> f64
  ret a + (b - a) * t
.end

fn lerp_f32(a: f32, b: f32, t: f32) -> f32
  ret a + (b - a) * t
.end

fn inv_lerp_f64(a: f64, b: f64, x: f64) -> f64
  let d = b - a
  if d == 0.0 ret 0.0 .end
  ret (x - a) / d
.end

fn inv_lerp_f32(a: f32, b: f32, x: f32) -> f32
  let d = b - a
  if d == 0.0 ret 0.0 .end
  ret (x - a) / d
.end

fn remap_f64(in0: f64, in1: f64, out0: f64, out1: f64, x: f64) -> f64
  ret lerp_f64(out0, out1, inv_lerp_f64(in0, in1, x))
.end

fn remap_f32(in0: f32, in1: f32, out0: f32, out1: f32, x: f32) -> f32
  ret lerp_f32(out0, out1, inv_lerp_f32(in0, in1, x))
.end

# ---------------------------------
# Courbes lissées
# ---------------------------------

fn smoothstep_f64(edge0: f64, edge1: f64, x: f64) -> f64
  let t = saturate_f64(inv_lerp_f64(edge0, edge1, x))
  ret t*t*(3.0 - 2.0*t)
.end

fn smootherstep_f64(edge0: f64, edge1: f64, x: f64) -> f64
  let t = saturate_f64(inv_lerp_f64(edge0, edge1, x))
  ret t*t*t*(t*(t*6.0 - 15.0) + 10.0)
.end

# ---------------------------------
# Approximation numérique
# ---------------------------------

fn approx_eq_abs_f64(a: f64, b: f64, eps: f64) -> bool
  ret abs_f64(a - b) <= eps
.end

fn approx_eq_abs_f32(a: f32, b: f32, eps: f32) -> bool
  ret abs_f32(a - b) <= eps
.end

fn approx_eq_rel_f64(a: f64, b: f64, eps: f64) -> bool
  let d = abs_f64(a - b)
  let mut m = abs_f64(a)
  let bb = abs_f64(b)
  if bb > m m = bb .end
  if m == 0.0 ret d <= eps .end
  ret d <= eps * m
.end

fn approx_eq_rel_f32(a: f32, b: f32, eps: f32) -> bool
  let d = abs_f32(a - b)
  let mut m = abs_f32(a)
  let bb = abs_f32(b)
  if bb > m m = bb .end
  if m == 0.0 ret d <= eps .end
  ret d <= eps * m
.end

fn approx_eq_f64(a: f64, b: f64, rel: f64, abs: f64) -> bool
  let d = abs_f64(a - b)
  if d <= abs ret true .end
  let mut m = abs_f64(a)
  let bb = abs_f64(b)
  if bb > m m = bb .end
  ret d <= rel * m
.end

fn approx_eq_f32(a: f32, b: f32, rel: f32, abs: f32) -> bool
  let d = abs_f32(a - b)
  if d <= abs ret true .end
  let mut m = abs_f32(a)
  let bb = abs_f32(b)
  if bb > m m = bb .end
  ret d <= rel * m
.end

# ---------------------------------
# ULP helpers (delegation ieee754)
# ---------------------------------

fn ulp_distance_f64(a: f64, b: f64) -> ieee.UlpCmp
  ret ieee.f64_ulp_distance(a, b)
.end

fn ulp_distance_f32(a: f32, b: f32) -> ieee.UlpCmp
  ret ieee.f32_ulp_distance(a, b)
.end

fn almost_equal_ulps_f64(a: f64, b: f64, max_ulps: u64) -> bool
  ret ieee.f64_almost_equal_ulps(a, b, max_ulps)
.end

fn almost_equal_ulps_f32(a: f32, b: f32, max_ulps: u64) -> bool
  ret ieee.f32_almost_equal_ulps(a, b, max_ulps)
.end

# ---------------------------------
# Angles (radians)
# ---------------------------------

fn wrap_pi(theta: f64) -> f64
  let mut t = theta
  while t <= -PI
    t = t + TAU
  .end
  while t > PI
    t = t - TAU
  .end
  ret t
.end

fn wrap_0_tau(theta: f64) -> f64
  let mut t = theta
  while t < 0.0
    t = t + TAU
  .end
  while t >= TAU
    t = t - TAU
  .end
  ret t
.end

# ---------------------------------
# Statistiques simples
# ---------------------------------

fn mean_f64(a: f64, b: f64) -> f64
  ret 0.5 * (a + b)
.end

fn midpoint_f64(a: f64, b: f64) -> f64
  # forme stable
  ret a + (b - a) * 0.5
.end

# ---------------------------------
# Tests smoke
# ---------------------------------

fn assert(cond: bool)
  if !cond panic("assert failed") .end
.end

fn test_basic()
  assert(abs_f64(-1.0) == 1.0)
  assert(clamp_f64(2.0, 0.0, 1.0) == 1.0)
.end

fn test_lerp()
  let v = lerp_f64(10.0, 20.0, 0.25)
  assert(approx_eq_abs_f64(v, 12.5, 1e-12))
.end

fn test_wrap()
  let a = wrap_pi(PI)
  assert(a == PI)
  let b = wrap_pi(-PI)
  assert(b == PI)
.end

fn run_all_tests()
  test_basic()
  test_lerp()
  test_wrap()
.end

.end
