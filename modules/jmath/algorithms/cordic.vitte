module algorithms.cordic

# ============================================================================
# CORDIC – COordinate Rotation DIgital Computer
#
# Objectifs :
#   - sin/cos via CORDIC (rotation)
#   - atan2 via CORDIC (vectoring)
#   - versions float (f64) + fixed-point (Q1.31)
#
# Notes :
#   - Pas d’accolades : blocs fermés par `.end`
#   - L’API est volontairement “stdlib-like” (pure, sans I/O)
#   - Le CORDIC “rotation mode” converge pour |theta| <= ~pi/2 (on normalise)
#   - Le “gain” K dépend du nombre d’itérations. On applique 1/K via table.
# ============================================================================

# ---------------------------------
# Constantes
# ---------------------------------

const PI      : f64 = 3.141592653589793238462643383279502884
const TAU     : f64 = 6.283185307179586476925286766559005768
const HALF_PI : f64 = 1.570796326794896619231321691639751442

# Table arctan(2^-i) en radians (i=0..59)
# (précision suffisante pour f64; on tronque à 60 itérations max)
const ATAN_POW2 : [f64; 60] =
  [
    0.7853981633974483096156608458198757,
    0.4636476090008061162142562314612144,
    0.2449786631268641541720824812112758,
    0.1243549945467614350313548491638710,
    0.0624188099959573484739791129855051,
    0.0312398334302682762537117448924900,
    0.0156237286204768308028015212565703,
    0.0078123410601011112964633918421993,
    0.0039062301319669718276286653114244,
    0.0019531225164788186851214826250767,
    0.0009765621895593194304034301997174,
    0.0004882812111948982754692396256448,
    0.0002441406201493617712447448120374,
    0.0001220703118936702042390586461179,
    0.0000610351561742087750216625691738,
    0.0000305175781155260968618259534385,
    0.0000152587890613157621072319358120,
    0.0000076293945311019702633884823401,
    0.0000038146972656064962829230756164,
    0.0000019073486328101870353653693050,
    0.0000009536743164059608781754440390,
    0.0000004768371582030888599275838278,
    0.0000002384185791015578297060836597,
    0.0000001192092895507806423985379286,
    0.0000000596046447753905520804993590,
    0.0000000298023223876953036767402226,
    0.0000000149011611938476552192444175,
    0.0000000074505805969238279871365646,
    0.0000000037252902984619140452672071,
    0.0000000018626451492309570290950218,
    0.0000000009313225746154785156970335,
    0.0000000004656612873077392578261620,
    0.0000000002328306436538696289062500,
    0.0000000001164153218269348144531250,
    0.0000000000582076609134674072265625,
    0.0000000000291038304567337036132812,
    0.0000000000145519152283668518066406,
    0.0000000000072759576141834259033203,
    0.0000000000036379788070917129516602,
    0.0000000000018189894035458564758301,
    0.0000000000009094947017729282379150,
    0.0000000000004547473508864641189575,
    0.0000000000002273736754432320594788,
    0.0000000000001136868377216160297394,
    0.0000000000000568434188608080148697,
    0.0000000000000284217094304040074348,
    0.0000000000000142108547152020037174,
    0.0000000000000071054273576010018587,
    0.0000000000000035527136788005009294,
    0.0000000000000017763568394002504647,
    0.0000000000000008881784197001252323,
    0.0000000000000004440892098500626162,
    0.0000000000000002220446049250313081,
    0.0000000000000001110223024625156540,
    0.0000000000000000555111512312578270,
    0.0000000000000000277555756156289135,
    0.0000000000000000138777878078144567
  ]

# Gains K pour N itérations (1..32 “classique” + 60 pour f64).
# K_N = Π_{i=0..N-1} 1/sqrt(1 + 2^(-2i))
# On stocke INV_K_N = 1/K_N (multiplicateur à appliquer en sortie).
const INV_K_1  : f64 = 0.70710678118654752440084436210485
const INV_K_2  : f64 = 0.63245553203367586639977870888654
const INV_K_3  : f64 = 0.61357199107789634961024710990292
const INV_K_4  : f64 = 0.60883391251775242102238307030173
const INV_K_5  : f64 = 0.60764825625616820092822054636487
const INV_K_6  : f64 = 0.60735177014129596269352315464555
const INV_K_7  : f64 = 0.60727764409352608259187500647999
const INV_K_8  : f64 = 0.60725911229889273006029434830961
const INV_K_9  : f64 = 0.60725447933256232957611472194529
const INV_K_10 : f64 = 0.60725332108987516367969922296829
const INV_K_11 : f64 = 0.60725303152913433540956399727453
const INV_K_12 : f64 = 0.60725295913894481363048136517617
const INV_K_13 : f64 = 0.60725294104139716351237010242930
const INV_K_14 : f64 = 0.60725293651701023413268107815076
const INV_K_15 : f64 = 0.60725293538591345555696388118383
const INV_K_16 : f64 = 0.60725293510313935803522327357963
const INV_K_17 : f64 = 0.60725293503244577146287143619070
const INV_K_18 : f64 = 0.60725293501477237402945281974197
const INV_K_19 : f64 = 0.60725293501035402417536414449355
const INV_K_20 : f64 = 0.60725293500924943674202649739000
const INV_K_21 : f64 = 0.60725293500897328909088950713665
const INV_K_22 : f64 = 0.60725293500890425217809277049611
const INV_K_23 : f64 = 0.60725293500888699295024760406565
const INV_K_24 : f64 = 0.60725293500888267814328402680207
const INV_K_25 : f64 = 0.60725293500888159944152958237358
const INV_K_26 : f64 = 0.60725293500888132976609097493432
const INV_K_27 : f64 = 0.60725293500888126234723132233509
const INV_K_28 : f64 = 0.60725293500888124549251972191915
const INV_K_29 : f64 = 0.60725293500888124127884181662284
const INV_K_30 : f64 = 0.60725293500888124022542234029878
const INV_K_31 : f64 = 0.60725293500888123996206747114210
const INV_K_32 : f64 = 0.60725293500888123989622975470054

# Pour 60 itérations, c’est quasiment la même limite.
const INV_K_60 : f64 = 0.6072529350088812398962297547

# ---------------------------------
# Types
# ---------------------------------

type CordicIter = i32

struct CordicCfg
  iterations : CordicIter
.end

struct CordicResult2
  a : f64
  b : f64
.end

# Fixed-point Q1.31 (signé) : valeur réelle = raw / 2^31
type Q31 = i64

struct CordicResultQ31
  a : Q31
  b : Q31
.end

# ---------------------------------
# Utils (float)
# ---------------------------------

fn clamp_i32(v: i32, lo: i32, hi: i32) -> i32
  if v < lo
    ret lo
  .end
  if v > hi
    ret hi
  .end
  ret v
.end

fn abs_f64(x: f64) -> f64
  if x < 0.0
    ret -x
  .end
  ret x
.end

fn wrap_angle_pi(theta: f64) -> f64
  # Normalise dans (-pi, pi]
  let mut t = theta

  # réduction grossière
  # (on évite la dépendance à fmod; boucle sûre)
  while t <= -PI
    t = t + TAU
  .end
  while t > PI
    t = t - TAU
  .end

  ret t
.end

fn inv_k_for_iters(iters: i32) -> f64
  let n = clamp_i32(iters, 1, 60)

  if n == 1  ret INV_K_1  .end
  if n == 2  ret INV_K_2  .end
  if n == 3  ret INV_K_3  .end
  if n == 4  ret INV_K_4  .end
  if n == 5  ret INV_K_5  .end
  if n == 6  ret INV_K_6  .end
  if n == 7  ret INV_K_7  .end
  if n == 8  ret INV_K_8  .end
  if n == 9  ret INV_K_9  .end
  if n == 10 ret INV_K_10 .end
  if n == 11 ret INV_K_11 .end
  if n == 12 ret INV_K_12 .end
  if n == 13 ret INV_K_13 .end
  if n == 14 ret INV_K_14 .end
  if n == 15 ret INV_K_15 .end
  if n == 16 ret INV_K_16 .end
  if n == 17 ret INV_K_17 .end
  if n == 18 ret INV_K_18 .end
  if n == 19 ret INV_K_19 .end
  if n == 20 ret INV_K_20 .end
  if n == 21 ret INV_K_21 .end
  if n == 22 ret INV_K_22 .end
  if n == 23 ret INV_K_23 .end
  if n == 24 ret INV_K_24 .end
  if n == 25 ret INV_K_25 .end
  if n == 26 ret INV_K_26 .end
  if n == 27 ret INV_K_27 .end
  if n == 28 ret INV_K_28 .end
  if n == 29 ret INV_K_29 .end
  if n == 30 ret INV_K_30 .end
  if n == 31 ret INV_K_31 .end
  if n == 32 ret INV_K_32 .end

  ret INV_K_60
.end

fn normalize_for_rotation(theta: f64) -> CordicResult2
  # Ramène l’angle dans [-pi/2, +pi/2] en absorbant un flip de signe.
  # On renvoie (theta_norm, sign_flip) via (a,b) : b vaut +1 ou -1.
  let mut t = wrap_angle_pi(theta)
  let mut s = 1.0

  if t > HALF_PI
    t = t - PI
    s = -1.0
  .end

  if t < -HALF_PI
    t = t + PI
    s = -1.0
  .end

  ret CordicResult2 { a: t, b: s }
.end

# ---------------------------------
# CORDIC (float) – Rotation mode
# ---------------------------------

fn cordic_sin_cos(theta: f64, iterations: i32) -> CordicResult2
  let n = clamp_i32(iterations, 1, 60)
  let norm = normalize_for_rotation(theta)
  let mut z = norm.a
  let flip = norm.b

  # Initial vector (1,0) puis correction par 1/K
  let inv_k = inv_k_for_iters(n)
  let mut x = inv_k
  let mut y = 0.0

  let mut i = 0
  while i < n
    let di = if z >= 0.0 then 1.0 else -1.0 .end

    # shifts par 2^-i
    let x_new = x - di * y * pow2_neg_i(i)
    let y_new = y + di * x * pow2_neg_i(i)
    let z_new = z - di * ATAN_POW2[i as usize]

    x = x_new
    y = y_new
    z = z_new

    i = i + 1
  .end

  # flip = -1 => (cos, sin) changent de signe (rotation de pi)
  ret CordicResult2 { a: x * flip, b: y * flip }
.end

fn cordic_cos(theta: f64, iterations: i32) -> f64
  let r = cordic_sin_cos(theta, iterations)
  ret r.a
.end

fn cordic_sin(theta: f64, iterations: i32) -> f64
  let r = cordic_sin_cos(theta, iterations)
  ret r.b
.end

fn pow2_neg_i(i: i32) -> f64
  # 2^-i en float via boucle (simple et déterministe)
  let mut v = 1.0
  let mut k = 0
  while k < i
    v = v * 0.5
    k = k + 1
  .end
  ret v
.end

# ---------------------------------
# CORDIC (float) – Vectoring mode (atan2)
# ---------------------------------

fn cordic_atan2(y0: f64, x0: f64, iterations: i32) -> f64
  let n = clamp_i32(iterations, 1, 60)

  # Gestion quadrants : on veut x >= 0 pour convergence “standard”.
  # On ramène (x,y) dans demi-plan x>=0 puis on ajuste l’angle.
  let mut x = x0
  let mut y = y0
  let mut angle_bias = 0.0

  if x < 0.0
    x = -x
    y = -y
    angle_bias = PI
  .end

  let mut z = 0.0
  let mut i = 0

  while i < n
    let di = if y >= 0.0 then 1.0 else -1.0 .end

    let x_new = x + di * y * pow2_neg_i(i)
    let y_new = y - di * x * pow2_neg_i(i)
    let z_new = z + di * ATAN_POW2[i as usize]

    x = x_new
    y = y_new
    z = z_new

    i = i + 1
  .end

  # Ajustement quadrant
  let mut out = z + angle_bias
  out = wrap_angle_pi(out)

  ret out
.end

# ---------------------------------
# Fixed-point Q1.31 helpers
# ---------------------------------

const Q31_ONE : Q31 = 2147483648  # 2^31

fn q31_from_f64(x: f64) -> Q31
  # clamp vers [-1, +1) pour Q1.31
  let mut v = x
  if v >= 0.9999999995343387
    v = 0.9999999995343387
  .end
  if v < -1.0
    v = -1.0
  .end
  ret (v * (Q31_ONE as f64)) as Q31
.end

fn q31_to_f64(x: Q31) -> f64
  ret (x as f64) / (Q31_ONE as f64)
.end

fn q31_add(a: Q31, b: Q31) -> Q31
  ret a + b
.end

fn q31_sub(a: Q31, b: Q31) -> Q31
  ret a - b
.end

fn q31_shr(a: Q31, sh: i32) -> Q31
  # arith shift
  ret a >> sh
.end

fn q31_mul(a: Q31, b: Q31) -> Q31
  # (a*b) >> 31 avec élargissement i128 “logique”
  let prod = (a as i128) * (b as i128)
  ret (prod >> 31) as Q31
.end

# atan(2^-i) en Q31 (radians) pour i=0..31 (utile pour atan2 Q31)
# On stocke des radians en Q1.31 (donc plage [-1,+1) ≠ pi), mais ici on veut angle.
# => On encode l’angle en Q2.30 (scalaire 2^30) pour tenir pi.
# On définit un format ANG30 : réel = raw / 2^30, plage ~[-2,+2).
type ANG30 = i64
const ANG30_ONE : ANG30 = 1073741824  # 2^30

fn ang30_from_f64(x: f64) -> ANG30
  ret (x * (ANG30_ONE as f64)) as ANG30
.end

fn ang30_to_f64(x: ANG30) -> f64
  ret (x as f64) / (ANG30_ONE as f64)
.end

const ATAN_POW2_ANG30 : [ANG30; 32] =
  [
    843314856,  # atan(1)
    497837829,
    263043836,
    133525159,
    67021687,
    33543516,
    16775851,
    8388437,
    4194283,
    2097149,
    1048576,
    524288,
    262144,
    131072,
    65536,
    32768,
    16384,
    8192,
    4096,
    2048,
    1024,
    512,
    256,
    128,
    64,
    32,
    16,
    8,
    4,
    2,
    1,
    0
  ]

# Gain inv_k en Q31 pour 16/32 itérations (classique)
const INV_K_16_Q31 : Q31 = 1304381788  # ~= 0.6072529351 * 2^31
const INV_K_32_Q31 : Q31 = 1304381788  # limite identique à cette précision

fn inv_k_q31(iters: i32) -> Q31
  let n = clamp_i32(iters, 1, 32)
  if n <= 16
    ret INV_K_16_Q31
  .end
  ret INV_K_32_Q31
.end

# ---------------------------------
# CORDIC (Q31) – sin/cos (rotation)
# ---------------------------------

fn cordic_sin_cos_q31(theta_rad: f64, iterations: i32) -> CordicResultQ31
  let n = clamp_i32(iterations, 1, 32)

  # normalisation angle (float) puis conversion en ANG30
  let norm = normalize_for_rotation(theta_rad)
  let z0 = ang30_from_f64(norm.a)
  let flip = if norm.b >= 0.0 then 1 else -1 .end

  let mut z : ANG30 = z0
  let mut x : Q31 = inv_k_q31(n)
  let mut y : Q31 = 0

  let mut i = 0
  while i < n
    let di = if z >= 0 then 1 else -1 .end

    # x' = x - di*(y >> i)
    # y' = y + di*(x >> i)
    let x_shift = q31_shr(x, i)
    let y_shift = q31_shr(y, i)

    let x_new = if di > 0 then q31_sub(x, y_shift) else q31_add(x, y_shift) .end
    let y_new = if di > 0 then q31_add(y, x_shift) else q31_sub(y, x_shift) .end
    let z_new = if di > 0 then (z - ATAN_POW2_ANG30[i as usize]) else (z + ATAN_POW2_ANG30[i as usize]) .end

    x = x_new
    y = y_new
    z = z_new

    i = i + 1
  .end

  if flip < 0
    x = -x
    y = -y
  .end

  ret CordicResultQ31 { a: x, b: y }
.end

fn cordic_sin_q31(theta_rad: f64, iterations: i32) -> Q31
  let r = cordic_sin_cos_q31(theta_rad, iterations)
  ret r.b
.end

fn cordic_cos_q31(theta_rad: f64, iterations: i32) -> Q31
  let r = cordic_sin_cos_q31(theta_rad, iterations)
  ret r.a
.end

# ---------------------------------
# CORDIC (Q31) – atan2 (vectoring)
# ---------------------------------

fn cordic_atan2_q31(y: Q31, x: Q31, iterations: i32) -> f64
  let n = clamp_i32(iterations, 1, 32)

  # vectoring: ramener x>=0 en Q31 et appliquer bias PI si besoin
  let mut vx = x
  let mut vy = y
  let mut bias : f64 = 0.0

  if vx < 0
    vx = -vx
    vy = -vy
    bias = PI
  .end

  let mut z : ANG30 = 0

  let mut i = 0
  while i < n
    let di = if vy >= 0 then 1 else -1 .end

    let x_shift = q31_shr(vx, i)
    let y_shift = q31_shr(vy, i)

    # x' = x + di*(y>>i)
    # y' = y - di*(x>>i)
    let x_new = if di > 0 then q31_add(vx, y_shift) else q31_sub(vx, y_shift) .end
    let y_new = if di > 0 then q31_sub(vy, x_shift) else q31_add(vy, x_shift) .end
    let z_new = if di > 0 then (z + ATAN_POW2_ANG30[i as usize]) else (z - ATAN_POW2_ANG30[i as usize]) .end

    vx = x_new
    vy = y_new
    z = z_new

    i = i + 1
  .end

  let out = ang30_to_f64(z) + bias
  ret wrap_angle_pi(out)
.end

# ---------------------------------
# API ergonomique via config
# ---------------------------------

fn cordic_sin_cos_cfg(theta: f64, cfg: CordicCfg) -> CordicResult2
  ret cordic_sin_cos(theta, cfg.iterations)
.end

fn cordic_atan2_cfg(y: f64, x: f64, cfg: CordicCfg) -> f64
  ret cordic_atan2(y, x, cfg.iterations)
.end

# ---------------------------------
# Tests (smoke + précision)
# ---------------------------------

fn approx_eq(a: f64, b: f64, eps: f64) -> bool
  ret abs_f64(a - b) <= eps
.end

fn test_wrap_angle_pi()
  let a = wrap_angle_pi(PI + 0.1)
  # doit être proche de -PI + 0.1
  if !approx_eq(a, -PI + 0.1, 1e-12)
    panic("wrap_angle_pi failed")
  .end
.end

fn test_sin_cos_basic()
  let n = 40

  let r0 = cordic_sin_cos(0.0, n)
  if !approx_eq(r0.a, 1.0, 1e-12) panic("cos(0) failed") .end
  if !approx_eq(r0.b, 0.0, 1e-12) panic("sin(0) failed") .end

  let r1 = cordic_sin_cos(HALF_PI, n)
  if !approx_eq(r1.a, 0.0, 1e-10) panic("cos(pi/2) failed") .end
  if !approx_eq(r1.b, 1.0, 1e-10) panic("sin(pi/2) failed") .end

  let r2 = cordic_sin_cos(PI, n)
  if !approx_eq(r2.a, -1.0, 1e-10) panic("cos(pi) failed") .end
  if !approx_eq(r2.b, 0.0, 1e-10) panic("sin(pi) failed") .end
.end

fn test_atan2_quadrants()
  let n = 50

  let a0 = cordic_atan2(0.0, 1.0, n)
  if !approx_eq(a0, 0.0, 1e-12) panic("atan2(0,1) failed") .end

  let a1 = cordic_atan2(1.0, 0.0, n)
  if !approx_eq(a1, HALF_PI, 1e-9) panic("atan2(1,0) failed") .end

  let a2 = cordic_atan2(0.0, -1.0, n)
  if !approx_eq(abs_f64(a2), PI, 1e-9) panic("atan2(0,-1) failed") .end

  let a3 = cordic_atan2(-1.0, 0.0, n)
  if !approx_eq(a3, -HALF_PI, 1e-9) panic("atan2(-1,0) failed") .end
.end

fn test_q31_roundtrip()
  let x = 0.123456789
  let q = q31_from_f64(x)
  let y = q31_to_f64(q)
  if !approx_eq(x, y, 1.0 / (Q31_ONE as f64) * 4.0)
    panic("q31 roundtrip failed")
  .end
.end

fn test_q31_sin_cos_smoke()
  let n = 24
  let r = cordic_sin_cos_q31(0.0, n)
  let c = q31_to_f64(r.a)
  let s = q31_to_f64(r.b)
  if !approx_eq(c, 1.0, 2e-6) panic("q31 cos(0) failed") .end
  if !approx_eq(s, 0.0, 2e-6) panic("q31 sin(0) failed") .end
.end

fn run_all_tests()
  test_wrap_angle_pi()
  test_sin_cos_basic()
  test_atan2_quadrants()
  test_q31_roundtrip()
  test_q31_sin_cos_smoke()
.end

.end
