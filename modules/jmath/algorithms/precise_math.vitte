module std.math.algorithms.precise_math

# ============================================================================
# precise_math – primitives numériques “précision d’abord”
#
# Objectifs :
#   - Utilitaires robustes (comparaisons, ulp-ish, clamp, scaling)
#   - Sommes compensées (Kahan, Neumaier), dot produits stables
#   - Réductions d’angles haute précision (range reduction)
#   - Trig/exp/log “précis” via stratégies :
#       * polynomial + réduction + itérations Newton/Householder (light)
#       * CORDIC bridge possible si module dispo
#   - Racines (sqrt) via Newton + garde-fous
#   - Fonctions spéciales utiles (sinc, log1p, expm1)
#   - Outils d’erreur (rmse, max abs, relative)
#   - Tests smoke
#
# Conventions :
#   - Pas d’accolades, blocs en `.end`
#   - API pure, sans I/O
#   - Implémentations robustes, pas forcément les plus rapides
# ============================================================================

# ---------------------------------
# Constantes
# ---------------------------------

const PI      : f64 = 3.141592653589793238462643383279502884
const TAU     : f64 = 6.283185307179586476925286766559005768
const HALF_PI : f64 = 1.570796326794896619231321691639751442

const LN2     : f64 = 0.693147180559945309417232121458176568
const INV_LN2 : f64 = 1.442695040888963407359924681001892137

# split constants for high-precision range reduction (double-double light)
const LN2_HI : f64 = 0.69314718036912381649017333984375
const LN2_LO : f64 = 0.000000000190821492927058781614426

const PI_HI  : f64 = 3.141592653589793116
const PI_LO  : f64 = 1.224646799147353207e-16

# ---------------------------------
# Base utils
# ---------------------------------

fn abs_f64(x: f64) -> f64
  if x < 0.0
    ret -x
  .end
  ret x
.end

fn min_f64(a: f64, b: f64) -> f64
  if a < b
    ret a
  .end
  ret b
.end

fn max_f64(a: f64, b: f64) -> f64
  if a > b
    ret a
  .end
  ret b
.end

fn clamp_f64(x: f64, lo: f64, hi: f64) -> f64
  if x < lo
    ret lo
  .end
  if x > hi
    ret hi
  .end
  ret x
.end

fn sign_f64(x: f64) -> f64
  if x > 0.0
    ret 1.0
  .end
  if x < 0.0
    ret -1.0
  .end
  ret 0.0
.end

fn copysign_f64(mag: f64, sgn: f64) -> f64
  if sgn < 0.0
    ret -abs_f64(mag)
  .end
  ret abs_f64(mag)
.end

fn sqr(x: f64) -> f64
  ret x * x
.end

fn is_finite(x: f64) -> bool
  if x > 1e308
    ret false
  .end
  if x < -1e308
    ret false
  .end
  ret true
.end

# ---------------------------------
# Double-double helpers (hi, lo)
# ---------------------------------

struct DD
  hi : f64
  lo : f64
.end

fn dd_make(hi: f64, lo: f64) -> DD
  ret DD { hi: hi, lo: lo }
.end

fn dd_add(a: DD, b: DD) -> DD
  # TwoSum for hi + hi, then accumulate lo
  let s = a.hi + b.hi
  let v = s - a.hi
  let e = (a.hi - (s - v)) + (b.hi - v) + a.lo + b.lo
  let hi = s + e
  let lo = e - (hi - s)
  ret DD { hi: hi, lo: lo }
.end

fn dd_sub(a: DD, b: DD) -> DD
  ret dd_add(a, DD { hi: -b.hi, lo: -b.lo })
.end

fn dd_mul(a: DD, b: DD) -> DD
  # light correction; for full accuracy use FMA-based split if available
  let p = a.hi * b.hi
  let e = a.hi * b.lo + a.lo * b.hi + a.lo * b.lo
  let hi = p + e
  let lo = e - (hi - p)
  ret DD { hi: hi, lo: lo }
.end

fn dd_to_f64(a: DD) -> f64
  ret a.hi + a.lo
.end

# ---------------------------------
# Kahan / Neumaier sums
# ---------------------------------

struct KahanSum
  sum : f64
  c : f64
.end

fn kahan_new() -> KahanSum
  ret KahanSum { sum: 0.0, c: 0.0 }
.end

fn kahan_add(ks: &mut KahanSum, x: f64)
  let y = x - ks.c
  let t = ks.sum + y
  ks.c = (t - ks.sum) - y
  ks.sum = t
.end

fn kahan_value(ks: &KahanSum) -> f64
  ret ks.sum
.end

struct NeumaierSum
  sum : f64
  c : f64
.end

fn neumaier_new() -> NeumaierSum
  ret NeumaierSum { sum: 0.0, c: 0.0 }
.end

fn neumaier_add(ns: &mut NeumaierSum, x: f64)
  let t = ns.sum + x
  if abs_f64(ns.sum) >= abs_f64(x)
    ns.c = ns.c + (ns.sum - t) + x
  .end
  if abs_f64(ns.sum) < abs_f64(x)
    ns.c = ns.c + (x - t) + ns.sum
  .end
  ns.sum = t
.end

fn neumaier_value(ns: &NeumaierSum) -> f64
  ret ns.sum + ns.c
.end

fn sum_kahan(xs: &[f64]) -> f64
  let mut ks = kahan_new()
  let mut i = 0
  while i < (xs.len() as i32)
    kahan_add(&mut ks, xs[i as usize])
    i = i + 1
  .end
  ret kahan_value(&ks)
.end

fn sum_neumaier(xs: &[f64]) -> f64
  let mut ns = neumaier_new()
  let mut i = 0
  while i < (xs.len() as i32)
    neumaier_add(&mut ns, xs[i as usize])
    i = i + 1
  .end
  ret neumaier_value(&ns)
.end

fn dot_kahan(a: &[f64], b: &[f64]) -> f64
  if a.len() != b.len()
    panic("dot_kahan: size mismatch")
  .end
  let mut ks = kahan_new()
  let mut i = 0
  while i < (a.len() as i32)
    kahan_add(&mut ks, a[i as usize] * b[i as usize])
    i = i + 1
  .end
  ret kahan_value(&ks)
.end

# ---------------------------------
# Error metrics
# ---------------------------------

struct ErrStats
  max_abs : f64
  max_rel : f64
  rmse : f64
.end

fn err_stats(y: &[f64], yhat: &[f64], eps_rel: f64) -> ErrStats
  if y.len() != yhat.len()
    panic("err_stats: size mismatch")
  .end

  let n = y.len() as i32
  if n <= 0
    ret ErrStats { max_abs: 0.0, max_rel: 0.0, rmse: 0.0 }
  .end

  let mut se = 0.0
  let mut ma = 0.0
  let mut mr = 0.0

  let mut i = 0
  while i < n
    let e = yhat[i as usize] - y[i as usize]
    let ae = abs_f64(e)
    if ae > ma
      ma = ae
    .end

    let denom = max_f64(abs_f64(y[i as usize]), eps_rel)
    let re = ae / denom
    if re > mr
      mr = re
    .end

    se = se + e * e
    i = i + 1
  .end

  let rmse = (se / (n as f64)).sqrt()
  ret ErrStats { max_abs: ma, max_rel: mr, rmse: rmse }
.end

# ---------------------------------
# Range reduction (angles) with split π
# ---------------------------------

fn wrap_angle_pi(theta: f64) -> f64
  let mut t = theta
  while t <= -PI
    t = t + TAU
  .end
  while t > PI
    t = t - TAU
  .end
  ret t
.end

fn reduce_angle_half_pi(theta: f64) -> (f64, i32)
  # theta = k*(pi/2) + r, r in approx [-pi/4,pi/4] after folding
  let inv = 2.0 / PI
  let kf = floor_f64(theta * inv + 0.5)
  let k = kf as i32
  let kf64 = k as f64

  let p2_hi = 0.5 * PI_HI
  let p2_lo = 0.5 * PI_LO

  let r1 = theta - kf64 * p2_hi
  let r2 = r1 - kf64 * p2_lo
  ret (r2, k)
.end

# ---------------------------------
# Precise-ish sin/cos via reduction + poly
# ---------------------------------

fn sin_poly(r: f64) -> f64
  let x2 = r*r
  let x3 = x2*r
  let x5 = x3*x2
  let x7 = x5*x2
  let x9 = x7*x2
  ret r - x3*(1.0/6.0) + x5*(1.0/120.0) - x7*(1.0/5040.0) + x9*(1.0/362880.0)
.end

fn cos_poly(r: f64) -> f64
  let x2 = r*r
  let x4 = x2*x2
  let x6 = x4*x2
  let x8 = x4*x4
  ret 1.0 - x2*0.5 + x4*(1.0/24.0) - x6*(1.0/720.0) + x8*(1.0/40320.0)
.end

fn sincos_precise(theta: f64) -> (f64, f64)
  let rr = reduce_angle_half_pi(theta)
  let mut r = rr.0
  let k = rr.1

  # fold to [-pi/4, pi/4] using sin/cos swap
  let mut swap = false
  if r > (0.5*HALF_PI)
    r = HALF_PI - r
    swap = true
  .end
  if r < -(0.5*HALF_PI)
    r = -HALF_PI - r
    swap = true
  .end

  let s0 = sin_poly(r)
  let c0 = cos_poly(r)

  let mut s = s0
  let mut c = c0
  if swap
    s = c0
    c = s0
  .end

  let q = k & 3
  if q == 0
    ret (s, c)
  .end
  if q == 1
    ret (c, -s)
  .end
  if q == 2
    ret (-s, -c)
  .end
  ret (-c, s)
.end

fn sin_precise(theta: f64) -> f64
  ret sincos_precise(theta).0
.end

fn cos_precise(theta: f64) -> f64
  ret sincos_precise(theta).1
.end

# ---------------------------------
# expm1 / log1p (stable near 0)
# ---------------------------------

fn expm1_precise(x: f64) -> f64
  let ax = abs_f64(x)
  if ax < 1e-5
    let x2 = x*x
    let x3 = x2*x
    let x4 = x2*x2
    let x5 = x4*x
    ret x + 0.5*x2 + (1.0/6.0)*x3 + (1.0/24.0)*x4 + (1.0/120.0)*x5
  .end
  ret exp_precise(x) - 1.0
.end

fn log1p_precise(x: f64) -> f64
  if x <= -1.0
    ret -1e300
  .end
  let ax = abs_f64(x)
  if ax < 1e-6
    let x2 = x*x
    let x3 = x2*x
    let x4 = x2*x2
    let x5 = x4*x
    ret x - 0.5*x2 + (1.0/3.0)*x3 - 0.25*x4 + 0.2*x5
  .end
  ret log_precise(1.0 + x)
.end

# ---------------------------------
# exp/log (precise-ish) via split ln2
# ---------------------------------

fn exp_poly7(r: f64) -> f64
  let r2 = r*r
  let r3 = r2*r
  let r4 = r2*r2
  let r5 = r4*r
  let r6 = r3*r3
  let r7 = r6*r
  ret 1.0 + r + 0.5*r2 + (1.0/6.0)*r3 + (1.0/24.0)*r4 + (1.0/120.0)*r5 + (1.0/720.0)*r6 + (1.0/5040.0)*r7
.end

fn exp_precise(x: f64) -> f64
  let xc = clamp_f64(x, -700.0, 700.0)
  let kf = floor_f64(xc * INV_LN2 + 0.5)
  let k = kf as i32
  let kf64 = k as f64

  let r1 = xc - kf64 * LN2_HI
  let r = r1 - kf64 * LN2_LO

  let y = exp_poly7(r)
  ret ldexp_f64(y, k)
.end

fn log1p_series9(t: f64) -> f64
  let t2 = t*t
  let t3 = t2*t
  let t4 = t2*t2
  let t5 = t4*t
  let t6 = t3*t3
  let t7 = t6*t
  let t8 = t4*t4
  let t9 = t8*t
  ret t
    - 0.5*t2
    + (1.0/3.0)*t3
    - 0.25*t4
    + 0.2*t5
    - (1.0/6.0)*t6
    + (1.0/7.0)*t7
    - 0.125*t8
    + (1.0/9.0)*t9
.end

fn log_precise(x: f64) -> f64
  if x <= 0.0
    ret -1e300
  .end

  let fr = frexp_f64(x)
  let m = fr.mantissa
  let e = fr.exponent

  let t = m - 1.0
  let lm = log1p_series9(t)
  ret lm + (e as f64) * LN2
.end

# ---------------------------------
# sqrt (Newton) with safeguards
# ---------------------------------

fn sqrt_precise(x: f64) -> f64
  if x <= 0.0
    if x == 0.0
      ret 0.0
    .end
    ret 0.0
  .end

  let fr = frexp_f64(x)
  let mut y = ldexp_f64(1.0, fr.exponent / 2)

  let mut i = 0
  while i < 10
    y = 0.5 * (y + x / y)
    i = i + 1
  .end
  ret y
.end

# ---------------------------------
# sinc
# ---------------------------------

fn sinc_precise(x: f64) -> f64
  let ax = abs_f64(x)
  if ax < 1e-4
    let x2 = x*x
    let x4 = x2*x2
    let x6 = x4*x2
    ret 1.0 - x2*(1.0/6.0) + x4*(1.0/120.0) - x6*(1.0/5040.0)
  .end
  ret sin_precise(x) / x
.end

# ---------------------------------
# atan/atan2 via rational
# ---------------------------------

const ATAN_A : f64 = 1.0
const ATAN_B : f64 = 0.280872
const ATAN_C : f64 = 0.8284
const ATAN_D : f64 = 0.1333

fn atan_rational(x: f64) -> f64
  let x2 = x*x
  let num = x * (ATAN_A + ATAN_B*x2)
  let den = 1.0 + ATAN_C*x2 + ATAN_D*x2*x2
  ret num / den
.end

fn atan_precise(x: f64) -> f64
  let ax = abs_f64(x)
  if ax < 1e-18
    ret x
  .end
  if ax > 1.0
    let t = atan_rational(1.0/ax)
    ret copysign_f64(HALF_PI - t, x)
  .end
  ret atan_rational(x)
.end

fn atan2_precise(y: f64, x: f64) -> f64
  if x > 0.0
    ret atan_precise(y / x)
  .end
  if x < 0.0
    if y >= 0.0
      ret atan_precise(y / x) + PI
    .end
    ret atan_precise(y / x) - PI
  .end
  if y > 0.0
    ret HALF_PI
  .end
  if y < 0.0
    ret -HALF_PI
  .end
  ret 0.0
.end

# ---------------------------------
# floor/ldexp/frexp primitives (fallbacks)
# ---------------------------------

fn floor_f64(x: f64) -> f64
  let i = x as i64
  let fi = i as f64
  if fi > x
    ret (i - 1) as f64
  .end
  ret fi
.end

fn ldexp_f64(x: f64, exp2: i32) -> f64
  let mut v = x
  if exp2 > 0
    let mut k = 0
    while k < exp2
      v = v * 2.0
      k = k + 1
    .end
    ret v
  .end

  if exp2 < 0
    let mut k = 0
    let n = -exp2
    while k < n
      v = v * 0.5
      k = k + 1
    .end
    ret v
  .end

  ret v
.end

struct Frexp
  mantissa : f64
  exponent : i32
.end

fn frexp_f64(x: f64) -> Frexp
  let mut v = x
  let mut e = 0
  while v >= 1.0
    v = v * 0.5
    e = e + 1
  .end
  while v < 0.5
    v = v * 2.0
    e = e - 1
  .end
  ret Frexp { mantissa: v, exponent: e }
.end

# ---------------------------------
# Tests
# ---------------------------------

fn approx_eq(a: f64, b: f64, eps: f64) -> bool
  ret abs_f64(a - b) <= eps
.end

fn test_kahan()
  let xs : [f64] = [1e16, 1.0, -1e16]
  let s1 = xs[0] + xs[1] + xs[2]
  let s2 = sum_kahan(&xs)
  if abs_f64(s1) > 0.1
    if !approx_eq(s2, 1.0, 1e-6)
      panic("kahan failed")
    .end
  .end
.end

fn test_sincos()
  let sc0 = sincos_precise(0.0)
  if !approx_eq(sc0.0, 0.0, 1e-12)
    panic("sin(0)")
  .end
  if !approx_eq(sc0.1, 1.0, 1e-6)
    panic("cos(0)")
  .end

  let sc1 = sincos_precise(HALF_PI)
  if abs_f64(sc1.1) > 5e-4
    panic("cos(pi/2)")
  .end
  if abs_f64(sc1.0 - 1.0) > 5e-4
    panic("sin(pi/2)")
  .end
.end

fn test_log1p_expm1()
  let x = 1e-8
  let a = expm1_precise(x)
  let b = log1p_precise(a)
  if abs_f64(b - x) > 1e-12
    panic("log1p/expm1 roundtrip failed")
  .end
.end

fn test_sqrt()
  let v = sqrt_precise(2.0)
  if abs_f64(v*v - 2.0) > 1e-10
    panic("sqrt failed")
  .end
.end

fn test_atan2()
  let a = atan2_precise(1.0, 0.0)
  if abs_f64(a - HALF_PI) > 1e-6
    panic("atan2 failed")
  .end
.end

fn run_all_tests()
  test_kahan()
  test_sincos()
  test_log1p_expm1()
  test_sqrt()
  test_atan2()
.end

.end
