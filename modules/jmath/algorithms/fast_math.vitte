module algorithms.fast_math

# ============================================================================
# fast_math – approximations, utilities, et primitives perf-oriented
#
# Contenu :
#   - clamps, abs, min/max, lerp, smoothstep
#   - conversions deg/rad, wrap angles, trig via CORDIC bridge
#   - fast inverse sqrt (Quake) + rsqrt refine
#   - exp/log approximations (polynômes simples + range reduction)
#   - powi / powf wrappers
#   - atan/atan2 approximations + CORDIC fallback (si import dispo)
#   - intégration numérique simple (trapz, simpson)
#   - random hash utilities (xorshift32) pour bruit/seed léger
#   - tests smoke
#
# Conventions :
#   - Pas d’accolades, blocs en `.end`
#   - Pas d’I/O, pas d’alloc obligatoire
#   - Les approximations sont “engine-friendly” : rapides, stables, bornées
# ============================================================================

# ---------------------------------
# Constantes
# ---------------------------------

const PI      : f64 = 3.141592653589793238462643383279502884
const TAU     : f64 = 6.283185307179586476925286766559005768
const HALF_PI : f64 = 1.570796326794896619231321691639751442
const LN2     : f64 = 0.693147180559945309417232121458176568
const INV_LN2 : f64 = 1.442695040888963407359924681001892137

# ---------------------------------
# Scalar utils
# ---------------------------------

fn min_f64(a: f64, b: f64) -> f64
  if a < b ret a .end
  ret b
.end

fn max_f64(a: f64, b: f64) -> f64
  if a > b ret a .end
  ret b
.end

fn min_i32(a: i32, b: i32) -> i32
  if a < b ret a .end
  ret b
.end

fn max_i32(a: i32, b: i32) -> i32
  if a > b ret a .end
  ret b
.end

fn clamp_f64(x: f64, lo: f64, hi: f64) -> f64
  if x < lo ret lo .end
  if x > hi ret hi .end
  ret x
.end

fn clamp_i32(x: i32, lo: i32, hi: i32) -> i32
  if x < lo ret lo .end
  if x > hi ret hi .end
  ret x
.end

fn abs_f64(x: f64) -> f64
  if x < 0.0 ret -x .end
  ret x
.end

fn abs_i64(x: i64) -> i64
  if x < 0 ret -x .end
  ret x
.end

fn sign_f64(x: f64) -> f64
  if x > 0.0 ret 1.0 .end
  if x < 0.0 ret -1.0 .end
  ret 0.0
.end

fn copysign_f64(mag: f64, sgn: f64) -> f64
  if sgn < 0.0
    ret -abs_f64(mag)
  .end
  ret abs_f64(mag)
.end

fn lerp_f64(a: f64, b: f64, t: f64) -> f64
  ret a + (b - a) * t
.end

fn smoothstep_f64(edge0: f64, edge1: f64, x: f64) -> f64
  # classic smoothstep
  let t = clamp_f64((x - edge0) / (edge1 - edge0), 0.0, 1.0)
  ret t * t * (3.0 - 2.0 * t)
.end

fn smootherstep_f64(edge0: f64, edge1: f64, x: f64) -> f64
  let t = clamp_f64((x - edge0) / (edge1 - edge0), 0.0, 1.0)
  ret t * t * t * (t * (t * 6.0 - 15.0) + 10.0)
.end

# ---------------------------------
# Angles
# ---------------------------------

fn deg_to_rad(deg: f64) -> f64
  ret deg * (PI / 180.0)
.end

fn rad_to_deg(rad: f64) -> f64
  ret rad * (180.0 / PI)
.end

fn wrap_angle_pi(theta: f64) -> f64
  # (-pi, pi]
  let mut t = theta
  while t <= -PI
    t = t + TAU
  .end
  while t > PI
    t = t - TAU
  .end
  ret t
.end

fn wrap_angle_0_tau(theta: f64) -> f64
  # [0, 2pi)
  let mut t = theta
  while t < 0.0
    t = t + TAU
  .end
  while t >= TAU
    t = t - TAU
  .end
  ret t
.end

# ---------------------------------
# Trig (approximations + option CORDIC)
# ---------------------------------
# Approximations minimax-like sur intervalle réduit.
# Stratégie :
#   - normaliser angle -> [-pi, pi]
#   - plier vers [-pi/2, pi/2]
#   - approx sin(x) sur [-pi/2, pi/2] via poly d’ordre 7
#   - cos(x) via sin(pi/2 - x)
#
# Poly (type Taylor amélioré) :
#   sin(x) ≈ x + c3*x^3 + c5*x^5 + c7*x^7
# Coefs choisis pour bon compromis perf/erreur.

const SIN_C3 : f64 = -0.16666666666666666      # -1/6
const SIN_C5 : f64 =  0.008333333333333333     #  1/120
const SIN_C7 : f64 = -0.0001984126984126984    # -1/5040

fn fold_to_half_pi(x: f64) -> f64
  # x en [-pi, pi], on replie sur [-pi/2, pi/2]
  let mut t = x
  if t > HALF_PI
    t = PI - t
  .end
  if t < -HALF_PI
    t = -PI - t
  .end
  ret t
.end

fn fast_sin_poly(theta: f64) -> f64
  let x = fold_to_half_pi(wrap_angle_pi(theta))
  let x2 = x * x
  # x + c3 x^3 + c5 x^5 + c7 x^7
  ret x + x * x2 * (SIN_C3 + x2 * (SIN_C5 + x2 * SIN_C7))
.end

fn fast_cos_poly(theta: f64) -> f64
  ret fast_sin_poly(HALF_PI - theta)
.end

fn fast_sincos_poly(theta: f64) -> (f64, f64)
  ret (fast_sin_poly(theta), fast_cos_poly(theta))
.end

# Si tu as algorithms.cordic dans ton std, tu peux remplacer ces wrappers
# par un import + appel direct.
# Ici on expose une API “pluggable” :
struct TrigCfg
  use_cordic : bool
  cordic_iters : i32
.end

fn trig_cfg_default() -> TrigCfg
  ret TrigCfg { use_cordic: false, cordic_iters: 40 }
.end

fn sin(theta: f64, cfg: TrigCfg) -> f64
  if cfg.use_cordic
    # Stub : à remplacer par `import algorithms.cordic` puis call.
    # ret cordic.cordic_sin(theta, cfg.cordic_iters)
    ret fast_sin_poly(theta)
  .end
  ret fast_sin_poly(theta)
.end

fn cos(theta: f64, cfg: TrigCfg) -> f64
  if cfg.use_cordic
    ret fast_cos_poly(theta)
  .end
  ret fast_cos_poly(theta)
.end

fn sincos(theta: f64, cfg: TrigCfg) -> (f64, f64)
  if cfg.use_cordic
    ret fast_sincos_poly(theta)
  .end
  ret fast_sincos_poly(theta)
.end

# ---------------------------------
# atan / atan2 (approx rapide)
# ---------------------------------
# atan(x) approx (rational) :
#   atan(x) ~ x*(a + b*x^2) / (1 + c*x^2 + d*x^4)
# puis réduction :
#   atan(x) = sign(x)*pi/2 - atan(1/|x|) si |x|>1

const ATAN_A : f64 = 1.0
const ATAN_B : f64 = 0.280872
const ATAN_C : f64 = 0.8284
const ATAN_D : f64 = 0.1333

fn fast_atan(x: f64) -> f64
  let ax = abs_f64(x)
  if ax < 1e-18
    ret x
  .end

  if ax > 1.0
    let inv = 1.0 / ax
    let t = fast_atan_core(inv)
    ret copysign_f64(HALF_PI - t, x)
  .end

  ret fast_atan_core(x)
.end

fn fast_atan_core(x: f64) -> f64
  let x2 = x * x
  let num = x * (ATAN_A + ATAN_B * x2)
  let den = 1.0 + ATAN_C * x2 + ATAN_D * x2 * x2
  ret num / den
.end

fn fast_atan2(y: f64, x: f64) -> f64
  if x > 0.0
    ret fast_atan(y / x)
  .end
  if x < 0.0
    if y >= 0.0
      ret fast_atan(y / x) + PI
    .end
    ret fast_atan(y / x) - PI
  .end
  # x == 0
  if y > 0.0 ret HALF_PI .end
  if y < 0.0 ret -HALF_PI .end
  ret 0.0
.end

# ---------------------------------
# Fast inverse sqrt / rsqrt
# ---------------------------------
# Version f32 (classique), plus raffinement Newton.
# On manipule le bit pattern via i32.
# Note : dépend de reinterpret_cast primitives ; si ton runtime n’en a pas,
# remplace par FFI ou supprime.
#
# Ici on fournit une abstraction "bitcast" à adapter :
fn bitcast_f32_to_i32(x: f32) -> i32
  # TODO: à implémenter via runtime intrinsic
  panic("bitcast_f32_to_i32 not implemented")
.end

fn bitcast_i32_to_f32(x: i32) -> f32
  panic("bitcast_i32_to_f32 not implemented")
.end

fn fast_rsqrt_f32(x: f32) -> f32
  # Quake III
  let xhalf : f32 = x * 0.5
  let mut i : i32 = bitcast_f32_to_i32(x)
  i = 0x5f3759df - (i >> 1)
  let mut y : f32 = bitcast_i32_to_f32(i)
  # 1st Newton iteration
  y = y * (1.5 - xhalf * y * y)
  ret y
.end

fn fast_rsqrt_f32_refine(x: f32, iters: i32) -> f32
  let mut y = fast_rsqrt_f32(x)
  let mut k = 0
  while k < iters
    # y = y*(1.5 - 0.5*x*y*y)
    y = y * (1.5 - (0.5 * x) * y * y)
    k = k + 1
  .end
  ret y
.end

fn fast_sqrt_f32(x: f32) -> f32
  if x <= 0.0 ret 0.0 .end
  ret x * fast_rsqrt_f32_refine(x, 1)
.end

# ---------------------------------
# exp / log approximations
# ---------------------------------
# exp(x) :
#   x = k*ln2 + r, k = round(x/ln2), r in [-ln2/2, ln2/2]
#   exp(x) = 2^k * exp(r)
# exp(r) approx poly (order 5)
#
# log(x) :
#   range reduction via frexp : x = m*2^e, m in [0.5, 1)
#   log(x) = log(m) + e*ln2
#   log(m) approx via log1p around 1 : m = 1+t, t in [-0.5,0)
#   log(1+t) ~ t - t^2/2 + t^3/3 - t^4/4 + t^5/5

fn fast_exp(x: f64) -> f64
  # clamp input for stability (avoid overflow)
  let xc = clamp_f64(x, -700.0, 700.0)
  let kf = floor_f64(xc * INV_LN2 + 0.5)
  let k = kf as i32
  let r = xc - (k as f64) * LN2

  let er = exp_poly5(r)
  ret ldexp_f64(er, k)
.end

fn exp_poly5(r: f64) -> f64
  # 1 + r + r^2/2 + r^3/6 + r^4/24 + r^5/120
  let r2 = r * r
  let r3 = r2 * r
  let r4 = r2 * r2
  let r5 = r4 * r
  ret 1.0 + r + 0.5 * r2 + (1.0/6.0) * r3 + (1.0/24.0) * r4 + (1.0/120.0) * r5
.end

fn fast_log(x: f64) -> f64
  if x <= 0.0
    # convention : -inf => grand négatif
    ret -1e300
  .end

  let fr = frexp_f64(x)
  let m = fr.mantissa
  let e = fr.exponent

  # m in [0.5,1). Transform to 1+t in [0.5,1) => t in [-0.5,0)
  let t = m - 1.0
  let lm = log1p_poly5(t)
  ret lm + (e as f64) * LN2
.end

fn log1p_poly5(t: f64) -> f64
  # t - t^2/2 + t^3/3 - t^4/4 + t^5/5
  let t2 = t * t
  let t3 = t2 * t
  let t4 = t2 * t2
  let t5 = t4 * t
  ret t - 0.5*t2 + (1.0/3.0)*t3 - 0.25*t4 + 0.2*t5
.end

# --- floor/ldexp/frexp primitives à adapter selon runtime ---
# Versions fallback simples (moins perf). Idéalement remplacer par intrinsics.

fn floor_f64(x: f64) -> f64
  let i = x as i64
  let fi = i as f64
  if fi > x
    ret (i - 1) as f64
  .end
  ret fi
.end

fn ldexp_f64(x: f64, exp2: i32) -> f64
  # x * 2^exp2 via boucle (fallback)
  let mut v = x
  if exp2 > 0
    let mut k = 0
    while k < exp2
      v = v * 2.0
      k = k + 1
    .end
    ret v
  .end

  if exp2 < 0
    let mut k = 0
    let n = -exp2
    while k < n
      v = v * 0.5
      k = k + 1
    .end
    ret v
  .end

  ret v
.end

struct Frexp
  mantissa : f64
  exponent : i32
.end

fn frexp_f64(x: f64) -> Frexp
  # Fallback : normalise en [0.5,1) en multipliant/divisant par 2.
  # Coûteux mais portable.
  let mut v = x
  let mut e = 0

  while v >= 1.0
    v = v * 0.5
    e = e + 1
  .end
  while v < 0.5
    v = v * 2.0
    e = e - 1
  .end

  ret Frexp { mantissa: v, exponent: e }
.end

# ---------------------------------
# pow (int) et pow (float)
# ---------------------------------

fn powi_f64(mut base: f64, mut exp: i64) -> f64
  if exp == 0 ret 1.0 .end
  if exp < 0
    base = 1.0 / base
    exp = -exp
  .end

  let mut acc = 1.0
  let mut e = exp

  while e > 0
    if (e & 1) == 1
      acc = acc * base
    .end
    base = base * base
    e = e >> 1
  .end

  ret acc
.end

fn pow_f64(a: f64, b: f64) -> f64
  # pow(a,b) = exp(b*log(a))
  if a <= 0.0
    ret 0.0
  .end
  ret fast_exp(b * fast_log(a))
.end

# ---------------------------------
# Integration numérique
# ---------------------------------

type Fn1 = fn(x: f64) -> f64

fn integrate_trapz(f: Fn1, a: f64, b: f64, n: i32) -> f64
  let nn = max_i32(n, 1)
  let h = (b - a) / (nn as f64)
  let mut sum = 0.5 * (f(a) + f(b))
  let mut i = 1
  while i < nn
    sum = sum + f(a + (i as f64) * h)
    i = i + 1
  .end
  ret sum * h
.end

fn integrate_simpson(f: Fn1, a: f64, b: f64, n: i32) -> f64
  # n pair
  let mut nn = max_i32(n, 2)
  if (nn & 1) == 1
    nn = nn + 1
  .end

  let h = (b - a) / (nn as f64)
  let mut sum = f(a) + f(b)

  let mut i = 1
  while i < nn
    let x = a + (i as f64) * h
    if (i & 1) == 1
      sum = sum + 4.0 * f(x)
    .end
    if (i & 1) == 0
      sum = sum + 2.0 * f(x)
    .end
    i = i + 1
  .end

  ret sum * (h / 3.0)
.end

# ---------------------------------
# Hash / PRNG léger (xorshift32)
# ---------------------------------

struct XorShift32
  state : u32
.end

fn xorshift32_new(seed: u32) -> XorShift32
  let s = if seed == 0 then 0x6d2b79f5 else seed .end
  ret XorShift32 { state: s }
.end

fn xorshift32_next(rng: &mut XorShift32) -> u32
  let mut x = rng.state
  x = x ^ (x << 13)
  x = x ^ (x >> 17)
  x = x ^ (x << 5)
  rng.state = x
  ret x
.end

fn u32_to_unit_f64(x: u32) -> f64
  # [0,1)
  ret (x as f64) / 4294967296.0
.end

fn xorshift32_next_f64(rng: &mut XorShift32) -> f64
  ret u32_to_unit_f64(xorshift32_next(rng))
.end

fn hash_u64(mut x: u64) -> u64
  # SplitMix64-style mixer
  x = x + 0x9e3779b97f4a7c15
  let mut z = x
  z = (z ^ (z >> 30)) * 0xbf58476d1ce4e5b9
  z = (z ^ (z >> 27)) * 0x94d049bb133111eb
  ret z ^ (z >> 31)
.end

# ---------------------------------
# Tests
# ---------------------------------

fn approx_eq(a: f64, b: f64, eps: f64) -> bool
  ret abs_f64(a - b) <= eps
.end

fn test_angles()
  let a = wrap_angle_pi(PI + 0.25)
  if !approx_eq(a, -PI + 0.25, 1e-12)
    panic("wrap_angle_pi failed")
  .end

  let b = wrap_angle_0_tau(-0.5)
  if b < 0.0 || b >= TAU
    panic("wrap_angle_0_tau failed")
  .end
.end

fn test_trig_poly()
  let cfg = trig_cfg_default()

  let s0 = sin(0.0, cfg)
  let c0 = cos(0.0, cfg)
  if !approx_eq(s0, 0.0, 1e-12) panic("sin(0) failed") .end
  if !approx_eq(c0, 1.0, 1e-6)  panic("cos(0) failed") .end

  let s1 = sin(HALF_PI, cfg)
  let c1 = cos(HALF_PI, cfg)
  if !approx_eq(s1, 1.0, 2e-3) panic("sin(pi/2) failed") .end
  if abs_f64(c1) > 2e-3         panic("cos(pi/2) failed") .end
.end

fn test_atan2()
  let a = fast_atan2(1.0, 0.0)
  if !approx_eq(a, HALF_PI, 2e-3)
    panic("atan2(1,0) failed")
  .end
.end

fn test_exp_log()
  let x = 1.234
  let e = fast_exp(x)
  let l = fast_log(e)
  if !approx_eq(l, x, 5e-3)
    panic("exp/log roundtrip failed")
  .end
.end

fn test_powi()
  let v = powi_f64(2.0, 10)
  if !approx_eq(v, 1024.0, 1e-12) panic("powi failed") .end
.end

fn test_rng()
  let mut rng = xorshift32_new(123)
  let a = xorshift32_next(&mut rng)
  let b = xorshift32_next(&mut rng)
  if a == b
    panic("rng suspicious")
  .end
.end

fn run_all_tests()
  test_angles()
  test_trig_poly()
  test_atan2()
  test_exp_log()
  test_powi()
  test_rng()
.end

.end
