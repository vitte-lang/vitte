# core/basic.vitte
# -----------------------------------------------------------------------------
# Vitte Core Prelude — primitives et utilitaires "universels"
# Objectif: fournir un socle stable pour tout le reste de la stdlib.
#
# Conventions:
# - Pas d'accolades { }, uniquement des blocs en .end
# - API simple et prévisible, sans dépendances circulaires
# - Les "tests" ici sont des smoke tests (exécutables via runner interne si dispo)
# -----------------------------------------------------------------------------

mod core.basic

# -----------------------------------------------------------------------------
# Types scalaires (aliases) — si ton compilateur les a déjà en builtins,
# garde ces alias pour standardiser l'API.
# -----------------------------------------------------------------------------

type I8  = i8
type I16 = i16
type I32 = i32
type I64 = i64
type Isz = isize

type U8  = u8
type U16 = u16
type U32 = u32
type U64 = u64
type Usz = usize

type F32 = f32
type F64 = f64

type Bool = bool
type Char = char

# String/Bytes peuvent être des builtins (string, bytes) ou des types std.
# Ici on suppose des builtins.
type Str   = string
type Bytes = bytes

# -----------------------------------------------------------------------------
# Constantes de base
# -----------------------------------------------------------------------------

const TRUE: Bool  = true
const FALSE: Bool = false

const U8_MAX:  U8  = 255
const U16_MAX: U16 = 65535
const U32_MAX: U32 = 4294967295
const U64_MAX: U64 = 18446744073709551615

const I8_MIN:  I8  = -128
const I8_MAX:  I8  = 127
const I16_MIN: I16 = -32768
const I16_MAX: I16 = 32767
const I32_MIN: I32 = -2147483648
const I32_MAX: I32 = 2147483647
const I64_MIN: I64 = -9223372036854775808
const I64_MAX: I64 = 9223372036854775807

const F32_EPS: F32 = 0.00000011920928955078125
const F64_EPS: F64 = 0.0000000000000002220446049250313

# -----------------------------------------------------------------------------
# Panic / Abort / Unreachable
# -----------------------------------------------------------------------------
# Ces fonctions supposent que le runtime fournit au minimum un mécanisme
# de terminaison + message.
# - Si ton runtime n'a pas encore ça, mappe-les ensuite vers "rt.panic"
#   ou "vm.trap".

fn panic(msg: Str) -> never
  # Hook runtime: remplace l'impl ensuite
  # Exemple: rt_panic(msg)
  _intrinsic_panic(msg)
.end

fn abort() -> never
  _intrinsic_abort()
.end

fn unreachable() -> never
  _intrinsic_unreachable()
.end

# -----------------------------------------------------------------------------
# Debug / Trace minimal (no-op si non supporté)
# -----------------------------------------------------------------------------

fn dbg_str(label: Str, value: Str) -> void
  _intrinsic_dbg_str(label, value)
.end

fn dbg_i64(label: Str, value: I64) -> void
  _intrinsic_dbg_i64(label, value)
.end

fn dbg_u64(label: Str, value: U64) -> void
  _intrinsic_dbg_u64(label, value)
.end

# -----------------------------------------------------------------------------
# Error de base
# -----------------------------------------------------------------------------

type ErrorCode = U32

const E_OK: ErrorCode              = 0
const E_UNKNOWN: ErrorCode         = 1
const E_INVALID_ARG: ErrorCode     = 2
const E_OUT_OF_RANGE: ErrorCode    = 3
const E_OVERFLOW: ErrorCode        = 4
const E_UNDERFLOW: ErrorCode       = 5
const E_NOT_FOUND: ErrorCode       = 6
const E_UNSUPPORTED: ErrorCode     = 7
const E_IO: ErrorCode              = 8
const E_FORMAT: ErrorCode          = 9
const E_PERMISSION: ErrorCode      = 10
const E_TIMEOUT: ErrorCode         = 11
const E_INTERRUPTED: ErrorCode     = 12
const E_NOMEM: ErrorCode           = 13
const E_STATE: ErrorCode           = 14

struct Error
  code: ErrorCode
  message: Str
.end

fn error_new(code: ErrorCode, message: Str) -> Error
  ret Error(code: code, message: message)
.end

fn error_ok() -> Error
  ret Error(code: E_OK, message: "")
.end

fn error_is_ok(e: Error) -> Bool
  ret e.code == E_OK
.end

# -----------------------------------------------------------------------------
# Option[T]
# -----------------------------------------------------------------------------

enum Option[T]
  None
  Some(value: T)
.end

fn option_none[T]() -> Option[T]
  ret Option.None
.end

fn option_some[T](value: T) -> Option[T]
  ret Option.Some(value: value)
.end

fn option_is_some[T](o: Option[T]) -> Bool
  match o
    Option.Some(value: _) => ret true
    Option.None => ret false
  .end
.end

fn option_is_none[T](o: Option[T]) -> Bool
  ret !option_is_some[T](o)
.end

fn option_unwrap[T](o: Option[T]) -> T
  match o
    Option.Some(value: v) => ret v
    Option.None => panic("Option.unwrap(): None")
  .end
.end

fn option_unwrap_or[T](o: Option[T], fallback: T) -> T
  match o
    Option.Some(value: v) => ret v
    Option.None => ret fallback
  .end
.end

fn option_unwrap_or_else[T](o: Option[T], f: fn() -> T) -> T
  match o
    Option.Some(value: v) => ret v
    Option.None => ret f()
  .end
.end

fn option_map[T, U](o: Option[T], f: fn(T) -> U) -> Option[U]
  match o
    Option.Some(value: v) => ret Option.Some(value: f(v))
    Option.None => ret Option.None
  .end
.end

fn option_map_or[T, U](o: Option[T], fallback: U, f: fn(T) -> U) -> U
  match o
    Option.Some(value: v) => ret f(v)
    Option.None => ret fallback
  .end
.end

fn option_and_then[T, U](o: Option[T], f: fn(T) -> Option[U]) -> Option[U]
  match o
    Option.Some(value: v) => ret f(v)
    Option.None => ret Option.None
  .end
.end

fn option_expect[T](o: Option[T], msg: Str) -> T
  match o
    Option.Some(value: v) => ret v
    Option.None => panic(msg)
  .end
.end

# -----------------------------------------------------------------------------
# Result[T, E]
# -----------------------------------------------------------------------------

enum Result[T, E]
  Ok(value: T)
  Err(error: E)
.end

fn ok[T, E](value: T) -> Result[T, E]
  ret Result.Ok(value: value)
.end

fn err[T, E](error: E) -> Result[T, E]
  ret Result.Err(error: error)
.end

fn result_is_ok[T, E](r: Result[T, E]) -> Bool
  match r
    Result.Ok(value: _) => ret true
    Result.Err(error: _) => ret false
  .end
.end

fn result_is_err[T, E](r: Result[T, E]) -> Bool
  ret !result_is_ok[T, E](r)
.end

fn result_unwrap[T, E](r: Result[T, E]) -> T
  match r
    Result.Ok(value: v) => ret v
    Result.Err(error: _) => panic("Result.unwrap(): Err")
  .end
.end

fn result_expect[T, E](r: Result[T, E], msg: Str) -> T
  match r
    Result.Ok(value: v) => ret v
    Result.Err(error: _) => panic(msg)
  .end
.end

fn result_unwrap_err[T, E](r: Result[T, E]) -> E
  match r
    Result.Ok(value: _) => panic("Result.unwrap_err(): Ok")
    Result.Err(error: e) => ret e
  .end
.end

fn result_map[T, E, U](r: Result[T, E], f: fn(T) -> U) -> Result[U, E]
  match r
    Result.Ok(value: v) => ret Result.Ok(value: f(v))
    Result.Err(error: e) => ret Result.Err(error: e)
  .end
.end

fn result_map_err[T, E, F](r: Result[T, E], f: fn(E) -> F) -> Result[T, F]
  match r
    Result.Ok(value: v) => ret Result.Ok(value: v)
    Result.Err(error: e) => ret Result.Err(error: f(e))
  .end
.end

fn result_and_then[T, E, U](r: Result[T, E], f: fn(T) -> Result[U, E]) -> Result[U, E]
  match r
    Result.Ok(value: v) => ret f(v)
    Result.Err(error: e) => ret Result.Err(error: e)
  .end
.end

fn result_or_else[T, E](r: Result[T, E], f: fn(E) -> Result[T, E]) -> Result[T, E]
  match r
    Result.Ok(value: v) => ret Result.Ok(value: v)
    Result.Err(error: e) => ret f(e)
  .end
.end

# -----------------------------------------------------------------------------
# Assertions & checks — versions "panic" + versions "Result"
# -----------------------------------------------------------------------------

fn assert(cond: Bool, msg: Str) -> void
  if !cond
    panic(msg)
  .end
.end

fn assert_eq_i64(a: I64, b: I64, msg: Str) -> void
  if a != b
    panic(msg)
  .end
.end

fn assert_eq_u64(a: U64, b: U64, msg: Str) -> void
  if a != b
    panic(msg)
  .end
.end

fn assert_ne_i64(a: I64, b: I64, msg: Str) -> void
  if a == b
    panic(msg)
  .end
.end

fn check(cond: Bool, code: ErrorCode, msg: Str) -> Result[void, Error]
  if cond
    ret Result.Ok(value: ())
  .end
  ret Result.Err(error: Error(code: code, message: msg))
.end

fn ensure(cond: Bool, err: Error) -> Result[void, Error]
  if cond
    ret Result.Ok(value: ())
  .end
  ret Result.Err(error: err)
.end

# -----------------------------------------------------------------------------
# Comparaison & min/max/clamp
# -----------------------------------------------------------------------------

fn min_i64(a: I64, b: I64) -> I64
  if a < b
    ret a
  .end
  ret b
.end

fn max_i64(a: I64, b: I64) -> I64
  if a > b
    ret a
  .end
  ret b
.end

fn clamp_i64(x: I64, lo: I64, hi: I64) -> I64
  if lo > hi
    panic("clamp_i64: lo > hi")
  .end
  if x < lo
    ret lo
  .end
  if x > hi
    ret hi
  .end
  ret x
.end

fn min_u64(a: U64, b: U64) -> U64
  if a < b
    ret a
  .end
  ret b
.end

fn max_u64(a: U64, b: U64) -> U64
  if a > b
    ret a
  .end
  ret b
.end

fn clamp_u64(x: U64, lo: U64, hi: U64) -> U64
  if lo > hi
    panic("clamp_u64: lo > hi")
  .end
  if x < lo
    ret lo
  .end
  if x > hi
    ret hi
  .end
  ret x
.end

fn abs_i64(x: I64) -> I64
  if x >= 0
    ret x
  .end
  # Attention à I64_MIN; on panique pour rester safe.
  if x == I64_MIN
    panic("abs_i64 overflow on I64_MIN")
  .end
  ret -x
.end

fn sign_i64(x: I64) -> I32
  if x > 0
    ret 1
  .end
  if x < 0
    ret -1
  .end
  ret 0
.end

# -----------------------------------------------------------------------------
# Conversions safe (checked)
# -----------------------------------------------------------------------------

fn u64_to_u32_checked(x: U64) -> Result[U32, Error]
  if x <= U32_MAX as U64
    ret Result.Ok(value: x as U32)
  .end
  ret Result.Err(error: Error(code: E_OVERFLOW, message: "u64_to_u32_checked overflow"))
.end

fn i64_to_i32_checked(x: I64) -> Result[I32, Error]
  if x >= I32_MIN as I64 && x <= I32_MAX as I64
    ret Result.Ok(value: x as I32)
  .end
  ret Result.Err(error: Error(code: E_OVERFLOW, message: "i64_to_i32_checked overflow"))
.end

fn i64_to_u64_checked(x: I64) -> Result[U64, Error]
  if x < 0
    ret Result.Err(error: Error(code: E_INVALID_ARG, message: "i64_to_u64_checked negative"))
  .end
  ret Result.Ok(value: x as U64)
.end

# -----------------------------------------------------------------------------
# Bits — helpers
# -----------------------------------------------------------------------------

fn is_power_of_two_u64(x: U64) -> Bool
  if x == 0
    ret false
  .end
  ret (x & (x - 1)) == 0
.end

fn align_up_u64(x: U64, align: U64) -> Result[U64, Error]
  if align == 0
    ret Result.Err(error: Error(code: E_INVALID_ARG, message: "align_up_u64 align=0"))
  .end
  if !is_power_of_two_u64(align)
    ret Result.Err(error: Error(code: E_INVALID_ARG, message: "align_up_u64 align not power-of-two"))
  .end

  let mask: U64 = align - 1
  let y: U64 = (x + mask) & ~mask
  if y < x
    ret Result.Err(error: Error(code: E_OVERFLOW, message: "align_up_u64 overflow"))
  .end
  ret Result.Ok(value: y)
.end

fn align_down_u64(x: U64, align: U64) -> Result[U64, Error]
  if align == 0
    ret Result.Err(error: Error(code: E_INVALID_ARG, message: "align_down_u64 align=0"))
  .end
  if !is_power_of_two_u64(align)
    ret Result.Err(error: Error(code: E_INVALID_ARG, message: "align_down_u64 align not power-of-two"))
  .end
  let mask: U64 = align - 1
  ret Result.Ok(value: x & ~mask)
.end

# -----------------------------------------------------------------------------
# String helpers minimal (si string builtin a déjà tout, garde wrappers)
# -----------------------------------------------------------------------------

fn str_is_empty(s: Str) -> Bool
  ret _intrinsic_str_len(s) == 0
.end

fn str_len(s: Str) -> Usz
  ret _intrinsic_str_len(s)
.end

fn str_eq(a: Str, b: Str) -> Bool
  ret _intrinsic_str_eq(a, b)
.end

# -----------------------------------------------------------------------------
# Hash basique (FNV-1a 64) — utile partout (maps, caches, ids)
# -----------------------------------------------------------------------------

const FNV1A64_OFFSET: U64 = 14695981039346656037
const FNV1A64_PRIME:  U64 = 1099511628211

fn hash_bytes_fnv1a64(data: Bytes) -> U64
  let h: U64 = FNV1A64_OFFSET
  let n: Usz = _intrinsic_bytes_len(data)
  let i: Usz = 0
  loop
    if i >= n
      break
    .end
    let b: U8 = _intrinsic_bytes_get(data, i)
    h = h ^ (b as U64)
    h = h * FNV1A64_PRIME
    i = i + 1
  .end
  ret h
.end

fn hash_str_fnv1a64(s: Str) -> U64
  let bytes: Bytes = _intrinsic_str_as_bytes(s)
  ret hash_bytes_fnv1a64(bytes)
.end

# -----------------------------------------------------------------------------
# Random utilitaires “de base”
# -----------------------------------------------------------------------------

fn swap_i64(a: &mut I64, b: &mut I64) -> void
  let t: I64 = *a
  *a = *b
  *b = t
.end

fn swap_u64(a: &mut U64, b: &mut U64) -> void
  let t: U64 = *a
  *a = *b
  *b = t
.end

fn mem_eq(a: Bytes, b: Bytes) -> Bool
  let na: Usz = _intrinsic_bytes_len(a)
  let nb: Usz = _intrinsic_bytes_len(b)
  if na != nb
    ret false
  .end
  let i: Usz = 0
  loop
    if i >= na
      break
    .end
    if _intrinsic_bytes_get(a, i) != _intrinsic_bytes_get(b, i)
      ret false
    .end
    i = i + 1
  .end
  ret true
.end

# -----------------------------------------------------------------------------
# Smoke tests
# -----------------------------------------------------------------------------

fn _t_option_basic() -> void
  let a: Option
  assert(option_is_some[I64](a), "Option should be Some")
  assert_eq_i64(option_unwrap[I64](a), 42, "unwrap should return 42")

  let b: Option[I64] = option_none[I64]()
  assert(option_is_none[I64](b), "Option should be None")
  assert_eq_i64(option_unwrap_or[I64](b, 7), 7, "unwrap_or fallback")
.end

fn _t_result_basic() -> void
  let r1: Result
  assert(result_is_ok[I64, Error](r1), "Result should be Ok")
  assert_eq_i64(result_unwrap[I64, Error](r1), 10, "unwrap ok")

  let e: Error = error_new(E_INVALID_ARG, "bad")
  let r2: Result[I64, Error] = err[I64, Error](e)
  assert(result_is_err[I64, Error](r2), "Result should be Err")
  let e2: Error = result_unwrap_err[I64, Error](r2)
  assert(e2.code == E_INVALID_ARG, "error code")
.end

fn _t_bits_align() -> void
  assert(is_power_of_two_u64(1), "p2 1")
  assert(is_power_of_two_u64(2), "p2 2")
  assert(!is_power_of_two_u64(3), "p2 3")
  assert(!is_power_of_two_u64(0), "p2 0")

  let a1: Result[U64, Error] = align_up_u64(5, 4)
  assert(result_is_ok[U64, Error](a1), "align_up ok")
  assert_eq_u64(result_unwrap[U64, Error](a1), 8, "align_up 5->8")

  let a2: Result[U64, Error] = align_down_u64(9, 4)
  assert(result_is_ok[U64, Error](a2), "align_down ok")
  assert_eq_u64(result_unwrap[U64, Error](a2), 8, "align_down 9->8")
.end

fn _t_hash() -> void
  let h1: U64 = hash_str_fnv1a64("abc")
  let h2: U64 = hash_str_fnv1a64("abc")
  let h3: U64 = hash_str_fnv1a64("abcd")
  assert(h1 == h2, "hash stable")
  assert(h1 != h3, "hash differs")
.end

fn basic_smoke_tests() -> void
  _t_option_basic()
  _t_result_basic()
  _t_bits_align()
  _t_hash()
.end

# -----------------------------------------------------------------------------
# Intrinsics placeholders (à binder au runtime/VM)
# -----------------------------------------------------------------------------
# Tu peux:
# - soit les laisser "intrinsic" côté compilateur,
# - soit les router vers runtime (rt_*) dans un module core/rt.
#
# Signatures minimales attendues:
# - _intrinsic_panic(str) -> never
# - _intrinsic_abort() -> never
# - _intrinsic_unreachable() -> never
# - _intrinsic_dbg_* (optionnel)
# - _intrinsic_str_len, _intrinsic_str_eq, _intrinsic_str_as_bytes
# - _intrinsic_bytes_len, _intrinsic_bytes_get
#
# NOTE: "never" et "()" doivent exister dans ton noyau de types.

fn _intrinsic_panic(msg: Str) -> never
  # TODO runtime binding
  loop
  .end
.end

fn _intrinsic_abort() -> never
  loop
  .end
.end

fn _intrinsic_unreachable() -> never
  loop
  .end
.end

fn _intrinsic_dbg_str(label: Str, value: Str) -> void
  # no-op par défaut
  let _ = label
  let _ = value
.end

fn _intrinsic_dbg_i64(label: Str, value: I64) -> void
  let _ = label
  let _ = value
.end

fn _intrinsic_dbg_u64(label: Str, value: U64) -> void
  let _ = label
  let _ = value
.end

fn _intrinsic_str_len(s: Str) -> Usz
  # TODO runtime binding
  let _ = s
  ret 0
.end

fn _intrinsic_str_eq(a: Str, b: Str) -> Bool
  let _ = a
  let _ = b
  ret false
.end

fn _intrinsic_str_as_bytes(s: Str) -> Bytes
  let _ = s
  # TODO: renvoyer une vue bytes (UTF-8) ou copie.
  ret _intrinsic_bytes_empty()
.end

fn _intrinsic_bytes_len(b: Bytes) -> Usz
  let _ = b
  ret 0
.end

fn _intrinsic_bytes_get(b: Bytes, i: Usz) -> U8
  let _ = b
  let _ = i
  ret 0
.end

fn _intrinsic_bytes_empty() -> Bytes
  # TODO runtime binding
  ret "" as Bytes
.end
