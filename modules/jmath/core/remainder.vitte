# remainder.vitte
# -----------------------------------------------------------------------------
# Remainder — module ultra complet
# - remainder "trunc" (style % C/Rust)
# - rem_euclid / div_euclid (reste >= 0)
# - floating: fmod / ieee remainder (round-to-nearest ties-to-even)
# - modular arithmetic: add/sub/mul/pow (safe) + normalize
# - helpers: wrap_index, periodic ranges, gcd/lcm (utile avec division euclidienne)
#
# Dépendances: core/basic.vitte
# Contrainte: pas d'accolades, blocs en .end
# -----------------------------------------------------------------------------

mod core.remainder

use core.basic

# -----------------------------------------------------------------------------
# Integer: truncating division/remainder
# -----------------------------------------------------------------------------

fn div_i64(a: I64, m: I64) -> Result[I64, Error]
  if m == 0
    ret Result.Err(error: Error(code: E_INVALID_ARG, message: "div_i64: divide by zero"))
  .end
  if a == I64_MIN && m == -1
    ret Result.Err(error: Error(code: E_OVERFLOW, message: "div_i64: overflow I64_MIN / -1"))
  .end
  ret Result.Ok(value: a / m)
.end

fn rem_i64(a: I64, m: I64) -> Result[I64, Error]
  if m == 0
    ret Result.Err(error: Error(code: E_INVALID_ARG, message: "rem_i64: modulo by zero"))
  .end
  # I64_MIN % -1 = 0
  if a == I64_MIN && m == -1
    ret Result.Ok(value: 0)
  .end
  ret Result.Ok(value: a % m)
.end

fn div_u64(a: U64, m: U64) -> Result[U64, Error]
  if m == 0
    ret Result.Err(error: Error(code: E_INVALID_ARG, message: "div_u64: divide by zero"))
  .end
  ret Result.Ok(value: a / m)
.end

fn rem_u64(a: U64, m: U64) -> Result[U64, Error]
  if m == 0
    ret Result.Err(error: Error(code: E_INVALID_ARG, message: "rem_u64: modulo by zero"))
  .end
  ret Result.Ok(value: a % m)
.end

# -----------------------------------------------------------------------------
# Euclidean division (integers)
# -----------------------------------------------------------------------------
# rem_euclid: résultat dans [0, |m|) ; m != 0
# div_euclid: a = q*m + r avec r = rem_euclid

fn rem_euclid_i64(a: I64, m: I64) -> Result[I64, Error]
  if m == 0
    ret Result.Err(error: Error(code: E_INVALID_ARG, message: "rem_euclid_i64: modulo by zero"))
  .end

  # |m| overflow si m==I64_MIN
  if m == I64_MIN
    if a == I64_MIN
      ret Result.Ok(value: 0)
    .end
    if a >= 0
      ret Result.Ok(value: a)
    .end
    ret Result.Ok(value: a + (1 as I64 << 63))
  .end

  let mm: I64 = m
  if mm < 0
    mm = -mm
  .end

  let rr: Result[I64, Error] = rem_i64(a, mm)
  if result_is_err[I64, Error](rr)
    ret Result.Err(error: result_unwrap_err[I64, Error](rr))
  .end
  let r: I64 = result_unwrap[I64, Error](rr)
  if r >= 0
    ret Result.Ok(value: r)
  .end
  ret Result.Ok(value: r + mm)
.end

fn div_euclid_i64(a: I64, m: I64) -> Result[I64, Error]
  if m == 0
    ret Result.Err(error: Error(code: E_INVALID_ARG, message: "div_euclid_i64: divide by zero"))
  .end

  if m == I64_MIN
    # m = -2^63
    if a == I64_MIN
      ret Result.Ok(value: 1)
    .end
    if a >= 0
      ret Result.Ok(value: 0)
    .end
    ret Result.Ok(value: 1)
  .end

  let mm: I64 = m
  if mm < 0
    mm = -mm
  .end

  let q0r: Result[I64, Error] = div_i64(a, mm)
  if result_is_err[I64, Error](q0r)
    ret Result.Err(error: result_unwrap_err[I64, Error](q0r))
  .end
  let q0: I64 = result_unwrap[I64, Error](q0r)

  let r0r: Result[I64, Error] = rem_i64(a, mm)
  if result_is_err[I64, Error](r0r)
    ret Result.Err(error: result_unwrap_err[I64, Error](r0r))
  .end
  let r0: I64 = result_unwrap[I64, Error](r0r)

  let q: I64 = q0
  if r0 < 0
    q = q0 - 1
  .end

  if m < 0
    ret Result.Ok(value: -q)
  .end
  ret Result.Ok(value: q)
.end

fn rem_euclid_u64(a: U64, m: U64) -> Result[U64, Error]
  # déjà euclidien
  ret rem_u64(a, m)
.end

fn div_euclid_u64(a: U64, m: U64) -> Result[U64, Error]
  ret div_u64(a, m)
.end

# -----------------------------------------------------------------------------
# Normalize into range [0, m) or [lo, hi)
# -----------------------------------------------------------------------------

fn normalize_mod_i64(a: I64, m: I64) -> Result[I64, Error]
  ret rem_euclid_i64(a, m)
.end

fn normalize_mod_u64(a: U64, m: U64) -> Result[U64, Error]
  ret rem_u64(a, m)
.end

fn wrap_range_i64(x: I64, lo: I64, hi: I64) -> Result[I64, Error]
  # wrap into [lo, hi) (hi exclusive)
  if hi <= lo
    ret Result.Err(error: Error(code: E_INVALID_ARG, message: "wrap_range_i64: hi <= lo"))
  .end
  let w: I64 = hi - lo
  let rr: Result[I64, Error] = rem_euclid_i64(x - lo, w)
  if result_is_err[I64, Error](rr)
    ret Result.Err(error: result_unwrap_err[I64, Error](rr))
  .end
  ret Result.Ok(value: lo + result_unwrap[I64, Error](rr))
.end

# -----------------------------------------------------------------------------
# Floating remainder
# -----------------------------------------------------------------------------
# fmod: a - trunc(a/m)*m
# ieee remainder: a - round_ties_even(a/m)*m

fn fmod_f32(a: F32, m: F32) -> Result[F32, Error]
  if m == 0.0
    ret Result.Err(error: Error(code: E_INVALID_ARG, message: "fmod_f32: modulo by zero"))
  .end
  if _intrinsic_f32_is_nan(a) || _intrinsic_f32_is_nan(m)
    ret Result.Ok(value: a + m)
  .end
  ret Result.Ok(value: _intrinsic_fmod_f32(a, m))
.end

fn fmod_f64(a: F64, m: F64) -> Result[F64, Error]
  if m == 0.0
    ret Result.Err(error: Error(code: E_INVALID_ARG, message: "fmod_f64: modulo by zero"))
  .end
  if _intrinsic_f64_is_nan(a) || _intrinsic_f64_is_nan(m)
    ret Result.Ok(value: a + m)
  .end
  ret Result.Ok(value: _intrinsic_fmod_f64(a, m))
.end

fn ieee_remainder_f32(a: F32, m: F32) -> Result[F32, Error]
  if m == 0.0
    ret Result.Err(error: Error(code: E_INVALID_ARG, message: "ieee_remainder_f32: modulo by zero"))
  .end
  ret Result.Ok(value: _intrinsic_remainder_f32(a, m))
.end

fn ieee_remainder_f64(a: F64, m: F64) -> Result[F64, Error]
  if m == 0.0
    ret Result.Err(error: Error(code: E_INVALID_ARG, message: "ieee_remainder_f64: modulo by zero"))
  .end
  ret Result.Ok(value: _intrinsic_remainder_f64(a, m))
.end

fn rem_euclid_f64(a: F64, m: F64) -> Result[F64, Error]
  if m == 0.0
    ret Result.Err(error: Error(code: E_INVALID_ARG, message: "rem_euclid_f64: modulo by zero"))
  .end
  let mm: F64 = if m < 0.0 then -m else m
  let rr: Result[F64, Error] = fmod_f64(a, mm)
  if result_is_err[F64, Error](rr)
    ret Result.Err(error: result_unwrap_err[F64, Error](rr))
  .end
  let r: F64 = result_unwrap[F64, Error](rr)
  if r < 0.0
    ret Result.Ok(value: r + mm)
  .end
  ret Result.Ok(value: r)
.end

# -----------------------------------------------------------------------------
# Modular arithmetic (u64) — safe versions
# -----------------------------------------------------------------------------

fn mod_add_u64(a: U64, b: U64, m: U64) -> Result[U64, Error]
  if m == 0
    ret Result.Err(error: Error(code: E_INVALID_ARG, message: "mod_add_u64: m=0"))
  .end
  let aa: U64 = a % m
  let bb: U64 = b % m
  let s: U64 = aa + bb
  if s < aa
    ret Result.Ok(value: (aa + bb) % m)
  .end
  if s >= m
    ret Result.Ok(value: s - m)
  .end
  ret Result.Ok(value: s)
.end

fn mod_sub_u64(a: U64, b: U64, m: U64) -> Result[U64, Error]
  if m == 0
    ret Result.Err(error: Error(code: E_INVALID_ARG, message: "mod_sub_u64: m=0"))
  .end
  let aa: U64 = a % m
  let bb: U64 = b % m
  if aa >= bb
    ret Result.Ok(value: aa - bb)
  .end
  ret Result.Ok(value: (aa + m) - bb)
.end

fn mod_mul_u64(a: U64, b: U64, m: U64) -> Result[U64, Error]
  if m == 0
    ret Result.Err(error: Error(code: E_INVALID_ARG, message: "mod_mul_u64: m=0"))
  .end
  if _intrinsic_has_widen_mul_u64()
    ret Result.Ok(value: _intrinsic_mod_mul_u64(a, b, m))
  .end

  # double-and-add (O(log b))
  let res: U64 = 0
  let x: U64 = (a % m)
  let y: U64 = (b % m)

  let t: U64 = x
  let k: U64 = y
  loop
    if k == 0
      break
    .end
    if (k & 1) == 1
      let rr: Result[U64, Error] = mod_add_u64(res, t, m)
      if result_is_err[U64, Error](rr)
        ret Result.Err(error: result_unwrap_err[U64, Error](rr))
      .end
      res = result_unwrap[U64, Error](rr)
    .end
    k = k >> 1
    if k != 0
      let rr2: Result[U64, Error] = mod_add_u64(t, t, m)
      if result_is_err[U64, Error](rr2)
        ret Result.Err(error: result_unwrap_err[U64, Error](rr2))
      .end
      t = result_unwrap[U64, Error](rr2)
    .end
  .end

  ret Result.Ok(value: res)
.end

fn mod_pow_u64(base: U64, exp: U64, m: U64) -> Result[U64, Error]
  if m == 0
    ret Result.Err(error: Error(code: E_INVALID_ARG, message: "mod_pow_u64: m=0"))
  .end
  if m == 1
    ret Result.Ok(value: 0)
  .end

  let r: U64 = 1 % m
  let b: U64 = base % m
  let e: U64 = exp

  loop
    if e == 0
      break
    .end
    if (e & 1) == 1
      let rr: Result[U64, Error] = mod_mul_u64(r, b, m)
      if result_is_err[U64, Error](rr)
        ret Result.Err(error: result_unwrap_err[U64, Error](rr))
      .end
      r = result_unwrap[U64, Error](rr)
    .end
    e = e >> 1
    if e != 0
      let rr2: Result[U64, Error] = mod_mul_u64(b, b, m)
      if result_is_err[U64, Error](rr2)
        ret Result.Err(error: result_unwrap_err[U64, Error](rr2))
      .end
      b = result_unwrap[U64, Error](rr2)
    .end
  .end

  ret Result.Ok(value: r)
.end

# -----------------------------------------------------------------------------
# gcd / lcm (euclid)
# -----------------------------------------------------------------------------

fn gcd_u64(mut a: U64, mut b: U64) -> U64
  loop
    if b == 0
      break
    .end
    let t: U64 = a % b
    a = b
    b = t
  .end
  ret a
.end

fn gcd_i64(a: I64, b: I64) -> I64
  let aa: U64 = (if a < 0 then (-a) else a) as U64
  let bb: U64 = (if b < 0 then (-b) else b) as U64
  ret gcd_u64(aa, bb) as I64
.end

fn lcm_u64(a: U64, b: U64) -> U64
  if a == 0 || b == 0
    ret 0
  .end
  ret (a / gcd_u64(a, b)) * b
.end

# -----------------------------------------------------------------------------
# wrap index
# -----------------------------------------------------------------------------

fn wrap_index_i64(i: I64, len: I64) -> Result[I64, Error]
  if len <= 0
    ret Result.Err(error: Error(code: E_INVALID_ARG, message: "wrap_index_i64: len <= 0"))
  .end
  ret rem_euclid_i64(i, len)
.end

fn wrap_index_usz(i: Isz, len: Usz) -> Result[Usz, Error]
  if len == 0
    ret Result.Err(error: Error(code: E_INVALID_ARG, message: "wrap_index_usz: len == 0"))
  .end
  let rr: Result[I64, Error] = rem_euclid_i64(i as I64, len as I64)
  if result_is_err[I64, Error](rr)
    ret Result.Err(error: result_unwrap_err[I64, Error](rr))
  .end
  ret Result.Ok(value: result_unwrap[I64, Error](rr) as Usz)
.end

# -----------------------------------------------------------------------------
# Smoke tests
# -----------------------------------------------------------------------------

fn _t_euclid() -> void
  let r: Result[I64, Error] = rem_euclid_i64(-1, 5)
  assert(result_is_ok[I64, Error](r), "rem_euclid ok")
  assert_eq_i64(result_unwrap[I64, Error](r), 4, "(-1).rem_euclid(5)=4")

  let q: Result[I64, Error] = div_euclid_i64(-1, 5)
  assert(result_is_ok[I64, Error](q), "div_euclid ok")
  assert_eq_i64(result_unwrap[I64, Error](q), -1, "(-1).div_euclid(5)=-1")
.end

fn _t_modpow() -> void
  let r: Result[U64, Error] = mod_pow_u64(2, 10, 1000)
  assert(result_is_ok[U64, Error](r), "mod_pow ok")
  assert_eq_u64(result_unwrap[U64, Error](r), 24, "2^10 mod 1000 = 24")
.end

fn remainder_smoke_tests() -> void
  _t_euclid()
  _t_modpow()
.end

# -----------------------------------------------------------------------------
# Intrinsics placeholders (à binder runtime/VM)
# -----------------------------------------------------------------------------

fn _intrinsic_f32_is_nan(x: F32) -> Bool
  let _ = x
  ret false
.end

fn _intrinsic_f64_is_nan(x: F64) -> Bool
  let _ = x
  ret false
.end

fn _intrinsic_fmod_f32(a: F32, m: F32) -> F32
  let q: F32 = _intrinsic_trunc_f32(a / m)
  ret a - (q * m)
.end

fn _intrinsic_fmod_f64(a: F64, m: F64) -> F64
  let q: F64 = _intrinsic_trunc_f64(a / m)
  ret a - (q * m)
.end

fn _intrinsic_remainder_f32(a: F32, m: F32) -> F32
  let q: F32 = _intrinsic_round_ties_even_f32(a / m)
  ret a - (q * m)
.end

fn _intrinsic_remainder_f64(a: F64, m: F64) -> F64
  let q: F64 = _intrinsic_round_ties_even_f64(a / m)
  ret a - (q * m)
.end

fn _intrinsic_trunc_f32(x: F32) -> F32
  let _ = x
  ret x
.end

fn _intrinsic_trunc_f64(x: F64) -> F64
  let _ = x
  ret x
.end

fn _intrinsic_round_ties_even_f32(x: F32) -> F32
  let _ = x
  ret x
.end

fn _intrinsic_round_ties_even_f64(x: F64) -> F64
  let _ = x
  ret x
.end

fn _intrinsic_has_widen_mul_u64() -> Bool
  ret false
.end

fn _intrinsic_mod_mul_u64(a: U64, b: U64, m: U64) -> U64
  let _ = a
  let _ = b
  let _ = m
  ret 0
.end
