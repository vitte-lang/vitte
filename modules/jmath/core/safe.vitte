# safe.vitte
# -----------------------------------------------------------------------------
# Safety / checked operations / guards — module ultra complet
# - Checked arithmetic (signed/unsigned) + saturating + wrapping
# - Checked shifts, bit ops, rotate
# - Safe indexing helpers (slice/bytes/str) + bounds checks
# - Safe casts (narrowing) + range checks
# - Safe memory-ish helpers (copy, overlap policy) via intrinsics
# - Guards: require/ensure/assert variants + error builders
#
# Dépendances: core/basic.vitte (Error/Result/Option/assert/unreachable/constants)
# Contrainte: pas d'accolades, blocs en .end
# -----------------------------------------------------------------------------

mod core.safe

use core.basic

# -----------------------------------------------------------------------------
# Guard helpers
# -----------------------------------------------------------------------------

fn require(cond: Bool, code: I32, msg: Str) -> Result[void, Error]
  if cond
    ret Result.Ok(value: ())
  .end
  ret Result.Err(error: Error(code: code, message: msg))
.end

fn ensure(cond: Bool, err: Error) -> Result[void, Error]
  if cond
    ret Result.Ok(value: ())
  .end
  ret Result.Err(error: err)
.end

fn check_nonzero_i64(x: I64, msg: Str) -> Result[I64, Error]
  if x != 0
    ret Result.Ok(value: x)
  .end
  ret Result.Err(error: Error(code: E_INVALID_ARG, message: msg))
.end

fn check_nonzero_u64(x: U64, msg: Str) -> Result[U64, Error]
  if x != 0
    ret Result.Ok(value: x)
  .end
  ret Result.Err(error: Error(code: E_INVALID_ARG, message: msg))
.end

fn check_range_usz(i: Usz, len: Usz, what: Str) -> Result[void, Error]
  if i < len
    ret Result.Ok(value: ())
  .end
  ret Result.Err(error: Error(code: E_OUT_OF_RANGE, message: what))
.end

fn check_range_span_usz(off: Usz, span: Usz, len: Usz, what: Str) -> Result[void, Error]
  # verifies [off, off+span) within len
  if off <= len && span <= (len - off)
    ret Result.Ok(value: ())
  .end
  ret Result.Err(error: Error(code: E_OUT_OF_RANGE, message: what))
.end

# -----------------------------------------------------------------------------
# Checked arithmetic (U64)
# -----------------------------------------------------------------------------

fn add_u64_checked(a: U64, b: U64) -> Result[U64, Error]
  let c: U64 = a + b
  if c < a
    ret Result.Err(error: Error(code: E_OVERFLOW, message: "add_u64_checked overflow"))
  .end
  ret Result.Ok(value: c)
.end

fn sub_u64_checked(a: U64, b: U64) -> Result[U64, Error]
  if b > a
    ret Result.Err(error: Error(code: E_UNDERFLOW, message: "sub_u64_checked underflow"))
  .end
  ret Result.Ok(value: a - b)
.end

fn mul_u64_checked(a: U64, b: U64) -> Result[U64, Error]
  if a == 0 || b == 0
    ret Result.Ok(value: 0)
  .end
  let c: U64 = a * b
  if c / a != b
    ret Result.Err(error: Error(code: E_OVERFLOW, message: "mul_u64_checked overflow"))
  .end
  ret Result.Ok(value: c)
.end

fn div_u64_checked(a: U64, b: U64) -> Result[U64, Error]
  if b == 0
    ret Result.Err(error: Error(code: E_INVALID_ARG, message: "div_u64_checked div by zero"))
  .end
  ret Result.Ok(value: a / b)
.end

fn rem_u64_checked(a: U64, b: U64) -> Result[U64, Error]
  if b == 0
    ret Result.Err(error: Error(code: E_INVALID_ARG, message: "rem_u64_checked modulo by zero"))
  .end
  ret Result.Ok(value: a % b)
.end

# Saturating U64
fn add_u64_saturating(a: U64, b: U64) -> U64
  let c: U64 = a + b
  if c < a
    ret U64_MAX
  .end
  ret c
.end

fn sub_u64_saturating(a: U64, b: U64) -> U64
  if b > a
    ret 0
  .end
  ret a - b
.end

fn mul_u64_saturating(a: U64, b: U64) -> U64
  if a == 0 || b == 0
    ret 0
  .end
  let c: U64 = a * b
  if c / a != b
    ret U64_MAX
  .end
  ret c
.end

# Wrapping U64
fn add_u64_wrapping(a: U64, b: U64) -> U64
  ret a + b
.end

fn sub_u64_wrapping(a: U64, b: U64) -> U64
  ret a - b
.end

fn mul_u64_wrapping(a: U64, b: U64) -> U64
  ret a * b
.end

# -----------------------------------------------------------------------------
# Checked arithmetic (I64) using overflow intrinsics
# -----------------------------------------------------------------------------

fn add_i64_checked(a: I64, b: I64) -> Result[I64, Error]
  let out: I64 = 0
  if _intrinsic_i64_add_overflow(a, b, &mut out)
    ret Result.Err(error: Error(code: E_OVERFLOW, message: "add_i64_checked overflow"))
  .end
  ret Result.Ok(value: out)
.end

fn sub_i64_checked(a: I64, b: I64) -> Result[I64, Error]
  let out: I64 = 0
  if _intrinsic_i64_sub_overflow(a, b, &mut out)
    ret Result.Err(error: Error(code: E_OVERFLOW, message: "sub_i64_checked overflow"))
  .end
  ret Result.Ok(value: out)
.end

fn mul_i64_checked(a: I64, b: I64) -> Result[I64, Error]
  let out: I64 = 0
  if _intrinsic_i64_mul_overflow(a, b, &mut out)
    ret Result.Err(error: Error(code: E_OVERFLOW, message: "mul_i64_checked overflow"))
  .end
  ret Result.Ok(value: out)
.end

fn div_i64_checked(a: I64, b: I64) -> Result[I64, Error]
  if b == 0
    ret Result.Err(error: Error(code: E_INVALID_ARG, message: "div_i64_checked div by zero"))
  .end
  if a == I64_MIN && b == -1
    ret Result.Err(error: Error(code: E_OVERFLOW, message: "div_i64_checked overflow I64_MIN/-1"))
  .end
  ret Result.Ok(value: a / b)
.end

fn rem_i64_checked(a: I64, b: I64) -> Result[I64, Error]
  if b == 0
    ret Result.Err(error: Error(code: E_INVALID_ARG, message: "rem_i64_checked modulo by zero"))
  .end
  if a == I64_MIN && b == -1
    ret Result.Ok(value: 0)
  .end
  ret Result.Ok(value: a % b)
.end

# Saturating I64 (fallback without intrinsics for add/sub/mul would be heavy; do best)
fn add_i64_saturating(a: I64, b: I64) -> I64
  let out: I64 = 0
  if _intrinsic_i64_add_overflow(a, b, &mut out)
    if b >= 0
      ret I64_MAX
    .end
    ret I64_MIN
  .end
  ret out
.end

fn sub_i64_saturating(a: I64, b: I64) -> I64
  let out: I64 = 0
  if _intrinsic_i64_sub_overflow(a, b, &mut out)
    if b < 0
      ret I64_MAX
    .end
    ret I64_MIN
  .end
  ret out
.end

fn mul_i64_saturating(a: I64, b: I64) -> I64
  let out: I64 = 0
  if _intrinsic_i64_mul_overflow(a, b, &mut out)
    # signe du résultat
    let neg: Bool = (a < 0) != (b < 0)
    if neg
      ret I64_MIN
    .end
    ret I64_MAX
  .end
  ret out
.end

# Wrapping I64
fn add_i64_wrapping(a: I64, b: I64) -> I64
  ret a + b
.end

fn sub_i64_wrapping(a: I64, b: I64) -> I64
  ret a - b
.end

fn mul_i64_wrapping(a: I64, b: I64) -> I64
  ret a * b
.end

# -----------------------------------------------------------------------------
# Checked shifts / rotate
# -----------------------------------------------------------------------------

fn shl_u64_checked(x: U64, sh: U32) -> Result[U64, Error]
  if sh >= 64
    ret Result.Err(error: Error(code: E_INVALID_ARG, message: "shl_u64_checked: shift>=64"))
  .end
  ret Result.Ok(value: x << sh)
.end

fn shr_u64_checked(x: U64, sh: U32) -> Result[U64, Error]
  if sh >= 64
    ret Result.Err(error: Error(code: E_INVALID_ARG, message: "shr_u64_checked: shift>=64"))
  .end
  ret Result.Ok(value: x >> sh)
.end

fn rotl_u64(x: U64, sh: U32) -> U64
  let r: U32 = sh & 63
  if r == 0
    ret x
  .end
  ret (x << r) | (x >> (64 - r))
.end

fn rotr_u64(x: U64, sh: U32) -> U64
  let r: U32 = sh & 63
  if r == 0
    ret x
  .end
  ret (x >> r) | (x << (64 - r))
.end

# -----------------------------------------------------------------------------
# Safe casts (narrowing)
# -----------------------------------------------------------------------------

fn u64_to_u32_checked(x: U64) -> Result[U32, Error]
  if x <= U32_MAX as U64
    ret Result.Ok(value: x as U32)
  .end
  ret Result.Err(error: Error(code: E_OVERFLOW, message: "u64_to_u32_checked overflow"))
.end

fn u64_to_i64_checked(x: U64) -> Result[I64, Error]
  if x <= I64_MAX as U64
    ret Result.Ok(value: x as I64)
  .end
  ret Result.Err(error: Error(code: E_OVERFLOW, message: "u64_to_i64_checked overflow"))
.end

fn i64_to_u64_checked(x: I64) -> Result[U64, Error]
  if x < 0
    ret Result.Err(error: Error(code: E_INVALID_ARG, message: "i64_to_u64_checked negative"))
  .end
  ret Result.Ok(value: x as U64)
.end

fn i64_to_i32_checked(x: I64) -> Result[I32, Error]
  if x >= I32_MIN as I64 && x <= I32_MAX as I64
    ret Result.Ok(value: x as I32)
  .end
  ret Result.Err(error: Error(code: E_OVERFLOW, message: "i64_to_i32_checked overflow"))
.end

fn usz_to_u64(x: Usz) -> U64
  ret x as U64
.end

fn u64_to_usz_checked(x: U64) -> Result[Usz, Error]
  let max: U64 = _intrinsic_usz_max_as_u64()
  if x <= max
    ret Result.Ok(value: x as Usz)
  .end
  ret Result.Err(error: Error(code: E_OVERFLOW, message: "u64_to_usz_checked overflow"))
.end

# -----------------------------------------------------------------------------
# Safe indexing / accessors (bytes & slices)
# -----------------------------------------------------------------------------

fn bytes_get(b: Bytes, i: Usz) -> Result[U8, Error]
  let n: Usz = _intrinsic_bytes_len(b)
  if i < n
    ret Result.Ok(value: _intrinsic_bytes_get(b, i))
  .end
  ret Result.Err(error: Error(code: E_OUT_OF_RANGE, message: "bytes_get: out of range"))
.end

fn bytes_get_span(b: Bytes, off: Usz, len: Usz) -> Result[Bytes, Error]
  let n: Usz = _intrinsic_bytes_len(b)
  if off <= n && len <= (n - off)
    ret Result.Ok(value: _intrinsic_bytes_slice(b, off, len))
  .end
  ret Result.Err(error: Error(code: E_OUT_OF_RANGE, message: "bytes_get_span: out of range"))
.end

fn slice_get_u8(xs: &[U8], i: Usz) -> Result[U8, Error]
  let n: Usz = _intrinsic_slice_len_u8(xs)
  if i < n
    ret Result.Ok(value: _intrinsic_slice_get_u8(xs, i))
  .end
  ret Result.Err(error: Error(code: E_OUT_OF_RANGE, message: "slice_get_u8: out of range"))
.end

fn slice_get_i64(xs: &[I64], i: Usz) -> Result[I64, Error]
  let n: Usz = _intrinsic_slice_len_i64(xs)
  if i < n
    ret Result.Ok(value: _intrinsic_slice_get_i64(xs, i))
  .end
  ret Result.Err(error: Error(code: E_OUT_OF_RANGE, message: "slice_get_i64: out of range"))
.end

fn slice_set_u8(xs: &mut [U8], i: Usz, v: U8) -> Result[void, Error]
  let n: Usz = _intrinsic_slice_len_u8_mut(xs)
  if i < n
    _intrinsic_slice_set_u8(xs, i, v)
    ret Result.Ok(value: ())
  .end
  ret Result.Err(error: Error(code: E_OUT_OF_RANGE, message: "slice_set_u8: out of range"))
.end

# -----------------------------------------------------------------------------
# Safe copy helpers
# -----------------------------------------------------------------------------

enum OverlapPolicy
  AllowOverlap
  ForbidOverlap
.end

fn copy_bytes(dst: &mut [U8], dst_off: Usz, src: &[U8], src_off: Usz, len: Usz, policy: OverlapPolicy) -> Result[void, Error]
  if len == 0
    ret Result.Ok(value: ())
  .end
  let dn: Usz = _intrinsic_slice_len_u8_mut(dst)
  let sn: Usz = _intrinsic_slice_len_u8(src)

  if dst_off > dn || len > (dn - dst_off)
    ret Result.Err(error: Error(code: E_OUT_OF_RANGE, message: "copy_bytes: dst out of range"))
  .end
  if src_off > sn || len > (sn - src_off)
    ret Result.Err(error: Error(code: E_OUT_OF_RANGE, message: "copy_bytes: src out of range"))
  .end

  if policy == OverlapPolicy.ForbidOverlap
    if _intrinsic_ranges_overlap(dst, dst_off, src, src_off, len)
      ret Result.Err(error: Error(code: E_INVALID_ARG, message: "copy_bytes: overlap forbidden"))
    .end
  .end

  _intrinsic_mem_copy(dst, dst_off, src, src_off, len)
  ret Result.Ok(value: ())
.end

# -----------------------------------------------------------------------------
# Safe parse helpers (delegates to conversions if present)
# -----------------------------------------------------------------------------

fn parse_usz_checked(s: Str) -> Result[Usz, Error]
  # parse u64 then cast
  let r: Result[U64, Error] = _intrinsic_parse_u64(s)
  if result_is_err[U64, Error](r)
    ret Result.Err(error: result_unwrap_err[U64, Error](r))
  .end
  return u64_to_usz_checked(result_unwrap[U64, Error](r))
.end

# -----------------------------------------------------------------------------
# Safe arithmetic on sizes (avoid overflow)
# -----------------------------------------------------------------------------

fn size_add_checked(a: Usz, b: Usz) -> Result[Usz, Error]
  let ua: U64 = a as U64
  let ub: U64 = b as U64
  let rr: Result[U64, Error] = add_u64_checked(ua, ub)
  if result_is_err[U64, Error](rr)
    ret Result.Err(error: Error(code: E_OVERFLOW, message: "size_add_checked overflow"))
  .end
  return u64_to_usz_checked(result_unwrap[U64, Error](rr))
.end

fn size_mul_checked(a: Usz, b: Usz) -> Result[Usz, Error]
  let ua: U64 = a as U64
  let ub: U64 = b as U64
  let rr: Result[U64, Error] = mul_u64_checked(ua, ub)
  if result_is_err[U64, Error](rr)
    ret Result.Err(error: Error(code: E_OVERFLOW, message: "size_mul_checked overflow"))
  .end
  return u64_to_usz_checked(result_unwrap[U64, Error](rr))
.end

# -----------------------------------------------------------------------------
# Smoke tests
# -----------------------------------------------------------------------------

fn _t_add_overflow() -> void
  let r: Result[U64, Error] = add_u64_checked(U64_MAX, 1)
  assert(result_is_err[U64, Error](r), "add_u64_checked should overflow")
.end

fn _t_bounds() -> void
  let b: Bytes = "abc" as Bytes
  let r: Result[U8, Error] = bytes_get(b, 2)
  assert(result_is_ok[U8, Error](r), "bytes_get ok")
  let e: Result[U8, Error] = bytes_get(b, 99)
  assert(result_is_err[U8, Error](e), "bytes_get out of range")
.end

fn safe_smoke_tests() -> void
  _t_add_overflow()
  _t_bounds()
.end

# -----------------------------------------------------------------------------
# Intrinsics placeholders (à binder runtime/VM)
# -----------------------------------------------------------------------------

fn _intrinsic_i64_add_overflow(a: I64, b: I64, out: &mut I64) -> Bool
  let _ = a
  let _ = b
  *out = 0
  ret false
.end

fn _intrinsic_i64_sub_overflow(a: I64, b: I64, out: &mut I64) -> Bool
  let _ = a
  let _ = b
  *out = 0
  ret false
.end

fn _intrinsic_i64_mul_overflow(a: I64, b: I64, out: &mut I64) -> Bool
  let _ = a
  let _ = b
  *out = 0
  ret false
.end

fn _intrinsic_usz_max_as_u64() -> U64
  ret 18446744073709551615
.end

fn _intrinsic_bytes_len(b: Bytes) -> Usz
  let _ = b
  ret 0
.end

fn _intrinsic_bytes_get(b: Bytes, i: Usz) -> U8
  let _ = b
  let _ = i
  ret 0
.end

fn _intrinsic_bytes_slice(b: Bytes, off: Usz, len: Usz) -> Bytes
  let _ = b
  let _ = off
  let _ = len
  ret "" as Bytes
.end

fn _intrinsic_slice_len_u8(xs: &[U8]) -> Usz
  let _ = xs
  ret 0
.end

fn _intrinsic_slice_len_u8_mut(xs: &mut [U8]) -> Usz
  let _ = xs
  ret 0
.end

fn _intrinsic_slice_get_u8(xs: &[U8], i: Usz) -> U8
  let _ = xs
  let _ = i
  ret 0
.end

fn _intrinsic_slice_set_u8(xs: &mut [U8], i: Usz, v: U8) -> void
  let _ = xs
  let _ = i
  let _ = v
.end

fn _intrinsic_slice_len_i64(xs: &[I64]) -> Usz
  let _ = xs
  ret 0
.end

fn _intrinsic_slice_get_i64(xs: &[I64], i: Usz) -> I64
  let _ = xs
  let _ = i
  ret 0
.end

fn _intrinsic_ranges_overlap(dst: &mut [U8], dst_off: Usz, src: &[U8], src_off: Usz, len: Usz) -> Bool
  let _ = dst
  let _ = dst_off
  let _ = src
  let _ = src_off
  let _ = len
  ret false
.end

fn _intrinsic_mem_copy(dst: &mut [U8], dst_off: Usz, src: &[U8], src_off: Usz, len: Usz) -> void
  let _ = dst
  let _ = dst_off
  let _ = src
  let _ = src_off
  let _ = len
.end

fn _intrinsic_parse_u64(s: Str) -> Result[U64, Error]
  let _ = s
  ret Result.Err(error: Error(code: E_UNSUPPORTED, message: "parse_u64 intrinsic not bound"))
.end
