# scalb.vitte
# -----------------------------------------------------------------------------
# scalb / ldexp / scalbn — scaling by power of two (IEEE-754)
# - scalb(x, n): x * 2^n   (n peut être int ou float selon API; ici int)
# - ldexp: alias classique C (x * 2^exp)
# - scalbn: exp I32
# - variants f32/f64 + helpers frexp/ilogb/logb (intrinsics)
# - overflow/underflow handling via IEEE (inf/0, preserves NaN)
#
# Dépendances: core/basic.vitte
# Contrainte: pas d'accolades, blocs en .end
# -----------------------------------------------------------------------------

mod core.scalb

use core.basic

# -----------------------------------------------------------------------------
# Public API
# -----------------------------------------------------------------------------

fn scalb_f32(x: F32, n: I32) -> F32
  # Binder recommandé: intrinsic ldexp/scalbn pour exactitude perf + subnormals
  if _intrinsic_has_scalbn_f32()
    ret _intrinsic_scalbn_f32(x, n)
  .end
  # fallback: x * 2^n (moins exact sur bords/subnormals)
  ret x * pow2_f32(n)
.end

fn scalb_f64(x: F64, n: I32) -> F64
  if _intrinsic_has_scalbn_f64()
    ret _intrinsic_scalbn_f64(x, n)
  .end
  ret x * pow2_f64(n)
.end

fn ldexp_f32(x: F32, exp: I32) -> F32
  ret scalb_f32(x, exp)
.end

fn ldexp_f64(x: F64, exp: I32) -> F64
  ret scalb_f64(x, exp)
.end

fn scalbn_f32(x: F32, n: I32) -> F32
  ret scalb_f32(x, n)
.end

fn scalbn_f64(x: F64, n: I32) -> F64
  ret scalb_f64(x, n)
.end

# -----------------------------------------------------------------------------
# pow2 helpers (fallback)
# -----------------------------------------------------------------------------
# pow2(n) = 2^n. Fallback via exponent bits si possible, sinon loop.
# Ici on demande des intrinsics bits pour produire exact 2^n pour range normal.

fn pow2_f32(n: I32) -> F32
  if _intrinsic_has_pow2_bits_f32()
    ret _intrinsic_pow2_f32(n)
  .end

  # fallback brut: exponentiation par squaring en float
  # (peut under/overflow différemment de IEEE ldexp)
  let p: F32 = 1.0
  let e: I32 = n
  if e == 0
    ret 1.0
  .end
  if e > 0
    let i: I32 = 0
    loop
      if i >= e
        break
      .end
      p = p * 2.0
      i = i + 1
    .end
    ret p
  .end

  # e < 0
  let m: I32 = -e
  let i: I32 = 0
  loop
    if i >= m
      break
    .end
    p = p * 0.5
    i = i + 1
  .end
  ret p
.end

fn pow2_f64(n: I32) -> F64
  if _intrinsic_has_pow2_bits_f64()
    ret _intrinsic_pow2_f64(n)
  .end

  let p: F64 = 1.0
  let e: I32 = n
  if e == 0
    ret 1.0
  .end
  if e > 0
    let i: I32 = 0
    loop
      if i >= e
        break
      .end
      p = p * 2.0
      i = i + 1
    .end
    ret p
  .end

  let m: I32 = -e
  let i: I32 = 0
  loop
    if i >= m
      break
    .end
    p = p * 0.5
    i = i + 1
  .end
  ret p
.end

# -----------------------------------------------------------------------------
# frexp / ilogb / logb (useful companions)
# -----------------------------------------------------------------------------
# frexp(x) -> (m, e) with x = m * 2^e and m in [0.5,1) (or 0)
# ilogb(x) -> unbiased exponent as int (special cases)
# logb(x) -> exponent as float (special cases)

struct FrexpF32
  mant: F32
  exp: I32
.end

struct FrexpF64
  mant: F64
  exp: I32
.end

fn frexp_f32(x: F32) -> FrexpF32
  if _intrinsic_has_frexp_f32()
    ret _intrinsic_frexp_f32(x)
  .end
  # fallback via logb/scalb: m = x / 2^e ; choose e = ilogb(x)+1 so m in [0.5,1)
  if x == 0.0
    ret FrexpF32(mant: 0.0, exp: 0)
  .end
  let e: I32 = ilogb_f32(x)
  let ee: I32 = e + 1
  let m: F32 = scalb_f32(x, -ee)
  ret FrexpF32(mant: m, exp: ee)
.end

fn frexp_f64(x: F64) -> FrexpF64
  if _intrinsic_has_frexp_f64()
    ret _intrinsic_frexp_f64(x)
  .end
  if x == 0.0
    ret FrexpF64(mant: 0.0, exp: 0)
  .end
  let e: I32 = ilogb_f64(x)
  let ee: I32 = e + 1
  let m: F64 = scalb_f64(x, -ee)
  ret FrexpF64(mant: m, exp: ee)
.end

fn ilogb_f32(x: F32) -> I32
  ret _intrinsic_ilogb_f32(x)
.end

fn ilogb_f64(x: F64) -> I32
  ret _intrinsic_ilogb_f64(x)
.end

fn logb_f32(x: F32) -> F32
  ret _intrinsic_logb_f32(x)
.end

fn logb_f64(x: F64) -> F64
  ret _intrinsic_logb_f64(x)
.end

# -----------------------------------------------------------------------------
# Safe scaling with explicit error reporting
# -----------------------------------------------------------------------------
# Renvoie Err si overflow vers inf ou underflow vers 0 (hors x==0).
# NaN propage en Ok(NaN). Inf en Ok(Inf) (scaling garde inf).

fn scalb_f64_checked(x: F64, n: I32) -> Result[F64, Error]
  if _intrinsic_f64_is_nan(x)
    ret Result.Ok(value: x)
  .end
  if _intrinsic_f64_is_inf(x)
    ret Result.Ok(value: x)
  .end
  if x == 0.0
    ret Result.Ok(value: x)
  .end

  let y: F64 = scalb_f64(x, n)
  if _intrinsic_f64_is_inf(y)
    ret Result.Err(error: Error(code: E_OVERFLOW, message: "scalb_f64_checked: overflow to inf"))
  .end
  if y == 0.0
    ret Result.Err(error: Error(code: E_UNDERFLOW, message: "scalb_f64_checked: underflow to zero"))
  .end
  ret Result.Ok(value: y)
.end

fn scalb_f32_checked(x: F32, n: I32) -> Result[F32, Error]
  if _intrinsic_f32_is_nan(x)
    ret Result.Ok(value: x)
  .end
  if _intrinsic_f32_is_inf(x)
    ret Result.Ok(value: x)
  .end
  if x == 0.0
    ret Result.Ok(value: x)
  .end

  let y: F32 = scalb_f32(x, n)
  if _intrinsic_f32_is_inf(y)
    ret Result.Err(error: Error(code: E_OVERFLOW, message: "scalb_f32_checked: overflow to inf"))
  .end
  if y == 0.0
    ret Result.Err(error: Error(code: E_UNDERFLOW, message: "scalb_f32_checked: underflow to zero"))
  .end
  ret Result.Ok(value: y)
.end

# -----------------------------------------------------------------------------
# Smoke tests
# -----------------------------------------------------------------------------

fn _t_pow2_basic() -> void
  let a: F64 = scalb_f64(1.0, 10)
  assert(a == 1024.0, "scalb_f64(1,10)=1024")
  let b: F64 = scalb_f64(1.0, -1)
  assert(b == 0.5, "scalb_f64(1,-1)=0.5")
.end

fn _t_frexp_roundtrip() -> void
  let x: F64 = 12.0
  let fr: FrexpF64 = frexp_f64(x)
  let y: F64 = scalb_f64(fr.mant, fr.exp)
  # roundtrip approx (exact for simple)
  assert(_intrinsic_f64_approx_eq(y, x, 0.0, 0.0), "frexp/scalb roundtrip")
.end

fn scalb_smoke_tests() -> void
  _t_pow2_basic()
  _t_frexp_roundtrip()
.end

# -----------------------------------------------------------------------------
# Intrinsics placeholders (à binder runtime/VM)
# -----------------------------------------------------------------------------

fn _intrinsic_has_scalbn_f32() -> Bool
  ret false
.end

fn _intrinsic_has_scalbn_f64() -> Bool
  ret false
.end

fn _intrinsic_scalbn_f32(x: F32, n: I32) -> F32
  let _ = x
  let _ = n
  ret x
.end

fn _intrinsic_scalbn_f64(x: F64, n: I32) -> F64
  let _ = x
  let _ = n
  ret x
.end

fn _intrinsic_has_pow2_bits_f32() -> Bool
  ret false
.end

fn _intrinsic_has_pow2_bits_f64() -> Bool
  ret false
.end

fn _intrinsic_pow2_f32(n: I32) -> F32
  let _ = n
  ret 1.0
.end

fn _intrinsic_pow2_f64(n: I32) -> F64
  let _ = n
  ret 1.0
.end

fn _intrinsic_has_frexp_f32() -> Bool
  ret false
.end

fn _intrinsic_has_frexp_f64() -> Bool
  ret false
.end

fn _intrinsic_frexp_f32(x: F32) -> FrexpF32
  let _ = x
  ret FrexpF32(mant: 0.0, exp: 0)
.end

fn _intrinsic_frexp_f64(x: F64) -> FrexpF64
  let _ = x
  ret FrexpF64(mant: 0.0, exp: 0)
.end

fn _intrinsic_ilogb_f32(x: F32) -> I32
  let _ = x
  ret 0
.end

fn _intrinsic_ilogb_f64(x: F64) -> I32
  let _ = x
  ret 0
.end

fn _intrinsic_logb_f32(x: F32) -> F32
  let _ = x
  ret 0.0
.end

fn _intrinsic_logb_f64(x: F64) -> F64
  let _ = x
  ret 0.0
.end

fn _intrinsic_f32_is_nan(x: F32) -> Bool
  let _ = x
  ret false
.end

fn _intrinsic_f64_is_nan(x: F64) -> Bool
  let _ = x
  ret false
.end

fn _intrinsic_f32_is_inf(x: F32) -> Bool
  let _ = x
  ret false
.end

fn _intrinsic_f64_is_inf(x: F64) -> Bool
  let _ = x
  ret false
.end

fn _intrinsic_f64_approx_eq(a: F64, b: F64, abs_tol: F64, rel_tol: F64) -> Bool
  let _ = abs_tol
  let _ = rel_tol
  let d: F64 = if a > b then a - b else b - a
  ret d == 0.0
.end
