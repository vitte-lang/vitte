# compare.vitte
# -----------------------------------------------------------------------------
# Comparaison / ordering / equality / hashing helpers
# - Ord: cmp, min/max/clamp (wrappers), total_cmp pour f32/f64
# - Eq: eq, ne
# - Lexicographic compare pour slices/bytes/strings
# - Comparators configurables (asc/desc, key extractors)
# - Stable selection: argmin/argmax, top-k (simple), is_sorted, binary helpers
#
# Dépendances: core/basic.vitte (Option/Result/Error/assert, hash fnv1a, etc.)
# Contrainte: pas d'accolades, blocs en .end
# -----------------------------------------------------------------------------

mod core.compare

use core.basic

# -----------------------------------------------------------------------------
# Types d'ordre
# -----------------------------------------------------------------------------

enum Ordering
  Less
  Equal
  Greater
.end

fn ordering_reverse(o: Ordering) -> Ordering
  match o
    Ordering.Less => ret Ordering.Greater
    Ordering.Equal => ret Ordering.Equal
    Ordering.Greater => ret Ordering.Less
  .end
.end

fn ordering_from_i32(x: I32) -> Ordering
  if x < 0
    ret Ordering.Less
  .end
  if x > 0
    ret Ordering.Greater
  .end
  ret Ordering.Equal
.end

fn ordering_to_i32(o: Ordering) -> I32
  match o
    Ordering.Less => ret -1
    Ordering.Equal => ret 0
    Ordering.Greater => ret 1
  .end
.end

# -----------------------------------------------------------------------------
# Comparateurs basiques scalaires
# -----------------------------------------------------------------------------

fn cmp_i64(a: I64, b: I64) -> Ordering
  if a < b
    ret Ordering.Less
  .end
  if a > b
    ret Ordering.Greater
  .end
  ret Ordering.Equal
.end

fn cmp_u64(a: U64, b: U64) -> Ordering
  if a < b
    ret Ordering.Less
  .end
  if a > b
    ret Ordering.Greater
  .end
  ret Ordering.Equal
.end

fn cmp_bool(a: Bool, b: Bool) -> Ordering
  # false < true
  if a == b
    ret Ordering.Equal
  .end
  if a == false && b == true
    ret Ordering.Less
  .end
  ret Ordering.Greater
.end

fn cmp_char(a: Char, b: Char) -> Ordering
  return ordering_from_i32(_intrinsic_char_cmp(a, b))
.end

# -----------------------------------------------------------------------------
# Float: total order (NaN, -0.0/+0.0)
# -----------------------------------------------------------------------------
# total_cmp reproduit un ordre total stable (comme Rust f32::total_cmp).
# Règles:
# - Toutes les valeurs ordonnables (y compris NaN) selon leur représentation IEEE.
# - -0.0 < +0.0 (par convention total order)
# - NaN comparables (différents NaN ordonnés via payload bits)
#
# Impl basée sur bitcast -> u32/u64 puis transformation pour ordre lexicographique.

fn f32_to_bits(x: F32) -> U32
  ret _intrinsic_f32_to_bits(x)
.end

fn f64_to_bits(x: F64) -> U64
  ret _intrinsic_f64_to_bits(x)
.end

fn total_cmp_f32(a: F32, b: F32) -> Ordering
  let ua: U32 = f32_to_bits(a)
  let ub: U32 = f32_to_bits(b)

  # Transform: flip sign bit for positives, invert all bits for negatives
  # mask = (signbit ? 0xFFFFFFFF : 0x80000000)
  let sa: U32 = ua >> 31
  let sb: U32 = ub >> 31

  let ma: U32 = if sa == 1 then 4294967295 else 2147483648
  let mb: U32 = if sb == 1 then 4294967295 else 2147483648

  let ta: U32 = ua ^ ma
  let tb: U32 = ub ^ mb

  if ta < tb
    ret Ordering.Less
  .end
  if ta > tb
    ret Ordering.Greater
  .end
  ret Ordering.Equal
.end

fn total_cmp_f64(a: F64, b: F64) -> Ordering
  let ua: U64 = f64_to_bits(a)
  let ub: U64 = f64_to_bits(b)

  let sa: U64 = ua >> 63
  let sb: U64 = ub >> 63

  let ma: U64 = if sa == 1 then 18446744073709551615 else 9223372036854775808
  let mb: U64 = if sb == 1 then 18446744073709551615 else 9223372036854775808

  let ta: U64 = ua ^ ma
  let tb: U64 = ub ^ mb

  if ta < tb
    ret Ordering.Less
  .end
  if ta > tb
    ret Ordering.Greater
  .end
  ret Ordering.Equal
.end

fn cmp_f32_partial(a: F32, b: F32) -> Option[Ordering]
  # None si NaN (si runtime fournit isnan)
  if _intrinsic_f32_is_nan(a) || _intrinsic_f32_is_nan(b)
    ret Option.None
  .end
  if a < b
    ret Option.Some(value: Ordering.Less)
  .end
  if a > b
    ret Option.Some(value: Ordering.Greater)
  .end
  ret Option.Some(value: Ordering.Equal)
.end

fn cmp_f64_partial(a: F64, b: F64) -> Option[Ordering]
  if _intrinsic_f64_is_nan(a) || _intrinsic_f64_is_nan(b)
    ret Option.None
  .end
  if a < b
    ret Option.Some(value: Ordering.Less)
  .end
  if a > b
    ret Option.Some(value: Ordering.Greater)
  .end
  ret Option.Some(value: Ordering.Equal)
.end

# -----------------------------------------------------------------------------
# Eq / Ne helpers
# -----------------------------------------------------------------------------

fn eq_i64(a: I64, b: I64) -> Bool
  ret a == b
.end

fn ne_i64(a: I64, b: I64) -> Bool
  ret a != b
.end

fn eq_u64(a: U64, b: U64) -> Bool
  ret a == b
.end

fn ne_u64(a: U64, b: U64) -> Bool
  ret a != b
.end

fn eq_str(a: Str, b: Str) -> Bool
  ret str_eq(a, b)
.end

fn ne_str(a: Str, b: Str) -> Bool
  ret !str_eq(a, b)
.end

# -----------------------------------------------------------------------------
# Lexicographic compare (Bytes / slices) + strings
# -----------------------------------------------------------------------------

fn lex_cmp_bytes(a: Bytes, b: Bytes) -> Ordering
  let na: Usz = _intrinsic_bytes_len(a)
  let nb: Usz = _intrinsic_bytes_len(b)

  let n: Usz = if na < nb then na else nb
  let i: Usz = 0
  loop
    if i >= n
      break
    .end
    let ba: U8 = _intrinsic_bytes_get(a, i)
    let bb: U8 = _intrinsic_bytes_get(b, i)
    if ba < bb
      ret Ordering.Less
    .end
    if ba > bb
      ret Ordering.Greater
    .end
    i = i + 1
  .end

  if na < nb
    ret Ordering.Less
  .end
  if na > nb
    ret Ordering.Greater
  .end
  ret Ordering.Equal
.end

fn lex_cmp_str(a: Str, b: Str) -> Ordering
  # Compare UTF-8 bytes (ordre lexicographique sur bytes, pas collation locale)
  let ba: Bytes = _intrinsic_str_as_bytes(a)
  let bb: Bytes = _intrinsic_str_as_bytes(b)
  ret lex_cmp_bytes(ba, bb)
.end

fn lex_eq_bytes(a: Bytes, b: Bytes) -> Bool
  ret mem_eq(a, b)
.end

# -----------------------------------------------------------------------------
# is_sorted / is_strictly_sorted (avec cmp callback)
# -----------------------------------------------------------------------------

fn is_sorted_i64(xs: &[I64]) -> Bool
  let n: Usz = _intrinsic_slice_len_i64(xs)
  if n <= 1
    ret true
  .end
  let i: Usz = 1
  let prev: I64 = _intrinsic_slice_get_i64(xs, 0)
  loop
    if i >= n
      break
    .end
    let cur: I64 = _intrinsic_slice_get_i64(xs, i)
    if cur < prev
      ret false
    .end
    prev = cur
    i = i + 1
  .end
  ret true
.end

fn is_strictly_sorted_i64(xs: &[I64]) -> Bool
  let n: Usz = _intrinsic_slice_len_i64(xs)
  if n <= 1
    ret true
  .end
  let i: Usz = 1
  let prev: I64 = _intrinsic_slice_get_i64(xs, 0)
  loop
    if i >= n
      break
    .end
    let cur: I64 = _intrinsic_slice_get_i64(xs, i)
    if cur <= prev
      ret false
    .end
    prev = cur
    i = i + 1
  .end
  ret true
.end

# Generic callbacks (si le type système supporte fn(T,T)->Ordering)
fn is_sorted_by[T](xs: &[T], cmp: fn(T, T) -> Ordering) -> Bool
  let n: Usz = _intrinsic_slice_len_T(xs)
  if n <= 1
    ret true
  .end

  let i: Usz = 1
  let prev: T = _intrinsic_slice_get_T(xs, 0)
  loop
    if i >= n
      break
    .end
    let cur: T = _intrinsic_slice_get_T(xs, i)
    let o: Ordering = cmp(prev, cur)
    if o == Ordering.Greater
      ret false
    .end
    prev = cur
    i = i + 1
  .end
  ret true
.end

fn is_strictly_sorted_by[T](xs: &[T], cmp: fn(T, T) -> Ordering) -> Bool
  let n: Usz = _intrinsic_slice_len_T(xs)
  if n <= 1
    ret true
  .end

  let i: Usz = 1
  let prev: T = _intrinsic_slice_get_T(xs, 0)
  loop
    if i >= n
      break
    .end
    let cur: T = _intrinsic_slice_get_T(xs, i)
    let o: Ordering = cmp(prev, cur)
    if o != Ordering.Less
      ret false
    .end
    prev = cur
    i = i + 1
  .end
  ret true
.end

# -----------------------------------------------------------------------------
# argmin / argmax (index + value)
# -----------------------------------------------------------------------------

struct ArgMinI64
  index: Usz
  value: I64
.end

struct ArgMaxI64
  index: Usz
  value: I64
.end

fn argmin_i64(xs: &[I64]) -> Option[ArgMinI64]
  let n: Usz = _intrinsic_slice_len_i64(xs)
  if n == 0
    ret Option.None
  .end

  let best_i: Usz = 0
  let best_v: I64 = _intrinsic_slice_get_i64(xs, 0)

  let i: Usz = 1
  loop
    if i >= n
      break
    .end
    let v: I64 = _intrinsic_slice_get_i64(xs, i)
    if v < best_v
      best_v = v
      best_i = i
    .end
    i = i + 1
  .end

  ret Option.Some(value: ArgMinI64(index: best_i, value: best_v))
.end

fn argmax_i64(xs: &[I64]) -> Option[ArgMaxI64]
  let n: Usz = _intrinsic_slice_len_i64(xs)
  if n == 0
    ret Option.None
  .end

  let best_i: Usz = 0
  let best_v: I64 = _intrinsic_slice_get_i64(xs, 0)

  let i: Usz = 1
  loop
    if i >= n
      break
    .end
    let v: I64 = _intrinsic_slice_get_i64(xs, i)
    if v > best_v
      best_v = v
      best_i = i
    .end
    i = i + 1
  .end

  ret Option.Some(value: ArgMaxI64(index: best_i, value: best_v))
.end

# Generic argmin_by / argmax_by (stable: first wins on tie)
struct ArgIndex[T]
  index: Usz
  value: T
.end

fn argmin_by[T](xs: &[T], cmp: fn(T, T) -> Ordering) -> Option[ArgIndex[T]]
  let n: Usz = _intrinsic_slice_len_T(xs)
  if n == 0
    ret Option.None
  .end

  let best_i: Usz = 0
  let best_v: T = _intrinsic_slice_get_T(xs, 0)

  let i: Usz = 1
  loop
    if i >= n
      break
    .end
    let v: T = _intrinsic_slice_get_T(xs, i)
    if cmp(v, best_v) == Ordering.Less
      best_v = v
      best_i = i
    .end
    i = i + 1
  .end

  ret Option.Some(value: ArgIndex[T](index: best_i, value: best_v))
.end

fn argmax_by[T](xs: &[T], cmp: fn(T, T) -> Ordering) -> Option[ArgIndex[T]]
  let n: Usz = _intrinsic_slice_len_T(xs)
  if n == 0
    ret Option.None
  .end

  let best_i: Usz = 0
  let best_v: T = _intrinsic_slice_get_T(xs, 0)

  let i: Usz = 1
  loop
    if i >= n
      break
    .end
    let v: T = _intrinsic_slice_get_T(xs, i)
    if cmp(v, best_v) == Ordering.Greater
      best_v = v
      best_i = i
    .end
    i = i + 1
  .end

  ret Option.Some(value: ArgIndex[T](index: best_i, value: best_v))
.end

# -----------------------------------------------------------------------------
# Binary search helpers (sur slices triées)
# -----------------------------------------------------------------------------

enum SearchResult
  Found(index: Usz)
  NotFound(insert_index: Usz)
.end

fn binary_search_i64(xs: &[I64], key: I64) -> SearchResult
  let n: Usz = _intrinsic_slice_len_i64(xs)
  let lo: Usz = 0
  let hi: Usz = n

  loop
    if lo >= hi
      break
    .end

    let mid: Usz = lo + (hi - lo) / 2
    let v: I64 = _intrinsic_slice_get_i64(xs, mid)
    if v < key
      lo = mid + 1
    .end
    else
      if v > key
        hi = mid
      .end
      else
        ret SearchResult.Found(index: mid)
      .end
    .end
  .end

  ret SearchResult.NotFound(insert_index: lo)
.end

fn lower_bound_i64(xs: &[I64], key: I64) -> Usz
  let n: Usz = _intrinsic_slice_len_i64(xs)
  let lo: Usz = 0
  let hi: Usz = n
  loop
    if lo >= hi
      break
    .end
    let mid: Usz = lo + (hi - lo) / 2
    let v: I64 = _intrinsic_slice_get_i64(xs, mid)
    if v < key
      lo = mid + 1
    .end
    else
      hi = mid
    .end
  .end
  ret lo
.end

fn upper_bound_i64(xs: &[I64], key: I64) -> Usz
  let n: Usz = _intrinsic_slice_len_i64(xs)
  let lo: Usz = 0
  let hi: Usz = n
  loop
    if lo >= hi
      break
    .end
    let mid: Usz = lo + (hi - lo) / 2
    let v: I64 = _intrinsic_slice_get_i64(xs, mid)
    if v <= key
      lo = mid + 1
    .end
    else
      hi = mid
    .end
  .end
  ret lo
.end

# -----------------------------------------------------------------------------
# Top-K simple (O(n*k)) via hits/score — utile sans heap
# -----------------------------------------------------------------------------

struct TopK
  # buffer mutable de hits (taille <= k)
  k: Usz
  buf: &mut [Hit]
  len: Usz
.end

fn topk_init(k: Usz, buf: &mut [Hit]) -> TopK
  # buf doit avoir capacité >= k
  ret TopK(k: k, buf: buf, len: 0)
.end

fn topk_push(t: &mut TopK, h: Hit) -> void
  if t.k == 0
    ret
  .end

  if t.len < t.k
    _intrinsic_slice_set_hit(t.buf, t.len, h)
    t.len = t.len + 1
    ret
  .end

  # Trouver le pire dans buf, remplacer si h meilleur
  let worst_i: Usz = 0
  let worst: Hit = _intrinsic_slice_get_hit(t.buf, 0)
  let i: Usz = 1
  loop
    if i >= t.len
      break
    .end
    let cur: Hit = _intrinsic_slice_get_hit(t.buf, i)
    # cur est "pire" si worst meilleur que cur
    if hit_better(worst, cur)
      worst_i = i
      worst = cur
    .end
    i = i + 1
  .end

  if hit_better(h, worst)
    _intrinsic_slice_set_hit(t.buf, worst_i, h)
  .end
.end

fn topk_len(t: TopK) -> Usz
  ret t.len
.end

fn topk_get(t: TopK, i: Usz) -> Hit
  assert(i < t.len, "topk_get: out of range")
  ret _intrinsic_slice_get_hit(t.buf, i)
.end

# -----------------------------------------------------------------------------
# Smoke tests
# -----------------------------------------------------------------------------

fn _t_total_cmp() -> void
  # -0.0 vs +0.0
  let a: F64 = -0.0
  let b: F64 = 0.0
  let o: Ordering = total_cmp_f64(a, b)
  assert(o == Ordering.Less, "total_cmp_f64: -0.0 < +0.0")
.end

fn _t_lex() -> void
  assert(lex_cmp_str("a", "b") == Ordering.Less, "lex a<b")
  assert(lex_cmp_str("ab", "ab") == Ordering.Equal, "lex eq")
  assert(lex_cmp_str("b", "aa") == Ordering.Greater, "lex b>aa")
.end

fn compare_smoke_tests() -> void
  _t_total_cmp()
  _t_lex()
.end

# -----------------------------------------------------------------------------
# Intrinsics placeholders (à binder)
# -----------------------------------------------------------------------------

fn _intrinsic_char_cmp(a: Char, b: Char) -> I32
  let _ = a
  let _ = b
  ret 0
.end

fn _intrinsic_f32_to_bits(x: F32) -> U32
  let _ = x
  ret 0
.end

fn _intrinsic_f64_to_bits(x: F64) -> U64
  let _ = x
  ret 0
.end

fn _intrinsic_f32_is_nan(x: F32) -> Bool
  let _ = x
  ret false
.end

fn _intrinsic_f64_is_nan(x: F64) -> Bool
  let _ = x
  ret false
.end

fn _intrinsic_slice_len_i64(xs: &[I64]) -> Usz
  let _ = xs
  ret 0
.end

fn _intrinsic_slice_get_i64(xs: &[I64], i: Usz) -> I64
  let _ = xs
  let _ = i
  ret 0
.end

fn _intrinsic_slice_len_T[T](xs: &[T]) -> Usz
  let _ = xs
  ret 0
.end

fn _intrinsic_slice_get_T[T](xs: &[T], i: Usz) -> T
  let _ = xs
  let _ = i
  ret _intrinsic_default_T[T]()
.end

fn _intrinsic_default_T[T]() -> T
  # placeholder
  unreachable()
.end

fn _intrinsic_slice_get_hit(xs: &mut [Hit], i: Usz) -> Hit
  let _ = xs
  let _ = i
  ret Hit(label: "", score: 0)
.end

fn _intrinsic_slice_set_hit(xs: &mut [Hit], i: Usz, v: Hit) -> void
  let _ = xs
  let _ = i
  let _ = v
.end
