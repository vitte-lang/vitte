# rounding.vitte
# -----------------------------------------------------------------------------
# Rounding — module ultra complet
# - Rounding modes: floor/ceil/trunc/round (away), round_even (ties-to-even)
# - Quantization: round_to_step, round_to_decimals
# - Integer rounding helpers: div_ceil/div_floor for signed/unsigned, align_up/down
# - Banker's rounding helpers + midpoint detection
# - ULP-aware rounding (via nextafter if dispo)
#
# Dépendances: core/basic.vitte + (optionnel) core/nextafter.vitte
# Contrainte: pas d'accolades, blocs en .end
# -----------------------------------------------------------------------------

mod core.rounding

use core.basic

# -----------------------------------------------------------------------------
# Rounding modes enum (utile pour APIs génériques)
# -----------------------------------------------------------------------------

enum RoundMode
  Trunc
  Floor
  Ceil
  Away
  Even
.end

# -----------------------------------------------------------------------------
# Float primitives (via intrinsics)
# -----------------------------------------------------------------------------
# On bind au runtime pour conformité IEEE et perfs.
# Fallbacks minimaux fournis si intrinsics non dispo.

fn floor_f32(x: F32) -> F32
  ret _intrinsic_floor_f32(x)
.end

fn ceil_f32(x: F32) -> F32
  ret _intrinsic_ceil_f32(x)
.end

fn trunc_f32(x: F32) -> F32
  ret _intrinsic_trunc_f32(x)
.end

fn round_away_f32(x: F32) -> F32
  # arrondi au plus proche, tie => away from zero
  ret _intrinsic_round_away_f32(x)
.end

fn round_even_f32(x: F32) -> F32
  # tie => to even
  ret _intrinsic_round_even_f32(x)
.end

fn floor_f64(x: F64) -> F64
  ret _intrinsic_floor_f64(x)
.end

fn ceil_f64(x: F64) -> F64
  ret _intrinsic_ceil_f64(x)
.end

fn trunc_f64(x: F64) -> F64
  ret _intrinsic_trunc_f64(x)
.end

fn round_away_f64(x: F64) -> F64
  ret _intrinsic_round_away_f64(x)
.end

fn round_even_f64(x: F64) -> F64
  ret _intrinsic_round_even_f64(x)
.end

# -----------------------------------------------------------------------------
# Generic float rounding by mode
# -----------------------------------------------------------------------------

fn round_f32_mode(x: F32, mode: RoundMode) -> F32
  match mode
    RoundMode.Trunc => ret trunc_f32(x)
    RoundMode.Floor => ret floor_f32(x)
    RoundMode.Ceil  => ret ceil_f32(x)
    RoundMode.Away  => ret round_away_f32(x)
    RoundMode.Even  => ret round_even_f32(x)
  .end
.end

fn round_f64_mode(x: F64, mode: RoundMode) -> F64
  match mode
    RoundMode.Trunc => ret trunc_f64(x)
    RoundMode.Floor => ret floor_f64(x)
    RoundMode.Ceil  => ret ceil_f64(x)
    RoundMode.Away  => ret round_away_f64(x)
    RoundMode.Even  => ret round_even_f64(x)
  .end
.end

# -----------------------------------------------------------------------------
# Quantization: rounding to step / decimals
# -----------------------------------------------------------------------------

fn round_to_step_f64(x: F64, step: F64, mode: RoundMode) -> Result[F64, Error]
  if step == 0.0
    ret Result.Err(error: Error(code: E_INVALID_ARG, message: "round_to_step_f64: step=0"))
  .end
  if _intrinsic_f64_is_nan(x) || _intrinsic_f64_is_nan(step)
    ret Result.Err(error: Error(code: E_INVALID_ARG, message: "round_to_step_f64: NaN"))
  .end
  let q: F64 = x / step
  let rq: F64 = round_f64_mode(q, mode)
  ret Result.Ok(value: rq * step)
.end

fn round_to_step_f32(x: F32, step: F32, mode: RoundMode) -> Result[F32, Error]
  if step == 0.0
    ret Result.Err(error: Error(code: E_INVALID_ARG, message: "round_to_step_f32: step=0"))
  .end
  if _intrinsic_f32_is_nan(x) || _intrinsic_f32_is_nan(step)
    ret Result.Err(error: Error(code: E_INVALID_ARG, message: "round_to_step_f32: NaN"))
  .end
  let q: F32 = x / step
  let rq: F32 = round_f32_mode(q, mode)
  ret Result.Ok(value: rq * step)
.end

fn pow10_f64(n: I32) -> F64
  # runtime idéalement: powi
  ret _intrinsic_pow10_f64(n)
.end

fn round_to_decimals_f64(x: F64, decimals: I32, mode: RoundMode) -> Result[F64, Error]
  # decimals >= 0 => arrondi au 10^-decimals
  # decimals < 0  => arrondi au 10^(-decimals) (dizaines, centaines, ...)
  let p: F64 = pow10_f64(decimals)
  # si decimals=2 => p=100, quantize sur 1/p
  if p == 0.0
    ret Result.Err(error: Error(code: E_OVERFLOW, message: "round_to_decimals_f64: pow10 overflow"))
  .end
  return round_to_step_f64(x * p, 1.0, mode).map(fn(v: F64) -> F64
    ret v / p
  .end)
.end

# -----------------------------------------------------------------------------
# Integer division rounding
# -----------------------------------------------------------------------------
# div_floor/div_ceil pour signed et unsigned.
# Pour unsigned: div_floor = a/b ; div_ceil = (a + b - 1)/b (checked)
# Pour signed: utiliser ajustement via reste.

fn div_floor_u64(a: U64, b: U64) -> Result[U64, Error]
  if b == 0
    ret Result.Err(error: Error(code: E_INVALID_ARG, message: "div_floor_u64: b=0"))
  .end
  ret Result.Ok(value: a / b)
.end

fn div_ceil_u64(a: U64, b: U64) -> Result[U64, Error]
  if b == 0
    ret Result.Err(error: Error(code: E_INVALID_ARG, message: "div_ceil_u64: b=0"))
  .end
  if a == 0
    ret Result.Ok(value: 0)
  .end
  # (a + b - 1) / b with overflow guard
  let t: U64 = a + (b - 1)
  if t < a
    # overflow: use alternative
    let q: U64 = a / b
    let r: U64 = a % b
    if r == 0
      ret Result.Ok(value: q)
    .end
    ret Result.Ok(value: q + 1)
  .end
  ret Result.Ok(value: t / b)
.end

fn div_floor_i64(a: I64, b: I64) -> Result[I64, Error]
  if b == 0
    ret Result.Err(error: Error(code: E_INVALID_ARG, message: "div_floor_i64: b=0"))
  .end
  if a == I64_MIN && b == -1
    ret Result.Err(error: Error(code: E_OVERFLOW, message: "div_floor_i64: overflow"))
  .end

  let q: I64 = a / b
  let r: I64 = a % b
  if r == 0
    ret Result.Ok(value: q)
  .end

  # floor: si a et b de signes différents, et r != 0 => q - 1
  if (r > 0 && b < 0) || (r < 0 && b > 0)
    ret Result.Ok(value: q - 1)
  .end
  ret Result.Ok(value: q)
.end

fn div_ceil_i64(a: I64, b: I64) -> Result[I64, Error]
  if b == 0
    ret Result.Err(error: Error(code: E_INVALID_ARG, message: "div_ceil_i64: b=0"))
  .end
  if a == I64_MIN && b == -1
    ret Result.Err(error: Error(code: E_OVERFLOW, message: "div_ceil_i64: overflow"))
  .end

  let q: I64 = a / b
  let r: I64 = a % b
  if r == 0
    ret Result.Ok(value: q)
  .end

  # ceil: si a et b même signe, et r != 0 => q + 1
  if (r > 0 && b > 0) || (r < 0 && b < 0)
    ret Result.Ok(value: q + 1)
  .end
  ret Result.Ok(value: q)
.end

# -----------------------------------------------------------------------------
# Alignment helpers (power-of-two friendly)
# -----------------------------------------------------------------------------
# align_up/down: pour tailles/offsets
# - align doit être >0
# - align_up: plus petit multiple de align >= x
# - align_down: plus grand multiple <= x

fn align_down_u64(x: U64, align: U64) -> Result[U64, Error]
  if align == 0
    ret Result.Err(error: Error(code: E_INVALID_ARG, message: "align_down_u64: align=0"))
  .end
  ret Result.Ok(value: x - (x % align))
.end

fn align_up_u64(x: U64, align: U64) -> Result[U64, Error]
  if align == 0
    ret Result.Err(error: Error(code: E_INVALID_ARG, message: "align_up_u64: align=0"))
  .end
  let r: U64 = x % align
  if r == 0
    ret Result.Ok(value: x)
  .end
  let add: U64 = align - r
  let y: U64 = x + add
  if y < x
    ret Result.Err(error: Error(code: E_OVERFLOW, message: "align_up_u64: overflow"))
  .end
  ret Result.Ok(value: y)
.end

fn is_power_of_two_u64(x: U64) -> Bool
  if x == 0
    ret false
  .end
  ret (x & (x - 1)) == 0
.end

fn align_up_pow2_u64(x: U64, align: U64) -> Result[U64, Error]
  if align == 0
    ret Result.Err(error: Error(code: E_INVALID_ARG, message: "align_up_pow2_u64: align=0"))
  .end
  if !is_power_of_two_u64(align)
    ret Result.Err(error: Error(code: E_INVALID_ARG, message: "align_up_pow2_u64: align not pow2"))
  .end
  let mask: U64 = align - 1
  let y: U64 = (x + mask) & ~mask
  if y < x
    ret Result.Err(error: Error(code: E_OVERFLOW, message: "align_up_pow2_u64: overflow"))
  .end
  ret Result.Ok(value: y)
.end

fn align_down_pow2_u64(x: U64, align: U64) -> Result[U64, Error]
  if align == 0
    ret Result.Err(error: Error(code: E_INVALID_ARG, message: "align_down_pow2_u64: align=0"))
  .end
  if !is_power_of_two_u64(align)
    ret Result.Err(error: Error(code: E_INVALID_ARG, message: "align_down_pow2_u64: align not pow2"))
  .end
  let mask: U64 = align - 1
  ret Result.Ok(value: x & ~mask)
.end

# -----------------------------------------------------------------------------
# Midpoint helpers / Banker's rounding (ties-to-even) sans intrinsic
# -----------------------------------------------------------------------------
# is_halfway: frac(x) == 0.5 (exact) — difficile en float; on expose intrinsic.
# pour f64 on peut tester via bits si runtime propose.

fn is_halfway_f64(x: F64) -> Bool
  ret _intrinsic_is_halfway_f64(x)
.end

fn bankers_round_f64(x: F64) -> F64
  # tie to even
  ret round_even_f64(x)
.end

fn bankers_round_to_step_f64(x: F64, step: F64) -> Result[F64, Error]
  ret round_to_step_f64(x, step, RoundMode.Even)
.end

# -----------------------------------------------------------------------------
# ULP-aware: round up/down to representable neighbor
# -----------------------------------------------------------------------------

fn next_up_f64(x: F64) -> F64
  ret _intrinsic_nextup_f64(x)
.end

fn next_down_f64(x: F64) -> F64
  ret _intrinsic_nextdown_f64(x)
.end

fn round_up_to_representable_f64(x: F64) -> F64
  # si x est déjà integer exact, renvoie x, sinon ceil puis ajuste si overflow representable
  let c: F64 = ceil_f64(x)
  # si ceil(x) == x, ok
  if c == x
    ret x
  .end
  # c est entier exact, mais s'il est inf, garder
  ret c
.end

fn round_down_to_representable_f64(x: F64) -> F64
  let f: F64 = floor_f64(x)
  if f == x
    ret x
  .end
  ret f
.end

# -----------------------------------------------------------------------------
# Convenience: round to i64 (checked) via mode
# -----------------------------------------------------------------------------

fn round_to_i64_checked(x: F64, mode: RoundMode) -> Result[I64, Error]
  if _intrinsic_f64_is_nan(x)
    ret Result.Err(error: Error(code: E_INVALID_ARG, message: "round_to_i64_checked: NaN"))
  .end
  let r: F64 = round_f64_mode(x, mode)
  # bounds check
  if r < (I64_MIN as F64) || r > (I64_MAX as F64)
    ret Result.Err(error: Error(code: E_OVERFLOW, message: "round_to_i64_checked: out of range"))
  .end
  ret Result.Ok(value: r as I64)
.end

# -----------------------------------------------------------------------------
# Smoke tests
# -----------------------------------------------------------------------------

fn _t_div_rounding() -> void
  let a: Result[I64, Error] = div_floor_i64(-1, 5)
  assert(result_is_ok[I64, Error](a), "div_floor ok")
  assert_eq_i64(result_unwrap[I64, Error](a), -1, "floor(-1/5)=-1")

  let b: Result[I64, Error] = div_ceil_i64(-1, 5)
  assert(result_is_ok[I64, Error](b), "div_ceil ok")
  assert_eq_i64(result_unwrap[I64, Error](b), 0, "ceil(-1/5)=0")
.end

fn _t_align() -> void
  let r: Result[U64, Error] = align_up_u64(13, 8)
  assert(result_is_ok[U64, Error](r), "align_up ok")
  assert_eq_u64(result_unwrap[U64, Error](r), 16, "align_up(13,8)=16")
.end

fn rounding_smoke_tests() -> void
  _t_div_rounding()
  _t_align()
.end

# -----------------------------------------------------------------------------
# Intrinsics placeholders (à binder runtime/VM)
# -----------------------------------------------------------------------------

fn _intrinsic_floor_f32(x: F32) -> F32
  let _ = x
  ret x
.end

fn _intrinsic_ceil_f32(x: F32) -> F32
  let _ = x
  ret x
.end

fn _intrinsic_trunc_f32(x: F32) -> F32
  let _ = x
  ret x
.end

fn _intrinsic_round_away_f32(x: F32) -> F32
  let _ = x
  ret x
.end

fn _intrinsic_round_even_f32(x: F32) -> F32
  let _ = x
  ret x
.end

fn _intrinsic_floor_f64(x: F64) -> F64
  let _ = x
  ret x
.end

fn _intrinsic_ceil_f64(x: F64) -> F64
  let _ = x
  ret x
.end

fn _intrinsic_trunc_f64(x: F64) -> F64
  let _ = x
  ret x
.end

fn _intrinsic_round_away_f64(x: F64) -> F64
  let _ = x
  ret x
.end

fn _intrinsic_round_even_f64(x: F64) -> F64
  let _ = x
  ret x
.end

fn _intrinsic_pow10_f64(n: I32) -> F64
  # fallback naive: pow by repeated mult/div (slow) — binder recommandé
  let p: F64 = 1.0
  if n == 0
    ret 1.0
  .end
  if n > 0
    let i: I32 = 0
    loop
      if i >= n
        break
      .end
      p = p * 10.0
      i = i + 1
    .end
    ret p
  .end
  # n < 0
  let m: I32 = -n
  let i: I32 = 0
  loop
    if i >= m
      break
    .end
    p = p / 10.0
    i = i + 1
  .end
  ret p
.end

fn _intrinsic_f32_is_nan(x: F32) -> Bool
  let _ = x
  ret false
.end

fn _intrinsic_f64_is_nan(x: F64) -> Bool
  let _ = x
  ret false
.end

fn _intrinsic_is_halfway_f64(x: F64) -> Bool
  let _ = x
  ret false
.end

fn _intrinsic_nextup_f64(x: F64) -> F64
  let _ = x
  ret x
.end

fn _intrinsic_nextdown_f64(x: F64) -> F64
  let _ = x
  ret x
.end
