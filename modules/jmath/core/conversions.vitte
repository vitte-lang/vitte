# conversions.vitte
# -----------------------------------------------------------------------------
# Conversions 
# Objectif:
# - Conversions checked / saturating / wrapping / lossless / lossy
# - Parsing numérique (base 2..36) + format minimal (itoa/utoa/ftoa simple)
# - Conversions bytes <-> int (LE/BE), hex/base64 (base64 minimal)
# - Conversions string <-> bytes (UTF-8 view/copy via intrinsics)
# - Conversions Option/Result helpers
#
# Dépendances: core/basic.vitte (Error/Result/Option/assert, constants)
# Contrainte: pas d'accolades, blocs en .end
# -----------------------------------------------------------------------------

mod core.conversions

use core.basic
use core.compare

# -----------------------------------------------------------------------------
# Policies
# -----------------------------------------------------------------------------

enum Endian
  Little
  Big
.end

enum IntBase
  Bin
  Oct
  Dec
  Hex
.end

fn base_to_u32(base: IntBase) -> U32
  match base
    IntBase.Bin => ret 2
    IntBase.Oct => ret 8
    IntBase.Dec => ret 10
    IntBase.Hex => ret 16
  .end
.end

# -----------------------------------------------------------------------------
# Checked numeric casts
# -----------------------------------------------------------------------------

fn u64_to_u8_checked(x: U64) -> Result[U8, Error]
  if x <= U8_MAX as U64
    ret Result.Ok(value: x as U8)
  .end
  ret Result.Err(error: Error(code: E_OVERFLOW, message: "u64_to_u8_checked overflow"))
.end

fn u64_to_u16_checked(x: U64) -> Result[U16, Error]
  if x <= U16_MAX as U64
    ret Result.Ok(value: x as U16)
  .end
  ret Result.Err(error: Error(code: E_OVERFLOW, message: "u64_to_u16_checked overflow"))
.end

fn u64_to_u32_checked(x: U64) -> Result[U32, Error]
  if x <= U32_MAX as U64
    ret Result.Ok(value: x as U32)
  .end
  ret Result.Err(error: Error(code: E_OVERFLOW, message: "u64_to_u32_checked overflow"))
.end

fn u64_to_usz_checked(x: U64) -> Result[Usz, Error]
  # Usz dépend plateforme: binder runtime doit exposer USZ_MAX
  let max: U64 = _intrinsic_usz_max_as_u64()
  if x <= max
    ret Result.Ok(value: x as Usz)
  .end
  ret Result.Err(error: Error(code: E_OVERFLOW, message: "u64_to_usz_checked overflow"))
.end

fn i64_to_i8_checked(x: I64) -> Result[I8, Error]
  if x >= I8_MIN as I64 && x <= I8_MAX as I64
    ret Result.Ok(value: x as I8)
  .end
  ret Result.Err(error: Error(code: E_OVERFLOW, message: "i64_to_i8_checked overflow"))
.end

fn i64_to_i16_checked(x: I64) -> Result[I16, Error]
  if x >= I16_MIN as I64 && x <= I16_MAX as I64
    ret Result.Ok(value: x as I16)
  .end
  ret Result.Err(error: Error(code: E_OVERFLOW, message: "i64_to_i16_checked overflow"))
.end

fn i64_to_i32_checked(x: I64) -> Result[I32, Error]
  if x >= I32_MIN as I64 && x <= I32_MAX as I64
    ret Result.Ok(value: x as I32)
  .end
  ret Result.Err(error: Error(code: E_OVERFLOW, message: "i64_to_i32_checked overflow"))
.end

fn i64_to_isz_checked(x: I64) -> Result[Isz, Error]
  let min: I64 = _intrinsic_isz_min_as_i64()
  let max: I64 = _intrinsic_isz_max_as_i64()
  if x >= min && x <= max
    ret Result.Ok(value: x as Isz)
  .end
  ret Result.Err(error: Error(code: E_OVERFLOW, message: "i64_to_isz_checked overflow"))
.end

fn i64_to_u64_checked(x: I64) -> Result[U64, Error]
  if x < 0
    ret Result.Err(error: Error(code: E_INVALID_ARG, message: "i64_to_u64_checked negative"))
  .end
  ret Result.Ok(value: x as U64)
.end

fn u64_to_i64_checked(x: U64) -> Result[I64, Error]
  if x <= I64_MAX as U64
    ret Result.Ok(value: x as I64)
  .end
  ret Result.Err(error: Error(code: E_OVERFLOW, message: "u64_to_i64_checked overflow"))
.end

# -----------------------------------------------------------------------------
# Saturating casts
# -----------------------------------------------------------------------------

fn u64_to_u8_saturating(x: U64) -> U8
  if x > U8_MAX as U64
    ret U8_MAX
  .end
  ret x as U8
.end

fn u64_to_u16_saturating(x: U64) -> U16
  if x > U16_MAX as U64
    ret U16_MAX
  .end
  ret x as U16
.end

fn u64_to_u32_saturating(x: U64) -> U32
  if x > U32_MAX as U64
    ret U32_MAX
  .end
  ret x as U32
.end

fn u64_to_i64_saturating(x: U64) -> I64
  if x > I64_MAX as U64
    ret I64_MAX
  .end
  ret x as I64
.end

fn i64_to_u64_saturating(x: I64) -> U64
  if x < 0
    ret 0
  .end
  ret x as U64
.end

fn i64_to_i32_saturating(x: I64) -> I32
  if x < I32_MIN as I64
    ret I32_MIN
  .end
  if x > I32_MAX as I64
    ret I32_MAX
  .end
  ret x as I32
.end

# -----------------------------------------------------------------------------
# Wrapping (modulo) casts
# -----------------------------------------------------------------------------

fn u64_to_u32_wrapping(x: U64) -> U32
  ret x as U32
.end

fn i64_to_u32_wrapping(x: I64) -> U32
  ret x as U32
.end

fn u64_to_i32_wrapping(x: U64) -> I32
  ret x as I32
.end

# -----------------------------------------------------------------------------
# Checked arithmetic helpers (add/sub/mul/div)
# -----------------------------------------------------------------------------

fn add_u64_checked(a: U64, b: U64) -> Result[U64, Error]
  let c: U64 = a + b
  if c < a
    ret Result.Err(error: Error(code: E_OVERFLOW, message: "add_u64_checked overflow"))
  .end
  ret Result.Ok(value: c)
.end

fn sub_u64_checked(a: U64, b: U64) -> Result[U64, Error]
  if b > a
    ret Result.Err(error: Error(code: E_UNDERFLOW, message: "sub_u64_checked underflow"))
  .end
  ret Result.Ok(value: a - b)
.end

fn mul_u64_checked(a: U64, b: U64) -> Result[U64, Error]
  if a == 0 || b == 0
    ret Result.Ok(value: 0)
  .end
  let c: U64 = a * b
  if c / a != b
    ret Result.Err(error: Error(code: E_OVERFLOW, message: "mul_u64_checked overflow"))
  .end
  ret Result.Ok(value: c)
.end

fn div_u64_checked(a: U64, b: U64) -> Result[U64, Error]
  if b == 0
    ret Result.Err(error: Error(code: E_INVALID_ARG, message: "div_u64_checked div by zero"))
  .end
  ret Result.Ok(value: a / b)
.end

fn add_i64_checked(a: I64, b: I64) -> Result[I64, Error]
  # Overflow detection via intrinsics (safe)
  let ok: Bool = false
  let out: I64 = 0
  ok = _intrinsic_i64_add_overflow(a, b, &mut out) == false
  if !ok
    ret Result.Err(error: Error(code: E_OVERFLOW, message: "add_i64_checked overflow"))
  .end
  ret Result.Ok(value: out)
.end

fn sub_i64_checked(a: I64, b: I64) -> Result[I64, Error]
  let ok: Bool = false
  let out: I64 = 0
  ok = _intrinsic_i64_sub_overflow(a, b, &mut out) == false
  if !ok
    ret Result.Err(error: Error(code: E_OVERFLOW, message: "sub_i64_checked overflow"))
  .end
  ret Result.Ok(value: out)
.end

fn mul_i64_checked(a: I64, b: I64) -> Result[I64, Error]
  let ok: Bool = false
  let out: I64 = 0
  ok = _intrinsic_i64_mul_overflow(a, b, &mut out) == false
  if !ok
    ret Result.Err(error: Error(code: E_OVERFLOW, message: "mul_i64_checked overflow"))
  .end
  ret Result.Ok(value: out)
.end

fn div_i64_checked(a: I64, b: I64) -> Result[I64, Error]
  if b == 0
    ret Result.Err(error: Error(code: E_INVALID_ARG, message: "div_i64_checked div by zero"))
  .end
  if a == I64_MIN && b == -1
    ret Result.Err(error: Error(code: E_OVERFLOW, message: "div_i64_checked overflow"))
  .end
  ret Result.Ok(value: a / b)
.end

# -----------------------------------------------------------------------------
# Bytes <-> integers (LE/BE)
# -----------------------------------------------------------------------------

fn u16_from_le_bytes(b0: U8, b1: U8) -> U16
  ret (b0 as U16) | ((b1 as U16) << 8)
.end

fn u16_from_be_bytes(b0: U8, b1: U8) -> U16
  ret ((b0 as U16) << 8) | (b1 as U16)
.end

fn u32_from_le4(b: Bytes, off: Usz) -> Result[U32, Error]
  if _intrinsic_bytes_len(b) < off + 4
    ret Result.Err(error: Error(code: E_OUT_OF_RANGE, message: "u32_from_le4: out of range"))
  .end
  let b0: U8 = _intrinsic_bytes_get(b, off + 0)
  let b1: U8 = _intrinsic_bytes_get(b, off + 1)
  let b2: U8 = _intrinsic_bytes_get(b, off + 2)
  let b3: U8 = _intrinsic_bytes_get(b, off + 3)
  let v: U32 =
    (b0 as U32) |
    ((b1 as U32) << 8) |
    ((b2 as U32) << 16) |
    ((b3 as U32) << 24)
  ret Result.Ok(value: v)
.end

fn u32_from_be4(b: Bytes, off: Usz) -> Result[U32, Error]
  if _intrinsic_bytes_len(b) < off + 4
    ret Result.Err(error: Error(code: E_OUT_OF_RANGE, message: "u32_from_be4: out of range"))
  .end
  let b0: U8 = _intrinsic_bytes_get(b, off + 0)
  let b1: U8 = _intrinsic_bytes_get(b, off + 1)
  let b2: U8 = _intrinsic_bytes_get(b, off + 2)
  let b3: U8 = _intrinsic_bytes_get(b, off + 3)
  let v: U32 =
    ((b0 as U32) << 24) |
    ((b1 as U32) << 16) |
    ((b2 as U32) << 8) |
    (b3 as U32)
  ret Result.Ok(value: v)
.end

fn u64_from_le8(b: Bytes, off: Usz) -> Result[U64, Error]
  if _intrinsic_bytes_len(b) < off + 8
    ret Result.Err(error: Error(code: E_OUT_OF_RANGE, message: "u64_from_le8: out of range"))
  .end
  let v: U64 = 0
  let i: Usz = 0
  loop
    if i >= 8
      break
    .end
    v = v | ((_intrinsic_bytes_get(b, off + i) as U64) << (8 * i))
    i = i + 1
  .end
  ret Result.Ok(value: v)
.end

fn u64_from_be8(b: Bytes, off: Usz) -> Result[U64, Error]
  if _intrinsic_bytes_len(b) < off + 8
    ret Result.Err(error: Error(code: E_OUT_OF_RANGE, message: "u64_from_be8: out of range"))
  .end
  let v: U64 = 0
  let i: Usz = 0
  loop
    if i >= 8
      break
    .end
    v = (v << 8) | (_intrinsic_bytes_get(b, off + i) as U64)
    i = i + 1
  .end
  ret Result.Ok(value: v)
.end

# Write helpers via mutable bytes slice
fn u32_to_le4(dst: &mut [U8], off: Usz, x: U32) -> Result[void, Error]
  if _intrinsic_slice_len_u8(dst) < off + 4
    ret Result.Err(error: Error(code: E_OUT_OF_RANGE, message: "u32_to_le4: out of range"))
  .end
  _intrinsic_slice_set_u8(dst, off + 0, (x & 255) as U8)
  _intrinsic_slice_set_u8(dst, off + 1, ((x >> 8) & 255) as U8)
  _intrinsic_slice_set_u8(dst, off + 2, ((x >> 16) & 255) as U8)
  _intrinsic_slice_set_u8(dst, off + 3, ((x >> 24) & 255) as U8)
  ret Result.Ok(value: ())
.end

fn u32_to_be4(dst: &mut [U8], off: Usz, x: U32) -> Result[void, Error]
  if _intrinsic_slice_len_u8(dst) < off + 4
    ret Result.Err(error: Error(code: E_OUT_OF_RANGE, message: "u32_to_be4: out of range"))
  .end
  _intrinsic_slice_set_u8(dst, off + 0, ((x >> 24) & 255) as U8)
  _intrinsic_slice_set_u8(dst, off + 1, ((x >> 16) & 255) as U8)
  _intrinsic_slice_set_u8(dst, off + 2, ((x >> 8) & 255) as U8)
  _intrinsic_slice_set_u8(dst, off + 3, (x & 255) as U8)
  ret Result.Ok(value: ())
.end

# -----------------------------------------------------------------------------
# Digit helpers (0-9, a-z, A-Z) for base conversion
# -----------------------------------------------------------------------------

fn digit_val(c: U8) -> Option[U32]
  if c >= 48 && c <= 57
    ret Option.Some(value: (c - 48) as U32)
  .end
  if c >= 97 && c <= 122
    ret Option.Some(value: (c - 97 + 10) as U32)
  .end
  if c >= 65 && c <= 90
    ret Option.Some(value: (c - 65 + 10) as U32)
  .end
  ret Option.None
.end

fn digit_char(v: U32, upper: Bool) -> U8
  if v < 10
    ret (48 + v) as U8
  .end
  if upper
    ret (65 + (v - 10)) as U8
  .end
  ret (97 + (v - 10)) as U8
.end

# -----------------------------------------------------------------------------
# Parsing integers (u64/i64) base 2..36
# -----------------------------------------------------------------------------

fn parse_u64_base(s: Str, base: U32) -> Result[U64, Error]
  if base < 2 || base > 36
    ret Result.Err(error: Error(code: E_INVALID_ARG, message: "parse_u64_base: base out of range"))
  .end

  let bytes: Bytes = _intrinsic_str_as_bytes(s)
  let n: Usz = _intrinsic_bytes_len(bytes)
  if n == 0
    ret Result.Err(error: Error(code: E_FORMAT, message: "parse_u64_base: empty"))
  .end

  let i: Usz = 0
  let acc: U64 = 0

  loop
    if i >= n
      break
    .end
    let c: U8 = _intrinsic_bytes_get(bytes, i)
    if c == 95
      i = i + 1
      continue
    .end
    let dv: Option[U32] = digit_val(c)
    match dv
      Option.None =>
        ret Result.Err(error: Error(code: E_FORMAT, message: "parse_u64_base: invalid digit"))
      Option.Some(value: d) =>
        if d >= base
          ret Result.Err(error: Error(code: E_FORMAT, message: "parse_u64_base: digit out of base"))
        .end
        # acc = acc*base + d (checked)
        let mul: Result[U64, Error] = mul_u64_checked(acc, base as U64)
        if result_is_err[U64, Error](mul)
          ret Result.Err(error: Error(code: E_OVERFLOW, message: "parse_u64_base overflow (mul)"))
        .end
        let tmp: U64 = result_unwrap[U64, Error](mul)
        let add: Result[U64, Error] = add_u64_checked(tmp, d as U64)
        if result_is_err[U64, Error](add)
          ret Result.Err(error: Error(code: E_OVERFLOW, message: "parse_u64_base overflow (add)"))
        .end
        acc = result_unwrap[U64, Error](add)
    .end
    i = i + 1
  .end

  ret Result.Ok(value: acc)
.end

fn parse_i64_base(s: Str, base: U32) -> Result[I64, Error]
  if base < 2 || base > 36
    ret Result.Err(error: Error(code: E_INVALID_ARG, message: "parse_i64_base: base out of range"))
  .end
  if str_is_empty(s)
    ret Result.Err(error: Error(code: E_FORMAT, message: "parse_i64_base: empty"))
  .end

  # sign handling
  let bytes: Bytes = _intrinsic_str_as_bytes(s)
  let n: Usz = _intrinsic_bytes_len(bytes)
  let i: Usz = 0
  let neg: Bool = false

  if n > 0
    let c0: U8 = _intrinsic_bytes_get(bytes, 0)
    if c0 == 45
      neg = true
      i = 1
    .end
    else
      if c0 == 43
        i = 1
      .end
    .end
  .end

  if i >= n
    ret Result.Err(error: Error(code: E_FORMAT, message: "parse_i64_base: sign only"))
  .end

  # parse magnitude as u64
  let slice: Str = _intrinsic_str_substr_bytes(s, i, n - i)
  let mag: Result[U64, Error] = parse_u64_base(slice, base)
  if result_is_err[U64, Error](mag)
    ret Result.Err(error: result_unwrap_err[U64, Error](mag))
  .end
  let m: U64 = result_unwrap[U64, Error](mag)

  if !neg
    ret u64_to_i64_checked(m)
  .end

  # neg: allow magnitude up to I64_MAX+1
  if m > (I64_MAX as U64) + 1
    ret Result.Err(error: Error(code: E_OVERFLOW, message: "parse_i64_base: overflow"))
  .end
  if m == (I64_MAX as U64) + 1
    ret Result.Ok(value: I64_MIN)
  .end
  ret Result.Ok(value: -(m as I64))
.end

fn parse_u64(s: Str) -> Result[U64, Error]
  ret parse_u64_base(s, 10)
.end

fn parse_i64(s: Str) -> Result[I64, Error]
  ret parse_i64_base(s, 10)
.end

# -----------------------------------------------------------------------------
# Formatting integers (utoa/itoa) vers buffer bytes
# -----------------------------------------------------------------------------
# API: écrit dans dst, retourne la longueur écrite.
# dst doit être assez grand. (u64 max = 20 digits base10)

fn u64_to_str_base(dst: &mut [U8], x: U64, base: U32, upper: Bool) -> Result[Usz, Error]
  if base < 2 || base > 36
    ret Result.Err(error: Error(code: E_INVALID_ARG, message: "u64_to_str_base: base out of range"))
  .end
  let cap: Usz = _intrinsic_slice_len_u8(dst)
  if cap == 0
    ret Result.Err(error: Error(code: E_OUT_OF_RANGE, message: "u64_to_str_base: dst empty"))
  .end

  # build reversed
  let tmp: &mut [U8] = _intrinsic_tmp_buf_u8()
  let tcap: Usz = _intrinsic_slice_len_u8(tmp)
  let tlen: Usz = 0

  if x == 0
    if tcap < 1
      ret Result.Err(error: Error(code: E_NOMEM, message: "u64_to_str_base: tmp too small"))
    .end
    _intrinsic_slice_set_u8(tmp, 0, 48)
    tlen = 1
  .end
  else
    let v: U64 = x
    loop
      if v == 0
        break
      .end
      if tlen >= tcap
        ret Result.Err(error: Error(code: E_NOMEM, message: "u64_to_str_base: tmp overflow"))
      .end
      let d: U32 = (v % (base as U64)) as U32
      _intrinsic_slice_set_u8(tmp, tlen, digit_char(d, upper))
      tlen = tlen + 1
      v = v / (base as U64)
    .end
  .end

  if cap < tlen
    ret Result.Err(error: Error(code: E_OUT_OF_RANGE, message: "u64_to_str_base: dst too small"))
  .end

  # reverse copy
  let i: Usz = 0
  loop
    if i >= tlen
      break
    .end
    let c: U8 = _intrinsic_slice_get_u8(tmp, tlen - 1 - i)
    _intrinsic_slice_set_u8(dst, i, c)
    i = i + 1
  .end

  ret Result.Ok(value: tlen)
.end

fn i64_to_str_base(dst: &mut [U8], x: I64, base: U32, upper: Bool) -> Result[Usz, Error]
  if x >= 0
    return u64_to_str_base(dst, x as U64, base, upper)
  .end

  let cap: Usz = _intrinsic_slice_len_u8(dst)
  if cap < 2
    ret Result.Err(error: Error(code: E_OUT_OF_RANGE, message: "i64_to_str_base: dst too small"))
  .end

  _intrinsic_slice_set_u8(dst, 0, 45)

  # abs with I64_MIN case
  let mag: U64 = 0
  if x == I64_MIN
    mag = (I64_MAX as U64) + 1
  .end
  else
    mag = (-x) as U64
  .end

  let sub: &mut [U8] = _intrinsic_slice_sub_u8(dst, 1, cap - 1)
  let r: Result[Usz, Error] = u64_to_str_base(sub, mag, base, upper)
  if result_is_err[Usz, Error](r)
    ret Result.Err(error: result_unwrap_err[Usz, Error](r))
  .end

  ret Result.Ok(value: 1 + result_unwrap[Usz, Error](r))
.end

# Convenience wrappers base10/base16
fn u64_to_dec(dst: &mut [U8], x: U64) -> Result[Usz, Error]
  ret u64_to_str_base(dst, x, 10, false)
.end

fn i64_to_dec(dst: &mut [U8], x: I64) -> Result[Usz, Error]
  ret i64_to_str_base(dst, x, 10, false)
.end

fn u64_to_hex(dst: &mut [U8], x: U64, upper: Bool) -> Result[Usz, Error]
  ret u64_to_str_base(dst, x, 16, upper)
.end

# -----------------------------------------------------------------------------
# Float formatting/parsing (minimal)
# -----------------------------------------------------------------------------
# Pour du "max", on fournit:
# - to_string via runtime (fast)
# - parse via runtime (fast)
# - fallback minimal (scientific non garanti) si intrinsics indispo

fn f64_to_str(dst: &mut [U8], x: F64) -> Result[Usz, Error]
  # runtime fait le mieux (precision / rounding)
  ret _intrinsic_f64_to_str(dst, x)
.end

fn parse_f64(s: Str) -> Result[F64, Error]
  ret _intrinsic_parse_f64(s)
.end

# -----------------------------------------------------------------------------
# Hex encode/decode (bytes <-> hex string bytes)
# -----------------------------------------------------------------------------

fn hex_encoded_len(n: Usz) -> Usz
  ret n * 2
.end

fn hex_encode(dst: &mut [U8], src: Bytes, upper: Bool) -> Result[Usz, Error]
  let n: Usz = _intrinsic_bytes_len(src)
  let need: Usz = n * 2
  if _intrinsic_slice_len_u8(dst) < need
    ret Result.Err(error: Error(code: E_OUT_OF_RANGE, message: "hex_encode: dst too small"))
  .end

  let i: Usz = 0
  loop
    if i >= n
      break
    .end
    let b: U8 = _intrinsic_bytes_get(src, i)
    let hi: U32 = ((b >> 4) & 15) as U32
    let lo: U32 = (b & 15) as U32
    _intrinsic_slice_set_u8(dst, 2 * i + 0, digit_char(hi, upper))
    _intrinsic_slice_set_u8(dst, 2 * i + 1, digit_char(lo, upper))
    i = i + 1
  .end

  ret Result.Ok(value: need)
.end

fn hex_decode(dst: &mut [U8], src_hex: Str) -> Result[Usz, Error]
  let b: Bytes = _intrinsic_str_as_bytes(src_hex)
  let n: Usz = _intrinsic_bytes_len(b)
  if n % 2 != 0
    ret Result.Err(error: Error(code: E_FORMAT, message: "hex_decode: odd length"))
  .end
  let out_n: Usz = n / 2
  if _intrinsic_slice_len_u8(dst) < out_n
    ret Result.Err(error: Error(code: E_OUT_OF_RANGE, message: "hex_decode: dst too small"))
  .end

  let i: Usz = 0
  loop
    if i >= out_n
      break
    .end
    let c0: U8 = _intrinsic_bytes_get(b, 2 * i + 0)
    let c1: U8 = _intrinsic_bytes_get(b, 2 * i + 1)

    let v0: Option[U32] = digit_val(c0)
    let v1: Option[U32] = digit_val(c1)
    match v0
      Option.None => ret Result.Err(error: Error(code: E_FORMAT, message: "hex_decode: invalid digit"))
      Option.Some(value: d0) =>
        match v1
          Option.None => ret Result.Err(error: Error(code: E_FORMAT, message: "hex_decode: invalid digit"))
          Option.Some(value: d1) =>
            if d0 >= 16 || d1 >= 16
              ret Result.Err(error: Error(code: E_FORMAT, message: "hex_decode: digit out of range"))
            .end
            let out: U8 = ((d0 << 4) | d1) as U8
            _intrinsic_slice_set_u8(dst, i, out)
        .end
    .end
    i = i + 1
  .end

  ret Result.Ok(value: out_n)
.end

# -----------------------------------------------------------------------------
# Base64 (minimal, RFC 4648) — encode/decode
# -----------------------------------------------------------------------------

fn _b64_table() -> Bytes
  ret "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/" as Bytes
.end

fn b64_encoded_len(n: Usz) -> Usz
  # 4 * ceil(n/3)
  let q: Usz = n / 3
  let r: Usz = n % 3
  if r == 0
    ret q * 4
  .end
  ret (q + 1) * 4
.end

fn b64_encode(dst: &mut [U8], src: Bytes) -> Result[Usz, Error]
  let tab: Bytes = _b64_table()
  let n: Usz = _intrinsic_bytes_len(src)
  let need: Usz = b64_encoded_len(n)
  if _intrinsic_slice_len_u8(dst) < need
    ret Result.Err(error: Error(code: E_OUT_OF_RANGE, message: "b64_encode: dst too small"))
  .end

  let i: Usz = 0
  let o: Usz = 0
  loop
    if i >= n
      break
    .end

    let b0: U8 = _intrinsic_bytes_get(src, i)
    let b1: U8 = if i + 1 < n then _intrinsic_bytes_get(src, i + 1) else 0
    let b2: U8 = if i + 2 < n then _intrinsic_bytes_get(src, i + 2) else 0

    let triple: U32 = ((b0 as U32) << 16) | ((b1 as U32) << 8) | (b2 as U32)

    let c0: U8 = _intrinsic_bytes_get(tab, ((triple >> 18) & 63) as Usz)
    let c1: U8 = _intrinsic_bytes_get(tab, ((triple >> 12) & 63) as Usz)
    let c2: U8 = _intrinsic_bytes_get(tab, ((triple >> 6) & 63) as Usz)
    let c3: U8 = _intrinsic_bytes_get(tab, (triple & 63) as Usz)

    _intrinsic_slice_set_u8(dst, o + 0, c0)
    _intrinsic_slice_set_u8(dst, o + 1, c1)

    if i + 1 < n
      _intrinsic_slice_set_u8(dst, o + 2, c2)
    .end
    else
      _intrinsic_slice_set_u8(dst, o + 2, 61) # '='
    .end

    if i + 2 < n
      _intrinsic_slice_set_u8(dst, o + 3, c3)
    .end
    else
      _intrinsic_slice_set_u8(dst, o + 3, 61)
    .end

    i = i + 3
    o = o + 4
  .end

  ret Result.Ok(value: need)
.end

fn _b64_rev(c: U8) -> I32
  # returns 0..63, or -1 if invalid, -2 if '='
  if c == 61
    ret -2
  .end
  if c >= 65 && c <= 90
    ret (c - 65) as I32
  .end
  if c >= 97 && c <= 122
    ret (c - 97 + 26) as I32
  .end
  if c >= 48 && c <= 57
    ret (c - 48 + 52) as I32
  .end
  if c == 43
    ret 62
  .end
  if c == 47
    ret 63
  .end
  ret -1
.end

fn b64_decoded_max_len(n: Usz) -> Usz
  # floor(n/4)*3
  ret (n / 4) * 3
.end

fn b64_decode(dst: &mut [U8], src_b64: Str) -> Result[Usz, Error]
  let b: Bytes = _intrinsic_str_as_bytes(src_b64)
  let n: Usz = _intrinsic_bytes_len(b)
  if n == 0
    ret Result.Ok(value: 0)
  .end
  if n % 4 != 0
    ret Result.Err(error: Error(code: E_FORMAT, message: "b64_decode: len not multiple of 4"))
  .end

  let max_out: Usz = b64_decoded_max_len(n)
  if _intrinsic_slice_len_u8(dst) < max_out
    ret Result.Err(error: Error(code: E_OUT_OF_RANGE, message: "b64_decode: dst too small"))
  .end

  let i: Usz = 0
  let o: Usz = 0
  loop
    if i >= n
      break
    .end

    let c0: U8 = _intrinsic_bytes_get(b, i + 0)
    let c1: U8 = _intrinsic_bytes_get(b, i + 1)
    let c2: U8 = _intrinsic_bytes_get(b, i + 2)
    let c3: U8 = _intrinsic_bytes_get(b, i + 3)

    let v0: I32 = _b64_rev(c0)
    let v1: I32 = _b64_rev(c1)
    let v2: I32 = _b64_rev(c2)
    let v3: I32 = _b64_rev(c3)

    if v0 < 0 || v1 < 0
      ret Result.Err(error: Error(code: E_FORMAT, message: "b64_decode: invalid chars"))
    .end

    if v2 == -1 || v3 == -1
      ret Result.Err(error: Error(code: E_FORMAT, message: "b64_decode: invalid chars"))
    .end

    # '=' padding rules:
    # - '==' means 1 output byte
    # - '=' at c3 means 2 output bytes
    let pad2: Bool = (v2 == -2) && (v3 == -2)
    let pad1: Bool = (v2 != -2) && (v3 == -2)
    if v2 == -2 && v3 != -2
      ret Result.Err(error: Error(code: E_FORMAT, message: "b64_decode: invalid padding"))
    .end

    let a: U32 = (v0 as U32)
    let b1: U32 = (v1 as U32)
    let c: U32 = if v2 >= 0 then (v2 as U32) else 0
    let d: U32 = if v3 >= 0 then (v3 as U32) else 0

    let triple: U32 = (a << 18) | (b1 << 12) | (c << 6) | d

    _intrinsic_slice_set_u8(dst, o + 0, ((triple >> 16) & 255) as U8)
    if pad2
      o = o + 1
      ret Result.Ok(value: o)
    .end

    _intrinsic_slice_set_u8(dst, o + 1, ((triple >> 8) & 255) as U8)
    if pad1
      o = o + 2
      ret Result.Ok(value: o)
    .end

    _intrinsic_slice_set_u8(dst, o + 2, (triple & 255) as U8)
    o = o + 3

    i = i + 4
  .end

  ret Result.Ok(value: o)
.end

# -----------------------------------------------------------------------------
# String <-> Bytes
# -----------------------------------------------------------------------------

fn str_as_bytes(s: Str) -> Bytes
  ret _intrinsic_str_as_bytes(s)
.end

fn bytes_to_str_utf8_checked(b: Bytes) -> Result[Str, Error]
  ret _intrinsic_bytes_to_str_utf8_checked(b)
.end

fn bytes_to_str_lossy(b: Bytes) -> Str
  ret _intrinsic_bytes_to_str_lossy(b)
.end

# -----------------------------------------------------------------------------
# Option/Result conversion helpers
# -----------------------------------------------------------------------------

fn option_to_result[T](o: Option[T], err: Error) -> Result[T, Error]
  match o
    Option.Some(value: v) => ret Result.Ok(value: v)
    Option.None => ret Result.Err(error: err)
  .end
.end

fn result_to_option[T](r: Result[T, Error]) -> Option[T]
  match r
    Result.Ok(value: v) => ret Option.Some(value: v)
    Result.Err(error: _) => ret Option.None
  .end
.end

# -----------------------------------------------------------------------------
# Smoke tests
# -----------------------------------------------------------------------------

fn _t_parse_format_u64() -> void
  let r: Result[U64, Error] = parse_u64_base("ff", 16)
  assert(result_is_ok[U64, Error](r), "parse hex ok")
  assert_eq_u64(result_unwrap[U64, Error](r), 255, "ff=255")

  let buf: &mut [U8] = _intrinsic_tmp_buf_u8()
  let w: Result[Usz, Error] = u64_to_hex(buf, 255, false)
  assert(result_is_ok[Usz, Error](w), "utoa hex ok")
.end

fn _t_hex_roundtrip() -> void
  let src: Bytes = "abc" as Bytes
  let out: &mut [U8] = _intrinsic_tmp_buf_u8()
  let w: Result[Usz, Error] = hex_encode(out, src, false)
  assert(result_is_ok[Usz, Error](w), "hex encode ok")
.end

fn conversions_smoke_tests() -> void
  _t_parse_format_u64()
  _t_hex_roundtrip()
.end

# -----------------------------------------------------------------------------
# Intrinsics placeholders (à binder au runtime/VM)
# -----------------------------------------------------------------------------
# - usz/isize min/max
# - overflow ops i64
# - substr bytes
# - tmp buffers / slices ops
# - float parse/format
# - utf8 conversion
# -----------------------------------------------------------------------------

fn _intrinsic_usz_max_as_u64() -> U64
  ret 18446744073709551615
.end

fn _intrinsic_isz_min_as_i64() -> I64
  ret I64_MIN
.end

fn _intrinsic_isz_max_as_i64() -> I64
  ret I64_MAX
.end

fn _intrinsic_i64_add_overflow(a: I64, b: I64, out: &mut I64) -> Bool
  let _ = a
  let _ = b
  *out = 0
  ret false
.end

fn _intrinsic_i64_sub_overflow(a: I64, b: I64, out: &mut I64) -> Bool
  let _ = a
  let _ = b
  *out = 0
  ret false
.end

fn _intrinsic_i64_mul_overflow(a: I64, b: I64, out: &mut I64) -> Bool
  let _ = a
  let _ = b
  *out = 0
  ret false
.end

fn _intrinsic_str_substr_bytes(s: Str, off: Usz, len: Usz) -> Str
  let _ = s
  let _ = off
  let _ = len
  ret ""
.end

fn _intrinsic_slice_len_u8(xs: &mut [U8]) -> Usz
  let _ = xs
  ret 0
.end

fn _intrinsic_slice_get_u8(xs: &mut [U8], i: Usz) -> U8
  let _ = xs
  let _ = i
  ret 0
.end

fn _intrinsic_slice_set_u8(xs: &mut [U8], i: Usz, v: U8) -> void
  let _ = xs
  let _ = i
  let _ = v
.end

fn _intrinsic_slice_sub_u8(xs: &mut [U8], off: Usz, len: Usz) -> &mut [U8]
  let _ = xs
  let _ = off
  let _ = len
  ret xs
.end

fn _intrinsic_tmp_buf_u8() -> &mut [U8]
  # buffer scratch global / thread-local fourni par runtime
  unreachable()
.end

fn _intrinsic_f64_to_str(dst: &mut [U8], x: F64) -> Result[Usz, Error]
  let _ = dst
  let _ = x
  ret Result.Err(error: Error(code: E_UNSUPPORTED, message: "f64_to_str intrinsic not bound"))
.end

fn _intrinsic_parse_f64(s: Str) -> Result[F64, Error]
  let _ = s
  ret Result.Err(error: Error(code: E_UNSUPPORTED, message: "parse_f64 intrinsic not bound"))
.end

fn _intrinsic_bytes_to_str_utf8_checked(b: Bytes) -> Result[Str, Error]
  let _ = b
  ret Result.Err(error: Error(code: E_UNSUPPORTED, message: "bytes_to_str_utf8_checked intrinsic not bound"))
.end

fn _intrinsic_bytes_to_str_lossy(b: Bytes) -> Str
  let _ = b
  ret ""
.end
