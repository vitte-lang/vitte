# fma.vitte
# -----------------------------------------------------------------------------
# FMA / fused multiply-add — module ultra complet (max)
# Objectif:
# - API unifiée pour fma/fms/nfma + variantes float/double
# - FMA vectorisé "soft" (sur slices) + accumulateurs
# - FMA "exact" via intrinsics (si CPU/VM supporte) sinon fallback robuste
# - Helpers: Kahan / Neumaier / pairwise pour réduire l'erreur
# - Ops sur complex (si dispo) via structure locale minimale
#
# Dépendances: core/basic.vitte + core/compare.vitte (Ordering/total_cmp si utile)
# Contrainte: pas d'accolades, blocs en .end
# -----------------------------------------------------------------------------

mod core.fma

use core.basic
use core.compare

# -----------------------------------------------------------------------------
# Feature flags (runtime)
# -----------------------------------------------------------------------------

fn supports_fma_f32() -> Bool
  ret _intrinsic_supports_fma_f32()
.end

fn supports_fma_f64() -> Bool
  ret _intrinsic_supports_fma_f64()
.end

# -----------------------------------------------------------------------------
# Primitives FMA
# -----------------------------------------------------------------------------
# fma(a,b,c) = (a*b)+c en une seule opération arrondie (si support matériel)
# fallback = (a*b)+c (non fused), ou algos d'amélioration si dispo.

fn fma_f32(a: F32, b: F32, c: F32) -> F32
  if supports_fma_f32()
    ret _intrinsic_fma_f32(a, b, c)
  .end
  ret (a * b) + c
.end

fn fma_f64(a: F64, b: F64, c: F64) -> F64
  if supports_fma_f64()
    ret _intrinsic_fma_f64(a, b, c)
  .end
  ret (a * b) + c
.end

# fms(a,b,c) = (a*b)-c
fn fms_f32(a: F32, b: F32, c: F32) -> F32
  ret fma_f32(a, b, -c)
.end

fn fms_f64(a: F64, b: F64, c: F64) -> F64
  ret fma_f64(a, b, -c)
.end

# nfma(a,b,c) = -(a*b)+c
fn nfma_f32(a: F32, b: F32, c: F32) -> F32
  ret fma_f32(-a, b, c)
.end

fn nfma_f64(a: F64, b: F64, c: F64) -> F64
  ret fma_f64(-a, b, c)
.end

# -----------------------------------------------------------------------------
# Dot product (FMA) — vecteur
# -----------------------------------------------------------------------------

fn dot_f32(a: &[F32], b: &[F32]) -> Result[F32, Error]
  let na: Usz = _intrinsic_slice_len_f32(a)
  let nb: Usz = _intrinsic_slice_len_f32(b)
  if na != nb
    ret Result.Err(error: Error(code: E_INVALID_ARG, message: "dot_f32: length mismatch"))
  .end
  let acc: F32 = 0.0
  let i: Usz = 0
  loop
    if i >= na
      break
    .end
    let x: F32 = _intrinsic_slice_get_f32(a, i)
    let y: F32 = _intrinsic_slice_get_f32(b, i)
    acc = fma_f32(x, y, acc)
    i = i + 1
  .end
  ret Result.Ok(value: acc)
.end

fn dot_f64(a: &[F64], b: &[F64]) -> Result[F64, Error]
  let na: Usz = _intrinsic_slice_len_f64(a)
  let nb: Usz = _intrinsic_slice_len_f64(b)
  if na != nb
    ret Result.Err(error: Error(code: E_INVALID_ARG, message: "dot_f64: length mismatch"))
  .end
  let acc: F64 = 0.0
  let i: Usz = 0
  loop
    if i >= na
      break
    .end
    let x: F64 = _intrinsic_slice_get_f64(a, i)
    let y: F64 = _intrinsic_slice_get_f64(b, i)
    acc = fma_f64(x, y, acc)
    i = i + 1
  .end
  ret Result.Ok(value: acc)
.end

# -----------------------------------------------------------------------------
# Polynomial evaluation (Horner) — FMA friendly
# -----------------------------------------------------------------------------
# coeffs: a0 + a1*x + a2*x^2 + ...
# Horner: (((an*x + a(n-1))*x + ... )*x + a0)
#
# Ici: coeffs[0]=a0 ... coeffs[n-1]=a(n-1)

fn poly_eval_f32(x: F32, coeffs: &[F32]) -> F32
  let n: Usz = _intrinsic_slice_len_f32(coeffs)
  if n == 0
    ret 0.0
  .end
  let acc: F32 = _intrinsic_slice_get_f32(coeffs, n - 1)
  let i: Usz = n - 1
  loop
    if i == 0
      break
    .end
    i = i - 1
    let a: F32 = _intrinsic_slice_get_f32(coeffs, i)
    acc = fma_f32(acc, x, a)
  .end
  ret acc
.end

fn poly_eval_f64(x: F64, coeffs: &[F64]) -> F64
  let n: Usz = _intrinsic_slice_len_f64(coeffs)
  if n == 0
    ret 0.0
  .end
  let acc: F64 = _intrinsic_slice_get_f64(coeffs, n - 1)
  let i: Usz = n - 1
  loop
    if i == 0
      break
    .end
    i = i - 1
    let a: F64 = _intrinsic_slice_get_f64(coeffs, i)
    acc = fma_f64(acc, x, a)
  .end
  ret acc
.end

# -----------------------------------------------------------------------------
# Accumulation: Kahan / Neumaier (reduce error)
# -----------------------------------------------------------------------------

struct KahanF32
  sum: F32
  c: F32
.end

fn kahan_f32_new() -> KahanF32
  ret KahanF32(sum: 0.0, c: 0.0)
.end

fn kahan_f32_add(k: &mut KahanF32, x: F32) -> void
  let y: F32 = x - k.c
  let t: F32 = k.sum + y
  k.c = (t - k.sum) - y
  k.sum = t
.end

fn kahan_f32_value(k: KahanF32) -> F32
  ret k.sum
.end

struct KahanF64
  sum: F64
  c: F64
.end

fn kahan_f64_new() -> KahanF64
  ret KahanF64(sum: 0.0, c: 0.0)
.end

fn kahan_f64_add(k: &mut KahanF64, x: F64) -> void
  let y: F64 = x - k.c
  let t: F64 = k.sum + y
  k.c = (t - k.sum) - y
  k.sum = t
.end

fn kahan_f64_value(k: KahanF64) -> F64
  ret k.sum
.end

struct NeumaierF64
  sum: F64
  c: F64
.end

fn neumaier_f64_new() -> NeumaierF64
  ret NeumaierF64(sum: 0.0, c: 0.0)
.end

fn neumaier_f64_add(nm: &mut NeumaierF64, x: F64) -> void
  let t: F64 = nm.sum + x
  if abs_f64(nm.sum) >= abs_f64(x)
    nm.c = nm.c + ((nm.sum - t) + x)
  .end
  else
    nm.c = nm.c + ((x - t) + nm.sum)
  .end
  nm.sum = t
.end

fn neumaier_f64_value(nm: NeumaierF64) -> F64
  ret nm.sum + nm.c
.end

fn abs_f64(x: F64) -> F64
  if x >= 0.0
    ret x
  .end
  ret -x
.end

# -----------------------------------------------------------------------------
# Pairwise sum (réduction en arbre) — stable et rapide
# -----------------------------------------------------------------------------

fn pairwise_sum_f64(xs: &[F64]) -> F64
  let n: Usz = _intrinsic_slice_len_f64(xs)
  if n == 0
    ret 0.0
  .end
  ret _pairwise_sum_f64(xs, 0, n)
.end

fn _pairwise_sum_f64(xs: &[F64], off: Usz, len: Usz) -> F64
  if len == 0
    ret 0.0
  .end
  if len == 1
    ret _intrinsic_slice_get_f64(xs, off)
  .end
  if len == 2
    ret _intrinsic_slice_get_f64(xs, off) + _intrinsic_slice_get_f64(xs, off + 1)
  .end
  let mid: Usz = len / 2
  let a: F64 = _pairwise_sum_f64(xs, off, mid)
  let b: F64 = _pairwise_sum_f64(xs, off + mid, len - mid)
  ret a + b
.end

# -----------------------------------------------------------------------------
# FMA-based reduce: sum(x_i * y_i) with compensated accumulation
# -----------------------------------------------------------------------------

fn dot_f64_kahan(a: &[F64], b: &[F64]) -> Result[F64, Error]
  let na: Usz = _intrinsic_slice_len_f64(a)
  let nb: Usz = _intrinsic_slice_len_f64(b)
  if na != nb
    ret Result.Err(error: Error(code: E_INVALID_ARG, message: "dot_f64_kahan: length mismatch"))
  .end

  let k: KahanF64 = kahan_f64_new()
  let i: Usz = 0
  loop
    if i >= na
      break
    .end
    let x: F64 = _intrinsic_slice_get_f64(a, i)
    let y: F64 = _intrinsic_slice_get_f64(b, i)
    let p: F64 = fma_f64(x, y, 0.0)
    kahan_f64_add(&mut k, p)
    i = i + 1
  .end
  ret Result.Ok(value: kahan_f64_value(k))
.end

# -----------------------------------------------------------------------------
# Complex (local minimal)
# -----------------------------------------------------------------------------

struct ComplexF64
  re: F64
  im: F64
.end

fn c64_new(re: F64, im: F64) -> ComplexF64
  ret ComplexF64(re: re, im: im)
.end

fn c64_add(a: ComplexF64, b: ComplexF64) -> ComplexF64
  ret ComplexF64(re: a.re + b.re, im: a.im + b.im)
.end

fn c64_mul_fma(a: ComplexF64, b: ComplexF64) -> ComplexF64
  # (ar + i ai) * (br + i bi) =
  # re = ar*br - ai*bi
  # im = ar*bi + ai*br
  let re: F64 = fms_f64(a.re, b.re, a.im * b.im)
  let im: F64 = fma_f64(a.re, b.im, a.im * b.re)
  ret ComplexF64(re: re, im: im)
.end

fn c64_mul_fma_fused(a: ComplexF64, b: ComplexF64) -> ComplexF64
  # Utilise uniquement des fma/fms/nfma
  let re: F64 = fms_f64(a.re, b.re, fma_f64(a.im, b.im, 0.0))
  let im: F64 = fma_f64(a.re, b.im, fma_f64(a.im, b.re, 0.0))
  ret ComplexF64(re: re, im: im)
.end

# -----------------------------------------------------------------------------
# Matrix multiply (2x2) FMA — exemple micro-kernel
# -----------------------------------------------------------------------------

struct Mat2F64
  a00: F64
  a01: F64
  a10: F64
  a11: F64
.end

fn mat2_mul_fma(x: Mat2F64, y: Mat2F64) -> Mat2F64
  # c00 = x00*y00 + x01*y10
  let c00: F64 = fma_f64(x.a00, y.a00, x.a01 * y.a10)
  let c01: F64 = fma_f64(x.a00, y.a01, x.a01 * y.a11)
  let c10: F64 = fma_f64(x.a10, y.a00, x.a11 * y.a10)
  let c11: F64 = fma_f64(x.a10, y.a01, x.a11 * y.a11)
  ret Mat2F64(a00: c00, a01: c01, a10: c10, a11: c11)
.end

# -----------------------------------------------------------------------------
# Error analysis helpers
# -----------------------------------------------------------------------------

fn ulp_diff_f64(a: F64, b: F64) -> U64
  # Compare via total order transform (comme total_cmp) + abs diff
  let ua: U64 = _intrinsic_f64_to_bits(a)
  let ub: U64 = _intrinsic_f64_to_bits(b)
  let ta: U64 = _total_key_f64(ua)
  let tb: U64 = _total_key_f64(ub)
  if ta >= tb
    ret ta - tb
  .end
  ret tb - ta
.end

fn _total_key_f64(u: U64) -> U64
  let s: U64 = u >> 63
  let m: U64 = if s == 1 then 18446744073709551615 else 9223372036854775808
  ret u ^ m
.end

fn approx_eq_f64(a: F64, b: F64, abs_tol: F64, rel_tol: F64) -> Bool
  let diff: F64 = abs_f64(a - b)
  if diff <= abs_tol
    ret true
  .end
  let ma: F64 = abs_f64(a)
  let mb: F64 = abs_f64(b)
  let m: F64 = if ma > mb then ma else mb
  ret diff <= (m * rel_tol)
.end

# -----------------------------------------------------------------------------
# Smoke tests
# -----------------------------------------------------------------------------

fn _t_fma_basic() -> void
  let x: F64 = fma_f64(2.0, 3.0, 4.0)
  assert(approx_eq_f64(x, 10.0, 0.0, 0.0), "fma_f64 2*3+4=10")
.end

fn _t_poly() -> void
  # 1 + 2x + 3x^2 at x=2 => 1+4+12=17
  let coeffs: &[F64] = _intrinsic_test_coeffs_f64()
  let y: F64 = poly_eval_f64(2.0, coeffs)
  assert(approx_eq_f64(y, 17.0, 1e-12, 0.0), "poly_eval")
.end

fn _t_dot() -> void
  let a: &[F64] = _intrinsic_test_vec_a_f64()
  let b: &[F64] = _intrinsic_test_vec_b_f64()
  let r: Result[F64, Error] = dot_f64(a, b)
  assert(result_is_ok[F64, Error](r), "dot ok")
.end

fn fma_smoke_tests() -> void
  _t_fma_basic()
  _t_poly()
  _t_dot()
.end

# -----------------------------------------------------------------------------
# Intrinsics placeholders (à binder au runtime/VM)
# -----------------------------------------------------------------------------

fn _intrinsic_supports_fma_f32() -> Bool
  ret false
.end

fn _intrinsic_supports_fma_f64() -> Bool
  ret false
.end

fn _intrinsic_fma_f32(a: F32, b: F32, c: F32) -> F32
  let _ = a
  let _ = b
  let _ = c
  ret (a * b) + c
.end

fn _intrinsic_fma_f64(a: F64, b: F64, c: F64) -> F64
  let _ = a
  let _ = b
  let _ = c
  ret (a * b) + c
.end

fn _intrinsic_slice_len_f32(xs: &[F32]) -> Usz
  let _ = xs
  ret 0
.end

fn _intrinsic_slice_get_f32(xs: &[F32], i: Usz) -> F32
  let _ = xs
  let _ = i
  ret 0.0
.end

fn _intrinsic_slice_len_f64(xs: &[F64]) -> Usz
  let _ = xs
  ret 0
.end

fn _intrinsic_slice_get_f64(xs: &[F64], i: Usz) -> F64
  let _ = xs
  let _ = i
  ret 0.0
.end

fn _intrinsic_f64_to_bits(x: F64) -> U64
  let _ = x
  ret 0
.end

fn _intrinsic_test_coeffs_f64() -> &[F64]
  # doit renvoyer [1,2,3] pour tests
  unreachable()
.end

fn _intrinsic_test_vec_a_f64() -> &[F64]
  unreachable()
.end

fn _intrinsic_test_vec_b_f64() -> &[F64]
  unreachable()
.end
