# classify.vitte
# -----------------------------------------------------------------------------
# Utilities de classification (catégorisation) :
# - classification de scalaires (i64/u64/f64) par intervalles
# - classification de chaînes (préfixe/suffixe/contains/regex-free)
# - classification de bytes/chars (ASCII)
# - helpers pour "best match" et scores
#
# Dépendances: core/basic.vitte (Error, Result, Option, assert, etc.)
# Contrainte: pas d'accolades, blocs en .end
# -----------------------------------------------------------------------------

mod core.classify

use core.basic

# -----------------------------------------------------------------------------
# Types
# -----------------------------------------------------------------------------

type Label = string

struct Hit
  label: Label
  score: I64
.end

struct RangeI64
  lo: I64
  hi: I64          # inclusif
  label: Label
.end

struct RangeU64
  lo: U64
  hi: U64          # inclusif
  label: Label
.end

struct RangeF64
  lo: F64
  hi: F64          # inclusif
  label: Label
.end

enum MatchMode
  Exact
  Prefix
  Suffix
  Contains
.end

struct RuleStr
  mode: MatchMode
  pattern: Str
  label: Label
  score: I64
.end

# -----------------------------------------------------------------------------
# Comparateurs / helpers
# -----------------------------------------------------------------------------

fn hit_new(label: Label, score: I64) -> Hit
  ret Hit(label: label, score: score)
.end

fn hit_better(a: Hit, b: Hit) -> Bool
  # true si a "gagne" contre b
  if a.score > b.score
    ret true
  .end
  if a.score < b.score
    ret false
  .end
  # tie-breaker: label lexicographique (stable)
  ret _intrinsic_str_cmp(a.label, b.label) < 0
.end

fn best_hit_opt(a: Option[Hit], b: Hit) -> Option[Hit]
  match a
    Option.None => ret Option.Some(value: b)
    Option.Some(value: h) =>
      if hit_better(b, h)
        ret Option.Some(value: b)
      .end
      ret Option.Some(value: h)
  .end
.end

# -----------------------------------------------------------------------------
# ASCII classification (Char / U8)
# -----------------------------------------------------------------------------

fn is_ascii_u8(x: U8) -> Bool
  ret x <= 127
.end

fn is_ascii_alpha_u8(x: U8) -> Bool
  ret (x >= 65 && x <= 90) || (x >= 97 && x <= 122)
.end

fn is_ascii_digit_u8(x: U8) -> Bool
  ret x >= 48 && x <= 57
.end

fn is_ascii_alnum_u8(x: U8) -> Bool
  ret is_ascii_alpha_u8(x) || is_ascii_digit_u8(x)
.end

fn is_ascii_space_u8(x: U8) -> Bool
  # ' ' \t \n \r \v \f
  ret x == 32 || x == 9 || x == 10 || x == 13 || x == 11 || x == 12
.end

fn is_ascii_hex_u8(x: U8) -> Bool
  if is_ascii_digit_u8(x)
    ret true
  .end
  ret (x >= 65 && x <= 70) || (x >= 97 && x <= 102)
.end

fn ascii_class_u8(x: U8) -> Label
  if !is_ascii_u8(x)
    ret "non-ascii"
  .end
  if is_ascii_space_u8(x)
    ret "space"
  .end
  if is_ascii_digit_u8(x)
    ret "digit"
  .end
  if is_ascii_alpha_u8(x)
    if x >= 65 && x <= 90
      ret "alpha-upper"
    .end
    ret "alpha-lower"
  .end
  ret "punct"
.end

# -----------------------------------------------------------------------------
# Range classification (I64/U64/F64)
# -----------------------------------------------------------------------------

fn range_i64_is_valid(r: RangeI64) -> Bool
  ret r.lo <= r.hi
.end

fn range_u64_is_valid(r: RangeU64) -> Bool
  ret r.lo <= r.hi
.end

fn range_f64_is_valid(r: RangeF64) -> Bool
  ret r.lo <= r.hi
.end

fn classify_i64_by_ranges(x: I64, ranges: &[RangeI64]) -> Option[Label]
  let i: Usz = 0
  let n: Usz = _intrinsic_slice_len_ranges_i64(ranges)
  loop
    if i >= n
      break
    .end
    let r: RangeI64 = _intrinsic_slice_get_ranges_i64(ranges, i)
    if x >= r.lo && x <= r.hi
      ret Option.Some(value: r.label)
    .end
    i = i + 1
  .end
  ret Option.None
.end

fn classify_u64_by_ranges(x: U64, ranges: &[RangeU64]) -> Option[Label]
  let i: Usz = 0
  let n: Usz = _intrinsic_slice_len_ranges_u64(ranges)
  loop
    if i >= n
      break
    .end
    let r: RangeU64 = _intrinsic_slice_get_ranges_u64(ranges, i)
    if x >= r.lo && x <= r.hi
      ret Option.Some(value: r.label)
    .end
    i = i + 1
  .end
  ret Option.None
.end

fn classify_f64_by_ranges(x: F64, ranges: &[RangeF64]) -> Option[Label]
  let i: Usz = 0
  let n: Usz = _intrinsic_slice_len_ranges_f64(ranges)
  loop
    if i >= n
      break
    .end
    let r: RangeF64 = _intrinsic_slice_get_ranges_f64(ranges, i)
    if x >= r.lo && x <= r.hi
      ret Option.Some(value: r.label)
    .end
    i = i + 1
  .end
  ret Option.None
.end

fn validate_ranges_i64(ranges: &[RangeI64]) -> Result[void, Error]
  let i: Usz = 0
  let n: Usz = _intrinsic_slice_len_ranges_i64(ranges)
  loop
    if i >= n
      break
    .end
    let r: RangeI64 = _intrinsic_slice_get_ranges_i64(ranges, i)
    if !range_i64_is_valid(r)
      ret Result.Err(error: Error(code: E_INVALID_ARG, message: "invalid i64 range: lo > hi"))
    .end
    i = i + 1
  .end
  ret Result.Ok(value: ())
.end

fn validate_ranges_u64(ranges: &[RangeU64]) -> Result[void, Error]
  let i: Usz = 0
  let n: Usz = _intrinsic_slice_len_ranges_u64(ranges)
  loop
    if i >= n
      break
    .end
    let r: RangeU64 = _intrinsic_slice_get_ranges_u64(ranges, i)
    if !range_u64_is_valid(r)
      ret Result.Err(error: Error(code: E_INVALID_ARG, message: "invalid u64 range: lo > hi"))
    .end
    i = i + 1
  .end
  ret Result.Ok(value: ())
.end

fn validate_ranges_f64(ranges: &[RangeF64]) -> Result[void, Error]
  let i: Usz = 0
  let n: Usz = _intrinsic_slice_len_ranges_f64(ranges)
  loop
    if i >= n
      break
    .end
    let r: RangeF64 = _intrinsic_slice_get_ranges_f64(ranges, i)
    if !range_f64_is_valid(r)
      ret Result.Err(error: Error(code: E_INVALID_ARG, message: "invalid f64 range: lo > hi"))
    .end
    i = i + 1
  .end
  ret Result.Ok(value: ())
.end

# -----------------------------------------------------------------------------
# String rules classification (sans regex)
# -----------------------------------------------------------------------------

fn str_has_prefix(s: Str, prefix: Str) -> Bool
  ret _intrinsic_str_has_prefix(s, prefix)
.end

fn str_has_suffix(s: Str, suffix: Str) -> Bool
  ret _intrinsic_str_has_suffix(s, suffix)
.end

fn str_contains(s: Str, needle: Str) -> Bool
  ret _intrinsic_str_contains(s, needle)
.end

fn str_match(mode: MatchMode, s: Str, pat: Str) -> Bool
  match mode
    MatchMode.Exact => ret str_eq(s, pat)
    MatchMode.Prefix => ret str_has_prefix(s, pat)
    MatchMode.Suffix => ret str_has_suffix(s, pat)
    MatchMode.Contains => ret str_contains(s, pat)
  .end
.end

fn classify_str_best(s: Str, rules: &[RuleStr]) -> Option[Hit]
  let i: Usz = 0
  let n: Usz = _intrinsic_slice_len_rules_str(rules)
  let best: Option[Hit] = Option.None

  loop
    if i >= n
      break
    .end
    let r: RuleStr = _intrinsic_slice_get_rules_str(rules, i)
    if str_match(r.mode, s, r.pattern)
      let h: Hit = hit_new(r.label, r.score)
      best = best_hit_opt(best, h)
    .end
    i = i + 1
  .end

  ret best
.end

fn classify_str_label(s: Str, rules: &[RuleStr], default_label: Label) -> Label
  let opt: Option[Hit] = classify_str_best(s, rules)
  match opt
    Option.Some(value: h) => ret h.label
    Option.None => ret default_label
  .end
.end

# -----------------------------------------------------------------------------
# Score helpers (ex: similarité simple)
# -----------------------------------------------------------------------------

fn score_prefix_len(a: Str, b: Str) -> I64
  # longueur du préfixe commun (ASCII/bytes)
  let ba: Bytes = _intrinsic_str_as_bytes(a)
  let bb: Bytes = _intrinsic_str_as_bytes(b)
  let na: Usz = _intrinsic_bytes_len(ba)
  let nb: Usz = _intrinsic_bytes_len(bb)
  let n: Usz = if na < nb then na else nb

  let i: Usz = 0
  loop
    if i >= n
      break
    .end
    if _intrinsic_bytes_get(ba, i) != _intrinsic_bytes_get(bb, i)
      break
    .end
    i = i + 1
  .end

  ret i as I64
.end

fn score_contains_bonus(s: Str, needle: Str, bonus: I64) -> I64
  if str_contains(s, needle)
    ret bonus
  .end
  ret 0
.end

# -----------------------------------------------------------------------------
# “Classifier” générique par hits (facilite pipes)
# -----------------------------------------------------------------------------

struct Classifier
  # règles string (optionnel)
  str_rules: &[RuleStr]
  str_default: Label

  # ranges numériques (optionnels)
  i64_ranges: &[RangeI64]
  u64_ranges: &[RangeU64]
  f64_ranges: &[RangeF64]
.end

fn classifier_new(
  str_rules: &[RuleStr],
  str_default: Label,
  i64_ranges: &[RangeI64],
  u64_ranges: &[RangeU64],
  f64_ranges: &[RangeF64]
) -> Classifier
  ret Classifier(
    str_rules: str_rules,
    str_default: str_default,
    i64_ranges: i64_ranges,
    u64_ranges: u64_ranges,
    f64_ranges: f64_ranges
  )
.end

fn classifier_validate(c: Classifier) -> Result[void, Error]
  let a: Result[void, Error] = validate_ranges_i64(c.i64_ranges)
  if result_is_err[void, Error](a)
    ret a
  .end
  let b: Result[void, Error] = validate_ranges_u64(c.u64_ranges)
  if result_is_err[void, Error](b)
    ret b
  .end
  let d: Result[void, Error] = validate_ranges_f64(c.f64_ranges)
  if result_is_err[void, Error](d)
    ret d
  .end
  ret Result.Ok(value: ())
.end

fn classifier_classify_str(c: Classifier, s: Str) -> Label
  ret classify_str_label(s, c.str_rules, c.str_default)
.end

fn classifier_classify_i64(c: Classifier, x: I64) -> Option[Label]
  ret classify_i64_by_ranges(x, c.i64_ranges)
.end

fn classifier_classify_u64(c: Classifier, x: U64) -> Option[Label]
  ret classify_u64_by_ranges(x, c.u64_ranges)
.end

fn classifier_classify_f64(c: Classifier, x: F64) -> Option[Label]
  ret classify_f64_by_ranges(x, c.f64_ranges)
.end

# -----------------------------------------------------------------------------
# Smoke tests
# -----------------------------------------------------------------------------

fn _t_ascii() -> void
  assert(str_eq(ascii_class_u8(48), "digit"), "ascii digit")
  assert(str_eq(ascii_class_u8(65), "alpha-upper"), "ascii upper")
  assert(str_eq(ascii_class_u8(97), "alpha-lower"), "ascii lower")
  assert(str_eq(ascii_class_u8(32), "space"), "ascii space")
.end

fn _t_score() -> void
  assert_eq_i64(score_prefix_len("abcd", "abZZ"), 2, "prefix score")
  assert_eq_i64(score_contains_bonus("hello world", "world", 10), 10, "contains bonus")
  assert_eq_i64(score_contains_bonus("hello", "world", 10), 0, "contains bonus none")
.end

fn classify_smoke_tests() -> void
  _t_ascii()
  _t_score()
.end

# -----------------------------------------------------------------------------
# Intrinsics placeholders (à binder)
# -----------------------------------------------------------------------------

fn _intrinsic_str_cmp(a: Str, b: Str) -> I32
  let _ = a
  let _ = b
  ret 0
.end

fn _intrinsic_str_has_prefix(s: Str, prefix: Str) -> Bool
  let _ = s
  let _ = prefix
  ret false
.end

fn _intrinsic_str_has_suffix(s: Str, suffix: Str) -> Bool
  let _ = s
  let _ = suffix
  ret false
.end

fn _intrinsic_str_contains(s: Str, needle: Str) -> Bool
  let _ = s
  let _ = needle
  ret false
.end

fn _intrinsic_slice_len_rules_str(rules: &[RuleStr]) -> Usz
  let _ = rules
  ret 0
.end

fn _intrinsic_slice_get_rules_str(rules: &[RuleStr], i: Usz) -> RuleStr
  let _ = rules
  let _ = i
  ret RuleStr(mode: MatchMode.Exact, pattern: "", label: "", score: 0)
.end

fn _intrinsic_slice_len_ranges_i64(ranges: &[RangeI64]) -> Usz
  let _ = ranges
  ret 0
.end

fn _intrinsic_slice_get_ranges_i64(ranges: &[RangeI64], i: Usz) -> RangeI64
  let _ = ranges
  let _ = i
  ret RangeI64(lo: 0, hi: 0, label: "")
.end

fn _intrinsic_slice_len_ranges_u64(ranges: &[RangeU64]) -> Usz
  let _ = ranges
  ret 0
.end

fn _intrinsic_slice_get_ranges_u64(ranges: &[RangeU64], i: Usz) -> RangeU64
  let _ = ranges
  let _ = i
  ret RangeU64(lo: 0, hi: 0, label: "")
.end

fn _intrinsic_slice_len_ranges_f64(ranges: &[RangeF64]) -> Usz
  let _ = ranges
  ret 0
.end

fn _intrinsic_slice_get_ranges_f64(ranges: &[RangeF64], i: Usz) -> RangeF64
  let _ = ranges
  let _ = i
  ret RangeF64(lo: 0.0, hi: 0.0, label: "")
.end
