// File: exp_log/pow.vitte
// Module: exp_log.pow
//
// Objectif:
//   - pow(x, y) f64 + f32
//   - powi(x, n) entier
//   - cbrt, sqrt wrappers (si core ne les expose pas)
//   - gestion IEEE-754: NaN, ±Inf, x=0, x<0 avec exposant entier, etc.
//   - impl "portable": pow(x,y)=exp(y*log(x)) avec chemins spéciaux
//
// Dépendances:
//   - core/basic.vitte : isnan/isinf/isfinite/abs/copysign/floor/trunc/scalb, sqrt si dispo, f64 bits helpers
//   - exp_log/exp.vitte : exp
//   - exp_log/log.vitte : log, log1p (optionnel)
//
// Notes:
//   - Pour x<0 et y non-entier => NaN.
//   - Pour y entier => powi (fast exponentiation) pour stabilité et perf.
//   - Pour y proche d’un entier, on peut “snap” si distance < eps*|y|.
//
// Conventions: blocs .end

module exp_log.pow

use core.basic as basic
use exp_log.exp as expmod
use exp_log.log as logmod

const LN2: f64 = 0.693147180559945309417232121458176568

// -----------------------------
// API publique
// -----------------------------
pub fn pow(x: f64, y: f64) -> f64
  ret pow_f64_impl(x, y)
.end

pub fn powi(x: f64, n: i32) -> f64
  ret powi_f64_impl(x, n)
.end

pub fn pow_f32(x: f32, y: f32) -> f32
  ret pow_f32_impl(x, y)
.end

pub fn powi_f32(x: f32, n: i32) -> f32
  ret powi_f32_impl(x, n)
.end

pub fn cbrt(x: f64) -> f64
  // cbrt(x) = sign * exp(log(|x|)/3)
  if basic.is_nan(x)
    ret x
  .end
  if basic.is_inf(x)
    ret x
  .end
  if x == 0.0
    ret x
  .end
  let ax: f64 = basic.abs(x)
  let l: f64 = logmod.log(ax)
  let r: f64 = expmod.exp(l / 3.0)
  ret basic.copysign(r, x)
.end

// -----------------------------
// Impl f64 pow
// -----------------------------
fn pow_f64_impl(x: f64, y: f64) -> f64
  // NaNs
  if basic.is_nan(x) || basic.is_nan(y)
    // IEEE: pow(1, NaN)=1, pow(NaN,0)=1
    if y == 0.0
      ret 1.0
    .end
    if x == 1.0
      ret 1.0
    .end
    ret basic.nan_f64()
  .end

  // y == 0 => 1 (même si x=NaN déjà géré)
  if y == 0.0
    ret 1.0
  .end

  // x == 1 => 1
  if x == 1.0
    ret 1.0
  .end

  // ±0
  if x == 0.0
    // pow(±0, y):
    // y>0 => ±0 (si y impair entier, signe préservé), sinon +0
    // y<0 => ±inf
    if y > 0.0
      if is_integer(y) && is_odd_integer(y)
        ret x // garde le signe de -0 si présent
      .end
      ret 0.0
    .end
    // y < 0
    if is_integer(y) && is_odd_integer(y)
      ret basic.copysign(basic.inf_f64(), x)
    .end
    ret basic.inf_f64()
  .end

  // x infini
  if basic.is_inf(x)
    if x > 0.0
      if y > 0.0
        ret basic.inf_f64()
      .end
      ret 0.0
    .end
    // x = -inf
    if is_integer(y)
      if y > 0.0
        if is_odd_integer(y)
          ret -basic.inf_f64()
        .end
        ret basic.inf_f64()
      .end
      // y<0
      if is_odd_integer(y)
        ret -0.0
      .end
      ret 0.0
    .end
    // non-entier
    ret basic.nan_f64()
  .end

  // y infini
  if basic.is_inf(y)
    // pow(x, +inf): |x|>1 => inf, |x|<1 => 0, |x|==1 => 1
    // pow(x, -inf): inverses
    let ax: f64 = basic.abs(x)
    if ax == 1.0
      ret 1.0
    .end
    if y > 0.0
      if ax > 1.0
        ret basic.inf_f64()
      .end
      ret 0.0
    .end
    // y < 0
    if ax > 1.0
      ret 0.0
    .end
    ret basic.inf_f64()
  .end

  // y entier => powi (si ça tient)
  if is_integer(y)
    let n: i32 = to_i32_saturate(y)
    // si y trop grand pour i32, fallback exp/log (rare)
    if to_f64(n) == y
      ret powi_f64_impl(x, n)
    .end
  .end

  // x négatif => y doit être entier, sinon NaN
  if x < 0.0
    // y non-entier => NaN
    if !is_integer(y)
      ret basic.nan_f64()
    .end
    // y entier => signe selon parité
    let n: i32 = to_i32_saturate(y)
    if to_f64(n) != y
      // entier hors i32: parité déterminée via y/2
      if is_odd_integer(y)
        // signe négatif
        let rabs: f64 = pow_pos_f64(-x, y)
        ret -rabs
      .end
      ret pow_pos_f64(-x, y)
    .end

    let ax: f64 = -x
    let r: f64 = powi_f64_impl(ax, n)
    if (n & 1) != 0
      ret -r
    .end
    ret r
  .end

  // x positif => cas général
  ret pow_pos_f64(x, y)
.end

fn pow_pos_f64(x: f64, y: f64) -> f64
  // x>0, y fini non-nan
  // Chemins rapides: y==1, y==2, y==0.5
  if y == 1.0
    ret x
  .end
  if y == 2.0
    ret x * x
  .end
  if y == 0.5
    if basic.has_sqrt_f64()
      ret basic.sqrt(x)
    .end
    ret expmod.exp(0.5 * logmod.log(x))
  .end

  // Amélioration: si y très proche d’un entier, snap
  let ys: f64 = snap_to_int_if_close(y)
  if ys != y
    let n: i32 = to_i32_saturate(ys)
    if to_f64(n) == ys
      ret powi_f64_impl(x, n)
    .end
  .end

  // log/exp
  let l: f64 = logmod.log(x)
  let t: f64 = y * l
  ret expmod.exp(t)
.end

// -----------------------------
// powi f64 (exponentiation rapide)
// -----------------------------
fn powi_f64_impl(x: f64, n: i32) -> f64
  // gère n négatif
  if n == 0
    ret 1.0
  .end

  // NaN
  if basic.is_nan(x)
    ret basic.nan_f64()
  .end

  // inf
  if basic.is_inf(x)
    if n > 0
      if x > 0.0
        ret basic.inf_f64()
      .end
      // x = -inf
      if (n & 1) != 0
        ret -basic.inf_f64()
      .end
      ret basic.inf_f64()
    .end
    // n < 0
    if x > 0.0
      ret 0.0
    .end
    if (n & 1) != 0
      ret -0.0
    .end
    ret 0.0
  .end

  let nn: i32 = n
  let base: f64 = x
  let res: f64 = 1.0
  let b: f64 = base
  let r: f64 = res
  let e: i32 = nn

  if e < 0
    e = -e
    b = 1.0 / b
  .end

  while e != 0
    if (e & 1) != 0
      r = r * b
    .end
    e = e >> 1
    if e != 0
      b = b * b
    .end
  .end

  ret r
.end

// -----------------------------
// Impl f32
// -----------------------------
fn pow_f32_impl(x: f32, y: f32) -> f32
  if basic.is_nan_f32(x) || basic.is_nan_f32(y)
    if y == 0.0
      ret 1.0
    .end
    if x == 1.0
      ret 1.0
    .end
    ret basic.nan_f32()
  .end

  if y == 0.0
    ret 1.0
  .end
  if x == 1.0
    ret 1.0
  .end

  if x == 0.0
    if y > 0.0
      if is_integer_f32(y) && is_odd_integer_f32(y)
        ret x
      .end
      ret 0.0
    .end
    if is_integer_f32(y) && is_odd_integer_f32(y)
      ret basic.copysign_f32(basic.inf_f32(), x)
    .end
    ret basic.inf_f32()
  .end

  if basic.is_inf_f32(x)
    if x > 0.0
      if y > 0.0
        ret basic.inf_f32()
      .end
      ret 0.0
    .end
    if is_integer_f32(y)
      if y > 0.0
        if is_odd_integer_f32(y)
          ret -basic.inf_f32()
        .end
        ret basic.inf_f32()
      .end
      if is_odd_integer_f32(y)
        ret -0.0
      .end
      ret 0.0
    .end
    ret basic.nan_f32()
  .end

  if basic.is_inf_f32(y)
    let ax: f32 = basic.abs_f32(x)
    if ax == 1.0
      ret 1.0
    .end
    if y > 0.0
      if ax > 1.0
        ret basic.inf_f32()
      .end
      ret 0.0
    .end
    if ax > 1.0
      ret 0.0
    .end
    ret basic.inf_f32()
  .end

  if is_integer_f32(y)
    let n: i32 = to_i32_saturate_f32(y)
    if to_f32(n) == y
      ret powi_f32_impl(x, n)
    .end
  .end

  if x < 0.0
    if !is_integer_f32(y)
      ret basic.nan_f32()
    .end
    let n: i32 = to_i32_saturate_f32(y)
    if to_f32(n) == y
      let r: f32 = powi_f32_impl(-x, n)
      if (n & 1) != 0
        ret -r
      .end
      ret r
    .end
    // fallback
    let rabs: f32 = expmod.exp_f32(y * logmod.log_f32(-x))
    if is_odd_integer_f32(y)
      ret -rabs
    .end
    ret rabs
  .end

  // x>0
  if y == 1.0
    ret x
  .end
  if y == 2.0
    ret x * x
  .end
  let t: f32 = y * logmod.log_f32(x)
  ret expmod.exp_f32(t)
.end

fn powi_f32_impl(x: f32, n: i32) -> f32
  if n == 0
    ret 1.0
  .end
  if basic.is_nan_f32(x)
    ret basic.nan_f32()
  .end
  if basic.is_inf_f32(x)
    if n > 0
      if x > 0.0
        ret basic.inf_f32()
      .end
      if (n & 1) != 0
        ret -basic.inf_f32()
      .end
      ret basic.inf_f32()
    .end
    if x > 0.0
      ret 0.0
    .end
    if (n & 1) != 0
      ret -0.0
    .end
    ret 0.0
  .end

  let e: i32 = n
  let b: f32 = x
  let r: f32 = 1.0

  if e < 0
    e = -e
    b = 1.0 / b
  .end

  while e != 0
    if (e & 1) != 0
      r = r * b
    .end
    e = e >> 1
    if e != 0
      b = b * b
    .end
  .end

  ret r
.end

// -----------------------------
// Helpers: integer detection, snapping, conversions
// -----------------------------
fn is_integer(y: f64) -> bool
  // y entier si y == trunc(y) et fini
  if !basic.is_finite(y)
    ret false
  .end
  let t: f64 = basic.trunc(y)
  ret t == y
.end

fn is_odd_integer(y: f64) -> bool
  if !is_integer(y)
    ret false
  .end
  // odd via y/2
  let h: f64 = y * 0.5
  let th: f64 = basic.trunc(h)
  ret th != h
.end

fn snap_to_int_if_close(y: f64) -> f64
  // si y est très proche d’un entier, renvoie cet entier
  // seuil: ~ 2 ulp autour de l’entier (approx)
  if !basic.is_finite(y)
    ret y
  .end
  let r: f64 = basic.floor(y + 0.5)
  let d: f64 = basic.abs(y - r)
  let tol: f64 = 8.0 * 2.2204460492503131e-16 * basic.max(1.0, basic.abs(y))
  if d <= tol
    ret r
  .end
  ret y
.end

fn is_integer_f32(y: f32) -> bool
  if !basic.is_finite_f32(y)
    ret false
  .end
  let t: f32 = basic.trunc_f32(y)
  ret t == y
.end

fn is_odd_integer_f32(y: f32) -> bool
  if !is_integer_f32(y)
    ret false
  .end
  let h: f32 = y * 0.5
  let th: f32 = basic.trunc_f32(h)
  ret th != h
.end

fn to_i32_saturate(y: f64) -> i32
  if y > 2147483647.0
    ret 2147483647
  .end
  if y < -2147483648.0
    ret -2147483648
  .end
  ret basic.trunc_i32(y)
.end

fn to_i32_saturate_f32(y: f32) -> i32
  if y > 2147483647.0
    ret 2147483647
  .end
  if y < -2147483648.0
    ret -2147483648
  .end
  ret basic.trunc_i32_f32(y)
.end

fn to_f64(i: i32) -> f64
  ret basic.i32_to_f64(i)
.end

fn to_f32(i: i32) -> f32
  ret basic.i32_to_f32(i)
.end

// -----------------------------
// Tests
// -----------------------------
pub fn test_exp_log_pow_smoke() -> void
  // powi
  assert_close_f64(powi(2.0, 10), 1024.0, 0.0)
  assert_close_f64(powi(2.0, -2), 0.25, 1e-15)

  // pow
  assert_close_f64(pow(2.0, 3.0), 8.0, 1e-12)
  assert_close_f64(pow(9.0, 0.5), 3.0, 1e-12)

  // négatif + entier
  assert_close_f64(pow(-2.0, 3.0), -8.0, 1e-12)
  assert_close_f64(pow(-2.0, 4.0), 16.0, 1e-12)

  // négatif + non-entier => NaN
  assert_true(basic.is_nan(pow(-2.0, 0.5)))

  // inf cases
  assert_true(pow(2.0, basic.inf_f64()) == basic.inf_f64())
  assert_true(pow(0.5, basic.inf_f64()) == 0.0)

  // f32 quick
  assert_close_f32(powi_f32(2.0, 10), 1024.0, 1e-3)
  assert_close_f32(pow_f32(2.0, 3.0), 8.0, 1e-4)
.end

fn assert_true(cond: bool) -> void
  if !cond
    basic.panic("assert_true failed")
  .end
.end

fn assert_close_f64(x: f64, y: f64, tol: f64) -> void
  let d: f64 = basic.abs(x - y)
  let t: f64 = tol + 1e-12 * basic.max(basic.abs(x), basic.abs(y))
  if d > t
    basic.panic("assert_close_f64 failed")
  .end
.end

fn assert_close_f32(x: f32, y: f32, tol: f32) -> void
  let d: f32 = basic.abs_f32(x - y)
  let t: f32 = tol + 1e-5 * basic.max_f32(basic.abs_f32(x), basic.abs_f32(y))
  if d > t
    basic.panic("assert_close_f32 failed")
  .end
.end
