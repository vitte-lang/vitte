// File: exp_log/log.vitte
// Module: exp_log.log
//
// Objectif:
//   - log(x), log2(x), log10(x), log1p(x)
//   - versions f64 et f32
//   - robustesse IEEE-754: NaN, ±Inf, x<=0, subnormaux
//   - implémentation “portable”: décomposition mantisse/exposant, approximation polynomiale
//
// Stratégie (f64):
//   1) Décomposer x = m * 2^e avec m ∈ [1,2)
//   2) Réduction: m = 1 + f, f ∈ [0,1)
//      pour stabilité: transformer vers y = (m-1)/(m+1) => log(m)=2*(y + y^3/3 + y^5/5 + ...)
//      série tronquée + mini-polynôme
//   3) log(x) = log(m) + e*ln2
//   4) log1p(x): branche série si |x| petit, sinon log(1+x)
//
// Dépendances attendues (core):
//   - core/basic.vitte : isnan/isinf/isfinite/abs/copysign/floor/trunc/scalb, frexp/ldexp ou équivalents
//   - core/basic.vitte : nan_f64/inf_f64, etc.
//
// Notes:
//   - Si core expose log/log1p natifs, on peut déléguer (feature flags).
//   - Ici, on fournit un fallback complet.
//
// Conventions:
//   - blocs via .end uniquement

module exp_log.log

use core.basic as basic

// -----------------------------
// Constantes f64
// -----------------------------
const LN2: f64 = 0.693147180559945309417232121458176568
const INV_LN2: f64 = 1.442695040888963407359924681001892137
const LN10: f64 = 2.302585092994045684017991454684364208
const INV_LN10: f64 = 0.434294481903251827651128918916605082 // 1/ln(10)

// Seuils
const LOG_TINY: f64 = 1.0e-300
const LOG1P_TINY: f64 = 1.0e-8

// -----------------------------
// Constantes f32
// -----------------------------
const LN2_F: f32 = 0.69314718056
const INV_LN2_F: f32 = 1.44269504089
const LN10_F: f32 = 2.30258509299
const INV_LN10_F: f32 = 0.43429448190
const LOG1P_TINY_F: f32 = 1.0e-4

// -----------------------------
// API publique f64
// -----------------------------
pub fn log(x: f64) -> f64
  // délégation si dispo
  if basic.has_log_f64()
    ret basic.log(x)
  .end
  ret log_f64_impl(x)
.end

pub fn log2(x: f64) -> f64
  if basic.has_log2_f64()
    ret basic.log2(x)
  .end
  let l: f64 = log(x)
  ret l * INV_LN2
.end

pub fn log10(x: f64) -> f64
  if basic.has_log10_f64()
    ret basic.log10(x)
  .end
  let l: f64 = log(x)
  ret l * INV_LN10
.end

pub fn log1p(x: f64) -> f64
  if basic.has_log1p_f64()
    ret basic.log1p(x)
  .end
  ret log1p_f64_impl(x)
.end

// -----------------------------
// API publique f32
// -----------------------------
pub fn log_f32(x: f32) -> f32
  if basic.has_log_f32()
    ret basic.log_f32(x)
  .end
  ret log_f32_impl(x)
.end

pub fn log2_f32(x: f32) -> f32
  if basic.has_log2_f32()
    ret basic.log2_f32(x)
  .end
  let l: f32 = log_f32(x)
  ret l * INV_LN2_F
.end

pub fn log10_f32(x: f32) -> f32
  if basic.has_log10_f32()
    ret basic.log10_f32(x)
  .end
  let l: f32 = log_f32(x)
  ret l * INV_LN10_F
.end

pub fn log1p_f32(x: f32) -> f32
  if basic.has_log1p_f32()
    ret basic.log1p_f32(x)
  .end
  ret log1p_f32_impl(x)
.end

// -----------------------------
// Impl f64
// -----------------------------
fn log_f64_impl(x: f64) -> f64
  // IEEE-754
  if basic.is_nan(x)
    ret x
  .end
  if x == 0.0
    ret -basic.inf_f64()
  .end
  if x < 0.0
    ret basic.nan_f64()
  .end
  if basic.is_inf(x)
    if x > 0.0
      ret x
    .end
    ret basic.nan_f64()
  .end

  // normalisation (gère subnormaux via scalb)
  let xx: f64 = x
  let kfix: i32 = 0
  let xf: f64 = xx
  let kk: i32 = kfix

  if xf < LOG_TINY
    // remonte les subnormaux
    xf = basic.scalb(xf, 54)
    kk = kk - 54
  .end

  // frexp: xf = m * 2^e avec m in [0.5,1)
  // on veut m2 in [1,2)
  let m: f64 = 0.0
  let e: i32 = 0
  (m, e) = frexp_f64(xf)

  // m ∈ [0.5,1) => m2=2m ∈ [1,2), e2=e-1
  let m2: f64 = m + m
  let e2: i32 = e - 1 + kk

  // log(x) = log(m2) + e2*ln2
  let lm: f64 = log_mantissa_f64(m2)
  ret lm + to_f64(e2) * LN2
.end

fn log1p_f64_impl(x: f64) -> f64
  // log(1+x)
  if basic.is_nan(x)
    ret x
  .end
  if basic.is_inf(x)
    if x > 0.0
      ret x
    .end
    ret basic.nan_f64()
  .end
  if x == -1.0
    ret -basic.inf_f64()
  .end
  if x < -1.0
    ret basic.nan_f64()
  .end

  let ax: f64 = basic.abs(x)
  if ax < LOG1P_TINY
    ret log1p_series_f64(x)
  .end

  // si x grand, 1+x perd pas trop; sinon on peut faire log(1+x)
  ret log(1.0 + x)
.end

fn log1p_series_f64(x: f64) -> f64
  // Série alternée: x - x^2/2 + x^3/3 - x^4/4 + x^5/5 - x^6/6
  let x2: f64 = x * x
  let x3: f64 = x2 * x
  let x4: f64 = x2 * x2
  let x5: f64 = x4 * x
  let x6: f64 = x3 * x3

  ret x
    - 0.5 * x2
    + (1.0/3.0) * x3
    - 0.25 * x4
    + 0.2 * x5
    - (1.0/6.0) * x6
.end

// log(m) avec m ∈ [1,2)
fn log_mantissa_f64(m: f64) -> f64
  // Transformation: y = (m-1)/(m+1) ∈ [0, 1/3]
  // log(m) = 2*(y + y^3/3 + y^5/5 + ...).
  let num: f64 = m - 1.0
  let den: f64 = m + 1.0
  let y: f64 = num / den
  let y2: f64 = y * y

  // Polynôme sur y2 pour approx de atanh-like:
  // y + y^3/3 + y^5/5 + y^7/7 + y^9/9
  let t: f64 = y
  let y3: f64 = y * y2
  let y5: f64 = y3 * y2
  let y7: f64 = y5 * y2
  let y9: f64 = y7 * y2

  let s: f64 = t
    + y3 * (1.0/3.0)
    + y5 * (1.0/5.0)
    + y7 * (1.0/7.0)
    + y9 * (1.0/9.0)

  ret 2.0 * s
.end

// -----------------------------
// Impl f32
// -----------------------------
fn log_f32_impl(x: f32) -> f32
  if basic.is_nan_f32(x)
    ret x
  .end
  if x == 0.0
    ret -basic.inf_f32()
  .end
  if x < 0.0
    ret basic.nan_f32()
  .end
  if basic.is_inf_f32(x)
    if x > 0.0
      ret x
    .end
    ret basic.nan_f32()
  .end

  // normalisation subnormaux (f32)
  let xf: f32 = x
  let kk: i32 = 0
  if xf < 1.0e-30
    xf = basic.scalb_f32(xf, 25)
    kk = kk - 25
  .end

  let m: f32 = 0.0
  let e: i32 = 0
  (m, e) = frexp_f32(xf)

  let m2: f32 = m + m
  let e2: i32 = e - 1 + kk

  let lm: f32 = log_mantissa_f32(m2)
  ret lm + to_f32(e2) * LN2_F
.end

fn log1p_f32_impl(x: f32) -> f32
  if basic.is_nan_f32(x)
    ret x
  .end
  if basic.is_inf_f32(x)
    if x > 0.0
      ret x
    .end
    ret basic.nan_f32()
  .end
  if x == -1.0
    ret -basic.inf_f32()
  .end
  if x < -1.0
    ret basic.nan_f32()
  .end

  let ax: f32 = basic.abs_f32(x)
  if ax < LOG1P_TINY_F
    ret log1p_series_f32(x)
  .end

  ret log_f32(1.0 + x)
.end

fn log1p_series_f32(x: f32) -> f32
  let x2: f32 = x * x
  let x3: f32 = x2 * x
  let x4: f32 = x2 * x2
  ret x - 0.5 * x2 + 0.33333334 * x3 - 0.25 * x4
.end

fn log_mantissa_f32(m: f32) -> f32
  let y: f32 = (m - 1.0) / (m + 1.0)
  let y2: f32 = y * y
  let y3: f32 = y * y2
  let y5: f32 = y3 * y2
  let y7: f32 = y5 * y2
  let s: f32 = y + y3 * 0.33333334 + y5 * 0.2 + y7 * 0.14285715
  ret 2.0 * s
.end

// -----------------------------
// frexp helpers (fallback)
// -----------------------------
// frexp(x) => (m,e) tels que x = m * 2^e, m ∈ [0.5,1) pour x != 0
fn frexp_f64(x: f64) -> (f64, i32)
  if basic.has_frexp_f64()
    ret basic.frexp(x)
  .end

  // Fallback bit-level: nécessite primitives de bits dans basic.
  // On tente via basic.f64_to_bits / bits_to_f64, sinon panic.
  if !basic.has_f64_bits()
    basic.panic("frexp_f64: missing f64 bit primitives")
    ret (0.0, 0)
  .end

  let bits: u64 = basic.f64_to_bits(x)
  let exp: i32 = ((bits >> 52) & 0x7ff) as i32
  let frac: u64 = bits & 0x000fffffffffffff

  if exp == 0
    // subnormal: normaliser
    if x == 0.0
      ret (0.0, 0)
    .end
    let xx: f64 = basic.scalb(x, 54)
    let m2: f64 = 0.0
    let e2: i32 = 0
    (m2, e2) = frexp_f64(xx)
    ret (m2, e2 - 54)
  .end

  // exp bias=1023
  let e: i32 = exp - 1022 // on force m dans [0.5,1)
  // construire mantisse avec exp=1022
  let mbits: u64 = (bits & 0x800fffffffffffff) | (u64(1022) << 52)
  let m: f64 = basic.bits_to_f64(mbits)
  ret (m, e)
.end

fn frexp_f32(x: f32) -> (f32, i32)
  if basic.has_frexp_f32()
    ret basic.frexp_f32(x)
  .end

  if !basic.has_f32_bits()
    basic.panic("frexp_f32: missing f32 bit primitives")
    ret (0.0, 0)
  .end

  let bits: u32 = basic.f32_to_bits(x)
  let exp: i32 = ((bits >> 23) & 0xff) as i32
  let frac: u32 = bits & 0x007fffff

  if exp == 0
    if x == 0.0
      ret (0.0, 0)
    .end
    let xx: f32 = basic.scalb_f32(x, 25)
    let m2: f32 = 0.0
    let e2: i32 = 0
    (m2, e2) = frexp_f32(xx)
    ret (m2, e2 - 25)
  .end

  // bias=127
  let e: i32 = exp - 126
  let mbits: u32 = (bits & 0x807fffff) | (u32(126) << 23)
  let m: f32 = basic.bits_to_f32(mbits)
  ret (m, e)
.end

// -----------------------------
// Conversions
// -----------------------------
fn to_f64(e: i32) -> f64
  ret basic.i32_to_f64(e)
.end

fn to_f32(e: i32) -> f32
  ret basic.i32_to_f32(e)
.end

// -----------------------------
// Tests
// -----------------------------
pub fn test_exp_log_log_smoke() -> void
  // log(1)=0
  assert_close_f64(log(1.0), 0.0, 0.0)
  // log(e) ~ 1
  let e: f64 = 2.71828182845904523536
  assert_close_f64(log(e), 1.0, 1e-10)

  // log2(2)=1
  assert_close_f64(log2(2.0), 1.0, 1e-12)
  // log10(10)=1
  assert_close_f64(log10(10.0), 1.0, 1e-12)

  // log1p tiny
  assert_close_f64(log1p(1e-12), 1e-12, 1e-24)
  assert_close_f64(log1p(-1e-12), -1e-12, 1e-24)

  // domain errors
  assert_true(basic.is_nan(log(-1.0)))
  assert_true(log(0.0) == -basic.inf_f64())

  // f32 sanity
  assert_close_f32(log_f32(1.0), 0.0, 0.0)
  assert_close_f32(log2_f32(2.0), 1.0, 1e-5)
  assert_close_f32(log10_f32(10.0), 1.0, 1e-5)
.end

fn assert_true(cond: bool) -> void
  if !cond
    basic.panic("assert_true failed")
  .end
.end

fn assert_close_f64(x: f64, y: f64, tol: f64) -> void
  let d: f64 = basic.abs(x - y)
  let t: f64 = tol + 1e-12 * basic.max(basic.abs(x), basic.abs(y))
  if d > t
    basic.panic("assert_close_f64 failed")
  .end
.end

fn assert_close_f32(x: f32, y: f32, tol: f32) -> void
  let d: f32 = basic.abs_f32(x - y)
  let t: f32 = tol + 1e-5 * basic.max_f32(basic.abs_f32(x), basic.abs_f32(y))
  if d > t
    basic.panic("assert_close_f32 failed")
  .end
.end
