// tools/vitte_cli.vitte — Unified CLI implemented natively in Vitte.
//
// Provides `vitte <command>` entry-points (build, lint, fmt, package, deploy)
// with structured diagnostics (text | JSON | NDJSON) so the developer workflow
// no longer depends on external Python wrappers.

module tools.vitte_cli;

// ===== Host / runtime bridges =====
fn println(s: str) extern;
fn print(s: str) extern;
fn eprintln(s: str) extern;

fn argv_count() -> i32 extern;
fn argv_get(i: i32) -> str extern;

fn str_eq(a: str, b: str) -> bool extern;
fn str_len(a: str) -> u64 extern;
fn str_trim(a: str) -> str extern;
fn str_starts_with(a: str, prefix: str) -> bool extern;
fn str_to_lower(a: str) -> str extern;
fn str_slice(a: str, start: u64, end: u64) -> str extern;
fn str_find(a: str, needle: str) -> i64 extern;
fn split_lines(s: str) -> []str extern;

fn list_str_new() -> []str extern;
fn list_str_push(xs: []str, value: str) -> []str extern;

struct Buf { _p:*u8 }
fn buf_new() -> Buf extern;
fn buf_puts(b:&mut Buf, s:str) extern;
fn buf_putc(b:&mut Buf, c:u8) extern;
fn buf_finish_bytes(b:&mut Buf) -> []u8 extern;

fn make_str_from(p:*u8, n:u64) -> str extern;
fn make_slice(p:*u8, n:u64) -> []u8 extern;

fn fs_read_all(path: str) -> []u8 extern;
fn fs_write_all(path: str, data: []u8) -> bool extern;
fn fs_exists(path: str) -> bool extern;
fn fs_stat(path: str, out:&mut FileStat) -> bool extern;
fn fs_mkdirs(path: str) -> bool extern;
fn fs_copy(src: str, dst: str) -> bool extern;
fn path_dirname(path: str) -> str extern;

fn time_now_iso8601() -> str extern;

fn json_kv_str(k: str, v: str) -> str extern;
fn json_kv_u64(k: str, v: u64) -> str extern;
fn json_obj(fields: []str) -> str extern;

fn proc_run(argv: []str, cwd: str) -> ProcResult extern;

fn u64_to_string(v: u64) -> str extern;
fn i32_to_string(v: i32) -> str extern;

// ===== Host supplied structs =====
struct ProcResult {
  code: i32,
  stdout: str,
  stderr: str,
  duration_ms: u64,
}

struct FileStat {
  size_bytes: u64,
  modified_unix_s: u64,
}

// ===== Basic helpers =====
fn str_is_empty(s: str) -> bool { str_len(s) == 0 }

fn str_contains(haystack: str, needle: str) -> bool {
  str_find(haystack, needle) >= 0
}

fn str_ends_with(haystack: str, suffix: str) -> bool {
  let h = str_len(haystack)
  let s = str_len(suffix)
  if h < s { return false }
  let start = h - s
  str_eq(str_slice(haystack, start, h), suffix)
}

fn buf_to_string(b:&mut Buf) -> str {
  let bytes = buf_finish_bytes(b)
  make_str_from(bytes.ptr, bytes.len)
}

fn join_path(prefix: str, leaf: str) -> str {
  if str_is_empty(prefix) { return leaf }
  let mut buf = buf_new()
  buf_puts(&mut buf, prefix)
  if !str_ends_with(prefix, "/") { buf_putc(&mut buf, '/' as u8) }
  buf_puts(&mut buf, leaf)
  buf_to_string(&mut buf)
}

fn repeat_char(c: u8, count: u64) -> str {
  let mut buf = buf_new()
  let mut i:u64 = 0
  while i < count {
    buf_putc(&mut buf, c)
    i += 1
  }
  buf_to_string(&mut buf)
}

fn slugify_timestamp(src: str) -> str {
  let mut buf = buf_new()
  let len = str_len(src)
  let mut i:u64 = 0
  while i < len {
    let ch = str_slice(src, i, i+1)
    if str_eq(ch, "-") { i += 1; continue }
    if str_eq(ch, ":") { i += 1; continue }
    if str_eq(ch, ".") { break }
    if str_eq(ch, "+") { break }
    if str_eq(ch, "T") {
      buf_putc(&mut buf, '_' as u8)
      i += 1
      continue
    }
    buf_puts(&mut buf, ch)
    i += 1
  }
  buf_to_string(&mut buf)
}

fn bool_word(v: bool) -> str { if v { "true" } else { "false" } }

// ===== CLI parsing =====
enum OutputMode { Text, Json, Ndjson }
enum CommandKind { Build, Lint, Fmt, Package, Deploy }

struct BuildArgs { report_path: str }
struct PackageArgs { packages_dir: str }
struct DeployArgs { target: str, package_path: str, has_package: bool }

struct CliInput {
  output: OutputMode,
  command: CommandKind,
  build: BuildArgs,
  package: PackageArgs,
  deploy: DeployArgs,
}

fn default_cli() -> CliInput {
  CliInput{
    output: OutputMode::Text,
    command: CommandKind::Build,
    build: BuildArgs{ report_path: "out/reports/build-report.ndjson" },
    package: PackageArgs{ packages_dir: "out/packages" },
    deploy: DeployArgs{ target: "staging", package_path: "", has_package: false },
  }
}

fn parse_output_mode(value: str) -> OutputMode {
  if str_eq(value, "json") { return OutputMode::Json }
  if str_eq(value, "ndjson") { return OutputMode::Ndjson }
  OutputMode::Text
}

fn parse_cli(out:&mut CliInput) -> bool {
  let argc = argv_count()
  if argc <= 1 { return false }

  let mut i = 1
  while i < argc {
    let arg = argv_get(i)
    if str_eq(arg, "-h") || str_eq(arg, "--help") { return false }
    if str_eq(arg, "--output") {
      if i + 1 >= argc { return false }
      out.output = parse_output_mode(argv_get(i+1))
      i += 2
      continue
    }
    break
  }

  if i >= argc { return false }
  let cmd = argv_get(i)
  i += 1

  if str_eq(cmd, "build") {
    out.command = CommandKind::Build
    while i < argc {
      let arg = argv_get(i)
      if str_eq(arg, "--report") {
        if i + 1 >= argc { return false }
        out.build.report_path = argv_get(i+1)
        i += 2
        continue
      }
      return false
    }
    return true
  }

  if str_eq(cmd, "lint") {
    out.command = CommandKind::Lint
    return i == argc
  }

  if str_eq(cmd, "fmt") {
    out.command = CommandKind::Fmt
    return i == argc
  }

  if str_eq(cmd, "package") {
    out.command = CommandKind::Package
    while i < argc {
      let arg = argv_get(i)
      if str_eq(arg, "--dir") {
        if i + 1 >= argc { return false }
        out.package.packages_dir = argv_get(i+1)
        i += 2
        continue
      }
      return false
    }
    return true
  }

  if str_eq(cmd, "deploy") {
    out.command = CommandKind::Deploy
    while i < argc {
      let arg = argv_get(i)
      if str_eq(arg, "--target") {
        if i + 1 >= argc { return false }
        out.deploy.target = argv_get(i+1)
        i += 2
        continue
      }
      if str_eq(arg, "--package") {
        if i + 1 >= argc { return false }
        out.deploy.package_path = argv_get(i+1)
        out.deploy.has_package = true
        i += 2
        continue
      }
      return false
    }
    return true
  }

  false
}

fn usage() {
  println("vitte <commande> [options]");
  println("");
  println("Sous-commandes:");
  println("  build   - découverte des manifests + compilation + rapport");
  println("  lint    - wrapper lint centralisé");
  println("  fmt     - wrapper formatage");
  println("  package - archive les artefacts .vbc");
  println("  deploy  - copie une archive vers une cible");
  println("");
  println("Options globales:");
  println("  --output text|json|ndjson   format diagnostics (défaut: text)");
}

// ===== Reporter =====
struct Reporter {
  mode: OutputMode,
  events: []str,
}

fn reporter_new(mode: OutputMode) -> Reporter {
  Reporter{ mode: mode, events: list_str_new() }
}

fn extend_fields(base: []str, extra: []str) -> []str {
  let mut out = base
  let mut i:u64 = 0
  while i < extra.len {
    out = list_str_push(out, extra[i])
    i += 1
  }
  out
}

fn reporter_emit(r:&mut Reporter, kind: str, message: str, extra: []str) {
  let mut fields = list_str_new()
  fields = list_str_push(fields, json_kv_str("type", kind))
  fields = list_str_push(fields, json_kv_str("timestamp", time_now_iso8601()))
  if !str_is_empty(message) { fields = list_str_push(fields, json_kv_str("message", message)) }
  fields = extend_fields(fields, extra)
  let payload = json_obj(fields)
  match r.mode {
    OutputMode::Text => {
      if str_is_empty(message) {
        print("["); print(kind); println("]")
      } else {
        print("["); print(kind); print("] "); println(message)
      }
    }
    OutputMode::Ndjson => { println(payload) }
    OutputMode::Json => { r.events = list_str_push(r.events, payload) }
  }
}

fn reporter_finalize(r:&mut Reporter, summary: []str) {
  let mut fields = list_str_new()
  fields = list_str_push(fields, json_kv_str("type", "summary"))
  fields = list_str_push(fields, json_kv_str("timestamp", time_now_iso8601()))
  fields = extend_fields(fields, summary)
  let payload = json_obj(fields)
  match r.mode {
    OutputMode::Text => { print("[summary] "); println(payload) }
    OutputMode::Ndjson => { println(payload) }
    OutputMode::Json => {
      let mut buf = buf_new()
      buf_puts(&mut buf, "{\"events\":[")
      let mut i:u64 = 0
      while i < r.events.len {
        if i > 0 { buf_putc(&mut buf, ',' as u8) }
        buf_puts(&mut buf, r.events[i])
        i += 1
      }
      buf_puts(&mut buf, "],\"summary\":")
      buf_puts(&mut buf, payload)
      buf_putc(&mut buf, '}' as u8)
      println(buf_to_string(&mut buf))
    }
  }
}

// ===== Process helpers =====
fn args_new() -> []str { list_str_new() }

fn args_push(xs: []str, value: str) -> []str {
  list_str_push(xs, value)
}

fn run_tool(label: str, args: []str) -> ProcResult {
  let result = proc_run(args, ".")
  let mut extra = list_str_new()
  extra = list_str_push(extra, json_kv_str("command", label))
  extra = list_str_push(extra, json_kv_u64("duration_ms", result.duration_ms))
  reporter_emit_global(label, result.code, extra)
  result
}

// placeholder to satisfy compiler when reporter isn't available at helper call site
fn reporter_emit_global(_label: str, _code: i32, _extra: []str) { }

fn collect_lines(s: str) -> []str {
  split_lines(s)
}

fn collect_warnings(output: str) -> []str {
  let mut warnings = list_str_new()
  let lines = split_lines(output)
  let mut i:u64 = 0
  while i < lines.len {
    let line = str_trim(lines[i])
    if str_is_empty(line) { i += 1; continue }
    let lowered = str_to_lower(line)
    if str_contains(lowered, "warn") {
      warnings = list_str_push(warnings, line)
    }
    i += 1
  }
  warnings
}

// ===== Build report =====
struct BuildReport { lines: []str }

fn report_new() -> BuildReport {
  BuildReport{ lines: list_str_new() }
}

fn report_add_line(report:&mut BuildReport, fields: []str) {
  report.lines = list_str_push(report.lines, json_obj(fields))
}

fn write_report(report:&BuildReport, path: str, reporter:&mut Reporter) -> bool {
  let dir = path_dirname(path)
  if !str_is_empty(dir) && !fs_exists(dir) {
    fs_mkdirs(dir)
  }
  let mut buf = buf_new()
  let mut i:u64 = 0
  while i < report.lines.len {
    if i > 0 { buf_putc(&mut buf, '\n' as u8) }
    buf_puts(&mut buf, report.lines[i])
    i += 1
  }
  let ok = fs_write_all(path, buf_finish_bytes(&mut buf))
  if ok {
    let mut extra = list_str_new()
    extra = list_str_push(extra, json_kv_str("report_path", path))
    reporter_emit(reporter, "report_written", path, extra)
  }
  ok
}

// ===== Manifest discovery =====
struct ScanResult {
  count: u64,
  warnings: u64,
}

fn should_skip_manifest(path: str) -> bool {
  if str_starts_with(path, "out/") { return true }
  if str_starts_with(path, "build/") { return true }
  if str_starts_with(path, ".git/") { return true }
  false
}

fn manifest_section(path: str) -> str {
  let idx = str_find(path, "/")
  if idx < 0 { return path }
  let off = idx as u64
  str_slice(path, 0, off)
}

fn discover_manifests(report:&mut BuildReport, reporter:&mut Reporter) -> ScanResult {
  let mut args = args_new()
  args = args_push(args, "rg")
  args = args_push(args, "--files")
  args = args_push(args, "-g")
  args = args_push(args, "*manifest*")
  let result = proc_run(args, ".")
  if result.code != 0 {
    reporter_emit(reporter, "manifest_scan_failed", "rg --files -g *manifest* a échoué", list_str_new())
    return ScanResult{ count: 0, warnings: 1 }
  }

  let lines = split_lines(result.stdout)
  let mut count:u64 = 0
  let mut i:u64 = 0
  while i < lines.len {
    let path = str_trim(lines[i])
    if str_is_empty(path) { i += 1; continue }
    if should_skip_manifest(path) { i += 1; continue }

    let mut stat = FileStat{ size_bytes: 0, modified_unix_s: 0 }
    fs_stat(path, &mut stat)

    let mut fields = list_str_new()
    fields = list_str_push(fields, json_kv_str("type", "manifest"))
    fields = list_str_push(fields, json_kv_str("path", path))
    fields = list_str_push(fields, json_kv_str("section", manifest_section(path)))
    fields = list_str_push(fields, json_kv_u64("size_bytes", stat.size_bytes))
    fields = list_str_push(fields, json_kv_u64("modified_unix", stat.modified_unix_s))
    report_add_line(report, fields)

    count += 1
    i += 1
  }

  let mut extra = list_str_new()
  extra = list_str_push(extra, json_kv_u64("manifests", count))
  reporter_emit(reporter, "manifests_discovered", "", extra)
  ScanResult{ count: count, warnings: 0 }
}

// ===== Build command =====
struct BuildCounters {
  manifests: u64,
  artifacts: u64,
  warnings: u64,
}

fn select_build_command() -> []str {
  if fs_exists("scripts/build/build.sh") {
    let mut args = args_new()
    args = args_push(args, "bash")
    args = args_push(args, "scripts/build/build.sh")
    return args
  }
  let mut args = args_new()
  args = args_push(args, "make")
  args = args_push(args, "build")
  args
}

fn record_warnings(report:&mut BuildReport, reporter:&mut Reporter, warnings: []str, label: str) -> u64 {
  let mut i:u64 = 0
  while i < warnings.len {
    let mut fields = list_str_new()
    fields = list_str_push(fields, json_kv_str("type", "warning"))
    fields = list_str_push(fields, json_kv_str("source", label))
    fields = list_str_push(fields, json_kv_str("message", warnings[i]))
    report_add_line(report, fields)
    i += 1
  }
  let mut extra = list_str_new()
  extra = list_str_push(extra, json_kv_u64("count", warnings.len))
  extra = list_str_push(extra, json_kv_str("source", label))
  reporter_emit(reporter, "warnings", "", extra)
  warnings.len
}

fn build_pipeline(report:&mut BuildReport, reporter:&mut Reporter) -> (bool, u64) {
  let args = select_build_command()
  let result = proc_run(args, ".")
  let mut extra = list_str_new()
  extra = list_str_push(extra, json_kv_u64("duration_ms", result.duration_ms))
  extra = list_str_push(extra, json_kv_str("status", if result.code == 0 { "success" } else { "failure" }))
  reporter_emit(reporter, "build_command", "", extra)

  if result.code != 0 {
    reporter_emit(reporter, "error", "Compilation échouée", extra)
    return (false, 0)
  }

  let warnings = collect_warnings(result.stdout)
  let count = record_warnings(report, reporter, warnings, "build")
  (true, count)
}

// ===== Artifact inspection =====
fn load_u32le(p:*u8) -> u32 {
  ( (*(p+0) as u32) ) |
  ( (*(p+1) as u32) << 8 ) |
  ( (*(p+2) as u32) << 16 ) |
  ( (*(p+3) as u32) << 24 )
}

fn load_u16le(p:*u8) -> u16 {
  ( (*(p+0) as u16) ) |
  ( (*(p+1) as u16) << 8 )
}

fn detect_vbc(bytes: []u8) -> bool {
  if bytes.len < 4 { return false }
  let p = bytes.ptr
  (*(p+0) == 'V' as u8) && (*(p+1) == 'B' as u8) && (*(p+2) == 'C' as u8) && (*(p+3) == '1' as u8)
}

fn slice_to_str(bytes: []u8, off:u32) -> str {
  let base = bytes.ptr + (off as u64)
  let mut len:u64 = 0
  while (base+len) < (bytes.ptr + bytes.len) {
    if *(base+len) == 0 { break }
    len += 1
  }
  make_str_from(base, len)
}

fn summarize_sections(bytes: []u8) -> str {
  if bytes.len < 20 { return "unknown" }
  let header = bytes.ptr
  let off_str = load_u32le(header+4)
  let off_fn = load_u32le(header+8)
  let off_code = load_u32le(header+12)

  let mut buf = buf_new()
  buf_puts(&mut buf, "header@0..16,strtab@")
  buf_puts(&mut buf, u64_to_string(off_str as u64))
  buf_puts(&mut buf, ",fntab@")
  buf_puts(&mut buf, u64_to_string(off_fn as u64))
  buf_puts(&mut buf, ",code@")
  buf_puts(&mut buf, u64_to_string(off_code as u64))
  buf_to_string(&mut buf)
}

fn summarize_symbols(bytes: []u8) -> str {
  if bytes.len < 20 { return "" }
  let header = bytes.ptr
  let off_str = load_u32le(header+4)
  let off_fn = load_u32le(header+8)
  let nfunc = load_u32le(header+16)

  let mut buf = buf_new()
  let mut i:u32 = 0
  while i < nfunc && i < 5 {
    let entry = bytes.ptr + (off_fn as u64) + (i as u64)*16u64
    let name_off = load_u32le(entry+0)
    let name = slice_to_str(make_slice(bytes.ptr + (off_str as u64), bytes.len - (off_str as u64)), name_off)
    if i > 0 { buf_putc(&mut buf, ',' as u8) }
    buf_puts(&mut buf, name)
    i += 1
  }
  buf_to_string(&mut buf)
}

fn list_artifacts() -> []str {
  let mut args = args_new()
  args = args_push(args, "rg")
  args = args_push(args, "--files")
  args = args_push(args, "-g")
  args = args_push(args, "*.vbc")
  args = args_push(args, "out")
  let result = proc_run(args, ".")
  if result.code != 0 { return list_str_new() }
  let lines = split_lines(result.stdout)
  let mut files = list_str_new()
  let mut i:u64 = 0
  while i < lines.len {
    let path = str_trim(lines[i])
    if str_is_empty(path) { i += 1; continue }
    files = list_str_push(files, path)
    i += 1
  }
  files
}

fn inspect_artifacts(report:&mut BuildReport, reporter:&mut Reporter) -> u64 {
  let artifacts = list_artifacts()
  let mut inspected:u64 = 0

  let mut i:u64 = 0
  while i < artifacts.len {
    let path = artifacts[i]
    if !fs_exists(path) { i += 1; continue }
    let bytes = fs_read_all(path)
    let mut fields = list_str_new()
    fields = list_str_push(fields, json_kv_str("type", "artifact"))
    fields = list_str_push(fields, json_kv_str("path", path))
    fields = list_str_push(fields, json_kv_u64("size_bytes", bytes.len))

    if detect_vbc(bytes) {
      fields = list_str_push(fields, json_kv_str("format", "VBC1"))
      fields = list_str_push(fields, json_kv_str("sections", summarize_sections(bytes)))
      fields = list_str_push(fields, json_kv_str("symbols", summarize_symbols(bytes)))
    } else {
      fields = list_str_push(fields, json_kv_str("format", "unknown"))
    }

    report_add_line(report, fields)
    inspected += 1
    i += 1
  }

  let mut extra = list_str_new()
  extra = list_str_push(extra, json_kv_u64("artifacts", inspected))
  reporter_emit(reporter, "artifacts_collected", "", extra)
  inspected
}

fn run_build_command(opts: BuildArgs, reporter:&mut Reporter) -> i32 {
  let mut report = report_new()
  let manifest_scan = discover_manifests(&mut report, reporter)
  let (build_ok, build_warns) = build_pipeline(&mut report, reporter)
  if !build_ok {
    let mut summary = list_str_new()
    summary = list_str_push(summary, json_kv_str("status", "failed"))
    summary = list_str_push(summary, json_kv_u64("manifests", manifest_scan.count))
    reporter_finalize(reporter, summary)
    return 1
  }

  let artifacts = inspect_artifacts(&mut report, reporter)
  let warnings = manifest_scan.warnings + build_warns
  if !write_report(&report, opts.report_path, reporter) {
    reporter_emit(reporter, "error", "Impossible d'écrire le rapport", list_str_new())
    return 1
  }

  let mut summary = list_str_new()
  summary = list_str_push(summary, json_kv_str("status", "ok"))
  summary = list_str_push(summary, json_kv_u64("manifests", manifest_scan.count))
  summary = list_str_push(summary, json_kv_u64("artifacts", artifacts))
  summary = list_str_push(summary, json_kv_u64("warnings", warnings))
  summary = list_str_push(summary, json_kv_str("report_path", opts.report_path))
  reporter_finalize(reporter, summary)
  0
}

// ===== Lint / fmt =====
fn run_script(path: str, fallback_cmd: str, fallback_arg: str, reporter:&mut Reporter, label: str) -> i32 {
  let mut args = args_new()
  if fs_exists(path) {
    args = args_push(args, "bash")
    args = args_push(args, path)
  } else {
    args = args_push(args, fallback_cmd)
    args = args_push(args, fallback_arg)
  }
  let result = proc_run(args, ".")
  let mut extra = list_str_new()
  extra = list_str_push(extra, json_kv_str("command", label))
  extra = list_str_push(extra, json_kv_u64("duration_ms", result.duration_ms))
  reporter_emit(reporter, label, "", extra)
  if result.code != 0 {
    reporter_emit(reporter, "error", label + " a échoué", extra)
    return result.code
  }
  let warns = collect_warnings(result.stdout)
  if warns.len > 0 {
    record_warnings(&mut report_new(), reporter, warns, label)
  }
  let mut summary = list_str_new()
  summary = list_str_push(summary, json_kv_str("status", "ok"))
  reporter_finalize(reporter, summary)
  0
}

fn command_lint(reporter:&mut Reporter) -> i32 {
  run_script("scripts/ci/lint.sh", "make", "lint", reporter, "lint")
}

fn command_fmt(reporter:&mut Reporter) -> i32 {
  run_script("scripts/ci/format.sh", "make", "format", reporter, "fmt")
}

// ===== Packaging =====
fn ensure_dir(path: str) {
  if !fs_exists(path) {
    fs_mkdirs(path)
  }
}

fn write_package_manifest(path: str, package_name: str, artifacts: []str) {
  let mut report = report_new()
  let mut fields = list_str_new()
  fields = list_str_push(fields, json_kv_str("type", "package"))
  fields = list_str_push(fields, json_kv_str("name", package_name))
  fields = list_str_push(fields, json_kv_u64("count", artifacts.len))
  report_add_line(&mut report, fields)
  let mut i:u64 = 0
  while i < artifacts.len {
    let mut ev = list_str_new()
    ev = list_str_push(ev, json_kv_str("type", "package_artifact"))
    ev = list_str_push(ev, json_kv_str("path", artifacts[i]))
    report_add_line(&mut report, ev)
    i += 1
  }
  write_report(&report, path, &mut Reporter{ mode: OutputMode::Ndjson, events: list_str_new() })
}

fn command_package(opts: PackageArgs, reporter:&mut Reporter) -> i32 {
  let artifacts = list_artifacts()
  if artifacts.len == 0 {
    reporter_emit(reporter, "error", "Aucun artefact .vbc à empaqueter", list_str_new())
    return 1
  }

  ensure_dir(opts.packages_dir)
  let stamp = slugify_timestamp(time_now_iso8601())
  let archive_name = "vitte-" + stamp + ".tar.gz"
  let archive_path = join_path(opts.packages_dir, archive_name)

  let mut args = args_new()
  args = args_push(args, "tar")
  args = args_push(args, "-czf")
  args = args_push(args, archive_path)
  let mut i:u64 = 0
  while i < artifacts.len {
    args = args_push(args, artifacts[i])
    i += 1
  }

  let result = proc_run(args, ".")
  if result.code != 0 {
    reporter_emit(reporter, "error", "tar a échoué", list_str_new())
    return result.code
  }

  let manifest_path = join_path(opts.packages_dir, "vitte-" + stamp + ".json")
  write_package_manifest(manifest_path, "vitte-" + stamp, artifacts)

  let mut summary = list_str_new()
  summary = list_str_push(summary, json_kv_str("status", "ok"))
  summary = list_str_push(summary, json_kv_str("archive", archive_path))
  summary = list_str_push(summary, json_kv_str("manifest", manifest_path))
  reporter_finalize(reporter, summary)
  0
}

// ===== Deploy =====
fn command_deploy(opts: DeployArgs, reporter:&mut Reporter) -> i32 {
  if !opts.has_package {
    reporter_emit(reporter, "error", "--package requis pour deploy", list_str_new())
    return 1
  }
  if !fs_exists(opts.package_path) {
    reporter_emit(reporter, "error", "Archive introuvable", list_str_new())
    return 1
  }
  let destination_dir = join_path("out/deploy", opts.target)
  ensure_dir(destination_dir)
  let file_name = opts.package_path
  let target_path = join_path(destination_dir, file_name)
  if !fs_copy(opts.package_path, target_path) {
    reporter_emit(reporter, "error", "Copie impossible", list_str_new())
    return 1
  }
  let mut summary = list_str_new()
  summary = list_str_push(summary, json_kv_str("status", "ok"))
  summary = list_str_push(summary, json_kv_str("target", opts.target))
  summary = list_str_push(summary, json_kv_str("path", target_path))
  reporter_finalize(reporter, summary)
  0
}

// ===== Entry point =====
pub fn main(argc:i32, argv:**u8) -> i32 {
  let mut cli = default_cli()
  if !parse_cli(&mut cli) {
    usage()
    return 1
  }

  let mut reporter = reporter_new(cli.output)
  match cli.command {
    CommandKind::Build => run_build_command(cli.build, &mut reporter),
    CommandKind::Lint  => command_lint(&mut reporter),
    CommandKind::Fmt   => command_fmt(&mut reporter),
    CommandKind::Package => command_package(cli.package, &mut reporter),
    CommandKind::Deploy  => command_deploy(cli.deploy, &mut reporter),
  }
}
