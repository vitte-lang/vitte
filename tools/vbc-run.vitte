module tools.vbc_run;
use compiler.vm::{Program, Value, ValKind, vm_load, vm_invoke, vm_invoke_index, vm_find_fn, val_u64, val_f64, val_void};

// ===== Extern runtime hooks =====
fn println(s: str) extern;
fn print(s: str) extern;
fn eprintln(s: str) extern;
fn exit(code:i32) extern;

// FS
fn fs_read_all(path: str) -> []u8 extern;
fn fs_exists(path: str) -> bool extern;

// Args
fn argv_count() -> i32 extern;
fn argv_get(i:i32) -> str extern;

// String utils
fn str_eq(a: str, b: str) -> bool extern;
fn str_starts_with(a: str, prefix: str) -> bool extern;
fn make_slice(p:*u8, n:u64) -> []u8 extern;

// Build []Value helpers
fn alloc(n:u64) -> *u8 extern;
fn free(p:*u8) extern;
fn memcpy(dst:*u8, src:*u8, n:u64) extern;
fn size_of_value() -> u64 extern;
fn slice_as_values(buf:[]u8, count:u64) -> []Value extern;

// Number parsing (host provided). If missing, minimal fallback should be supplied host-side.
fn parse_u64(s: str, out:&mut u64) -> bool extern;
fn parse_f64(s: str, out:&mut f64) -> bool extern;

// ===== CLI options =====
struct Opts {
  file: str,
  func: str,     // default: "main"
  args_v: []Value,
}

fn opts_default() -> Opts {
  Opts{ file: "", func: "main", args_v: make_slice(null(), 0) }
}

// push one Value into args_v by reallocating buffer of Values
fn args_push(xs: []Value, v: Value) -> []Value {
  let n = xs.len + 1
  let nb = n * size_of_value()
  let np = alloc(nb)
  if xs.len > 0 { memcpy(np, xs.ptr as *u8, xs.len * size_of_value()) }
  *( (np as *Value) + xs.len ) = v
  slice_as_values(make_slice(np, nb), n)
}

fn usage() {
  println("vbc-run — exécute un fichier .vbc")
  println("Usage: vbc-run <prog.vbc> [options] [--] [args]")
  println("Options:")
  println("  --fn <name>           Nom de la fonction à appeler (défaut: main)")
  println("  --u64 <n>             Ajoute un argument entier non signé")
  println("  --f64 <x>             Ajoute un argument flottant 64 bits")
  println("  --index <i>           Appelle par index de fonction (override --fn)")
  println("  -h, --help            Affiche l’aide")
}

pub fn main(argc:i32, argv:**u8) -> i32 {
  let mut opts = opts_default()
  let mut call_by_index = false
  let mut fn_index:u32 = 0

  let n = argv_count()
  if n <= 1 { usage(); return 1 }

  let mut i = 1
  // first non-option is file
  let first = argv_get(i)
  if str_starts_with(first, "-") { eprintln("error: fichier .vbc manquant"); usage(); return 1 }
  opts.file = first; i += 1

  while i < n {
    let a = argv_get(i)
    if str_eq(a, "-h") || str_eq(a, "--help") { usage(); return 0 }
    else if str_eq(a, "--fn") {
      if i+1 >= n { eprintln("error: --fn nécessite un nom"); return 1 }
      opts.func = argv_get(i+1); i += 2; continue
    }
    else if str_eq(a, "--index") {
      if i+1 >= n { eprintln("error: --index nécessite un entier"); return 1 }
      let mut tmp: u64 = 0
      if !parse_u64(argv_get(i+1), &mut tmp) { eprintln("error: --index invalide"); return 1 }
      fn_index = tmp as u32; call_by_index = true; i += 2; continue
    }
    else if str_eq(a, "--u64") {
      if i+1 >= n { eprintln("error: --u64 nécessite une valeur"); return 1 }
      let mut v:u64 = 0
      if !parse_u64(argv_get(i+1), &mut v) { eprintln("error: --u64 invalide"); return 1 }
      opts.args_v = args_push(opts.args_v, val_u64(v)); i += 2; continue
    }
    else if str_eq(a, "--f64") {
      if i+1 >= n { eprintln("error: --f64 nécessite une valeur"); return 1 }
      let mut x:f64 = 0.0
      if !parse_f64(argv_get(i+1), &mut x) { eprintln("error: --f64 invalide"); return 1 }
      opts.args_v = args_push(opts.args_v, val_f64(x)); i += 2; continue
    }
    else if str_eq(a, "--") { i += 1; break }
    else if str_starts_with(a, "-") { eprintln("warn: option inconnue ignorée"); i += 1; continue }
    else {
      // positional after file without --, try to parse as u64 then f64
      let mut v:u64 = 0
      let mut x:f64 = 0.0
      if parse_u64(a, &mut v) { opts.args_v = args_push(opts.args_v, val_u64(v)); i += 1; continue }
      if parse_f64(a, &mut x) { opts.args_v = args_push(opts.args_v, val_f64(x)); i += 1; continue }
      eprintln("warn: argument non numérique ignoré"); i += 1; continue
    }
  }

  // read file
  if !fs_exists(opts.file) { eprintln("error: fichier introuvable"); return 1 }
  let bytes = fs_read_all(opts.file)
  if bytes.len == 0 { eprintln("error: fichier vide"); return 1 }

  let prg = vm_load(bytes)

  let ret = if call_by_index { vm_invoke_index(&prg, fn_index, opts.args_v) } else { vm_invoke(&prg, opts.func, opts.args_v) }

  // print return value
  match ret.kind {
    ValKind::Void => { println("(void)"); },
    ValKind::U64 => { print("u64 "); println(u64_to_string(ret.u)) },
    ValKind::F64 => { print("f64 "); println(f64_to_string(u64_to_f64_val(ret))) },
  }
  0
}

// Printing helpers — host must provide these conversions. If not available, adapt.
fn u64_to_string(v:u64) -> str extern;
fn f64_to_string(x:f64) -> str extern;
fn u64_to_f64_val(v:Value) -> f64 { // bitcast
  u64_to_f64(v.u)
}
fn u64_to_f64(x:u64) -> f64 extern;