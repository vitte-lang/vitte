module l.tools.lsym

import vitte.compiler.ast
import lvm.bytecode
import lvm.value
import lvm.debug

# ============================================================================
# Vitte tools – Modèle logique des symboles & debug info (lsym)
#
# Objectifs :
#   - Modéliser, au niveau purement déclaratif, la vision "symboles" du monde :
#       * symboles de haut niveau (fonctions, variables, types, modules),
#       * scopes lexicaux et hiérarchie de symboles,
#       * unités de compilation, fichiers source et binaires,
#       * adresses, sections, tables de lignes, inlining,
#       * liens vers l'AST du compilateur et le bytecode LVM.
#   - Servir de contrat entre :
#       * le compilateur Vitte (producteur de symboles),
#       * les outils de debug/profilage (`lvm.debug`, runner, REPL),
#       * les outils d'analyse statique / indexation (LSP, navigateurs de code).
#   - Ne contenir que des structures de données (aucune fonction ni I/O).
#
# Conventions :
#   - Même style que vitte.compiler.ast / lrt.ffi / lvm.* / l.tools.* :
#       * `pub struct/enum` + ":" et blocs terminés par `.end` ;
#       * enums "tag-only" ;
#       * IDs forts basés sur des indices u32.
# ============================================================================

# ----------------------------------------------------------------------------
# Indices et identifiants lsym
# ----------------------------------------------------------------------------

pub typedef u32 LsymSymbolIndex
pub typedef u32 LsymScopeIndex
pub typedef u32 LsymFileIndex
pub typedef u32 LsymUnitIndex
pub typedef u32 LsymSectionIndex
pub typedef u32 LsymBinaryIndex
pub typedef u32 LsymLocationIndex
pub typedef u32 LsymLineIndex
pub typedef u32 LsymTableIndex
pub typedef u32 LsymNodeIndex

pub struct LsymSymbolId:
    let raw: LsymSymbolIndex
.end

pub struct LsymScopeId:
    let raw: LsymScopeIndex
.end

pub struct LsymFileId:
    let raw: LsymFileIndex
.end

pub struct LsymUnitId:
    let raw: LsymUnitIndex
.end

pub struct LsymSectionId:
    let raw: LsymSectionIndex
.end

pub struct LsymBinaryId:
    let raw: LsymBinaryIndex
.end

pub struct LsymLocationId:
    let raw: LsymLocationIndex
.end

pub struct LsymLineId:
    let raw: LsymLineIndex
.end

pub struct LsymTableId:
    let raw: LsymTableIndex
.end

# ----------------------------------------------------------------------------
# Langage, fichiers source et unités de compilation
# ----------------------------------------------------------------------------

# Langage source utilisé pour un fichier/unité.
pub enum LsymLanguageKind:
    LangVitte
    LangRust
    LangC
    LangCpp
    LangOther
.end

# Type de checksum.
pub enum LsymChecksumKind:
    ChecksumNone
    ChecksumMd5
    ChecksumSha1
    ChecksumSha256
    ChecksumOther
.end

# Checksum d'un fichier source.
pub struct LsymChecksum:
    let kind: LsymChecksumKind
    let value: Option<String>
.end

# Fichier source logique.
pub struct LsymFile:
    let id: LsymFileId
    let path: String                # chemin relatif au workspace
    let language: LsymLanguageKind
    let checksum: LsymChecksum
.end

# Unité de compilation (analogue à "compilation unit" DWARF).
pub struct LsymUnit:
    let id: LsymUnitId
    let primary_file: LsymFileId
    let language: LsymLanguageKind
    let producer: String           # ex: "vitte-compiler 0.1.0"
    let flags: Vec<String>         # ex: ["-O2", "-g", ...]
    let defines: Vec<String>       # définitions de préprocesseur éventuelles
.end

# ----------------------------------------------------------------------------
# Sections binaires et images
# ----------------------------------------------------------------------------

# Type de section binaire.
pub enum LsymSectionKind:
    SectionText
    SectionData
    SectionBss
    SectionRodata
    SectionDebug
    SectionOther
.end

# Section binaire dans une image.
pub struct LsymSection:
    let id: LsymSectionId
    let binary: LsymBinaryId
    let name: String               # ex: ".text", ".data"
    let kind: LsymSectionKind
    let address: u64               # adresse de base
    let size_bytes: u64
.end

# Image binaire (exécutable, lib, objet).
pub struct LsymBinaryImage:
    let id: LsymBinaryId
    let path: String               # chemin du binaire
    let format: String             # ex: "ELF", "Mach-O", "PE"
    let arch: String               # ex: "x86_64", "aarch64"
    let uuid: Option<String>       # UUID / build-id
.end

# ----------------------------------------------------------------------------
# Localisation source & adresses
# ----------------------------------------------------------------------------

# Position source (1-based).
pub struct LsymSourcePos:
    let line: u32
    let column: u32
.end

# Localisation source complète.
pub struct LsymLocation:
    let id: LsymLocationId
    let file: LsymFileId
    let pos: LsymSourcePos
.end

# Plage d'adresses machine.
pub struct LsymAddressRange:
    let section: LsymSectionId
    let start_address: u64
    let size_bytes: u64
.end

# ----------------------------------------------------------------------------
# Scopes lexicaux et symboles
# ----------------------------------------------------------------------------

# Type de scope.
pub enum LsymScopeKind:
    ScopeGlobal
    ScopeModule
    ScopeFunction
    ScopeBlock
    ScopeType
    ScopeNamespace
    ScopeParameterList
    ScopeOther
.end

# Scope lexical.
pub struct LsymScope:
    let id: LsymScopeId
    let kind: LsymScopeKind
    let parent: Option<LsymScopeId>
    let unit: LsymUnitId
    let file: LsymFileId
    let start_location: Option<LsymLocationId>
    let end_location: Option<LsymLocationId>
.end

# Visibilité de symbole.
pub enum LsymVisibility:
    VisibilityDefault
    VisibilityPublic
    VisibilityPrivate
    VisibilityHidden
.end

# Linkage de symbole.
pub enum LsymLinkage:
    LinkageNone
    LinkageInternal
    LinkageExternal
    LinkageWeak
    LinkageImport
    LinkageExport
.end

# Classe de stockage.
pub enum LsymStorageClass:
    StorageAuto
    StorageStatic
    StorageExtern
    StorageRegister
    StorageThreadLocal
.end

# Genre de symbole.
pub enum LsymSymbolKind:
    SymFunction
    SymGlobalVar
    SymLocalVar
    SymParam
    SymType
    SymModule
    SymNamespace
    SymLabel
    SymConstant
    SymBuiltin
    SymImport
    SymExport
.end

# Flags supplémentaires sur un symbole.
pub struct LsymSymbolFlags:
    let is_defined: Bool               # true si le symbole a une définition
    let is_declaration_only: Bool      # true si uniquement déclaré
    let is_inline: Bool
    let is_constexpr: Bool
    let is_artificial: Bool            # généré par le compilateur
    let is_tls: Bool                   # thread-local
.end

# Symbole logique.
pub struct LsymSymbol:
    let id: LsymSymbolId
    let name: String                   # nom tel qu'il apparaît dans le code
    let demangled_name: Option<String>
    let qualified_name: Option<String> # ex: "core.math/Vector.len"

    let kind: LsymSymbolKind
    let visibility: LsymVisibility
    let linkage: LsymLinkage
    let storage: LsymStorageClass
    let flags: LsymSymbolFlags

    # Typage / AST.
    let type_name: Option<String>
    let type_expr: Option<TypeExprId>      # lien vers le type dans l'AST
    let ast_node: Option<AstNodeId>       # nœud AST définissant ce symbole

    # Scopes & unités.
    let scope: LsymScopeId
    let defining_unit: LsymUnitId
    let defining_file: LsymFileId
    let defining_location: Option<LsymLocationId>
    let declaring_location: Option<LsymLocationId>

    # Adresse binaire (si applicable).
    let address_range: Option<LsymAddressRange>

    # Lien vers la VM / bytecode (facultatif).
    let lvm_function: Option<LvmFunctionId>
    let lvm_value: Option<LvmValueId>
.end

# Table des symboles.
pub struct LsymSymbolTable:
    let id: LsymTableId
    let binary: Option<LsymBinaryId>
    let unit: Option<LsymUnitId>
    let symbols: Vec<LsymSymbol>
.end

# ----------------------------------------------------------------------------
# Tables de lignes & inlining
# ----------------------------------------------------------------------------

# Entrée de table de lignes.
pub struct LsymLineEntry:
    let id: LsymLineId
    let file: LsymFileId
    let location: LsymSourcePos
    let address_range: LsymAddressRange

    let is_stmt: Bool          # true => début d'instruction
    let is_prologue_end: Bool
    let is_epilogue_begin: Bool
.end

# Programme de lignes (analogue à DWARF line program).
pub struct LsymLineProgram:
    let table: LsymTableId
    let unit: LsymUnitId
    let entries: Vec<LsymLineEntry>
.end

# Site d'inlining (appel inliné).
pub struct LsymInlineSite:
    let call_location: LsymLocationId
    let callee_symbol: LsymSymbolId
    let inlined_into: LsymSymbolId       # fonction dans laquelle on inline
.end

# Chaîne d'inlining (stack d'appels inlinés).
pub struct LsymInlineChain:
    let sites: Vec<LsymInlineSite>
.end

# ----------------------------------------------------------------------------
# Indexation symbolique & vues pour tooling
# ----------------------------------------------------------------------------

# Index nom -> symboles (sur un scope donné).
pub struct LsymNameIndexEntry:
    let name: String
    let symbols: Vec<LsymSymbolId>
.end

pub struct LsymNameIndex:
    let scope: LsymScopeId
    let entries: Vec<LsymNameIndexEntry>
.end

# Vue "workspace" des symboles (multi-unités / multi-binaires).
pub struct LsymWorkspaceIndex:
    let units: Vec<LsymUnitId>
    let binaries: Vec<LsymBinaryId>
    let tables: Vec<LsymSymbolTable>
    let name_indices: Vec<LsymNameIndex>
.end

# ----------------------------------------------------------------------------
# Nœuds génériques lsym pour tooling
# ----------------------------------------------------------------------------

pub enum LsymNodeKind:
    NodeSymbol
    NodeScope
    NodeFile
    NodeUnit
    NodeSection
    NodeBinary
    NodeLocation
    NodeLineEntry
    NodeSymbolTable
.end

pub struct LsymNode:
    let id: LsymNodeIndex
    let kind: LsymNodeKind
.end
