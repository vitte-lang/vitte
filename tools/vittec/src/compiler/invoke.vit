# =========================================================
# vittec — Compiler / Invoke
# =========================================================

space vittec/compiler/invoke

share all

<<< doc
Point d’orchestration principal du compilateur vittec.

Ce module :
- relie la CLI / driver au compilateur interne
- orchestre les phases de compilation
- intègre le cache incrémental
- ne contient aucune logique spécifique de backend

Flux global :
CLI → driver → invoke → (frontend → HIR → backend)
>>>

# ---------------------------------------------------------
# Dépendances
# ---------------------------------------------------------

pull vitte/ast/item
pull vitte/ast/expr
pull vitte/ast/block
pull vitte/ast/common

pull vittec/cache
pull vittec/compiler/frontend
pull vittec/compiler/hir
pull vittec/compiler/validate
pull vittec/compiler/backend

pull vittec/diagnostics as diags
pull vittec/fs as fs

# ---------------------------------------------------------
# Mode d’invocation
# ---------------------------------------------------------

pick InvokeMode
    case Build
    case Check
    case Run
    case Bench
.end

# ---------------------------------------------------------
# Configuration d’invocation
# ---------------------------------------------------------

form InvokeConfig
    field mode as InvokeMode
    field input as string
    field output as Option[string]
    field incremental as bool
    field emit_ast as bool
    field emit_ir as bool
.end

# ---------------------------------------------------------
# Résultat de compilation
# ---------------------------------------------------------

pick InvokeResult
    case Success
    case Failed(code as i32)
.end

# ---------------------------------------------------------
# Entrée principale
# ---------------------------------------------------------

proc invoke(cfg as InvokeConfig) gives InvokeResult

    # --- lecture source ---
    make source as string =
        fs.read_to_string(cfg.input)

    # --- cache incrémental ---
    if cfg.incremental
        make plan as cache.IncrementalPlan =
            cache.build_plan([
                cache.IncrementalUnit.Source(cfg.input)
            ])

        make todo as List[cache.IncrementalUnit] =
            cache.units_to_rebuild(plan)

        if len(todo) == 0
            emit "nothing to rebuild"
            give Success
        .end
    .end

    # --- frontend (parse → AST) ---
    make ast as item.ItemList =
        frontend.parse(source)

    if cfg.emit_ast
        emit ast
    .end

    # --- lowering AST → HIR ---
    make hir_mod as hir.Module =
        hir.lower(ast)

    # --- validation sémantique ---
    make ok as bool =
        validate.run(hir_mod)

    if not ok
        emit diags.print()
        give Failed(1)
    .end

    # --- backend ---
    select cfg.mode
        when Build
            backend.build(hir_mod, cfg.output)
        when Check
            emit "check ok"
        when Run
            backend.run(hir_mod)
        when Bench
            backend.bench(hir_mod)
    .end

    # --- commit cache ---
    if cfg.incremental
        cache.commit(
            cache.build_plan([
                cache.IncrementalUnit.Source(cfg.input)
            ])
        )
    .end

    give Success
.end
