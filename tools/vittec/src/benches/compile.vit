// vittec src ULTRA MAX skeleton
# =========================================================
# vittec — Bench / Compile
# =========================================================

space vittec/benches/compile

share all

<<< doc
Benchmark de compilation pour le compilateur vittec.

Ce fichier définit une suite de benchmarks visant à mesurer :
- le temps de parsing
- le temps de construction AST
- le temps de lowering (AST → HIR)
- le temps de validation sémantique
- le temps de génération backend (si activé)
- le temps total de compilation

Le benchmark est volontairement structuré pour :
- être stable dans le temps
- être comparable entre versions
- être exploitable en CI
>>>

# ---------------------------------------------------------
# Dépendances
# ---------------------------------------------------------

pull vitte/ast/common
pull vitte/ast/item
pull vitte/ast/expr
pull vitte/ast/block

# (interfaces compilateur — à adapter selon vittec)
pull vittec/compiler as compiler
pull vittec/driver as driver
pull vittec/timer as timer
pull vittec/fs as fs

# ---------------------------------------------------------
# Configuration benchmark
# ---------------------------------------------------------

form BenchConfig
    field name as string
    field source_path as string
    field iterations as u32
    field warmup as u32
.end

# ---------------------------------------------------------
# Résultat benchmark
# ---------------------------------------------------------

form BenchResult
    field name as string
    field iterations as u32
    field parse_ms as u64
    field ast_ms as u64
    field hir_ms as u64
    field validate_ms as u64
    field codegen_ms as u64
    field total_ms as u64
.end

# ---------------------------------------------------------
# Cas de test benchmark
# ---------------------------------------------------------

form BenchCase
    field config as BenchConfig
    field result as Option[BenchResult]
.end

# ---------------------------------------------------------
# Benchmarks enregistrés
# ---------------------------------------------------------

form BenchSuite
    field cases as List[BenchCase]
.end

# ---------------------------------------------------------
# Initialisation suite
# ---------------------------------------------------------

proc default_suite() gives BenchSuite

    give BenchSuite([
        BenchCase(
            BenchConfig(
                "small_file",
                "tests/fixtures/small.vit",
                50,
                10
            ),
            none
        ),
        BenchCase(
            BenchConfig(
                "medium_file",
                "tests/fixtures/medium.vit",
                30,
                5
            ),
            none
        ),
        BenchCase(
            BenchConfig(
                "large_file",
                "tests/fixtures/large.vit",
                10,
                2
            ),
            none
        )
    ])
.end

# ---------------------------------------------------------
# Exécution d’un benchmark
# ---------------------------------------------------------

proc run_case(case as BenchCase) gives BenchCase

    make cfg as BenchConfig = case.config

    make parse_total as u64 = 0
    make ast_total as u64 = 0
    make hir_total as u64 = 0
    make validate_total as u64 = 0
    make codegen_total as u64 = 0
    make total_total as u64 = 0

    # warmup
    loop i from 0 to cfg.warmup
        emit driver.compile_file(cfg.source_path)
    .end

    loop i from 0 to cfg.iterations

        make t0 as u64 = timer.now_ms()

        make src as string = fs.read_to_string(cfg.source_path)

        make t1 as u64 = timer.now_ms()
        make ast as item.ItemList = compiler.parse(src)

        make t2 as u64 = timer.now_ms()
        make hir = compiler.lower(ast)

        make t3 as u64 = timer.now_ms()
        compiler.validate(hir)

        make t4 as u64 = timer.now_ms()
        compiler.codegen(hir)

        make t5 as u64 = timer.now_ms()

        set parse_total = parse_total + (t1 - t0)
        set ast_total = ast_total + (t2 - t1)
        set hir_total = hir_total + (t3 - t2)
        set validate_total = validate_total + (t4 - t3)
        set codegen_total = codegen_total + (t5 - t4)
        set total_total = total_total + (t5 - t0)

    .end

    make result as BenchResult =
        BenchResult(
            cfg.name,
            cfg.iterations,
            parse_total / cfg.iterations,
            ast_total / cfg.iterations,
            hir_total / cfg.iterations,
            validate_total / cfg.iterations,
            codegen_total / cfg.iterations,
            total_total / cfg.iterations
        )

    give BenchCase(cfg, result)
.end

# ---------------------------------------------------------
# Exécution de toute la suite
# ---------------------------------------------------------

proc run_suite(suite as BenchSuite) gives BenchSuite

    make out as List[BenchCase] = []

    loop case in suite.cases
        emit out.push(run_case(case))
    .end

    give BenchSuite(out)
.end

# ---------------------------------------------------------
# Affichage résultats
# ---------------------------------------------------------

proc print_result(result as BenchResult)

    emit "=== BENCH: " + result.name
    emit "iterations   : " + result.iterations
    emit "parse (ms)   : " + result.parse_ms
    emit "ast (ms)     : " + result.ast_ms
    emit "hir (ms)     : " + result.hir_ms
    emit "validate(ms) : " + result.validate_ms
    emit "codegen(ms)  : " + result.codegen_ms
    emit "total (ms)   : " + result.total_ms
.end

proc print_suite(suite as BenchSuite)

    loop case in suite.cases
        select case.result
            when some(res)
                emit print_result(res)
        otherwise
            emit "no result"
        .end
    .end
.end

# ---------------------------------------------------------
# Point d’entrée benchmark
# ---------------------------------------------------------

entry bench_compile at vittec/benches/compile

    make suite as BenchSuite = default_suite()
    make results as BenchSuite = run_suite(suite)
    emit print_suite(results)

.end