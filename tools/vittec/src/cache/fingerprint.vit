# =========================================================
# vittec — Cache / Fingerprint
# =========================================================

space vittec/cache/fingerprint

share all

<<< doc
Ce module définit le système de fingerprint de compilation
du compilateur vittec.

Un fingerprint représente l’état *exact* des entrées
influant sur un artefact de compilation.

Utilisé pour :
- cache incrémental
- invalidation sélective
- builds reproductibles
- CI determinism

Principe :
    même entrée → même hash
    entrée différente → hash différent

Aucune dépendance à la stratégie de stockage.
>>>

# ---------------------------------------------------------
# Dépendances
# ---------------------------------------------------------

pull vitte/ast/common/span
pull vitte/ast/common/path

pull vittec/hash as hash
pull vittec/fs as fs
pull vittec/env as env

# ---------------------------------------------------------
# Version du format fingerprint
# ---------------------------------------------------------

form FingerprintVersion
    field major as u16
    field minor as u16
.end

proc current_version() gives FingerprintVersion
    give FingerprintVersion(1, 0)
.end

# ---------------------------------------------------------
# Unité de fingerprint
# ---------------------------------------------------------

pick FingerprintUnit
    case SourceFile(path as string, hash as string)
    case CompilerVersion(version as string)
    case TargetTriple(value as string)
    case OptimizationLevel(level as string)
    case FeatureFlag(name as string, enabled as bool)
    case EnvVar(name as string, value as string)
.end

# ---------------------------------------------------------
# Fingerprint complet
# ---------------------------------------------------------

form Fingerprint
    field version as FingerprintVersion
    field units as List[FingerprintUnit]
.end

# ---------------------------------------------------------
# Hash final
# ---------------------------------------------------------

form FingerprintHash
    field value as string
.end

# ---------------------------------------------------------
# Collecte des unités
# ---------------------------------------------------------

proc source_unit(path as string) gives FingerprintUnit

    make content as string = fs.read_to_string(path)
    make h as string = hash.sha256(content)

    give FingerprintUnit.SourceFile(path, h)
.end

proc compiler_unit() gives FingerprintUnit

    make version as string = env.compiler_version()
    give FingerprintUnit.CompilerVersion(version)
.end

proc target_unit() gives FingerprintUnit

    make triple as string = env.target_triple()
    give FingerprintUnit.TargetTriple(triple)
.end

proc opt_level_unit() gives FingerprintUnit

    make level as string = env.optimization_level()
    give FingerprintUnit.OptimizationLevel(level)
.end

proc feature_unit(name as string, enabled as bool) gives FingerprintUnit
    give FingerprintUnit.FeatureFlag(name, enabled)
.end

proc env_unit(name as string) gives FingerprintUnit

    make value as string = env.get(name)
    give FingerprintUnit.EnvVar(name, value)
.end

# ---------------------------------------------------------
# Construction d’un fingerprint
# ---------------------------------------------------------

proc new_fingerprint() gives Fingerprint

    give Fingerprint(
        current_version(),
        []
    )
.end

proc add_unit(
    fp as Fingerprint,
    unit as FingerprintUnit
) gives Fingerprint

    emit fp.units.push(unit)
    give fp
.end

# ---------------------------------------------------------
# Normalisation (ordre stable)
# ---------------------------------------------------------

proc unit_key(unit as FingerprintUnit) gives string

    select unit
        when SourceFile(path, _)
            give "src:" + path
        when CompilerVersion(v)
            give "compiler:" + v
        when TargetTriple(t)
            give "target:" + t
        when OptimizationLevel(l)
            give "opt:" + l
        when FeatureFlag(n, _)
            give "feature:" + n
        when EnvVar(n, _)
            give "env:" + n
    .end
.end

proc normalize(fp as Fingerprint) gives Fingerprint

    make sorted as List[FingerprintUnit] =
        sort_by(fp.units, unit_key)

    give Fingerprint(fp.version, sorted)
.end

# ---------------------------------------------------------
# Sérialisation déterministe
# ---------------------------------------------------------

proc serialize_unit(unit as FingerprintUnit) gives string

    select unit
        when SourceFile(path, h)
            give "SRC|" + path + "|" + h
        when CompilerVersion(v)
            give "COMPILER|" + v
        when TargetTriple(t)
            give "TARGET|" + t
        when OptimizationLevel(l)
            give "OPT|" + l
        when FeatureFlag(n, e)
            give "FEATURE|" + n + "|" + e
        when EnvVar(n, v)
            give "ENV|" + n + "|" + v
    .end
.end

proc serialize(fp as Fingerprint) gives string

    make out as string =
        "VITTE_FP|" +
        fp.version.major +
        "." +
        fp.version.minor +
        "\n"

    loop unit in fp.units
        set out = out + serialize_unit(unit) + "\n"
    .end

    give out
.end

# ---------------------------------------------------------
# Hash final du fingerprint
# ---------------------------------------------------------

proc compute_hash(fp as Fingerprint) gives FingerprintHash

    make normalized as Fingerprint = normalize(fp)
    make data as string = serialize(normalized)
    make h as string = hash.sha256(data)

    give FingerprintHash(h)
.end

# ---------------------------------------------------------
# API haut niveau
# ---------------------------------------------------------

proc fingerprint_for_file(
    path as string
) gives FingerprintHash

    make fp as Fingerprint = new_fingerprint()

    set fp = add_unit(fp, source_unit(path))
    set fp = add_unit(fp, compiler_unit())
    set fp = add_unit(fp, target_unit())
    set fp = add_unit(fp, opt_level_unit())

    give compute_hash(fp)
.end