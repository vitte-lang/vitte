# =========================================================
# vittec — Cache / Incremental Compilation
# =========================================================

space vittec/cache/incremental

share all

<<< doc
Ce module implémente la logique de compilation incrémentale
du compilateur vittec.

Responsabilités :
- décider si un artefact peut être réutilisé
- comparer fingerprints anciens / nouveaux
- déterminer les unités à recompiler
- orchestrer les passes incrémentales

Ce module :
- NE stocke rien (voir cache/storage)
- NE compile rien directement
- NE dépend PAS du backend

Il agit comme un moteur de décision.
>>>

# ---------------------------------------------------------
# Dépendances
# ---------------------------------------------------------

pull vittec/cache/fingerprint
pull vittec/cache/storage
pull vittec/cache/graph

pull vitte/ast/common/path
pull vitte/ast/common/span

# ---------------------------------------------------------
# Unité de compilation incrémentale
# ---------------------------------------------------------

pick IncrementalUnit
    case Source(path as string)
    case Module(path as Path)
    case Item(name as string)
    case Crate(name as string)
.end

# ---------------------------------------------------------
# État d’une unité
# ---------------------------------------------------------

pick UnitState
    case Clean          # fingerprint identique
    case Dirty          # fingerprint différent
    case New            # pas encore compilé
    case Removed        # supprimé depuis le dernier build
.end

# ---------------------------------------------------------
# Résultat d’analyse incrémentale
# ---------------------------------------------------------

form IncrementalDecision
    field unit as IncrementalUnit
    field state as UnitState
    field old_hash as Option[FingerprintHash]
    field new_hash as Option[FingerprintHash]
.end

# ---------------------------------------------------------
# Plan de compilation incrémentale
# ---------------------------------------------------------

form IncrementalPlan
    field decisions as List[IncrementalDecision]
.end

# ---------------------------------------------------------
# Analyse d’une unité
# ---------------------------------------------------------

proc analyze_unit(
    unit as IncrementalUnit
) gives IncrementalDecision

    make old as Option[FingerprintHash] =
        storage.load_fingerprint(unit)

    make new as Option[FingerprintHash] =
        fingerprint.compute_for_unit(unit)

    select (old, new)
        when (none, some(n))
            give IncrementalDecision(unit, New, none, some(n))
        when (some(o), none)
            give IncrementalDecision(unit, Removed, some(o), none)
        when (some(o), some(n))
            if o.value == n.value
                give IncrementalDecision(unit, Clean, some(o), some(n))
            .end
            give IncrementalDecision(unit, Dirty, some(o), some(n))
    otherwise
        give IncrementalDecision(unit, Dirty, old, new)
    .end
.end

# ---------------------------------------------------------
# Analyse d’un ensemble d’unités
# ---------------------------------------------------------

proc analyze_units(
    units as List[IncrementalUnit]
) gives IncrementalPlan

    make decisions as List[IncrementalDecision] = []

    loop u in units
        emit decisions.push(analyze_unit(u))
    .end

    give IncrementalPlan(decisions)
.end

# ---------------------------------------------------------
# Propagation des invalidations (graphe de dépendances)
# ---------------------------------------------------------

proc propagate(
    plan as IncrementalPlan
) gives IncrementalPlan

    make dirty_units as List[IncrementalUnit] = []

    loop d in plan.decisions
        if d.state == Dirty or d.state == New or d.state == Removed
            emit dirty_units.push(d.unit)
        .end
    .end

    make expanded as List[IncrementalUnit] =
        graph.expand_dependents(dirty_units)

    make final as List[IncrementalDecision] = []

    loop d in plan.decisions
        if expanded.contains(d.unit)
            emit final.push(
                IncrementalDecision(
                    d.unit,
                    Dirty,
                    d.old_hash,
                    d.new_hash
                )
            )
        else
            emit final.push(d)
        .end
    .end

    give IncrementalPlan(final)
.end

# ---------------------------------------------------------
# Plan final incrémental
# ---------------------------------------------------------

proc build_plan(
    units as List[IncrementalUnit]
) gives IncrementalPlan

    make base as IncrementalPlan = analyze_units(units)
    give propagate(base)
.end

# ---------------------------------------------------------
# Sélection des unités à recompiler
# ---------------------------------------------------------

proc units_to_rebuild(
    plan as IncrementalPlan
) gives List[IncrementalUnit]

    make out as List[IncrementalUnit] = []

    loop d in plan.decisions
        if d.state == Dirty or d.state == New
            emit out.push(d.unit)
        .end
    .end

    give out
.end

# ---------------------------------------------------------
# Commit post-build
# ---------------------------------------------------------

proc commit(
    plan as IncrementalPlan
)

    loop d in plan.decisions
        select d.state
            when Clean
                emit ()
            when Dirty
                emit storage.store_fingerprint(d.unit, d.new_hash)
            when New
                emit storage.store_fingerprint(d.unit, d.new_hash)
            when Removed
                emit storage.remove_fingerprint(d.unit)
        .end
    .end

.end