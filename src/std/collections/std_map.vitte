

module std.collections.std_map

import std.collections as coll

# ============================================================================
# std.collections.std_map – Modèle logique des maps associatives
# (maximal, déclaratif, sans I/O)
#
# Objectifs :
#   - Décrire une famille de maps associatives génériques :
#       * HashMap<K, V> (map de base, non ordonnée),
#       * MultiMap<K, V> (clé → plusieurs valeurs),
#       * OrderedMap<K, V> (clé ordonnée, abstraction de type BTree),
#       * vues/itérateurs (clé, valeur, entrée),
#       * configuration interne, stats, métadonnées.
#   - Fournir un contrat de données entre :
#       * le compilateur / typechecker,
#       * le runtime / VM (implémentations concrètes),
#       * les outils (debugger, profiler, visualiseurs).
#   - Ne contenir :
#       * aucune fonction,
#       * aucune logique d’algorithme (hashing, probing, comparaison),
#       * aucune I/O ni formatage.
# ============================================================================

# ---------------------------------------------------------------------------
# Identifiants et genres de map
# ---------------------------------------------------------------------------

struct StdMapId
    raw: u64
.end

enum StdMapKind
    StdMapHashMap
    StdMapMultiMap
    StdMapOrderedMap
    StdMapOther
.end

enum StdMapBackendKind
    StdMapBackendRuntimeBuiltin     # implémentation fournie par le runtime/VM
    StdMapBackendNativeHost         # implémentation native (ex: C/Rust) via FFI
    StdMapBackendPureVitte          # implémentation pure Vitte
    StdMapBackendExperimental
    StdMapBackendOther
.end

# ---------------------------------------------------------------------------
# État des entrées / buckets (HashMap)
# ---------------------------------------------------------------------------

enum StdMapEntryState
    StdMapEntryEmpty
    StdMapEntryOccupied
    StdMapEntryTombstone
.end

struct StdMapHash
    # Représentation brute du hash (64 bits)
    value: u64

    # Entropie/qualité estimée (0..100)
    quality_percent: u8

    extra: coll.HashMap<String, String>
.end

struct StdMapBucketIndex
    # Index du bucket dans le tableau
    index: u64

    # Longueur de probing (ex: robin-hood, linear probing)
    probe_length: u32

    extra: coll.HashMap<String, String>
.end

# ---------------------------------------------------------------------------
# Entrées génériques HashMap<K, V>
# ---------------------------------------------------------------------------

struct StdMapEntry<K, V>
    state: StdMapEntryState

    # Clé/valeur logiques
    key: K
    value: V

    # Hash associé à la clé (memoisé)
    hash: StdMapHash

    # Métadonnées diverses (timestamp insertion, tag, etc.)
    tag: String

    extra: coll.HashMap<String, String>
.end

# ---------------------------------------------------------------------------
# Configuration et stats des HashMap
# ---------------------------------------------------------------------------

enum StdMapGrowthStrategy
    StdMapGrowthDouble            # capacity *= 2
    StdMapGrowthFactor            # capacity *= factor
    StdMapGrowthPrimeSequence     # nombres premiers
    StdMapGrowthFixed             # pas de croissance auto
    StdMapGrowthOther
.end

struct StdMapCapacityHint
    initial_capacity: u64         # capacité initiale suggérée
    max_load_percent: u8          # ex: 75
    growth_strategy: StdMapGrowthStrategy

    # Facteur de croissance custom si StdMapGrowthFactor
    growth_factor_numerator: u32
    growth_factor_denominator: u32

    # Autoriser le shrink sur petites tables
    allow_shrink: bool

    extra: coll.HashMap<String, String>
.end

struct StdMapStats
    # Taille logique (nombre de paires clé/valeur)
    len: u64

    # Capacité (nombre de buckets)
    capacity: u64

    # Nombre de tombstones
    tombstones: u64

    # Nombre de rehashes / resizes
    resize_count: u64

    # Collisions enregistrées
    collision_count: u64

    # Longueur max de probing observée
    max_probe_length: u32

    # Mesures approximatives (optionnelles)
    average_probe_length: f64
    load_factor: f64

    extra: coll.HashMap<String, String>
.end

struct StdMapHashConfig
    # Identifiant de la stratégie de hash (ex: "std-fnv1a-64")
    algorithm_name: String

    # Seed actuelle (si applicable)
    seed: u64

    # True si la stratégie est randomisée par process
    randomized: bool

    extra: coll.HashMap<String, String>
.end

# ---------------------------------------------------------------------------
# Représentation interne d’une HashMap<K, V>
# ---------------------------------------------------------------------------

struct StdHashMapCore<K, V>
    # Entrées/buckets
    buckets: coll.Vec<StdMapEntry<K, V>>

    # Nombre logique d’éléments occupés
    len: u64

    # Nombre de tombstones
    tombstones: u64

    # Stratégie de capacité
    capacity_hint: StdMapCapacityHint

    # Config de hashing
    hash_config: StdMapHashConfig

    # Statistiques agrégées
    stats: StdMapStats

    extra: coll.HashMap<String, String>
.end

# ---------------------------------------------------------------------------
# MultiMap<K, V> (clé → plusieurs valeurs)
# ---------------------------------------------------------------------------

struct StdMultiMapEntry<K, V>
    key: K
    values: coll.Vec<V>

    # Hash de la clé pour réutiliser la logique HashMap
    hash: StdMapHash

    extra: coll.HashMap<String, String>
.end

struct StdMultiMapCore<K, V>
    # Entrées associées
    entries: coll.Vec<StdMultiMapEntry<K, V>>

    # Nombre logique de clés
    key_count: u64

    # Nombre total de valeurs
    value_count: u64

    # Config de capacité/charge (facultatif)
    capacity_hint: StdMapCapacityHint

    extra: coll.HashMap<String, String>
.end

# ---------------------------------------------------------------------------
# OrderedMap<K, V> – map ordonnée (abstraction B-Tree/équivalent)
# ---------------------------------------------------------------------------

enum StdOrderedMapNodeKind
    StdOrderedMapNodeInternal
    StdOrderedMapNodeLeaf
.end

struct StdOrderedMapNode<K, V>
    kind: StdOrderedMapNodeKind

    # Clés du node
    keys: coll.Vec<K>
    values: coll.Vec<V>

    # Enfants pour nœuds internes
    children_indices: coll.Vec<u64>

    # Index de ce node dans le stockage
    self_index: u64

    # Index du parent (ou -1/UINT64_MAX si racine)
    parent_index: u64

    extra: coll.HashMap<String, String>
.end

struct StdOrderedMapCore<K, V>
    # Stockage des nœuds
    nodes: coll.Vec<StdOrderedMapNode<K, V>>

    # Index du nœud racine
    root_index: u64

    # Nombre logique d’entrées (paires clé/valeur)
    len: u64

    # Paramètres de B-Tree (ordre minimal/maximal), si pertinent
    min_degree: u32
    max_degree: u32

    extra: coll.HashMap<String, String>
.end

# ---------------------------------------------------------------------------
# Vues/itérateurs (data-only)
# ---------------------------------------------------------------------------

enum StdMapIterKind
    StdMapIterKeys
    StdMapIterValues
    StdMapIterEntries
    StdMapIterOther
.end

struct StdMapIterState
    index: u64
    remaining: u64

    # Position interne pour probing / structure arborescente
    bucket_index: u64
    probe_length: u32

    extra: coll.HashMap<String, String>
.end

struct StdHashMapIter<K, V>
    kind: StdMapIterKind

    # Référence logique vers une map
    map_id: StdMapId

    # Instantané ou vue logique sur les buckets
    bucket_count: u64

    state: StdMapIterState

    extra: coll.HashMap<String, String>
.end

struct StdOrderedMapIter<K, V>
    kind: StdMapIterKind

    map_id: StdMapId

    # Pile de navigation dans l’arbre (indexes de nœuds)
    node_stack: coll.Vec<u64>
    key_indices_stack: coll.Vec<u64>

    state: StdMapIterState

    extra: coll.HashMap<String, String>
.end

struct StdMultiMapIter<K, V>
    kind: StdMapIterKind

    map_id: StdMapId

    # Indices dans la structure MultiMap
    entry_index: u64        # index de StdMultiMapEntry
    value_index: u64        # index dans la liste de valeurs

    state: StdMapIterState

    extra: coll.HashMap<String, String>
.end

# ---------------------------------------------------------------------------
# Résumés/logiques partagées pour toutes les maps
# ---------------------------------------------------------------------------

struct StdMapMeta
    id: StdMapId

    kind: StdMapKind
    backend_kind: StdMapBackendKind

    # Nom logique / debug (ex: "env_vars_map", "symbol_table")
    logical_name: String
    debug_label: String

    # Infos de capacité/chargement
    capacity_hint: StdMapCapacityHint
    stats: StdMapStats

    # Flags de comportement
    is_thread_safe: bool
    is_shared: bool
    is_read_only: bool

    # Tags libres (profiling, logging, etc.)
    tags: coll.Vec<String>

    extra: coll.HashMap<String, String>
.end

struct StdHashMap<K, V>
    meta: StdMapMeta
    core: StdHashMapCore<K, V>

    extra: coll.HashMap<String, String>
.end

struct StdMultiMap<K, V>
    meta: StdMapMeta
    core: StdMultiMapCore<K, V>

    extra: coll.HashMap<String, String>
.end

struct StdOrderedMap<K, V>
    meta: StdMapMeta
    core: StdOrderedMapCore<K, V>

    extra: coll.HashMap<String, String>
.end

# ---------------------------------------------------------------------------
# Résumés globaux / index pour introspection std.collections
# ---------------------------------------------------------------------------

struct StdMapRegistryEntry
    id: StdMapId

    kind: StdMapKind
    backend_kind: StdMapBackendKind

    logical_name: String

    # Statistiques instantanées
    stats: StdMapStats

    extra: coll.HashMap<String, String>
.end

struct StdMapRegistry
    # Liste des maps connues/trackées
    maps: coll.Vec<StdMapRegistryEntry>

    # Index par logical_name
    map_id_by_name: coll.HashMap<String, StdMapId>

    extra: coll.HashMap<String, String>
.end

struct StdMapModel
    # Registry global des maps (pour introspection/debug)
    registry: StdMapRegistry

    # Données libres
    extra: coll.HashMap<String, String>
.end