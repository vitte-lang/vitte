

module std.fs.std_fs

import std.collections as coll

# ============================================================================
# std.fs.std_fs – Modèle logique du système de fichiers standard
# (maximal, déclaratif, sans I/O)
#
# Objectifs :
#   - Décrire une vue purement déclarative du système de fichiers :
#       * chemins (paths) et segments,
#       * types d’entrées (fichiers, répertoires, symlinks, etc.),
#       * métadonnées, permissions, volumes,
#       * handles/logique d’ouverture (sans fonctions),
#       * erreurs et opérations logiques (requêtes/résultats),
#       * snapshot et registre logique des chemins.
#   - Servir de contrat de données entre :
#       * le compilateur / typechecker,
#       * le runtime / VM (impl concrètes d’I/O),
#       * les outils (debugger, profiler, visualiseurs, IDE).
#   - Ne contenir :
#       * aucune fonction,
#       * aucune logique d’algorithme ou d’I/O,
#       * aucun accès réel au système de fichiers.
# ============================================================================

# ---------------------------------------------------------------------------
# Identifiants
# ---------------------------------------------------------------------------

struct StdFsPathId
    raw: u64
.end

struct StdFsEntryId
    raw: u64
.end

struct StdFsHandleId
    raw: u64
.end

struct StdFsVolumeId
    raw: u64
.end

struct StdFsSnapshotId
    raw: u64
.end

struct StdFsOpId
    raw: u64
.end

# ---------------------------------------------------------------------------
# Styles et composants de chemins
# ---------------------------------------------------------------------------

enum StdFsPathStyle
    StdFsPathStylePosix
    StdFsPathStyleWindows
    StdFsPathStyleUrl
    StdFsPathStyleVirtual
    StdFsPathStyleOther
.end

enum StdFsPathComponentKind
    StdFsPathComponentRoot
    StdFsPathComponentCurrent      # "."
    StdFsPathComponentParent       # ".."
    StdFsPathComponentNormal       # segment "normal"
    StdFsPathComponentSeparator
    StdFsPathComponentDrivePrefix  # "C:" sur Windows
    StdFsPathComponentUNCServer
    StdFsPathComponentUNCShare
    StdFsPathComponentOther
.end

struct StdFsPathSegment
    kind: StdFsPathComponentKind

    # Texte brut tel que fourni par l’utilisateur ou le système
    raw: String

    # Version normalisée (ex: case folding selon la plateforme)
    normalized: String

    # Indique si ce segment est un composant spécial (., ..)
    is_special: bool

    extra: coll.HashMap<String, String]
.end

struct StdFsPathRepr
    style: StdFsPathStyle

    # Chemin texte complet
    text: String

    # Indications de forme
    is_absolute: bool
    has_trailing_separator: bool

    # Segments découpés
    segments: coll.Vec<StdFsPathSegment>

    # Détails spécifiques Windows (optionnels)
    drive_letter: String            # ex: "C"
    unc_server: String
    unc_share: String

    extra: coll.HashMap<String, String]
.end

struct StdFsPath
    id: StdFsPathId

    # Représentation canonique
    repr: StdFsPathRepr

    # Namespace logique (ex: "local", "temp", "virtual")
    namespace: String

    # Tags libres
    tags: coll.Vec<String>

    extra: coll.HashMap<String, String]
.end

# ---------------------------------------------------------------------------
# Types d’entrées / permissions / métadonnées
# ---------------------------------------------------------------------------

enum StdFsFileType
    StdFsFileTypeFile
    StdFsFileTypeDirectory
    StdFsFileTypeSymlink
    StdFsFileTypeSocket
    StdFsFileTypeFifo
    StdFsFileTypeBlockDevice
    StdFsFileTypeCharDevice
    StdFsFileTypeUnknown
.end

struct StdFsPermissionBits
    # Permissions de style POSIX (si disponibles)
    owner_read: bool
    owner_write: bool
    owner_exec: bool

    group_read: bool
    group_write: bool
    group_exec: bool

    other_read: bool
    other_write: bool
    other_exec: bool

    # Représentation brute (ex: mode_t sur POSIX)
    raw_mode: u32

    extra: coll.HashMap<String, String]
.end

struct StdFsOwnership
    # Identifiants de propriétaire (si disponibles)
    uid: u32
    gid: u32

    # Noms logiques (optionnels)
    owner_name: String
    group_name: String

    extra: coll.HashMap<String, String]
.end

struct StdFsTimestamps
    # Timestamps en format ISO 8601 ou epoch stringifié
    created_at: String
    modified_at: String
    accessed_at: String

    extra: coll.HashMap<String, String]
.end

struct StdFsMetadata
    # Type d’entrée
    file_type: StdFsFileType

    # Taille en octets (pour les fichiers réguliers, si connu)
    size_bytes: u64

    # Nombre de liens durs (si applicable)
    hard_link_count: u64

    # Permissions et ownership
    permissions: StdFsPermissionBits
    ownership: StdFsOwnership

    # Timestamps
    timestamps: StdFsTimestamps

    # Identifiants bas niveau (si exposés)
    inode: u64
    device_id: u64

    # Indique si la cible est un symlink
    is_symlink: bool

    extra: coll.HashMap<String, String]
.end

# ---------------------------------------------------------------------------
# Volumes / partitions / points de montage
# ---------------------------------------------------------------------------

struct StdFsVolumeInfo
    id: StdFsVolumeId

    # Nom logique / device
    device_name: String
    mount_point: StdFsPath

    # Type de système de fichiers (ex: "ext4", "apfs", "ntfs")
    fs_type: String

    # Capacités
    total_bytes: u64
    free_bytes: u64
    available_bytes: u64

    # Flags
    read_only: bool
    supports_symlinks: bool
    case_sensitive: bool
    case_preserving: bool

    extra: coll.HashMap<String, String]
.end

# ---------------------------------------------------------------------------
# Handles / options d’ouverture (modèle logique, sans fonctions)
# ---------------------------------------------------------------------------

struct StdFsOpenOptions
    read: bool
    write: bool
    append: bool
    truncate: bool
    create: bool
    create_new: bool

    # Mode brut (ex: 0o644)
    mode_bits: u32

    # Indicateurs avancés (non portables)
    non_blocking: bool
    close_on_exec: bool

    extra: coll.HashMap<String, String]
.end

enum StdFsHandleKind
    StdFsHandleFile
    StdFsHandleDirectory
    StdFsHandleSymlink
    StdFsHandleOther
.end

struct StdFsHandleState
    # Offset logique dans le flux (pour les fichiers)
    offset: u64

    # True si le handle est encore ouvert
    is_open: bool

    # True si la position est au bout du fichier
    is_at_end: bool

    extra: coll.HashMap<String, String]
.end

struct StdFsHandle
    id: StdFsHandleId

    kind: StdFsHandleKind

    # Chemin logiquement associé (si connu)
    path_id: StdFsPathId

    # Options d’ouverture
    open_options: StdFsOpenOptions

    # Métadonnées au moment de l’ouverture (snapshot)
    metadata_at_open: StdFsMetadata

    # État logique courant
    state: StdFsHandleState

    extra: coll.HashMap<String, String]
.end

# ---------------------------------------------------------------------------
# Entrées de répertoire
# ---------------------------------------------------------------------------

struct StdFsDirEntry
    entry_id: StdFsEntryId

    # Répertoire parent
    parent_dir_path_id: StdFsPathId

    # Chemin complet de l’entrée
    path_id: StdFsPathId

    # Nom basique (basename)
    file_name: String

    file_type: StdFsFileType

    # Métadonnées optionnelles (snapshot)
    metadata: StdFsMetadata

    extra: coll.HashMap<String, String]
.end

struct StdFsDirectoryListing
    dir_path_id: StdFsPathId

    entries: coll.Vec<StdFsDirEntry>

    # Indique si la liste est complète ou partielle (pagination, filtres)
    is_complete: bool

    extra: coll.HashMap<String, String]
.end

# ---------------------------------------------------------------------------
# Glob / patterns / filtres de chemin (modèle data-only)
# ---------------------------------------------------------------------------

enum StdFsGlobTokenKind
    StdFsGlobTokenLiteral
    StdFsGlobTokenWildcardSingle     # ?
    StdFsGlobTokenWildcardMulti      # *
    StdFsGlobTokenCharClass          # [...]
    StdFsGlobTokenRecursive          # **
    StdFsGlobTokenSeparator
    StdFsGlobTokenOther
.end

struct StdFsGlobToken
    kind: StdFsGlobTokenKind
    text: String

    extra: coll.HashMap<String, String]
.end

struct StdFsGlobPattern
    # Pattern brut (ex: "**/*.vitte")
    raw_pattern: String

    # Tokens découpés
    tokens: coll.Vec<StdFsGlobToken>

    # Flags de matching
    case_sensitive: bool
    anchored: bool

    extra: coll.HashMap<String, String]
.end

# ---------------------------------------------------------------------------
# Erreurs et opérations logiques
# ---------------------------------------------------------------------------

enum StdFsErrorKind
    StdFsErrorNotFound
    StdFsErrorPermissionDenied
    StdFsErrorAlreadyExists
    StdFsErrorInvalidInput
    StdFsErrorIo
    StdFsErrorInterrupted
    StdFsErrorUnsupported
    StdFsErrorNameTooLong
    StdFsErrorTooManySymlinks
    StdFsErrorOutOfSpace
    StdFsErrorQuotaExceeded
    StdFsErrorCrossDevice
    StdFsErrorOther
.end

struct StdFsError
    kind: StdFsErrorKind

    message: String

    # Code d’erreur système (errno, GetLastError, etc.)
    os_code: i32

    # Chemin concerné (si connu)
    primary_path_id: StdFsPathId
    secondary_path_id: StdFsPathId

    # Opération logique qui a échoué
    op_name: String                  # ex: "open", "read", "write", "create_dir"

    extra: coll.HashMap<String, String]
.end

enum StdFsOpKind
    StdFsOpReadFile
    StdFsOpWriteFile
    StdFsOpAppendFile
    StdFsOpOpenHandle
    StdFsOpCloseHandle
    StdFsOpCreateDir
    StdFsOpRemoveFile
    StdFsOpRemoveDir
    StdFsOpRename
    StdFsOpCopy
    StdFsOpReadDir
    StdFsOpSymlink
    StdFsOpReadLink
    StdFsOpMetadata
    StdFsOpOther
.end

struct StdFsOpRequest
    id: StdFsOpId

    kind: StdFsOpKind

    # Chemins impliqués
    primary_path_id: StdFsPathId
    secondary_path_id: StdFsPathId

    # Handle concerné (si applicable)
    handle_id: StdFsHandleId

    # Paramètres numériques (offset, longueur, etc.)
    offset: u64
    length: u64

    # Options d’ouverture/écriture (pour les opérations qui en ont besoin)
    open_options: StdFsOpenOptions

    extra: coll.HashMap<String, String]
.end

struct StdFsOpResult
    id: StdFsOpId

    # True si l’opération est un succès logique
    success: bool

    # Erreur (si !success)
    error: StdFsError

    # Informations sur l’opération effectuée
    bytes_transferred: u64
    resulting_metadata: StdFsMetadata
    resulting_handle_id: StdFsHandleId

    # Résultat de type "listing" (pour read_dir, par exemple)
    dir_listing: StdFsDirectoryListing

    extra: coll.HashMap<String, String]
.end

# ---------------------------------------------------------------------------
# Snapshots / vues globales
# ---------------------------------------------------------------------------

struct StdFsSnapshot
    id: StdFsSnapshotId

    # Contexte temporel
    captured_at: String              # ISO 8601

    # Contexte d’environnement
    workspace_root_path_id: StdFsPathId
    cwd_path_id: StdFsPathId
    home_path_id: StdFsPathId
    temp_dir_path_id: StdFsPathId

    # Volumes
    volumes: coll.Vec<StdFsVolumeInfo>

    extra: coll.HashMap<String, String]
.end

# ---------------------------------------------------------------------------
# Registre logique des chemins / entrées
# ---------------------------------------------------------------------------

struct StdFsRegistryEntry
    entry_id: StdFsEntryId

    # Chemin et type
    path_id: StdFsPathId
    file_type: StdFsFileType

    # Métadonnées caches
    metadata: StdFsMetadata

    # Indique si ce chemin est connu pour exister
    exists: bool

    # Tags libres (ex: "project-root", "build-output")
    tags: coll.Vec<String>

    extra: coll.HashMap<String, String]
.end

struct StdFsRegistry
    # Entrées connues
    entries: coll.Vec<StdFsRegistryEntry>

    # Index par texte de chemin canonique
    path_id_by_text: coll.HashMap<String, StdFsPathId>

    # Index par tag logique
    entry_ids_by_tag: coll.HashMap<String, coll.Vec<StdFsEntryId>>

    extra: coll.HashMap<String, String]
.end

# ---------------------------------------------------------------------------
# Modèle racine std.fs
# ---------------------------------------------------------------------------

struct StdFsModel
    # Registre logique des chemins/entrées
    registry: StdFsRegistry

    # Dernier snapshot global connu
    latest_snapshot: StdFsSnapshot

    # Historique d’opérations (requêtes/résultats)
    op_requests: coll.Vec<StdFsOpRequest>
    op_results: coll.Vec<StdFsOpResult>

    # Données libres (notes, versions de schéma, tags)
    extra: coll.HashMap<String, String]
.end