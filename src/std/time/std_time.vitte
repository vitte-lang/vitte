module std.time.std_time

import std.collections as coll

# ============================================================================
# std.time.std_time – Modèle logique du temps et des horloges
# (maximal, déclaratif, sans I/O)
#
# Objectifs :
#   - Décrire une vue purement déclarative du temps :
#       * instants (points sur une ligne de temps),
#       * durées (intervals),
#       * date/heure, fuseaux horaires, calendriers,
#       * horloges (system, monotonic, high-res, custom),
#       * timers, deadlines, timeouts,
#       * opérations logiques (now, add, diff, convert, parse, format)
#         sous forme de requêtes/résultats/métriques/sessions.
#   - Servir de contrat de données entre :
#       * le compilateur / typechecker,
#       * le runtime / VM (impl concrètes),
#       * les outils (debugger, profiler, visualiseurs, IDE).
#   - Ne contenir :
#       * aucune fonction,
#       * aucune logique d’algorithme,
#       * aucune I/O ni accès réel à l’horloge système.
# ============================================================================

# ---------------------------------------------------------------------------
# Identifiants
# ---------------------------------------------------------------------------

struct StdTimeInstantId
    raw: u64
.end

struct StdTimeDurationId
    raw: u64
.end

struct StdTimeZoneId
    raw: u32
.end

struct StdTimeCalendarId
    raw: u32
.end

struct StdTimeClockId
    raw: u32
.end

struct StdTimeTimerId
    raw: u64
.end

struct StdTimeOpId
    raw: u64
.end

struct StdTimeSessionId
    raw: u64
.end

struct StdTimeSnapshotId
    raw: u64
.end

# ---------------------------------------------------------------------------
# Genres d’instants / durées / horloges
# ---------------------------------------------------------------------------

enum StdTimeInstantKind
    StdTimeInstantWallUtc        # horloge murale UTC
    StdTimeInstantWallLocal      # horloge murale locale
    StdTimeInstantMonotonic      # horloge monotone (durées fiables, pas d’horodatage absolu)
    StdTimeInstantSteady         # horloge stable (pas de saut)
    StdTimeInstantProcess        # temps process
    StdTimeInstantThread         # temps thread
    StdTimeInstantCustom
.end

enum StdTimeDurationUnit
    StdTimeDurationSeconds
    StdTimeDurationMilliseconds
    StdTimeDurationMicroseconds
    StdTimeDurationNanoseconds
    StdTimeDurationMinutes
    StdTimeDurationHours
    StdTimeDurationDays
    StdTimeDurationOther
.end

enum StdTimeClockKind
    StdTimeClockSystemUtc
    StdTimeClockSystemLocal
    StdTimeClockMonotonic
    StdTimeClockHighResolution
    StdTimeClockCustom
.end

enum StdTimeTimerKind
    StdTimeTimerOneShot
    StdTimeTimerRepeating
    StdTimeTimerDeadline
    StdTimeTimerTimeout
    StdTimeTimerOther
.end

# ---------------------------------------------------------------------------
# Fuseaux horaires / offsets
# ---------------------------------------------------------------------------

struct StdTimeUtcOffset
    # Offset en secondes par rapport à UTC (-86400..+86400 environ)
    seconds: i32

    # Indique si c’est un offset fixe (sans règles DST)
    is_fixed: bool

    extra: coll.HashMap<String, String>
.end

enum StdTimeZoneKind
    StdTimeZoneFixedOffset        # ex: UTC+02:00
    StdTimeZoneNamed              # ex: "Europe/Paris"
    StdTimeZoneSystemLocal        # fuseau local du système
    StdTimeZoneCustom
.end

struct StdTimeZoneRule
    # Règle de changement d’heure (DST, etc.)
    name: String                  # ex: "CET", "CEST"
    offset: StdTimeUtcOffset

    # Heuristique de début/fin (texte, purement déclaratif)
    start_rule: String            # ex: "last Sunday of March 02:00"
    end_rule: String              # ex: "last Sunday of October 03:00"

    extra: coll.HashMap<String, String]
.end

struct StdTimeZoneInfo
    id: StdTimeZoneId

    kind: StdTimeZoneKind

    # Nom logique complet, ex: "Europe/Paris"
    canonical_name: String

    # Offset par défaut
    default_offset: StdTimeUtcOffset

    # Règles éventuelles (DST, etc.)
    rules: coll.Vec<StdTimeZoneRule>

    # Tags libres (ex: "europe", "system-default")
    tags: coll.Vec<String]

    extra: coll.HashMap<String, String]
.end

struct StdTimeZoneDatabase
    # Fuseaux connus
    zones: coll.Vec<StdTimeZoneInfo>

    # Index par nom canonique
    zone_id_by_name: coll.HashMap<String, StdTimeZoneId>

    # Nom du bundle de données (ex: "tzdb-2025a")
    data_bundle_name: String

    extra: coll.HashMap<String, String]
.end

# ---------------------------------------------------------------------------
# Calendrier / date / heure locale
# ---------------------------------------------------------------------------

enum StdTimeCalendarKind
    StdTimeCalendarIso8601
    StdTimeCalendarProlepticGregorian
    StdTimeCalendarUnixTime
    StdTimeCalendarCustom
.end

struct StdTimeCalendarInfo
    id: StdTimeCalendarId

    kind: StdTimeCalendarKind

    name: String
    description: String

    # True si le calendrier suit ISO 8601 (année/mois/jour)
    is_iso_compatible: bool

    extra: coll.HashMap<String, String]
.end

enum StdTimeWeekday
    StdTimeWeekdayMonday
    StdTimeWeekdayTuesday
    StdTimeWeekdayWednesday
    StdTimeWeekdayThursday
    StdTimeWeekdayFriday
    StdTimeWeekdaySaturday
    StdTimeWeekdaySunday
.end

struct StdTimeDate
    year: i32
    month: u8              # 1..12
    day: u8                # 1..31

    # Jour de la semaine (si connu)
    weekday: StdTimeWeekday

    # Jour de l’année (1..366), si connu
    ordinal_day: u16

    extra: coll.HashMap<String, String]
.end

struct StdTimeTimeOfDay
    hour: u8               # 0..23
    minute: u8             # 0..59
    second: u8             # 0..60 (pour gérer leap seconds)
    nanosecond: u32        # 0..999_999_999

    extra: coll.HashMap<String, String]
.end

struct StdTimeDateTimeLocal
    calendar_id: StdTimeCalendarId

    date: StdTimeDate
    time: StdTimeTimeOfDay

    # Fuseau associé
    zone_id: StdTimeZoneId
    utc_offset: StdTimeUtcOffset

    extra: coll.HashMap<String, String]
.end

# ---------------------------------------------------------------------------
# Instants / durées – représentation canonique
# ---------------------------------------------------------------------------

struct StdTimeInstantCore
    # Nombre de secondes depuis une époque de référence
    # (Unix epoch pour WallUtc, base interne pour monotonic, etc.)
    epoch_seconds: i64

    # Nanos additionnels (0..999_999_999)
    subsecond_nanos: u32

    kind: StdTimeInstantKind

    # Offset/fuseau (pour les instants muraux locaux)
    utc_offset: StdTimeUtcOffset
    zone_id: StdTimeZoneId

    extra: coll.HashMap<String, String]
.end

struct StdTimeInstant
    id: StdTimeInstantId

    core: StdTimeInstantCore

    # Vue date-heure locale (optionnelle, pour debug/inspection)
    local_datetime: StdTimeDateTimeLocal

    extra: coll.HashMap<String, String]
.end

struct StdTimeDurationCore
    # Durée en secondes (signée)
    seconds: i64

    # Nanos additionnels, même signe que seconds
    subsecond_nanos: i32

    # True si la durée est strictement négative
    is_negative: bool

    # Description logique (ex: "5m", "2h30m", "forever")
    display_label: String

    extra: coll.HashMap<String, String]
.end

struct StdTimeDuration
    id: StdTimeDurationId

    core: StdTimeDurationCore

    # Unité préférée pour présentation/profiling
    preferred_unit: StdTimeDurationUnit

    extra: coll.HashMap<String, String]
.end

# ---------------------------------------------------------------------------
# Horloges / timers
# ---------------------------------------------------------------------------

struct StdTimeClockMeta
    id: StdTimeClockId

    kind: StdTimeClockKind

    # Nom logique / debug (ex: "system-utc", "monotonic")
    logical_name: String
    debug_label: String

    # True si l’horloge est monotone
    is_monotonic: bool

    # True si l’horloge n’est pas affectée par les changements de fuseau
    is_steady: bool

    # Résolution approx (nanosecondes)
    approx_resolution_nanos: u64

    extra: coll.HashMap<String, String]
.end

struct StdTimeClockSnapshot
    clock_id: StdTimeClockId

    # Instant actuel observé
    now_instant_id: StdTimeInstantId

    # Timestamp logique (string, ISO 8601)
    captured_at: String

    extra: coll.HashMap<String, String]
.end

struct StdTimeTimerConfig
    id: StdTimeTimerId

    kind: StdTimeTimerKind

    # Horloge utilisée
    clock_id: StdTimeClockId

    # Instant de départ et délai
    start_instant_id: StdTimeInstantId
    initial_delay_id: StdTimeDurationId

    # Pour les timers répétitifs
    interval_id: StdTimeDurationId
    max_fire_count: u64

    # True si le timer doit être aligné sur des ticks d’horloge spécifiques
    align_to_clock_ticks: bool

    extra: coll.HashMap<String, String]
.end

struct StdTimeTimerState
    # True si le timer est actuellement actif
    is_active: bool

    # Nombre de fois où le timer a “fire”
    fire_count: u64

    # Dernier instant où le timer a été déclenché
    last_fire_instant_id: StdTimeInstantId

    # Prochaine échéance prévue
    next_deadline_instant_id: StdTimeInstantId

    extra: coll.HashMap<String, String]
.end

struct StdTimeTimerMetrics
    # Statistiques sur les déclenchements
    total_fire_count: u64
    total_skipped_fire_count: u64

    # Jitter/latence – purement logique
    max_fire_lateness_nanos: i64
    total_fire_lateness_nanos: i64

    extra: coll.HashMap<String, String]
.end

struct StdTimeTimer
    config: StdTimeTimerConfig
    state: StdTimeTimerState
    metrics: StdTimeTimerMetrics

    extra: coll.HashMap<String, String]
.end

# ---------------------------------------------------------------------------
# Erreurs / opérations temporelles
# ---------------------------------------------------------------------------

enum StdTimeErrorKind
    StdTimeErrorInvalidInstant
    StdTimeErrorInvalidDuration
    StdTimeErrorOverflow
    StdTimeErrorUnderflow
    StdTimeErrorInvalidZone
    StdTimeErrorInvalidCalendar
    StdTimeErrorParseFailed
    StdTimeErrorFormatFailed
    StdTimeErrorClockUnavailable
    StdTimeErrorOther
.end

struct StdTimeError
    kind: StdTimeErrorKind

    message: String

    # Instant / durée / fuseau concernés (si applicable)
    instant_id: StdTimeInstantId
    duration_id: StdTimeDurationId
    zone_id: StdTimeZoneId
    calendar_id: StdTimeCalendarId

    extra: coll.HashMap<String, String]
.end

enum StdTimeOpKind
    StdTimeOpNowInstant           # lecture horloge (now)
    StdTimeOpAddDuration          # instant + durée
    StdTimeOpSubtractDuration     # instant - durée
    StdTimeOpDiffInstant          # diff entre deux instants
    StdTimeOpConvertZone          # conversion de fuseau
    StdTimeOpToLocalDateTime      # instant -> date/heure locale
    StdTimeOpFromLocalDateTime    # date/heure locale -> instant
    StdTimeOpParseDateTime        # parse texte -> date/heure
    StdTimeOpFormatDateTime       # format date/heure -> texte
    StdTimeOpParseDuration        # parse texte -> durée
    StdTimeOpFormatDuration       # format durée -> texte
    StdTimeOpOther
.end

# ---------------------------------------------------------------------------
# Paramètres d’opérations
# ---------------------------------------------------------------------------

struct StdTimeNowParams
    clock_id: StdTimeClockId

    extra: coll.HashMap<String, String]
.end

struct StdTimeAddSubParams
    # True si l’opération doit saturer en cas de dépassement
    saturating: bool

    # True si l’on veut une erreur explicite en cas d’overflow/underflow
    error_on_overflow: bool

    extra: coll.HashMap<String, String]
.end

struct StdTimeDiffParams
    # True si résultat toujours >= 0 (re-ordonner les instants)
    absolute: bool

    extra: coll.HashMap<String, String]
.end

struct StdTimeConvertZoneParams
    target_zone_id: StdTimeZoneId

    # True si l’on veut conserver l’heure locale (changer l’offset)
    keep_local_time: bool

    extra: coll.HashMap<String, String]
.end

struct StdTimeParseDateTimeParams
    # Format de parsing (ex: "YYYY-MM-DDTHH:MM:SSZ")
    format_string: String

    # Fuseau par défaut si aucun n’est fourni dans le texte
    default_zone_id: StdTimeZoneId

    # Calendrier cible
    calendar_id: StdTimeCalendarId

    extra: coll.HashMap<String, String]
.end

struct StdTimeFormatDateTimeParams
    # Format de sortie
    format_string: String

    # True si on force l’UTC dans la sortie
    force_utc: bool

    extra: coll.HashMap<String, String]
.end

struct StdTimeParseDurationParams
    # Format attendu (ex: "ISO8601", "human", "seconds-only")
    format_kind: String

    extra: coll.HashMap<String, String]
.end

struct StdTimeFormatDurationParams
    # Format de sortie (ex: "human-short", "human-long", "seconds")
    format_kind: String

    # Unité préférée
    preferred_unit: StdTimeDurationUnit

    extra: coll.HashMap<String, String]
.end

# ---------------------------------------------------------------------------
# Requête / résultat d’opérations temporelles
# ---------------------------------------------------------------------------

struct StdTimeOpRequest
    id: StdTimeOpId

    kind: StdTimeOpKind

    # Instants / durées impliqués
    primary_instant_id: StdTimeInstantId
    secondary_instant_id: StdTimeInstantId
    primary_duration_id: StdTimeDurationId

    # Paramètres spécifiques
    now_params: StdTimeNowParams
    add_sub_params: StdTimeAddSubParams
    diff_params: StdTimeDiffParams
    convert_zone_params: StdTimeConvertZoneParams
    parse_datetime_params: StdTimeParseDateTimeParams
    format_datetime_params: StdTimeFormatDateTimeParams
    parse_duration_params: StdTimeParseDurationParams
    format_duration_params: StdTimeFormatDurationParams

    # Texte brut pour parse (date/heure ou durée)
    raw_text: String

    # Contexte logique (ex: "compiler-timestamp", "log-parser")
    logical_context: String

    tags: coll.Vec<String]

    extra: coll.HashMap<String, String]
.end

struct StdTimeOpResult
    id: StdTimeOpId

    # True si succès logique
    success: bool

    # Erreur (si !success)
    error: StdTimeError

    # Instants/durées résultants
    result_instant_id: StdTimeInstantId
    result_duration_id: StdTimeDurationId

    # Date/heure locale résultante (pour conversions)
    result_local_datetime: StdTimeDateTimeLocal

    # Texte formaté (pour formatage)
    formatted_text: String

    # Indique si un changement de fuseau a été appliqué
    zone_changed: bool

    extra: coll.HashMap<String, String]
.end

# ---------------------------------------------------------------------------
# Métriques / sessions / snapshots
# ---------------------------------------------------------------------------

struct StdTimeMetrics
    # Nombre total d’opérations
    total_ops: u64

    # Par type
    now_ops: u64
    add_duration_ops: u64
    subtract_duration_ops: u64
    diff_ops: u64
    convert_zone_ops: u64
    to_local_datetime_ops: u64
    from_local_datetime_ops: u64
    parse_datetime_ops: u64
    format_datetime_ops: u64
    parse_duration_ops: u64
    format_duration_ops: u64

    # Erreurs
    error_count: u64
    error_count_by_kind: coll.HashMap<String, u64>

    # Latence logique (ms)
    total_latency_ms: u64
    max_latency_ms: u64

    extra: coll.HashMap<String, String]
.end

struct StdTimeSessionMeta
    id: StdTimeSessionId

    logical_name: String
    description: String

    started_at: String
    finished_at: String

    extra: coll.HashMap<String, String]
.end

struct StdTimeSession
    meta: StdTimeSessionMeta

    # Opérations observées
    op_requests: coll.Vec<StdTimeOpRequest>
    op_results: coll.Vec<StdTimeOpResult>

    # Timers observés dans cette session
    timers: coll.Vec<StdTimeTimer>

    # Métriques agrégées
    metrics: StdTimeMetrics

    extra: coll.HashMap<String, String]
.end

struct StdTimeSnapshot
    id: StdTimeSnapshotId

    captured_at: String

    # Sessions incluses
    sessions: coll.Vec<StdTimeSession>

    # Métriques globales agrégées
    metrics: StdTimeMetrics

    extra: coll.HashMap<String, String]
.end

# ---------------------------------------------------------------------------
# Registre / modèle global std.time
# ---------------------------------------------------------------------------

struct StdTimeRegistryInstantEntry
    instant_id: StdTimeInstantId

    kind: StdTimeInstantKind

    # Epoque & nanos
    epoch_seconds: i64
    subsecond_nanos: u32

    # Zone / offset
    zone_id: StdTimeZoneId
    utc_offset: StdTimeUtcOffset

    logical_label: String

    extra: coll.HashMap<String, String]
.end

struct StdTimeRegistryDurationEntry
    duration_id: StdTimeDurationId

    seconds: i64
    subsecond_nanos: i32
    is_negative: bool

    preferred_unit: StdTimeDurationUnit

    logical_label: String

    extra: coll.HashMap<String, String]
.end

struct StdTimeRegistry
    # Instants enregistrés
    instants: coll.Vec<StdTimeRegistryInstantEntry>

    # Durées enregistrées
    durations: coll.Vec<StdTimeRegistryDurationEntry>

    # Index par label logique
    instant_ids_by_label: coll.HashMap<String, coll.Vec<StdTimeInstantId>>
    duration_ids_by_label: coll.HashMap<String, coll.Vec<StdTimeDurationId>>

    extra: coll.HashMap<String, String]
.end

struct StdTimeModel
    # Calendriers disponibles
    calendars: coll.Vec<StdTimeCalendarInfo>

    # Fuseaux et base de données TZ
    zone_db: StdTimeZoneDatabase

    # Horloges connues
    clocks: coll.Vec<StdTimeClockMeta>

    # Timers globaux (model logique)
    timers: coll.Vec<StdTimeTimer>

    # Registre d’instants/durées
    registry: StdTimeRegistry

    # Sessions & snapshots
    sessions: coll.Vec<StdTimeSession>
    snapshots: coll.Vec<StdTimeSnapshot>

    # Données libres (version de schéma, notes)
    extra: coll.HashMap<String, String]
.end
