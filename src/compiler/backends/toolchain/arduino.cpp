#include "arduino.hpp"

#include <cstdlib>
#include <filesystem>
#include <fstream>
#include <iostream>
#include <sstream>
#include <cstdio>
#include <array>

namespace vitte::backend::toolchain {

static std::string read_command_output(const std::string& cmd) {
    std::array<char, 512> buffer{};
    std::string out;
    FILE* pipe = popen(cmd.c_str(), "r");
    if (!pipe) {
        return out;
    }
    while (fgets(buffer.data(), static_cast<int>(buffer.size()), pipe)) {
        out.append(buffer.data());
    }
    pclose(pipe);
    return out;
}

static std::string extract_json_field(const std::string& json, const std::string& field) {
    std::string key = "\"" + field + "\":\"";
    auto pos = json.find(key);
    if (pos == std::string::npos) {
        return {};
    }
    pos += key.size();
    auto end = json.find('"', pos);
    if (end == std::string::npos) {
        return {};
    }
    return json.substr(pos, end - pos);
}

static std::string find_port_for_fqbn(const std::string& json, const std::string& fqbn) {
    std::string key = "\"fqbn\":\"";
    std::size_t pos = 0;
    while ((pos = json.find(key, pos)) != std::string::npos) {
        std::size_t start = pos + key.size();
        std::size_t end = json.find('"', start);
        if (end == std::string::npos) {
            break;
        }
        std::string val = json.substr(start, end - start);
        if (val == fqbn) {
            std::size_t addr_pos = json.find("\"address\":\"", end);
            if (addr_pos != std::string::npos) {
                addr_pos += std::string("\"address\":\"").size();
                std::size_t addr_end = json.find('"', addr_pos);
                if (addr_end != std::string::npos) {
                    return json.substr(addr_pos, addr_end - addr_pos);
                }
            }
        }
        pos = end + 1;
    }
    return {};
}

static std::string auto_detect_port(const std::string& cli_path, const std::string& fqbn) {
    std::ostringstream cmd;
    cmd << cli_path << " board list --format json";
    std::string out = read_command_output(cmd.str());
    if (out.empty()) {
        return {};
    }
    if (!fqbn.empty()) {
        return find_port_for_fqbn(out, fqbn);
    }
    return extract_json_field(out, "address");
}

static bool copy_file(const std::filesystem::path& src, const std::filesystem::path& dst) {
    std::error_code ec;
    std::filesystem::copy_file(
        src,
        dst,
        std::filesystem::copy_options::overwrite_existing,
        ec
    );
    if (ec) {
        std::cerr << "[arduino] failed to copy " << src << " -> " << dst
                  << ": " << ec.message() << "\n";
        return false;
    }
    return true;
}

bool invoke_arduino_cli(
    const std::string& input_cpp,
    const std::vector<std::string>& extra_sources,
    const std::string& runtime_header,
    const std::string& output_hex,
    const ArduinoOptions& opts
) {
    namespace fs = std::filesystem;

    fs::path work_dir = opts.work_dir;
    fs::path sketch_dir = work_dir / "arduino_sketch";
    fs::path build_dir = work_dir / "arduino_build";

    std::error_code ec;
    fs::create_directories(sketch_dir, ec);
    if (ec) {
        std::cerr << "[arduino] failed to create sketch dir: " << ec.message() << "\n";
        return false;
    }
    fs::create_directories(build_dir, ec);
    if (ec) {
        std::cerr << "[arduino] failed to create build dir: " << ec.message() << "\n";
        return false;
    }

    fs::path sketch_cpp = sketch_dir / "vitte_out.cpp";
    if (!copy_file(input_cpp, sketch_cpp)) {
        return false;
    }

    for (const auto& src : extra_sources) {
        fs::path p = src;
        fs::path dst = sketch_dir / p.filename();
        if (!copy_file(p, dst)) {
            return false;
        }
    }

    if (!runtime_header.empty()) {
        fs::path hdr = runtime_header;
        fs::path dst = sketch_dir / "vitte_runtime.hpp";
        if (!copy_file(hdr, dst)) {
            return false;
        }
    }

    fs::path ino = sketch_dir / (opts.sketch_name + ".ino");
    std::ofstream ino_out(ino);
    if (!ino_out.is_open()) {
        std::cerr << "[arduino] failed to write sketch file\n";
        return false;
    }
    ino_out << "// Generated by Vitte (Arduino target)\n";
    ino_out.close();

    std::ostringstream cmd;
    cmd << opts.cli_path << " compile";
    cmd << " --fqbn " << opts.fqbn;
    cmd << " --build-path " << build_dir.string();
    cmd << " " << sketch_dir.string();

    std::string command = cmd.str();
    if (opts.verbose) {
        std::cerr << "[arduino] " << command << "\n";
    }

    int rc = std::system(command.c_str());
    if (rc != 0) {
        std::cerr << "[arduino] arduino-cli compile failed (" << rc << ")\n";
        return false;
    }

    if (opts.upload) {
        std::string port = opts.port;
        if (port.empty()) {
            const char* env_port = std::getenv("ARDUINO_PORT");
            if (env_port && *env_port) {
                port = env_port;
            }
        }
        if (port.empty()) {
            port = auto_detect_port(opts.cli_path, opts.fqbn);
        }
        if (port.empty()) {
            std::cerr << "[arduino] upload requested but no port provided (--port or ARDUINO_PORT), and auto-detect failed\n";
            return false;
        }

        std::ostringstream up_cmd;
        up_cmd << opts.cli_path << " upload";
        up_cmd << " --fqbn " << opts.fqbn;
        up_cmd << " --port " << port;
        up_cmd << " --input-dir " << build_dir.string();
        up_cmd << " " << sketch_dir.string();

        std::string upload_command = up_cmd.str();
        if (opts.verbose) {
            std::cerr << "[arduino] " << upload_command << "\n";
        }

        int urc = std::system(upload_command.c_str());
        if (urc != 0) {
            std::cerr << "[arduino] arduino-cli upload failed (" << urc << ")\n";
            return false;
        }
    }

    fs::path hex_out;
    for (const auto& entry : fs::directory_iterator(build_dir)) {
        if (entry.path().extension() == ".hex") {
            hex_out = entry.path();
            break;
        }
    }
    if (hex_out.empty()) {
        std::cerr << "[arduino] no .hex output found in build dir\n";
        return false;
    }

    if (!output_hex.empty()) {
        if (!copy_file(hex_out, output_hex)) {
            return false;
        }
    }

    return true;
}

} // namespace vitte::backend::toolchain
