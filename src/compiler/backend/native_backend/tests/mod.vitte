module compiler::backend::native_backend::tests;

use crate::compiler::backend::native_backend;
use crate::compiler::backend::native_backend::opts::options::NativeBackendOptions;
use crate::compiler::codegen::driver::session::CodegenSession;
use crate::compiler::codegen::options::codegen_options::CodegenOptions;
use crate::compiler::codegen::options::emit_mode::EmitKind;
use crate::diagnostics::DiagSink;
use crate::compiler::ir::IrModule;

fn build_dummy_ir() -> IrModule {
    IrModule::new_for_tests()
}

#[test]
fn emit_native_asm() {
    let mut diag = DiagSink::new();
    let ir = build_dummy_ir();
    let mut opts = CodegenOptions::default_c17();
    opts.emit = EmitKind::Asm;
    let mut session = CodegenSession::new(opts, &mut diag);
    let backend_opts = NativeBackendOptions::default();
    let mut backend = native_backend::NativeBackend::new(&mut session, backend_opts);
    let artifacts = backend.emit_module(&ir).unwrap();
    assert!(artifacts.files.iter().any(|a| a.name.ends_with(".s")));
}

#[test]
fn emit_native_obj() {
    let mut diag = DiagSink::new();
    let ir = build_dummy_ir();
    let mut opts = CodegenOptions::default_c17();
    opts.emit = EmitKind::Object;
    let mut session = CodegenSession::new(opts, &mut diag);
    let backend_opts = NativeBackendOptions::default();
    let mut backend = native_backend::NativeBackend::new(&mut session, backend_opts);
    let artifacts = backend.emit_module(&ir).unwrap();
    assert!(artifacts.files.iter().any(|a| a.name.ends_with(".o")));
}
