module compiler::backend::vbc_backend;

pub mod opts;
pub mod format;
pub mod encoder;
pub mod decoder;
pub mod verifier;
pub mod disasm;
pub mod runtime;
pub mod tests;

use crate::compiler::backend::traits::backend_trait::Backend;
use crate::compiler::codegen::driver::artifacts::{CodegenArtifacts, Artifact, ArtifactKind};
use crate::compiler::codegen::options::emit_mode::EmitKind;
use crate::compiler::codegen::driver::session::CodegenSession;
use crate::compiler::ir::IrModule;

/// Backend VBC (Vitte ByteCode): IR → bytecode + (optionnel) désassemblage texte.
pub struct VbcBackend<'s> {
    pub session: &'s mut CodegenSession<'s>,
    pub opts: opts::options::VbcBackendOptions,
}

impl<'s> VbcBackend<'s> {
    pub fn new(session: &'s mut CodegenSession<'s>, opts: opts::options::VbcBackendOptions) -> VbcBackend<'s> {
        VbcBackend { session, opts }
    }

    pub fn emit_vbc(&mut self, module: &IrModule) -> Vec<u8> {
        let vmod = encoder::builder::build_vbc_module(self.session, &self.opts, module);
        encoder::encode::encode_module(&vmod)
    }

    pub fn emit_vbc_disasm(&mut self, module: &IrModule) -> String {
        let bytes = self.emit_vbc(module);
        let vmod = decoder::decode::decode_module(&bytes).unwrap_or_else(|| decoder::model::VbcModule::empty());
        disasm::text::disasm_module(&vmod)
    }

    pub fn emit_artifacts(&mut self, module: &IrModule) -> CodegenArtifacts {
        let bytes = self.emit_vbc(module);
        let mut artifacts = CodegenArtifacts::new(EmitKind::Bytecode, self.session.options.output.clone());
        artifacts.files.push(Artifact {
            name: "module.vbc".to_string(),
            kind: ArtifactKind::Binary,
            data: bytes,
        });
        if self.opts.emit_disasm {
            let txt = self.emit_vbc_disasm(module);
            artifacts.files.push(Artifact {
                name: "module.vbc.txt".to_string(),
                kind: ArtifactKind::Text,
                data: txt.as_bytes().to_vec(),
            });
        }
        artifacts
    }
}

impl<'s> Backend for VbcBackend<'s> {
    fn name(&self) -> &str {
        "vbc"
    }

    fn supports_target(&self, _triple: &crate::compiler::codegen::target::triple::TargetTriple) -> bool {
        true
    }

    fn emit_module(&mut self, module: &IrModule) -> Result<CodegenArtifacts, String> {
        Ok(self.emit_artifacts(module))
    }
}
