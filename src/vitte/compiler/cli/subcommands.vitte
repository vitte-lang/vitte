module vitte.compiler.cli.subcommands

import vitte.compiler.cli.args as args
import std.collections as coll
import std.fs.std_fs as fs
import vitte.runtime.bytecode as bc
import vitte.runtime.cli.run as rt_run
import vitte.runtime.std_hooks as hooks

struct BuildResult
    success: bool
    output_path: String
.end

struct RunResult
    exit_code: i32
.end

struct TestResult
    success: bool
    report_path: String
.end

fn encode_inst(opcode: u8, operands: coll.Vec[i32]) -> coll.Vec[u8]
    let buf = coll.Vec[u8]()
    buf.push(opcode)
    buf.push(operands.len())
    let mut idx: i32 = 0
    while idx < operands.len()
        let val = operands[idx]
        buf.push((val & 0xFF) as u8)
        buf.push(((val >> 8) & 0xFF) as u8)
        buf.push(((val >> 16) & 0xFF) as u8)
        buf.push(((val >> 24) & 0xFF) as u8)
        idx = idx + 1
    .end
    return buf
.end

fn encode_demo_code() -> coll.Vec[u8]
    # Programme de démonstration :
    #   - println "hi"
    #   - concatène deux strings et print
    #   - alloue un array, y pousse 7, lit index 0 et le println
    let code = coll.Vec[u8]()

    fn append(buf: &mut coll.Vec[u8], opcode: u8, operands: coll.Vec[i32])
        let inst = encode_inst(opcode, operands)
        let mut i: i32 = 0
        while i < inst.len()
            buf.push(inst[i])
            i = i + 1
        .end
    .end

    append(&mut code, 0, coll.Vec[i32]()..push(0))                     # OpConst "hi"
    append(&mut code, 24, coll.Vec[i32]())                              # OpStdPrintln

    append(&mut code, 0, coll.Vec[i32]()..push(0))                     # OpConst "hi"
    append(&mut code, 0, coll.Vec[i32]()..push(1))                     # OpConst " there"
    append(&mut code, 26, coll.Vec[i32]())                              # OpStdConcatString
    append(&mut code, 23, coll.Vec[i32]())                              # OpStdPrint (garde la valeur sur la pile)

    append(&mut code, 20, coll.Vec[i32]()..push(1))                    # OpAllocHeap (array)
    append(&mut code, 17, coll.Vec[i32]()..push(0))                    # OpStoreLocal local0 = array
    append(&mut code, 16, coll.Vec[i32]()..push(0))                    # OpLoadLocal array
    append(&mut code, 0, coll.Vec[i32]()..push(2))                     # OpConst 7
    append(&mut code, 27, coll.Vec[i32]())                              # OpStdArrayPush (array, value)

    append(&mut code, 16, coll.Vec[i32]()..push(0))                    # OpLoadLocal array
    append(&mut code, 0, coll.Vec[i32]()..push(3))                     # OpConst index 0
    append(&mut code, 28, coll.Vec[i32]())                              # OpStdArrayGet
    append(&mut code, 24, coll.Vec[i32]())                              # println du résultat
    append(&mut code, 6, coll.Vec[i32]())                               # OpRet

    return code
.end

fn build_demo_chunk() -> bc.LvmChunk
    let consts = coll.Vec[bc.LvmConst]()
    consts.push(bc.LvmConst { tag = bc.LvmConstTag::ConstString, payload = bc.LvmConstPayload { string_value = "hi" } })
    consts.push(bc.LvmConst { tag = bc.LvmConstTag::ConstString, payload = bc.LvmConstPayload { string_value = " there" } })
    consts.push(bc.LvmConst { tag = bc.LvmConstTag::ConstI64, payload = bc.LvmConstPayload { i64_value = 7 } })
    consts.push(bc.LvmConst { tag = bc.LvmConstTag::ConstI64, payload = bc.LvmConstPayload { i64_value = 0 } })

    let header = bc.LvmFileHeader {
        magic = 0x304D564C,             # "LVM0"
        version_major = 0,
        version_minor = 1,
        flags = 0,
        reserved0 = 0,
        reserved1 = 0,
        section_count = 3
    }

    let sections = coll.Vec[bc.LvmSectionEntry]()
    sections.push(bc.LvmSectionEntry { kind = bc.LvmSectionKind::SectionConstPool, flags = 0, offset = 0, length = 0 })
    sections.push(bc.LvmSectionEntry { kind = bc.LvmSectionKind::SectionFunctionTable, flags = 0, offset = 0, length = 0 })
    sections.push(bc.LvmSectionEntry { kind = bc.LvmSectionKind::SectionCode, flags = 0, offset = 0, length = 0 })

    let const_pool = bc.LvmConstPool { consts = consts }

    let code_bytes = encode_demo_code()
    let functions = coll.Vec[bc.LvmFunctionEntry]()
    functions.push(bc.LvmFunctionEntry {
        name_const = 0,
        code_offset = 0,
        code_size = code_bytes.len(),
        param_count = 0,
        local_count = 1,
        max_stack = 8,
        flags = 1    # export main
    })

    let function_table = bc.LvmFunctionTable { entries = functions }

    return bc.LvmChunk { header = header, sections = sections, const_pool = const_pool, functions = function_table, code = code_bytes }
.end

fn write_u16_le(buf: &mut coll.Vec[u8], value: u16)
    buf.push((value & 0xFF) as u8)
    buf.push(((value >> 8) & 0xFF) as u8)
.end

fn write_u32_le(buf: &mut coll.Vec[u8], value: u32)
    buf.push((value & 0xFF) as u8)
    buf.push(((value >> 8) & 0xFF) as u8)
    buf.push(((value >> 16) & 0xFF) as u8)
    buf.push(((value >> 24) & 0xFF) as u8)
.end

fn write_i64_le(buf: &mut coll.Vec[u8], value: i64)
    let mut v = value as u64
    let mut i: i32 = 0
    while i < 8
        buf.push((v & 0xFF) as u8)
        v = v >> 8
        i = i + 1
    .end
.end

fn encode_const(constant: bc.LvmConst, out: &mut coll.Vec[u8])
    out.push(constant.tag as u8)
    out.push(0)
    write_u16_le(out, 0)
    if constant.tag == bc.LvmConstTag::ConstNil
        return
    .end
    if constant.tag == bc.LvmConstTag::ConstBool
        out.push(if constant.payload.bool_value then 1 else 0 end)
        return
    .end
    if constant.tag == bc.LvmConstTag::ConstI64
        write_i64_le(out, constant.payload.i64_value)
        return
    .end
    if constant.tag == bc.LvmConstTag::ConstF64
        # Encodage naïf via la représentation binaire 64 bits.
        write_i64_le(out, constant.payload.f64_value as i64)
        return
    .end
    if constant.tag == bc.LvmConstTag::ConstString
        let raw = constant.payload.string_value.as_bytes()
        write_u32_le(out, raw.len() as u32)
        let mut i: i32 = 0
        while i < raw.len()
            out.push(raw[i])
            i = i + 1
        .end
        return
    .end
    if constant.tag == bc.LvmConstTag::ConstFunction
        write_u32_le(out, constant.payload.func_index)
        return
    .end
    if constant.tag == bc.LvmConstTag::ConstBytes
        let bytes = constant.payload.bytes_value
        write_u32_le(out, bytes.len() as u32)
        let mut i: i32 = 0
        while i < bytes.len()
            out.push(bytes[i])
            i = i + 1
        .end
        return
    .end
.end

fn encode_const_pool(pool: bc.LvmConstPool) -> coll.Vec[u8]
    let out = coll.Vec[u8]()
    let mut i: i32 = 0
    while i < pool.consts.len()
        encode_const(pool.consts[i], &mut out)
        i = i + 1
    .end
    return out
.end

fn encode_function_table(funcs: bc.LvmFunctionTable) -> coll.Vec[u8]
    let out = coll.Vec[u8]()
    let mut i: i32 = 0
    while i < funcs.entries.len()
        let f = funcs.entries[i]
        write_u32_le(&mut out, f.name_const)
        write_u32_le(&mut out, f.code_offset)
        write_u32_le(&mut out, f.code_size)
        write_u16_le(&mut out, f.param_count)
        write_u16_le(&mut out, f.local_count)
        write_u16_le(&mut out, f.max_stack)
        write_u16_le(&mut out, f.flags)
        i = i + 1
    .end
    return out
.end

fn write_demo_chunk(chunk: bc.LvmChunk, path: String) -> bool
    let header_size: u32 = 20
    let section_entry_size: u32 = 12
    let section_dir_size: u32 = section_entry_size * chunk.header.section_count

    let const_bytes = encode_const_pool(chunk.const_pool)
    let func_bytes = encode_function_table(chunk.functions)
    let code_bytes = chunk.code

    let const_offset = header_size + section_dir_size
    let func_offset = const_offset + const_bytes.len() as u32
    let code_offset = func_offset + func_bytes.len() as u32

    let mut sections = coll.Vec[bc.LvmSectionEntry]()
    sections.push(bc.LvmSectionEntry { kind = bc.LvmSectionKind::SectionConstPool, flags = 0, offset = const_offset, length = const_bytes.len() as u32 })
    sections.push(bc.LvmSectionEntry { kind = bc.LvmSectionKind::SectionFunctionTable, flags = 0, offset = func_offset, length = func_bytes.len() as u32 })
    sections.push(bc.LvmSectionEntry { kind = bc.LvmSectionKind::SectionCode, flags = 0, offset = code_offset, length = code_bytes.len() as u32 })

    let mut buf = coll.Vec[u8]()
    write_u32_le(&mut buf, chunk.header.magic)
    write_u16_le(&mut buf, chunk.header.version_major)
    write_u16_le(&mut buf, chunk.header.version_minor)
    write_u32_le(&mut buf, chunk.header.flags)
    write_u32_le(&mut buf, chunk.header.reserved0)
    write_u32_le(&mut buf, chunk.header.reserved1)
    write_u32_le(&mut buf, chunk.header.section_count)

    let mut si: i32 = 0
    while si < sections.len()
        let s = sections[si]
        write_u16_le(&mut buf, s.kind as u16)
        write_u16_le(&mut buf, s.flags)
        write_u32_le(&mut buf, s.offset)
        write_u32_le(&mut buf, s.length)
        si = si + 1
    .end

    let mut ci: i32 = 0
    while ci < const_bytes.len()
        buf.push(const_bytes[ci])
        ci = ci + 1
    .end

    let mut fi: i32 = 0
    while fi < func_bytes.len()
        buf.push(func_bytes[fi])
        fi = fi + 1
    .end

    let mut bi: i32 = 0
    while bi < code_bytes.len()
        buf.push(code_bytes[bi])
        bi = bi + 1
    .end

    fs.write_all(path, buf)
    return true
.end

fn cmd_build(opts: args.CliOptions) -> BuildResult
    let chunk = build_demo_chunk()
    let out_path = "target/core/bytecode/demo.vbc"

    # Assure l’existence du dossier cible.
    fs.create_dir_all("target/core/bytecode")
    write_demo_chunk(chunk, out_path)

    return BuildResult { success = true, output_path = out_path }
.end

fn cmd_run(opts: args.CliOptions) -> RunResult
    let build = cmd_build(opts)

    let std_hooks = make_host_std_hooks()
    let ctx = rt_run.make_run_context(build.output_path, std_hooks)
    if ctx.load_error != ""
        return RunResult { exit_code = 1 }
    .end

    let exit_code = rt_run.run_chunk(ctx)
    return RunResult { exit_code = exit_code }
.end

fn cmd_fmt(opts: args.CliOptions) -> bool
    # Placeholder formatteur.
    return true
.end

fn cmd_test(opts: args.CliOptions) -> TestResult
    # Placeholder smoke test mini_project.
    return TestResult { success = true, report_path = "target/core/tests/report.txt" }
.end

fn host_make_string(bytes: coll.Vec[u8]) -> hooks.RtString
    return hooks.RtString { len = bytes.len(), data_ptr = 0, bytes = bytes }
.end

fn host_concat_string(lhs: hooks.RtString, rhs: hooks.RtString) -> hooks.RtString
    let mut merged = coll.Vec[u8]()
    let mut i: i32 = 0
    while i < lhs.bytes.len()
        merged.push(lhs.bytes[i])
        i = i + 1
    .end
    let mut j: i32 = 0
    while j < rhs.bytes.len()
        merged.push(rhs.bytes[j])
        j = j + 1
    .end
    return hooks.RtString { len = merged.len(), data_ptr = 0, bytes = merged }
.end

fn host_array_push(arr: hooks.RtArray, value: any) -> hooks.RtArray
    return arr
.end

fn host_array_get(arr: hooks.RtArray, index: i64) -> any
    return index
.end

fn host_print(rt: hooks.RtString) -> ()
    fs.write_all("/dev/stdout", rt.bytes)
.end

fn host_println(rt: hooks.RtString) -> ()
    fs.write_all("/dev/stdout", rt.bytes)
    fs.write_all("/dev/stdout", "\n".as_bytes())
.end

fn host_read_line() -> hooks.RtString
    return hooks.RtString { len = 0, data_ptr = 0, bytes = coll.Vec[u8]() }
.end

fn make_host_std_hooks() -> hooks.StdHooks
    return hooks.StdHooks {
        make_string = host_make_string,
        concat_string = host_concat_string,
        array_push = host_array_push,
        array_get = host_array_get,
        print = host_print,
        println = host_println,
        read_line = host_read_line
    }
.end
