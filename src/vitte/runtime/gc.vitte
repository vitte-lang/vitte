module vitte.runtime.gc

import std.collections as coll

# ============================================================================
# GC mark/sweep linéaire – modèle
# ============================================================================

enum GcTag
    GcString
    GcArray
    GcStruct
    GcBytes
.end

struct GcHeader
    tag: GcTag
    size_bytes: i64
    marked: bool
.end

struct GcObject
    header: GcHeader
    addr: i64                 # offset linÃ©aire dans la heap
    payload: coll.Vec[u8]     # opaque du point de vue GC
.end

struct GcFreeBlock
    addr: i64
    size_bytes: i64
.end

struct GcHeap
    base: i64
    limit: i64
    hp: i64
    freelist: coll.Vec[GcFreeBlock]
    objects: coll.Vec[GcObject]
.end

struct GcStats
    collections: u64
    bytes_allocated: u64
    bytes_live: u64
.end

struct GcState
    heap: GcHeap
    stats: GcStats
.end

struct GcRoot
    addr: i64
.end

fn gc_alloc(gc: &mut GcState, tag: GcTag, size_bytes: i64) -> i64
    # Alloue via bump-pointer et réutilise les blocs libérés quand c'est possible.
    let payload_size = gc_aligned_size(size_bytes)
    if payload_size <= 0
        return -1
    .end

    let total_size = payload_size + gc_header_size()
    let reused = gc_claim_free_block(&mut gc.heap, total_size)
    if reused.addr >= 0
        let obj = gc_make_object(reused.addr, tag, payload_size)
        gc.heap.objects.push(obj)
        gc.stats.bytes_allocated = gc.stats.bytes_allocated + payload_size as u64
        return reused.addr
    .end

    let mut current_hp = gc.heap.hp
    if current_hp == 0
        current_hp = gc.heap.base
    .end
    if gc.heap.limit != 0 and current_hp + total_size > gc.heap.limit
        return -1
    .end

    let addr = current_hp
    gc.heap.hp = current_hp + total_size
    let obj = gc_make_object(addr, tag, payload_size)
    gc.heap.objects.push(obj)
    gc.stats.bytes_allocated = gc.stats.bytes_allocated + payload_size as u64
    return addr
.end

fn gc_collect(gc: &mut GcState, roots: coll.Vec[GcRoot]) -> GcStats
    # Parcours des racines, mark puis sweep linéaire.
    let mut idx = 0
    while idx < roots.len()
        gc_mark_from_root(&mut gc.heap, roots[idx].addr)
        idx = idx + 1
    .end
    gc_sweep(&mut gc.heap, &mut gc.stats)
    gc.stats.collections = gc.stats.collections + 1
    return gc.stats
.end

fn gc_header_size() -> i64
    return 24
.end

fn gc_aligned_size(size_bytes: i64) -> i64
    if size_bytes <= 0
        return 0
    .end
    let align: i64 = 8
    let rem = size_bytes % align
    if rem == 0
        return size_bytes
    .end
    return size_bytes + (align - rem)
.end

fn gc_make_object(addr: i64, tag: GcTag, payload_size: i64) -> GcObject
    let payload = gc_zero_payload(payload_size)
    return GcObject {
        header = GcHeader { tag = tag, size_bytes = payload_size, marked = false },
        addr = addr,
        payload = payload
    }
.end

struct GcBlockClaim
    addr: i64
    size_bytes: i64
.end

fn gc_claim_free_block(heap: &mut GcHeap, requested: i64) -> GcBlockClaim
    let mut idx = 0
    while idx < heap.freelist.len()
        let block = heap.freelist[idx]
        if block.size_bytes >= requested
            let addr = block.addr
            heap.freelist[idx] = heap.freelist[heap.freelist.len() - 1]
            heap.freelist.pop()
            return GcBlockClaim { addr = addr, size_bytes = block.size_bytes }
        .end
        idx = idx + 1
    .end
    return GcBlockClaim { addr = -1, size_bytes = 0 }
.end

fn gc_zero_payload(size_bytes: i64) -> coll.Vec[u8]
    let bytes = coll.Vec[u8]()
    let mut i: i64 = 0
    while i < size_bytes
        bytes.push(0 as u8)
        i = i + 1
    .end
    return bytes
.end

fn gc_mark_from_root(heap: &mut GcHeap, addr: i64) -> Unit
    if addr < 0
        return
    .end
    let start_index = gc_find_object_index(heap, addr)
    if start_index < 0
        return
    .end

    let mut mark_stack = coll.Vec[i32]()
    mark_stack.push(start_index)
    while mark_stack.len() > 0
        let index = mark_stack.pop()
        if index < 0 or index >= heap.objects.len()
            continue
        .end
        let mut obj = heap.objects[index]
        if obj.header.marked
            continue
        .end
        obj.header.marked = true
        heap.objects[index] = obj

        let children = gc_decode_children(obj)
        let mut c = 0
        while c < children.len()
            let child_addr = children[c]
            if child_addr >= 0
                let child_index = gc_find_object_index(heap, child_addr)
                if child_index >= 0
                    mark_stack.push(child_index)
                .end
            .end
            c = c + 1
        .end
    .end
.end

fn gc_find_object_index(heap: &mut GcHeap, addr: i64) -> i32
    let mut idx = 0
    while idx < heap.objects.len()
        if heap.objects[idx].addr == addr
            return idx
        .end
        idx = idx + 1
    .end
    return -1
.end

fn gc_decode_children(obj: GcObject) -> coll.Vec[i64]
    let edges = coll.Vec[i64]()
    if obj.header.tag == GcTag::GcString or obj.header.tag == GcTag::GcBytes
        return edges
    .end
    let mut idx: i32 = 0
    let payload_len = obj.payload.len()
    while idx + 8 <= payload_len
        let mut value: i64 = 0
        let mut shift: i32 = 0
        while shift < 8
            value = value | ((obj.payload[idx + shift] as i64) << (shift * 8))
            shift = shift + 1
        .end
        edges.push(value)
        idx = idx + 8
    .end
    return edges
.end

fn gc_sweep(heap: &mut GcHeap, stats: &mut GcStats) -> Unit
    let live = coll.Vec[GcObject]()
    let mut idx = 0
    stats.bytes_live = 0
    while idx < heap.objects.len()
        let mut obj = heap.objects[idx]
        if obj.header.marked
            obj.header.marked = false
            stats.bytes_live = stats.bytes_live + obj.header.size_bytes as u64
            live.push(obj)
        else
            heap.freelist.push(GcFreeBlock { addr = obj.addr, size_bytes = obj.header.size_bytes + gc_header_size() })
        .end
        idx = idx + 1
    .end
    heap.objects = live
.end
