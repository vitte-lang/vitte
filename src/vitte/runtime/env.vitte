module vitte.runtime.env

import std.collections as coll
import std.string as str

# ============================================================================
# Runtime environment helpers wired to the host.
# ============================================================================

fn args() -> coll.Vec[String]
  # Snapshot the current argv exposed by the host (or fall back to defaults).
  let snapshot = host_collect_args()
  if snapshot.len() == 0
    return default_argv()
  .end
  return snapshot
.end

fn exit(code: Int) -> Unit
  host_request_exit(code)
.end

fn host_collect_args() -> coll.Vec[String]
  let count = host_arg_count()
  if count <= 0
    return coll.Vec[String]()
  .end

  let argv = coll.Vec[String]()
  let mut idx = 0
  while idx < count
    argv.push(host_arg_at(idx))
    idx = idx + 1
  .end
  return argv
.end

fn default_argv() -> coll.Vec[String]
  let argv = coll.Vec[String]()
  argv.push("lc-build")
  return argv
.end

fn host_arg_count() -> Int
  return _intrinsic_process_argc()
.end

fn host_arg_at(index: Int) -> String
  return _intrinsic_process_arg_at(index)
.end

fn host_request_exit(code: Int) -> Unit
  _intrinsic_process_exit(code)
.end

# ---------------------------------------------------------------------------
# Intrinsic hooks (to be provided by the host runtime). Fallback behaviour
# keeps testing viable when bindings are not wired yet.
# ---------------------------------------------------------------------------

fn _intrinsic_process_argc() -> Int
  return 0
.end

fn _intrinsic_process_arg_at(index: Int) -> String
  let _ = index
  return ""
.end

fn _intrinsic_process_exit(code: Int) -> Unit
  say "[runtime.env] exit requested with code=" + str.from_int(code)
.end
