module vitte.runtime.vm

import std.collections as coll
import vitte.runtime.bytecode as bc
import vitte.runtime.std_hooks as hooks

# ============================================================================
# VM Vitte – boucle d’exécution bytecode
# ============================================================================

enum VmValueTag
    VmNil
    VmBool
    VmI64
    VmF64
    VmStringRef
    VmArrayRef
    VmStructRef
.end

union VmValuePayload
    bool_value: bool
    i64_value: i64
    f64_value: f64
    heap_ptr: i64          # offset linéaire dans la heap
.end

struct VmValue
    tag: VmValueTag
    payload: VmValuePayload
.end

struct VmFrame
    func_index: i32
    pc: i32
    locals: coll.Vec[VmValue]
    stack_base: i32
.end

struct VmHeapRegion
    base: i64
    limit: i64
    hp: i64
    objects: coll.Vec[VmHeapObject]
.end

enum VmHeapTag
    HeapString
    HeapArray
    HeapStruct
.end

union VmHeapPayload
    string_bytes: coll.Vec[u8]
    array_items: coll.Vec[VmValue]
    struct_fields: coll.Vec[VmValue]
.end

struct VmHeapObject
    tag: VmHeapTag
    payload: VmHeapPayload
.end

struct VmState
    chunk: bc.LvmChunk
    frames: coll.Vec[VmFrame]
    value_stack: coll.Vec[VmValue]
    heap: VmHeapRegion
    std: hooks.StdHooks
.end

# ----------------------------------------------------------------------------
# Dispatch – specs
# ----------------------------------------------------------------------------

# apply_op : interprète une instruction décodée et met à jour l’état VM.
struct VmDispatchResult
    halted: bool
    trap: String
    last_value: VmValue
.end

struct VmDecodedInst
    inst: bc.LvmInstruction
    byte_size: i32
.end

fn vm_value_from_const(const_index: i32, constant: bc.LvmConst) -> VmValue
    if constant.tag == bc.LvmConstTag::ConstNil
        return VmValue { tag = VmValueTag::VmNil, payload = VmValuePayload { i64_value = 0 } }
    .end
    if constant.tag == bc.LvmConstTag::ConstBool
        return VmValue { tag = VmValueTag::VmBool, payload = VmValuePayload { bool_value = constant.payload.bool_value } }
    .end
    if constant.tag == bc.LvmConstTag::ConstI64
        return VmValue { tag = VmValueTag::VmI64, payload = VmValuePayload { i64_value = constant.payload.i64_value } }
    .end
    if constant.tag == bc.LvmConstTag::ConstF64
        return VmValue { tag = VmValueTag::VmF64, payload = VmValuePayload { f64_value = constant.payload.f64_value } }
    .end
    if constant.tag == bc.LvmConstTag::ConstString
        # Encodage : pointeur < 0 => index constant pool (évite collision avec heap).
        return VmValue { tag = VmValueTag::VmStringRef, payload = VmValuePayload { heap_ptr = -1 - (const_index as i64) } }
    .end
    return VmValue { tag = VmValueTag::VmNil, payload = VmValuePayload { i64_value = 0 } }
.end

fn vm_string_bytes(state: VmState, value: VmValue) -> coll.Vec[u8]
    let mut bytes = coll.Vec[u8]()
    if value.tag != VmValueTag::VmStringRef
        return bytes
    .end

    let ptr = value.payload.heap_ptr
    if ptr >= 0
        let heap_index = ptr as i32
        if heap_index >= 0 and heap_index < state.heap.objects.len()
            let obj = state.heap.objects[heap_index]
            if obj.tag == VmHeapTag::HeapString
                return obj.payload.string_bytes
            .end
        .end

        # Compat legacy: anciennes valeurs string référencent le const pool en >= 0.
        if heap_index >= 0 and heap_index < state.chunk.const_pool.consts.len()
            let str_val = state.chunk.const_pool.consts[heap_index].payload.string_value
            let raw = str_val.as_bytes()
            let mut i: i32 = 0
            while i < raw.len()
                bytes.push(raw[i])
                i = i + 1
            .end
            return bytes
        .end
        return bytes
    .end

    let const_index = (-1 - ptr) as i32
    if const_index >= 0 and const_index < state.chunk.const_pool.consts.len()
        let str_val = state.chunk.const_pool.consts[const_index].payload.string_value
        let raw = str_val.as_bytes()
        let mut i: i32 = 0
        while i < raw.len()
            bytes.push(raw[i])
            i = i + 1
        .end
        return bytes
    .end

    return bytes
.end

fn vm_render_value_bytes(state: VmState, value: VmValue) -> coll.Vec[u8]
    if value.tag == VmValueTag::VmStringRef
        return vm_string_bytes(state, value)
    .end
    if value.tag == VmValueTag::VmI64
        let text = value.payload.i64_value.to_string()
        return text.as_bytes()
    .end
    if value.tag == VmValueTag::VmBool
        let text = value.payload.bool_value.to_string()
        return text.as_bytes()
    .end
    let text = "<nil>"
    return text.as_bytes()
.end

fn heap_write_string(heap: &mut VmHeapRegion, ref_index: i64, bytes: coll.Vec[u8]) -> bool
    let idx = ref_index as i32
    if idx < 0 or idx >= heap.objects.len()
        return false
    .end
    let mut obj = heap.objects[idx]
    if obj.tag != VmHeapTag::HeapString
        return false
    .end
    obj.payload.string_bytes = bytes
    heap.objects[idx] = obj
    return true
.end

fn heap_array_push_value(heap: &mut VmHeapRegion, ref_index: i64, value: VmValue) -> bool
    let idx = ref_index as i32
    if idx < 0 or idx >= heap.objects.len()
        return false
    .end
    let mut obj = heap.objects[idx]
    if obj.tag != VmHeapTag::HeapArray
        return false
    .end
    obj.payload.array_items.push(value)
    heap.objects[idx] = obj
    return true
.end

fn heap_array_get_value(heap: VmHeapRegion, ref_index: i64, index: i32) -> VmValue
    let idx = ref_index as i32
    if idx < 0 or idx >= heap.objects.len()
        return VmValue { tag = VmValueTag::VmNil, payload = VmValuePayload { i64_value = -1 } }
    .end
    let obj = heap.objects[idx]
    if obj.tag != VmHeapTag::HeapArray
        return VmValue { tag = VmValueTag::VmNil, payload = VmValuePayload { i64_value = -1 } }
    .end
    if index < 0 or index >= obj.payload.array_items.len()
        return VmValue { tag = VmValueTag::VmNil, payload = VmValuePayload { i64_value = -1 } }
    .end
    return obj.payload.array_items[index]
.end

fn vm_value_from_rt_string(state: &mut VmState, rt: hooks.RtString) -> VmValue
    let ref_index = heap_alloc_empty(&mut state.heap, 0)
    let mut bytes = coll.Vec[u8]()
    let mut i: i32 = 0
    while i < rt.bytes.len()
        bytes.push(rt.bytes[i])
        i = i + 1
    .end
    let ok = heap_write_string(&mut state.heap, ref_index, bytes)
    if not ok
        return VmValue { tag = VmValueTag::VmNil, payload = VmValuePayload { i64_value = -1 } }
    .end
    return VmValue { tag = VmValueTag::VmStringRef, payload = VmValuePayload { heap_ptr = ref_index } }
.end

fn vm_array_from_value(state: VmState, value: VmValue) -> hooks.RtArray
    if value.tag != VmValueTag::VmArrayRef
        return hooks.RtArray { len = 0, cap = 0, data_ptr = -1 }
    .end
    let idx = value.payload.heap_ptr as i32
    if idx < 0 or idx >= state.heap.objects.len()
        return hooks.RtArray { len = 0, cap = 0, data_ptr = -1 }
    .end
    let obj = state.heap.objects[idx]
    if obj.tag != VmHeapTag::HeapArray
        return hooks.RtArray { len = 0, cap = 0, data_ptr = -1 }
    .end
    return hooks.RtArray { len = obj.payload.array_items.len(), cap = obj.payload.array_items.len(), data_ptr = value.payload.heap_ptr }
.end

fn vm_value_from_rt_array(state: &mut VmState, arr: hooks.RtArray) -> VmValue
    let ptr = arr.data_ptr
    if ptr >= 0 and ptr < state.heap.objects.len()
        let obj = state.heap.objects[ptr]
        if obj.tag == VmHeapTag::HeapArray
            return VmValue { tag = VmValueTag::VmArrayRef, payload = VmValuePayload { heap_ptr = ptr } }
        .end
    .end

    let ref_index = heap_alloc_empty(&mut state.heap, 1)
    return VmValue { tag = VmValueTag::VmArrayRef, payload = VmValuePayload { heap_ptr = ref_index } }
.end

fn vm_decode_at_pc(chunk: bc.LvmChunk, pc: i32) -> VmDecodedInst
    # Encodage MVP : [opcode:u8][argc:u8][operands:argc * i32 little-endian].
    let opcode_byte = chunk.code[pc]
    let operand_count = chunk.code[pc + 1]

    let operands = coll.Vec[i32]()
    let mut idx: i32 = 0
    while idx < operand_count as i32
        let base = pc + 2 + idx * 4
        let b0 = chunk.code[base]
        let b1 = chunk.code[base + 1]
        let b2 = chunk.code[base + 2]
        let b3 = chunk.code[base + 3]
        let value = (b0 as i32) | (b1 as i32) << 8 | (b2 as i32) << 16 | (b3 as i32) << 24
        operands.push(value)
        idx = idx + 1
    .end

    let mut opcode = bc.LvmOpcode::OpConst
    if opcode_byte == 1
        opcode = bc.LvmOpcode::OpAdd
    .end
    if opcode_byte == 2
        opcode = bc.LvmOpcode::OpSub
    .end
    if opcode_byte == 3
        opcode = bc.LvmOpcode::OpCmpEq
    .end
    if opcode_byte == 4
        opcode = bc.LvmOpcode::OpJmp
    .end
    if opcode_byte == 5
        opcode = bc.LvmOpcode::OpJmpIf
    .end
    if opcode_byte == 6
        opcode = bc.LvmOpcode::OpRet
    .end
    if opcode_byte == 7
        opcode = bc.LvmOpcode::OpMul
    .end
    if opcode_byte == 8
        opcode = bc.LvmOpcode::OpDiv
    .end
    if opcode_byte == 9
        opcode = bc.LvmOpcode::OpMod
    .end
    if opcode_byte == 10
        opcode = bc.LvmOpcode::OpNeg
    .end
    if opcode_byte == 11
        opcode = bc.LvmOpcode::OpCmpNe
    .end
    if opcode_byte == 12
        opcode = bc.LvmOpcode::OpCmpLt
    .end
    if opcode_byte == 13
        opcode = bc.LvmOpcode::OpCmpLe
    .end
    if opcode_byte == 14
        opcode = bc.LvmOpcode::OpCmpGt
    .end
    if opcode_byte == 15
        opcode = bc.LvmOpcode::OpCmpGe
    .end
    if opcode_byte == 16
        opcode = bc.LvmOpcode::OpLoadLocal
    .end
    if opcode_byte == 17
        opcode = bc.LvmOpcode::OpStoreLocal
    .end
    if opcode_byte == 18
        opcode = bc.LvmOpcode::OpLoadField
    .end
    if opcode_byte == 19
        opcode = bc.LvmOpcode::OpStoreField
    .end
    if opcode_byte == 20
        opcode = bc.LvmOpcode::OpAllocHeap
    .end
    if opcode_byte == 21
        opcode = bc.LvmOpcode::OpCall
    .end
    if opcode_byte == 22
        opcode = bc.LvmOpcode::OpCallIndirect
    .end
    if opcode_byte == 23
        opcode = bc.LvmOpcode::OpStdPrint
    .end
    if opcode_byte == 24
        opcode = bc.LvmOpcode::OpStdPrintln
    .end
    if opcode_byte == 25
        opcode = bc.LvmOpcode::OpStdMakeString
    .end
    if opcode_byte == 26
        opcode = bc.LvmOpcode::OpStdConcatString
    .end
    if opcode_byte == 27
        opcode = bc.LvmOpcode::OpStdArrayPush
    .end
    if opcode_byte == 28
        opcode = bc.LvmOpcode::OpStdArrayGet
    .end

    let inst = bc.LvmInstruction { opcode = opcode, operands = operands }
    let size = 2 + operand_count as i32 * 4
    return VmDecodedInst { inst = inst, byte_size = size }
.end

fn vm_equals(state: VmState, lhs: VmValue, rhs: VmValue) -> bool
    if lhs.tag != rhs.tag
        return false
    .end
    if lhs.tag == VmValueTag::VmBool
        return lhs.payload.bool_value == rhs.payload.bool_value
    .end
    if lhs.tag == VmValueTag::VmI64
        return lhs.payload.i64_value == rhs.payload.i64_value
    .end
    if lhs.tag == VmValueTag::VmF64
        return lhs.payload.f64_value == rhs.payload.f64_value
    .end
    if lhs.tag == VmValueTag::VmStringRef
        let lhs_bytes = vm_string_bytes(state, lhs)
        let rhs_bytes = vm_string_bytes(state, rhs)
        if lhs_bytes.len() != rhs_bytes.len()
            return false
        .end
        let mut i: i32 = 0
        while i < lhs_bytes.len()
            if lhs_bytes[i] != rhs_bytes[i]
                return false
            .end
            i = i + 1
        .end
        return true
    .end
    return false
.end

fn heap_tag_to_value_tag(kind: i32) -> VmValueTag
    if kind == 0
        return VmValueTag::VmStringRef
    .end
    if kind == 1
        return VmValueTag::VmArrayRef
    .end
    if kind == 2
        return VmValueTag::VmStructRef
    .end
    return VmValueTag::VmNil
.end

fn heap_alloc_empty(heap: &mut VmHeapRegion, kind: i32) -> i64
    let tag =
        if kind == 0 then VmHeapTag::HeapString
        else if kind == 1 then VmHeapTag::HeapArray
        else VmHeapTag::HeapStruct
        end

    let payload =
        if tag == VmHeapTag::HeapString then VmHeapPayload { string_bytes = coll.Vec[u8]() }
        else if tag == VmHeapTag::HeapArray then VmHeapPayload { array_items = coll.Vec[VmValue]() }
        else VmHeapPayload { struct_fields = coll.Vec[VmValue]() }
        end

    heap.objects.push(VmHeapObject { tag = tag, payload = payload })
    return (heap.objects.len() - 1) as i64
.end

fn heap_load_field(heap: VmHeapRegion, target: VmValue, field_index: i32) -> VmValue
    if target.tag == VmValueTag::VmStructRef
        let idx = target.payload.heap_ptr as i32
        if idx < 0 or idx >= heap.objects.len()
            return VmValue { tag = VmValueTag::VmNil, payload = VmValuePayload { i64_value = -1 } }
        .end
        let obj = heap.objects[idx]
        if obj.tag == VmHeapTag::HeapStruct
            if field_index < obj.payload.struct_fields.len()
                return obj.payload.struct_fields[field_index]
            .end
        .end
    .end

    if target.tag == VmValueTag::VmArrayRef
        let idx = target.payload.heap_ptr as i32
        if idx < 0 or idx >= heap.objects.len()
            return VmValue { tag = VmValueTag::VmNil, payload = VmValuePayload { i64_value = -1 } }
        .end
        let obj = heap.objects[idx]
        if obj.tag == VmHeapTag::HeapArray
            if field_index < obj.payload.array_items.len()
                return obj.payload.array_items[field_index]
            .end
        .end
    .end

    return VmValue { tag = VmValueTag::VmNil, payload = VmValuePayload { i64_value = -1 } }
.end

fn heap_store_field(heap: &mut VmHeapRegion, target: VmValue, field_index: i32, value: VmValue) -> bool
    if target.tag == VmValueTag::VmStructRef
        let idx = target.payload.heap_ptr as i32
        if idx < 0 or idx >= heap.objects.len()
            return false
        .end
        let mut obj = heap.objects[idx]
        if obj.tag != VmHeapTag::HeapStruct
            return false
        .end
        while obj.payload.struct_fields.len() <= field_index
            obj.payload.struct_fields.push(VmValue { tag = VmValueTag::VmNil, payload = VmValuePayload { i64_value = 0 } })
        .end
        obj.payload.struct_fields[field_index] = value
        heap.objects[idx] = obj
        return true
    .end

    if target.tag == VmValueTag::VmArrayRef
        let idx = target.payload.heap_ptr as i32
        if idx < 0 or idx >= heap.objects.len()
            return false
        .end
        let mut obj = heap.objects[idx]
        if obj.tag != VmHeapTag::HeapArray
            return false
        .end
        while obj.payload.array_items.len() <= field_index
            obj.payload.array_items.push(VmValue { tag = VmValueTag::VmNil, payload = VmValuePayload { i64_value = 0 } })
        .end
        obj.payload.array_items[field_index] = value
        heap.objects[idx] = obj
        return true
    .end

    return false
.end

fn vm_step(state: VmState, inst: bc.LvmInstruction, inst_size: i32) -> VmDispatchResult
    if state.frames.len() == 0
        return VmDispatchResult { halted = true, trap = "no frame", last_value = VmValue { tag = VmValueTag::VmNil, payload = VmValuePayload { i64_value = 0 } } }
    .end

    let frame_index = state.frames.len() - 1
    let mut frame = state.frames[frame_index]

    if inst.opcode == bc.LvmOpcode::OpConst
        let const_index = inst.operands[0]
        let constant = state.chunk.const_pool.consts[const_index]
        let mut value = vm_value_from_const(const_index, constant)
        if constant.tag == bc.LvmConstTag::ConstString
            let bytes = constant.payload.string_value.as_bytes()
            let rt = state.std.make_string(bytes)
            value = vm_value_from_rt_string(&mut state, rt)
        .end
        state.value_stack.push(value)
        frame.pc = frame.pc + inst_size
        state.frames[frame_index] = frame
        return VmDispatchResult { halted = false, trap = "", last_value = value }
    .end

    if inst.opcode == bc.LvmOpcode::OpAdd
        let rhs = state.value_stack.pop()
        let lhs = state.value_stack.pop()
        let sum = lhs.payload.i64_value + rhs.payload.i64_value
        let value = VmValue { tag = VmValueTag::VmI64, payload = VmValuePayload { i64_value = sum } }
        state.value_stack.push(value)
        frame.pc = frame.pc + inst_size
        state.frames[frame_index] = frame
        return VmDispatchResult { halted = false, trap = "", last_value = value }
    .end

    if inst.opcode == bc.LvmOpcode::OpSub
        let rhs = state.value_stack.pop()
        let lhs = state.value_stack.pop()
        let diff = lhs.payload.i64_value - rhs.payload.i64_value
        let value = VmValue { tag = VmValueTag::VmI64, payload = VmValuePayload { i64_value = diff } }
        state.value_stack.push(value)
        frame.pc = frame.pc + inst_size
        state.frames[frame_index] = frame
        return VmDispatchResult { halted = false, trap = "", last_value = value }
    .end

    if inst.opcode == bc.LvmOpcode::OpMul
        let rhs = state.value_stack.pop()
        let lhs = state.value_stack.pop()
        let prod = lhs.payload.i64_value * rhs.payload.i64_value
        let value = VmValue { tag = VmValueTag::VmI64, payload = VmValuePayload { i64_value = prod } }
        state.value_stack.push(value)
        frame.pc = frame.pc + inst_size
        state.frames[frame_index] = frame
        return VmDispatchResult { halted = false, trap = "", last_value = value }
    .end

    if inst.opcode == bc.LvmOpcode::OpDiv
        let rhs = state.value_stack.pop()
        let lhs = state.value_stack.pop()
        if rhs.payload.i64_value == 0
            return VmDispatchResult { halted = true, trap = "division by zero", last_value = rhs }
        .end
        let q = lhs.payload.i64_value / rhs.payload.i64_value
        let value = VmValue { tag = VmValueTag::VmI64, payload = VmValuePayload { i64_value = q } }
        state.value_stack.push(value)
        frame.pc = frame.pc + inst_size
        state.frames[frame_index] = frame
        return VmDispatchResult { halted = false, trap = "", last_value = value }
    .end

    if inst.opcode == bc.LvmOpcode::OpMod
        let rhs = state.value_stack.pop()
        let lhs = state.value_stack.pop()
        if rhs.payload.i64_value == 0
            return VmDispatchResult { halted = true, trap = "mod by zero", last_value = rhs }
        .end
        let r = lhs.payload.i64_value % rhs.payload.i64_value
        let value = VmValue { tag = VmValueTag::VmI64, payload = VmValuePayload { i64_value = r } }
        state.value_stack.push(value)
        frame.pc = frame.pc + inst_size
        state.frames[frame_index] = frame
        return VmDispatchResult { halted = false, trap = "", last_value = value }
    .end

    if inst.opcode == bc.LvmOpcode::OpNeg
        let v = state.value_stack.pop()
        let value = VmValue { tag = VmValueTag::VmI64, payload = VmValuePayload { i64_value = -v.payload.i64_value } }
        state.value_stack.push(value)
        frame.pc = frame.pc + inst_size
        state.frames[frame_index] = frame
        return VmDispatchResult { halted = false, trap = "", last_value = value }
    .end

    if inst.opcode == bc.LvmOpcode::OpCmpEq
        let rhs = state.value_stack.pop()
        let lhs = state.value_stack.pop()
        let equals = vm_equals(state, lhs, rhs)
        let value = VmValue { tag = VmValueTag::VmBool, payload = VmValuePayload { bool_value = equals } }
        state.value_stack.push(value)
        frame.pc = frame.pc + inst_size
        state.frames[frame_index] = frame
        return VmDispatchResult { halted = false, trap = "", last_value = value }
    .end

    if inst.opcode == bc.LvmOpcode::OpCmpNe
        let rhs = state.value_stack.pop()
        let lhs = state.value_stack.pop()
        let equals = vm_equals(state, lhs, rhs)
        let value = VmValue { tag = VmValueTag::VmBool, payload = VmValuePayload { bool_value = not equals } }
        state.value_stack.push(value)
        frame.pc = frame.pc + inst_size
        state.frames[frame_index] = frame
        return VmDispatchResult { halted = false, trap = "", last_value = value }
    .end

    if inst.opcode == bc.LvmOpcode::OpCmpLt
        let rhs = state.value_stack.pop()
        let lhs = state.value_stack.pop()
        let res = lhs.payload.i64_value < rhs.payload.i64_value
        let value = VmValue { tag = VmValueTag::VmBool, payload = VmValuePayload { bool_value = res } }
        state.value_stack.push(value)
        frame.pc = frame.pc + inst_size
        state.frames[frame_index] = frame
        return VmDispatchResult { halted = false, trap = "", last_value = value }
    .end

    if inst.opcode == bc.LvmOpcode::OpCmpLe
        let rhs = state.value_stack.pop()
        let lhs = state.value_stack.pop()
        let res = lhs.payload.i64_value <= rhs.payload.i64_value
        let value = VmValue { tag = VmValueTag::VmBool, payload = VmValuePayload { bool_value = res } }
        state.value_stack.push(value)
        frame.pc = frame.pc + inst_size
        state.frames[frame_index] = frame
        return VmDispatchResult { halted = false, trap = "", last_value = value }
    .end

    if inst.opcode == bc.LvmOpcode::OpCmpGt
        let rhs = state.value_stack.pop()
        let lhs = state.value_stack.pop()
        let res = lhs.payload.i64_value > rhs.payload.i64_value
        let value = VmValue { tag = VmValueTag::VmBool, payload = VmValuePayload { bool_value = res } }
        state.value_stack.push(value)
        frame.pc = frame.pc + inst_size
        state.frames[frame_index] = frame
        return VmDispatchResult { halted = false, trap = "", last_value = value }
    .end

    if inst.opcode == bc.LvmOpcode::OpCmpGe
        let rhs = state.value_stack.pop()
        let lhs = state.value_stack.pop()
        let res = lhs.payload.i64_value >= rhs.payload.i64_value
        let value = VmValue { tag = VmValueTag::VmBool, payload = VmValuePayload { bool_value = res } }
        state.value_stack.push(value)
        frame.pc = frame.pc + inst_size
        state.frames[frame_index] = frame
        return VmDispatchResult { halted = false, trap = "", last_value = value }
    .end

    if inst.opcode == bc.LvmOpcode::OpLoadLocal
        let slot = inst.operands[0]
        let val = frame.locals[slot]
        state.value_stack.push(val)
        frame.pc = frame.pc + inst_size
        state.frames[frame_index] = frame
        return VmDispatchResult { halted = false, trap = "", last_value = val }
    .end

    if inst.opcode == bc.LvmOpcode::OpStoreLocal
        let slot = inst.operands[0]
        let val = state.value_stack.pop()
        frame.locals[slot] = val
        frame.pc = frame.pc + inst_size
        state.frames[frame_index] = frame
        return VmDispatchResult { halted = false, trap = "", last_value = val }
    .end

    if inst.opcode == bc.LvmOpcode::OpAllocHeap
        let kind = inst.operands[0]
        let tag = heap_tag_to_value_tag(kind)
        if tag == VmValueTag::VmNil
            return VmDispatchResult { halted = true, trap = "invalid heap alloc kind", last_value = VmValue { tag = VmValueTag::VmNil, payload = VmValuePayload { i64_value = 0 } } }
        .end
        let ref_index = heap_alloc_empty(&mut state.heap, kind)
        let value = VmValue { tag = tag, payload = VmValuePayload { heap_ptr = ref_index } }
        state.value_stack.push(value)
        frame.pc = frame.pc + inst_size
        state.frames[frame_index] = frame
        return VmDispatchResult { halted = false, trap = "", last_value = value }
    .end

    if inst.opcode == bc.LvmOpcode::OpLoadField
        let field_index = inst.operands[0]
        let target = state.value_stack.pop()
        let fetched = heap_load_field(state.heap, target, field_index)
        if fetched.tag == VmValueTag::VmNil and fetched.payload.i64_value == -1
            return VmDispatchResult { halted = true, trap = "invalid field load", last_value = fetched }
        .end
        state.value_stack.push(fetched)
        frame.pc = frame.pc + inst_size
        state.frames[frame_index] = frame
        return VmDispatchResult { halted = false, trap = "", last_value = fetched }
    .end

    if inst.opcode == bc.LvmOpcode::OpStoreField
        let field_index = inst.operands[0]
        let value = state.value_stack.pop()
        let target = state.value_stack.pop()
        let ok = heap_store_field(&mut state.heap, target, field_index, value)
        if not ok
            return VmDispatchResult { halted = true, trap = "invalid field store", last_value = value }
        .end
        frame.pc = frame.pc + inst_size
        state.frames[frame_index] = frame
        return VmDispatchResult { halted = false, trap = "", last_value = value }
    .end

    if inst.opcode == bc.LvmOpcode::OpJmp
        frame.pc = frame.pc + inst_size + inst.operands[0]
        state.frames[frame_index] = frame
        return VmDispatchResult { halted = false, trap = "", last_value = VmValue { tag = VmValueTag::VmNil, payload = VmValuePayload { i64_value = 0 } } }
    .end

    if inst.opcode == bc.LvmOpcode::OpJmpIf
        let cond = state.value_stack.pop()
        if cond.tag != VmValueTag::VmBool
            return VmDispatchResult { halted = true, trap = "jmp_if expects bool", last_value = cond }
        .end
        if cond.payload.bool_value
            frame.pc = frame.pc + inst_size + inst.operands[0]
        else
            frame.pc = frame.pc + inst_size
        .end
        state.frames[frame_index] = frame
        return VmDispatchResult { halted = false, trap = "", last_value = cond }
    .end

    if inst.opcode == bc.LvmOpcode::OpCall
        let fn_index = inst.operands[0]
        let func = state.chunk.functions.entries[fn_index]
        let mut locals = coll.Vec[VmValue]()
        let mut i: i32 = 0
        while i < func.param_count + func.local_count
            locals.push(VmValue { tag = VmValueTag::VmNil, payload = VmValuePayload { i64_value = 0 } })
            i = i + 1
        .end
        # Charger les arguments depuis la pile (ordre LIFO).
        let mut arg: i32 = func.param_count as i32 - 1
        while arg >= 0
            locals[arg] = state.value_stack.pop()
            arg = arg - 1
        .end
        let new_frame = VmFrame { func_index = fn_index, pc = func.code_offset, locals = locals, stack_base = state.value_stack.len() }
        state.frames.push(new_frame)
        frame.pc = frame.pc + inst_size
        state.frames[frame_index] = frame
        return VmDispatchResult { halted = false, trap = "", last_value = VmValue { tag = VmValueTag::VmNil, payload = VmValuePayload { i64_value = 0 } } }
    .end

    if inst.opcode == bc.LvmOpcode::OpCallIndirect
        let fn_val = state.value_stack.pop()
        let fn_index = fn_val.payload.i64_value as i32
        let func = state.chunk.functions.entries[fn_index]
        let mut locals = coll.Vec[VmValue]()
        let mut i: i32 = 0
        while i < func.param_count + func.local_count
            locals.push(VmValue { tag = VmValueTag::VmNil, payload = VmValuePayload { i64_value = 0 } })
            i = i + 1
        .end
        let mut arg: i32 = func.param_count as i32 - 1
        while arg >= 0
            locals[arg] = state.value_stack.pop()
            arg = arg - 1
        .end
        let new_frame = VmFrame { func_index = fn_index, pc = func.code_offset, locals = locals, stack_base = state.value_stack.len() }
        state.frames.push(new_frame)
        frame.pc = frame.pc + inst_size
        state.frames[frame_index] = frame
        return VmDispatchResult { halted = false, trap = "", last_value = VmValue { tag = VmValueTag::VmNil, payload = VmValuePayload { i64_value = 0 } } }
    .end

    if inst.opcode == bc.LvmOpcode::OpStdPrint
        let value = state.value_stack.pop()
        let bytes = vm_render_value_bytes(state, value)
        let rt = state.std.make_string(bytes)
        state.std.print(rt)
        state.value_stack.push(value)
        frame.pc = frame.pc + inst_size
        state.frames[frame_index] = frame
        return VmDispatchResult { halted = false, trap = "", last_value = value }
    .end

    if inst.opcode == bc.LvmOpcode::OpStdPrintln
        let value = state.value_stack.pop()
        let bytes = vm_render_value_bytes(state, value)
        let rt = state.std.make_string(bytes)
        state.std.println(rt)
        state.value_stack.push(value)
        frame.pc = frame.pc + inst_size
        state.frames[frame_index] = frame
        return VmDispatchResult { halted = false, trap = "", last_value = value }
    .end

    if inst.opcode == bc.LvmOpcode::OpStdMakeString
        let const_index = inst.operands[0]
        let constant = state.chunk.const_pool.consts[const_index]
        if constant.tag != bc.LvmConstTag::ConstString
            return VmDispatchResult { halted = true, trap = "std_make_string expects string const", last_value = VmValue { tag = VmValueTag::VmNil, payload = VmValuePayload { i64_value = 0 } } }
        .end
        let rt = state.std.make_string(constant.payload.string_value.as_bytes())
        let value = vm_value_from_rt_string(&mut state, rt)
        state.value_stack.push(value)
        frame.pc = frame.pc + inst_size
        state.frames[frame_index] = frame
        return VmDispatchResult { halted = false, trap = "", last_value = value }
    .end

    if inst.opcode == bc.LvmOpcode::OpStdConcatString
        let rhs = state.value_stack.pop()
        let lhs = state.value_stack.pop()
        let lhs_bytes = vm_render_value_bytes(state, lhs)
        let rhs_bytes = vm_render_value_bytes(state, rhs)
        let lhs_rt = state.std.make_string(lhs_bytes)
        let rhs_rt = state.std.make_string(rhs_bytes)
        let merged = state.std.concat_string(lhs_rt, rhs_rt)
        let value = vm_value_from_rt_string(&mut state, merged)
        state.value_stack.push(value)
        frame.pc = frame.pc + inst_size
        state.frames[frame_index] = frame
        return VmDispatchResult { halted = false, trap = "", last_value = value }
    .end

    if inst.opcode == bc.LvmOpcode::OpStdArrayPush
        let value = state.value_stack.pop()
        let target = state.value_stack.pop()
        if target.tag != VmValueTag::VmArrayRef
            return VmDispatchResult { halted = true, trap = "array_push expects array", last_value = target }
        .end
        let mut ok = heap_array_push_value(&mut state.heap, target.payload.heap_ptr, value)
        let rt_array = vm_array_from_value(state, target)
        state.std.array_push(rt_array, value)
        if not ok
            return VmDispatchResult { halted = true, trap = "invalid array push", last_value = target }
        .end
        state.value_stack.push(target)
        frame.pc = frame.pc + inst_size
        state.frames[frame_index] = frame
        return VmDispatchResult { halted = false, trap = "", last_value = target }
    .end

    if inst.opcode == bc.LvmOpcode::OpStdArrayGet
        let index_value = state.value_stack.pop()
        let target = state.value_stack.pop()
        if target.tag != VmValueTag::VmArrayRef
            return VmDispatchResult { halted = true, trap = "array_get expects array", last_value = target }
        .end
        let elem = heap_array_get_value(state.heap, target.payload.heap_ptr, index_value.payload.i64_value as i32)
        if elem.tag == VmValueTag::VmNil and elem.payload.i64_value == -1
            return VmDispatchResult { halted = true, trap = "invalid array get", last_value = target }
        .end
        let rt_array = vm_array_from_value(state, target)
        state.std.array_get(rt_array, index_value.payload.i64_value)
        state.value_stack.push(elem)
        frame.pc = frame.pc + inst_size
        state.frames[frame_index] = frame
        return VmDispatchResult { halted = false, trap = "", last_value = elem }
    .end

    if inst.opcode == bc.LvmOpcode::OpRet
        let value = state.value_stack.pop()
        state.frames.pop()
        if state.frames.len() == 0
            return VmDispatchResult { halted = true, trap = "", last_value = value }
        .end
        # Retour vers l'appelant : remettre la valeur de retour sur la pile courante.
        state.value_stack.push(value)
        return VmDispatchResult { halted = false, trap = "", last_value = value }
    .end

    return VmDispatchResult { halted = false, trap = "unimplemented opcode", last_value = VmValue { tag = VmValueTag::VmNil, payload = VmValuePayload { i64_value = 0 } } }
.end

# Boucle principale (fetch/decode/execute).
fn vm_run(state: VmState) -> VmDispatchResult
    # Concept : while !halted { decode pc → inst; res = vm_step; update pc/frame; }
    if state.frames.len() == 0
        let entry = state.chunk.functions.entries[0]
        let mut locals = coll.Vec[VmValue]()
        let mut i: i32 = 0
        while i < entry.param_count + entry.local_count
            locals.push(VmValue { tag = VmValueTag::VmNil, payload = VmValuePayload { i64_value = 0 } })
            i = i + 1
        .end
        let frame = VmFrame { func_index = 0, pc = entry.code_offset, locals = locals, stack_base = 0 }
        state.frames.push(frame)
    .end

    let mut last = VmDispatchResult { halted = false, trap = "", last_value = VmValue { tag = VmValueTag::VmNil, payload = VmValuePayload { i64_value = 0 } } }
    while true
        let frame_index = state.frames.len() - 1
        let frame = state.frames[frame_index]
        let decoded = vm_decode_at_pc(state.chunk, frame.pc)
        last = vm_step(state, decoded.inst, decoded.byte_size)
        if last.halted or last.trap != ""
            return last
        .end
    .end

    return last
.end
