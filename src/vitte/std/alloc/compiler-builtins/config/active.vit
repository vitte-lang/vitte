<<<
active.vit
compiler-builtins config
>>>

space std/alloc/compiler_builtins/builtins_shim/config


<<<
imports
>>>

pull .target
pull .features


<<<
profiles
>>>

pick BuiltinProfile {
    STRICT
    HYBRID
    FALLBACK
}


<<<
active profile
>>>

#[export]
const ACTIVE_PROFILE: BuiltinProfile = BuiltinProfile.STRICT


<<<
feature selection
>>>

#[export]
const FEATURES: BuiltinFeatures =
    if ACTIVE_PROFILE == BuiltinProfile.STRICT {
        BuiltinFeatures(
            has_memcpy  = BACKEND_FEATURES.has_memcpy,
            has_memmove = BACKEND_FEATURES.has_memmove,
            has_memset  = BACKEND_FEATURES.has_memset,

            has_udiv    = BACKEND_FEATURES.has_udiv,
            has_urem    = BACKEND_FEATURES.has_urem,
            has_sdiv    = BACKEND_FEATURES.has_sdiv,
            has_srem    = BACKEND_FEATURES.has_srem,

            has_u128    = BACKEND_FEATURES.has_u128,
            has_i128    = BACKEND_FEATURES.has_i128,

            supports_unaligned_access = BACKEND_FEATURES.supports_unaligned_access,
            supports_fast_mul         = BACKEND_FEATURES.supports_fast_mul,
            supports_fast_div         = BACKEND_FEATURES.supports_fast_div,
            supports_fast_shift       = BACKEND_FEATURES.supports_fast_shift,
        )
    }
    else if ACTIVE_PROFILE == BuiltinProfile.HYBRID {
        builtin.trap("compiler-builtins: hybrid profile not supported")
    }
    else {
        builtin.trap("compiler-builtins: fallback profile not supported")
    }


<<<
required features
>>>

#[export]
proc assert_required_features() {
    assert_feature(FEATURES.has_memcpy,  "memcpy")
    assert_feature(FEATURES.has_memmove, "memmove")
    assert_feature(FEATURES.has_memset,  "memset")
    assert_feature(FEATURES.has_udiv,    "udiv")
    assert_feature(FEATURES.has_urem,    "urem")
}


proc assert_feature(ok: bool, name: string) {
    if !ok {
        builtin.trap("compiler-builtins: missing intrinsic: " + name)
    }
}


<<<
target invariants
>>>

#[export]
proc assert_target_compat() {
    if TARGET.pointer_bits != TARGET.sizes.size_ptr * 8 {
        builtin.trap("compiler-builtins: pointer size mismatch")
    }

    if TARGET.sizes.size_usize != TARGET.sizes.size_ptr {
        builtin.trap("compiler-builtins: usize/ptr mismatch")
    }
}