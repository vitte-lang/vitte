<<<
traits.vit
std math numeric traits
>>>

space std/math/traits


<<<
imports
>>>

use std/core/types.bool
use std/core/types.i32
use std/core/types.u32
use std/core/types.f32
use std/core/types.f64

use std/core/option.Option


<<<
identity traits
>>>

trait Zero[T] {
    zero: proc() -> T
    is_zero: proc(x: T) -> bool
}

trait One[T] {
    one: proc() -> T
}


<<<
ordering traits
>>>

trait MinMax[T] {
    min: proc(a: T, b: T) -> T
    max: proc(a: T, b: T) -> T
}


<<<
arithmetic traits
>>>

trait Add[T] {
    add: proc(a: T, b: T) -> T
}

trait Sub[T] {
    sub: proc(a: T, b: T) -> T
}

trait Mul[T] {
    mul: proc(a: T, b: T) -> T
}

trait Div[T] {
    div: proc(a: T, b: T) -> T
}


<<<
checked arithmetic traits
>>>

trait CheckedAdd[T] {
    checked_add: proc(a: T, b: T) -> Option[T]
}

trait CheckedSub[T] {
    checked_sub: proc(a: T, b: T) -> Option[T]
}

trait CheckedMul[T] {
    checked_mul: proc(a: T, b: T) -> Option[T]
}


<<<
wrapping arithmetic traits
>>>

trait WrappingAdd[T] {
    wrapping_add: proc(a: T, b: T) -> T
}

trait WrappingSub[T] {
    wrapping_sub: proc(a: T, b: T) -> T
}

trait WrappingMul[T] {
    wrapping_mul: proc(a: T, b: T) -> T
}


<<<
saturating arithmetic traits
>>>

trait SaturatingAdd[T] {
    saturating_add: proc(a: T, b: T) -> T
}

trait SaturatingSub[T] {
    saturating_sub: proc(a: T, b: T) -> T
}

trait SaturatingMul[T] {
    saturating_mul: proc(a: T, b: T) -> T
}


<<<
numeric classification
>>>

trait Signed[T] {
    abs: proc(x: T) -> T
}

trait Floating[T] {
    is_nan: proc(x: T) -> bool
    is_inf: proc(x: T) -> bool
    is_finite: proc(x: T) -> bool
}


<<<
random support
>>>

trait Random[T] {
    random: proc(rng: *Any) -> T
}