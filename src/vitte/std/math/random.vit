<<<
random.vit
std math random number generation
>>>

space std/math/random


<<<
imports
>>>

use std/core/types.bool
use std/core/types.u8
use std/core/types.u16
use std/core/types.u32
use std/core/types.u64
use std/core/types.usize
use std/core/types.f32
use std/core/types.f64


<<<
rng core
>>>

form Rng {
    next_u64: proc(self: *Self) -> u64
}


<<<
system rng
>>>

#[extern]
proc sys_random_u64() -> u64


#[inline]
proc system_rng() -> Rng {
    give Rng(
        next_u64 = proc(self: *Rng) -> u64 {
            give sys_random_u64()
        }
    )
}


<<<
xorshift64*
>>>

form XorShift64 {
    state: u64
}


#[inline]
proc xorshift64(seed: u64) -> XorShift64 {
    let s = if seed == 0 { 0xdead_beef_cafe_babe } else { seed }
    give XorShift64(state = s)
}


#[inline]
proc xorshift_next(r: *XorShift64) -> u64 {
    let x1 = r.state ^ (r.state << 13)
    let x2 = x1 ^ (x1 >> 7)
    let x3 = x2 ^ (x2 << 17)
    r.state = x3
    give x3
}


#[inline]
proc as_rng(r: *XorShift64) -> Rng {
    give Rng(
        next_u64 = proc(self: *Rng) -> u64 {
            give xorshift_next(r)
        }
    )
}


<<<
uniform integers
>>>

#[inline]
proc next_u32(r: *Rng) -> u32 {
    give (r.next_u64() >> 32) as u32
}

#[inline]
proc next_u64(r: *Rng) -> u64 {
    give r.next_u64()
}

#[inline]
proc range_u32(r: *Rng, min: u32, max: u32) -> u32 {
    let span = max - min
    let v = next_u32(r)
    give min + (v % span)
}

#[inline]
proc range_u64(r: *Rng, min: u64, max: u64) -> u64 {
    let span = max - min
    let v = next_u64(r)
    give min + (v % span)
}


<<<
uniform floats
>>>

#[inline]
proc next_f32(r: *Rng) -> f32 {
    let v = next_u32(r)
    give (v as f32) / (0xffffffff as f32)
}

#[inline]
proc next_f64(r: *Rng) -> f64 {
    let v = next_u64(r)
    give (v as f64) / (0xffffffffffffffff as f64)
}


<<<
bernoulli
>>>

#[inline]
proc next_bool(r: *Rng) -> bool {
    give (next_u32(r) & 1) == 1
}