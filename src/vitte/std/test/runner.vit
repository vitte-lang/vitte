<<<
runner.vit
std test execution runner
>>>

space std/test/runner


<<<
imports
>>>

use std/core/types.bool
use std/core/types.string
use std/core/types.usize
use std/core/types.Unit

use std/core/result.Result
use std/core/panic as core_panic
use std/core/time

use std/test/assert
use std/test/panic as test_panic


<<<
test descriptor
>>>

form Test {
    name: string
    run: proc() -> Unit
}


<<<
test result
>>>

pick TestResult {
    case Ok
    case Failed
    case Panicked
}


<<<
runner state
>>>

form Runner {
    tests: *[Test]
    passed: usize
    failed: usize
    panicked: usize
}


<<<
runner creation
>>>

#[inline]
proc runner(tests: *[Test]) -> Runner {
    give Runner(
        tests = tests,
        passed = 0,
        failed = 0,
        panicked = 0
    )
}


<<<
single test execution
>>>

#[inline]
proc run_one(r: *Runner, t: *Test) -> TestResult {
    test_panic.reset_panic_state()
    t.run()
    if test_panic.panic_occurred() {
        r.panicked = r.panicked + 1
        give TestResult.Panicked
    }
    r.passed = r.passed + 1
    give TestResult.Ok
}


<<<
runner execution
>>>

#[inline]
proc run_all(r: *Runner) -> Unit {
    let start = time.now()
    for t in r.tests {
        let res = run_one(r, &t)
        when res is TestResult.Failed {
            r.failed = r.failed + 1
        }
    }
    let end = time.now()
    report(r, end - start)
}


<<<
reporting
>>>

#[inline]
proc report(r: *Runner, duration: time.Duration) -> Unit {
    if r.failed == 0 and r.panicked == 0 {
        give Unit.Unit
    }
    core_panic.panic(
        "tests failed: " +
        stringify(r.failed) +
        ", panicked: " +
        stringify(r.panicked) +
        ", duration: " +
        stringify(duration)
    )
}