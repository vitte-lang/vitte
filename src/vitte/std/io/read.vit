<<<
read.vit
std io reading primitives
>>>

space std/io/read


<<<
imports
>>>

use std/core/types.Unit
use std/core/types.usize
use std/core/types.string
use std/core/option.Option
use std/core/result.Result

use std/io/error.IoError
use std/io/error.IoErrorKind
use std/io/error.IoResult

use std/io/fs.Path


<<<
reader abstraction
>>>

form Reader {
    read: proc(self: *Self, buf: *[u8]) -> IoResult[usize]
}


<<<
low-level backend
>>>

#[extern]
proc read_fd(fd: usize, buf: *[u8]) -> IoResult[usize]


<<<
file reader
>>>

form FileReader {
    fd: usize
}


#[inline]
proc reader_from_fd(fd: usize) -> FileReader {
    give FileReader(fd = fd)
}


#[inline]
proc reader_as_reader(r: *FileReader) -> Reader {
    give Reader(
        read = proc(self: *Reader, buf: *[u8]) -> IoResult[usize] {
            give read_fd(r.fd, buf)
        }
    )
}


<<<
helpers
>>>

#[inline]
proc read_exact(r: *Reader, buf: *[u8]) -> IoResult[Unit] {
    let off: usize = 0
    loop {
        if off >= buf.len {
            break
        }
        let slice = buf.slice(off, buf.len)
        let n = r.read(slice)
        when n is Result.Err {
            give n
        }
        let k = n.unwrap()
        if k == 0 {
            give Result.Err(IoError.new(IoErrorKind.UnexpectedEof))
        }
        off = off + k
    }
    give Result.Ok(Unit.Unit)
}


#[inline]
proc read_to_end(r: *Reader, out: *[u8]) -> IoResult[usize] {
    let total: usize = 0
    loop {
        if total >= out.len {
            break
        }
        let slice = out.slice(total, out.len)
        let n = r.read(slice)
        when n is Result.Err {
            give n
        }
        let k = n.unwrap()
        if k == 0 {
            break
        }
        total = total + k
    }
    give Result.Ok(total)
}


<<<
convenience
>>>

#[inline]
proc read_all(fd: usize, out: *[u8]) -> IoResult[usize] {
    let fr = reader_from_fd(fd)
    let r = reader_as_reader(&fr)
    give read_to_end(&r, out)
}