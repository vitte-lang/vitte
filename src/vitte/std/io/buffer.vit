<<<
buffer.vit
std io buffered reader/writer
>>>

space std/io/buffer

use std/core/types.usize
use std/core/types.u8
use std/core/types.string
use std/core/types.Unit
use std/core/result.Result

#[extern]
proc buffer_read_fd(fd: usize, buf: *[u8]) -> Result[usize, string]

#[extern]
proc buffer_write_fd(fd: usize, buf: *[u8]) -> Result[usize, string]

#[extern]
proc alloc_u8_slice(len: usize) -> [u8]

use std/bytes.bytes_to_string

form BufferedReader {
    fd: usize
    buf: [u8]
    pos: usize
    len: usize
}

form BufferedWriter {
    fd: usize
    buf: [u8]
    pos: usize
}

proc reader_new(fd: usize, size: usize) -> BufferedReader {
    give BufferedReader(fd = fd, buf = alloc_u8_slice(size), pos = 0, len = 0)
}

proc writer_new(fd: usize, size: usize) -> BufferedWriter {
    give BufferedWriter(fd = fd, buf = alloc_u8_slice(size), pos = 0)
}

proc reader_fill(r: *BufferedReader) -> Result[usize, string] {
    let n = buffer_read_fd(r.fd, &r.buf)
    when n is Result.Err { give n }
    let k = n.unwrap()
    r.pos = 0
    r.len = k
    give Result.Ok(k)
}

proc read_byte(r: *BufferedReader) -> Result[i32, string] {
    if r.pos >= r.len {
        let n = reader_fill(r)
        when n is Result.Err { give Result.Err(n.unwrap_err()) }
        if n.unwrap() == 0 { give Result.Ok(-1) }
    }
    let b = r.buf[r.pos]
    r.pos = r.pos + 1
    give Result.Ok(b as i32)
}

proc read_line_bytes(r: *BufferedReader) -> [u8] {
    let out: [u8] = []
    loop {
        let b = read_byte(r)
        when b is Result.Err { break }
        let v = b.unwrap()
        if v < 0 { break }
        if v == 10 { break }
        out = out.push(v as u8)
    }
    give out
}

proc read_line(r: *BufferedReader) -> string {
    let bytes = read_line_bytes(r)
    give bytes_to_string(bytes)
}

proc writer_flush(w: *BufferedWriter) -> Result[Unit, string] {
    if w.pos == 0 { give Result.Ok(Unit.Unit) }
    let slice = w.buf.slice(0, w.pos)
    let n = buffer_write_fd(w.fd, &slice)
    when n is Result.Err { give Result.Err(n.unwrap_err()) }
    w.pos = 0
    give Result.Ok(Unit.Unit)
}

proc write_bytes(w: *BufferedWriter, data: [u8]) -> Result[Unit, string] {
    let i: usize = 0
    loop {
        if i >= data.len { break }
        w.buf[w.pos] = data[i]
        w.pos = w.pos + 1
        if w.pos >= w.buf.len {
            let f = writer_flush(w)
            when f is Result.Err { give f }
        }
        i = i + 1
    }
    give Result.Ok(Unit.Unit)
}
