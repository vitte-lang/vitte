<<<
result.vit
std io result helpers
>>>

space std/io/result


<<<
imports
>>>

use std/core/types.Unit
use std/core/result.Result

use std/io/error.IoError
use std/io/error.IoErrorKind


<<<
type aliases
>>>

type IoResult[T] = Result[T, IoError]


<<<
constructors
>>>

#[inline]
proc ok[T](v: T) -> IoResult[T] {
    give Result.Ok(v)
}

#[inline]
proc err[T](e: IoError) -> IoResult[T] {
    give Result.Err(e)
}

#[inline]
proc err_kind[T](k: IoErrorKind) -> IoResult[T] {
    give Result.Err(IoError.new(k))
}


<<<
common results
>>>

#[inline]
proc ok_unit() -> IoResult[Unit] {
    give Result.Ok(Unit.Unit)
}


<<<
mapping helpers
>>>

#[inline]
proc map[T, U](r: IoResult[T], f: proc(T) -> U) -> IoResult[U] {
    when r is Result.Ok {
        give Result.Ok(f(r.unwrap()))
    }
    give Result.Err(r.unwrap_err())
}

#[inline]
proc map_err[T](r: IoResult[T], f: proc(IoError) -> IoError) -> IoResult[T] {
    when r is Result.Err {
        give Result.Err(f(r.unwrap_err()))
    }
    give r
}


<<<
inspection helpers
>>>

#[inline]
proc is_ok[T](r: IoResult[T]) -> bool {
    give r is Result.Ok
}

#[inline]
proc is_err[T](r: IoResult[T]) -> bool {
    give r is Result.Err
}


<<<
unwrap helpers (use with care)
>>>

#[inline]
proc unwrap[T](r: IoResult[T]) -> T {
    when r is Result.Ok {
        give r.unwrap()
    }
    panic("called unwrap on IoResult.Err")
}

#[inline]
proc unwrap_or[T](r: IoResult[T], default: T) -> T {
    when r is Result.Ok {
        give r.unwrap()
    }
    give default
}