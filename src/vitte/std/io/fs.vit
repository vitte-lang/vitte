<<<
fs.vit
std io filesystem api
>>>

space std/io/fs


<<<
imports
>>>

use std/io/error.IoError
use std/io/error.IoErrorKind
use std/io/error.IoResult

use std/core/option.Option
use std/core/result.Result


<<<
path type
>>>

type Path = string


<<<
file metadata
>>>

form Metadata {
    is_file: bool
    is_dir: bool
    size: usize
}


<<<
directory entry
>>>

form DirEntry {
    path: Path
    metadata: Metadata
}


<<<
filesystem queries
>>>

#[extern]
proc exists(path: Path) -> bool

#[extern]
proc is_file(path: Path) -> bool

#[extern]
proc is_dir(path: Path) -> bool

#[extern]
proc metadata(path: Path) -> IoResult[Metadata]


<<<
directory operations
>>>

#[extern]
proc read_dir(path: Path) -> IoResult[Iterator[DirEntry]]


<<<
file operations
>>>

#[extern]
proc create_dir(path: Path) -> IoResult[Unit]

#[extern]
proc remove_dir(path: Path) -> IoResult[Unit]

#[extern]
proc remove_file(path: Path) -> IoResult[Unit]

#[extern]
proc rename(from: Path, to: Path) -> IoResult[Unit]


<<<
convenience helpers
>>>

#[inline]
proc ensure_dir(path: Path) -> IoResult[Unit] {
    if exists(path) {
        if is_dir(path) {
            give Result.Ok(Unit.Unit)
        }
        give Result.Err(IoError.new(IoErrorKind.AlreadyExists))
    }
    give create_dir(path)
}


#[inline]
proc ensure_parent(path: Path) -> IoResult[Unit] {
    let idx = path.last_index_of("/")
    if idx is Option.None {
        give Result.Ok(Unit.Unit)
    }
    let parent = path.slice(0, idx.unwrap())
    give ensure_dir(parent)
}