<<<
path.vit
std io path utilities
>>>

space std/io/path


<<<
imports
>>>

use std/core/option.Option
use std/core/result.Result
use std/io/error.IoError
use std/io/error.IoErrorKind
use std/io/error.IoResult


<<<
path type
>>>

type Path = string


<<<
constants
>>>

const SEP_UNIX: string = "/"
const SEP_WIN:  string = "\\"


<<<
basic queries
>>>

#[inline]
proc is_absolute(p: Path) -> bool {
    if p.len == 0 {
        give false
    }
    if p[0] == '/' {
        give true
    }
    if p.len >= 2 && p[1] == ':' {
        give true
    }
    give false
}

#[inline]
proc is_relative(p: Path) -> bool {
    give !is_absolute(p)
}


<<<
components
>>>

#[inline]
proc file_name(p: Path) -> Option[string] {
    let i = last_sep_index(p)
    when i is Option.None {
        if p.len == 0 {
            give Option.None
        }
        give Option.Some(p)
    }
    let idx = i.unwrap()
    if idx + 1 >= p.len {
        give Option.None
    }
    give Option.Some(p.slice(idx + 1, p.len))
}

#[inline]
proc parent(p: Path) -> Option[Path] {
    let i = last_sep_index(p)
    when i is Option.None {
        give Option.None
    }
    let idx = i.unwrap()
    if idx == 0 {
        give Option.Some(p.slice(0, 1))
    }
    give Option.Some(p.slice(0, idx))
}


<<<
extension
>>>

#[inline]
proc extension(p: Path) -> Option[string] {
    let name = file_name(p)
    when name is Option.None {
        give Option.None
    }
    let s = name.unwrap()
    let dot = s.last_index_of(".")
    when dot is Option.None {
        give Option.None
    }
    let d = dot.unwrap()
    if d + 1 >= s.len {
        give Option.None
    }
    give Option.Some(s.slice(d + 1, s.len))
}


<<<
joining
>>>

#[inline]
proc join(a: Path, b: Path) -> Path {
    if a.len == 0 {
        give b
    }
    if b.len == 0 {
        give a
    }
    if a.ends_with("/") || a.ends_with("\\") {
        give a + b
    }
    give a + SEP_UNIX + b
}


<<<
normalization
>>>

#[inline]
proc normalize(p: Path) -> Path {
    let out = ""
    let i: usize = 0
    loop {
        if i >= p.len {
            break
        }
        let c = p[i]
        if c == '\\' {
            out = out + SEP_UNIX
        } else {
            out = out + c
        }
        i = i + 1
    }
    give out
}


<<<
internal helpers
>>>

#[inline]
proc last_sep_index(p: Path) -> Option[usize] {
    let i: isize = p.len as isize - 1
    loop {
        if i < 0 {
            break
        }
        let c = p[i as usize]
        if c == '/' || c == '\\' {
            give Option.Some(i as usize)
        }
        i = i - 1
    }
    give Option.None
}