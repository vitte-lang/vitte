<<<
mod.vit
std kernel memory helpers (user mapping + ELF reads)
>>>

space std/kernel/mem

<<<
imports
>>>

use std/core/types.u64
use std/core/types.u32
use std/core/types.u16
use std/core/types.u8
use std/core/types.Unit

<<<
externs
>>>

#[extern]
proc kernel_alloc_page() -> u64

#[extern]
proc kernel_map_user_page(va: u64, pa: u64) -> Unit

#[extern]
proc kernel_read_u8(base: *u8, off: u64) -> u8

#[extern]
proc kernel_read_u16(base: *u8, off: u64) -> u16

#[extern]
proc kernel_read_u32(base: *u8, off: u64) -> u32

#[extern]
proc kernel_read_u64(base: *u8, off: u64) -> u64

#[extern]
proc kernel_copy_to_user(dst_va: u64, src: *u8, off: u64, len: u64) -> Unit

#[extern]
proc kernel_fill_user(dst_va: u64, value: u8, len: u64) -> Unit

<<<
helpers
>>>

#[inline]
proc alloc_page() -> u64 {
  give kernel_alloc_page()
}

#[inline]
proc map_user_page(va: u64, pa: u64) -> Unit {
  kernel_map_user_page(va, pa)
  return
}

#[inline]
proc read_u8(base: *u8, off: u64) -> u8 {
  give kernel_read_u8(base, off)
}

#[inline]
proc read_u16(base: *u8, off: u64) -> u16 {
  give kernel_read_u16(base, off)
}

#[inline]
proc read_u32(base: *u8, off: u64) -> u32 {
  give kernel_read_u32(base, off)
}

#[inline]
proc read_u64(base: *u8, off: u64) -> u64 {
  give kernel_read_u64(base, off)
}

#[inline]
proc copy_to_user(dst_va: u64, src: *u8, off: u64, len: u64) -> Unit {
  kernel_copy_to_user(dst_va, src, off, len)
  return
}

#[inline]
proc fill_user(dst_va: u64, value: u8, len: u64) -> Unit {
  kernel_fill_user(dst_va, value, len)
  return
}
