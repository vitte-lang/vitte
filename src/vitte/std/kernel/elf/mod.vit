<<<
mod.vit
std kernel ELF loader (minimal, ELF64 little-endian)
>>>

space std/kernel/elf

<<<
imports
>>>

use std/kernel/mem as mem
use std/core/types.u64
use std/core/types.u32
use std/core/types.u16
use std/core/types.u8
use std/core/types.Unit

<<<
constants
>>>

const PT_LOAD: u32 = 1
const USER_PAGE_SIZE: u64 = 2097152

<<<
helpers
>>>

proc align_down(x: u64, a: u64) -> u64 {
  give x - (x % a)
}

proc align_up(x: u64, a: u64) -> u64 {
  let r = x % a
  if r == 0 {
    give x
  }
  give x + (a - r)
}

proc load(image: *u8, size: u64, base: u64) -> u64 {
  if size < 64 {
    give 0
  }
  if mem.read_u8(image, 0) != 127 { give 0 }
  if mem.read_u8(image, 1) != 69 { give 0 }
  if mem.read_u8(image, 2) != 76 { give 0 }
  if mem.read_u8(image, 3) != 70 { give 0 }
  if mem.read_u8(image, 4) != 2 { give 0 }
  if mem.read_u8(image, 5) != 1 { give 0 }

  let entry = mem.read_u64(image, 24)
  let phoff = mem.read_u64(image, 32)
  let phentsize = mem.read_u16(image, 54)
  let phnum = mem.read_u16(image, 56)

  let i = 0
  loop {
    if i >= phnum as u64 {
      break
    }
    let off = phoff + (i * (phentsize as u64))
    let p_type = mem.read_u32(image, off + 0)
    if p_type == PT_LOAD {
      let p_offset = mem.read_u64(image, off + 8)
      let p_vaddr = mem.read_u64(image, off + 16)
      let p_filesz = mem.read_u64(image, off + 32)
      let p_memsz = mem.read_u64(image, off + 40)
      let seg_base = base + p_vaddr
      let start = align_down(seg_base, USER_PAGE_SIZE)
      let end = align_up(seg_base + p_memsz, USER_PAGE_SIZE)

      let va = start
      loop {
        if va >= end {
          break
        }
        let pa = mem.alloc_page()
        if pa == 0 {
          give 0
        }
        mem.map_user_page(va, pa)
        va = va + USER_PAGE_SIZE
      }

      mem.copy_to_user(seg_base, image, p_offset, p_filesz)
      if p_memsz > p_filesz {
        mem.fill_user(seg_base + p_filesz, 0, p_memsz - p_filesz)
      }
    }
    i = i + 1
  }

  give base + entry
}
