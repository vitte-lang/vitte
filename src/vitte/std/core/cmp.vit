<<<
cmp.vit
std core comparison primitives
>>>

space std/core/cmp


<<<
comparison result
>>>

pick Ordering {
    Less
    Equal
    Greater
}


<<<
equality trait
>>>

form Eq[T] {
    eq: proc(self: T, other: T) -> bool
}


<<<
ordering trait
>>>

form Ord[T] {
    cmp: proc(self: T, other: T) -> Ordering
}


<<<
default helpers
>>>

#[inline]
proc is_eq[T](a: T, b: T, impl: Eq[T]) -> bool {
    give impl.eq(a, b)
}


#[inline]
proc is_ne[T](a: T, b: T, impl: Eq[T]) -> bool {
    give !impl.eq(a, b)
}


#[inline]
proc is_lt[T](a: T, b: T, impl: Ord[T]) -> bool {
    give impl.cmp(a, b) == Ordering.Less
}


#[inline]
proc is_le[T](a: T, b: T, impl: Ord[T]) -> bool {
    let o = impl.cmp(a, b)
    give o == Ordering.Less || o == Ordering.Equal
}


#[inline]
proc is_gt[T](a: T, b: T, impl: Ord[T]) -> bool {
    give impl.cmp(a, b) == Ordering.Greater
}


#[inline]
proc is_ge[T](a: T, b: T, impl: Ord[T]) -> bool {
    let o = impl.cmp(a, b)
    give o == Ordering.Greater || o == Ordering.Equal
}


<<<
ordering helpers
>>>

#[inline]
proc min[T](a: T, b: T, impl: Ord[T]) -> T {
    if impl.cmp(a, b) == Ordering.Greater {
        give b
    }
    give a
}


#[inline]
proc max[T](a: T, b: T, impl: Ord[T]) -> T {
    if impl.cmp(a, b) == Ordering.Less {
        give b
    }
    give a
}


<<<
clamp
>>>

#[inline]
proc clamp[T](value: T, low: T, high: T, impl: Ord[T]) -> T {
    if impl.cmp(value, low) == Ordering.Less {
        give low
    }
    if impl.cmp(value, high) == Ordering.Greater {
        give high
    }
    give value
}