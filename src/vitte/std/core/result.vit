<<<
result.vit
std core result type
>>>

space std/core/result


<<<
imports
>>>

use std/core/option.Option
use std/core/panic.panic


<<<
result type
>>>

pick Result[T, E] {
    Ok(value: T)
    Err(error: E)
}


<<<
constructors
>>>

#[inline]
proc ok[T, E](value: T) -> Result[T, E] {
    give Result.Ok(value)
}

#[inline]
proc err[T, E](error: E) -> Result[T, E] {
    give Result.Err(error)
}


<<<
introspection
>>>

#[inline]
proc is_ok[T, E](res: Result[T, E]) -> bool {
    when res is Result.Ok {
        give true
    }
    give false
}

#[inline]
proc is_err[T, E](res: Result[T, E]) -> bool {
    when res is Result.Err {
        give true
    }
    give false
}


<<<
unwrap
>>>

#[inline]
proc unwrap[T, E](res: Result[T, E]) -> T {
    when res is Result.Ok {
        give res.value
    }
    panic("called unwrap on Result.Err")
}

#[inline]
proc unwrap_or[T, E](res: Result[T, E], default: T) -> T {
    when res is Result.Ok {
        give res.value
    }
    give default
}


<<<
error handling
>>>

#[inline]
proc unwrap_err[T, E](res: Result[T, E]) -> E {
    when res is Result.Err {
        give res.error
    }
    panic("called unwrap_err on Result.Ok")
}


<<<
mapping
>>>

#[inline]
proc map[T, E, U](res: Result[T, E], f: proc(T) -> U) -> Result[U, E] {
    when res is Result.Ok {
        give Result.Ok(f(res.value))
    }
    give Result.Err(res.error)
}

#[inline]
proc map_err[T, E, F](res: Result[T, E], f: proc(E) -> F) -> Result[T, F] {
    when res is Result.Err {
        give Result.Err(f(res.error))
    }
    give Result.Ok(res.value)
}


<<<
and / or
>>>

#[inline]
proc and_then[T, E, U](res: Result[T, E], f: proc(T) -> Result[U, E]) -> Result[U, E] {
    when res is Result.Ok {
        give f(res.value)
    }
    give Result.Err(res.error)
}

#[inline]
proc or_else[T, E, F](res: Result[T, E], f: proc(E) -> Result[T, F]) -> Result[T, F] {
    when res is Result.Err {
        give f(res.error)
    }
    give Result.Ok(res.value)
}


<<<
conversion helpers
>>>

#[inline]
proc ok_option[T, E](res: Result[T, E]) -> Option[T] {
    when res is Result.Ok {
        give Option.Some(res.value)
    }
    give Option.None
}

#[inline]
proc err_option[T, E](res: Result[T, E]) -> Option[E] {
    when res is Result.Err {
        give Option.Some(res.error)
    }
    give Option.None
}
