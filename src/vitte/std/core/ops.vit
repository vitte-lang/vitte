<<<
ops.vit
std core operator primitives
>>>

space std/core/ops


<<<
arithmetic traits
>>>

form Add[T] {
    add: proc(self: T, rhs: T) -> T
}

form Sub[T] {
    sub: proc(self: T, rhs: T) -> T
}

form Mul[T] {
    mul: proc(self: T, rhs: T) -> T
}

form Div[T] {
    div: proc(self: T, rhs: T) -> T
}

form Rem[T] {
    rem: proc(self: T, rhs: T) -> T
}


<<<
bitwise traits
>>>

form BitAnd[T] {
    bitand: proc(self: T, rhs: T) -> T
}

form BitOr[T] {
    bitor: proc(self: T, rhs: T) -> T
}

form BitXor[T] {
    bitxor: proc(self: T, rhs: T) -> T
}

form Shl[T] {
    shl: proc(self: T, rhs: T) -> T
}

form Shr[T] {
    shr: proc(self: T, rhs: T) -> T
}


<<<
unary traits
>>>

form Neg[T] {
    neg: proc(self: T) -> T
}

form Not[T] {
    not: proc(self: T) -> bool
}


<<<
assignment-style helpers
>>>

#[inline]
proc add_assign[T](a: *T, b: T, impl: Add[T]) {
    a.* = impl.add(a.*, b)
}

#[inline]
proc sub_assign[T](a: *T, b: T, impl: Sub[T]) {
    a.* = impl.sub(a.*, b)
}

#[inline]
proc mul_assign[T](a: *T, b: T, impl: Mul[T]) {
    a.* = impl.mul(a.*, b)
}

#[inline]
proc div_assign[T](a: *T, b: T, impl: Div[T]) {
    a.* = impl.div(a.*, b)
}


<<<
boolean combinators
>>>

#[inline]
proc and(a: bool, b: bool) -> bool {
    give a && b
}

#[inline]
proc or(a: bool, b: bool) -> bool {
    give a || b
}

#[inline]
proc xor(a: bool, b: bool) -> bool {
    give (a || b) && !(a && b)
}


<<<
comparison adapters
>>>

#[inline]
proc eq[T](a: T, b: T, impl: cmp.Eq[T]) -> bool {
    give impl.eq(a, b)
}

#[inline]
proc ne[T](a: T, b: T, impl: cmp.Eq[T]) -> bool {
    give !impl.eq(a, b)
}

#[inline]
proc lt[T](a: T, b: T, impl: cmp.Ord[T]) -> bool {
    give impl.cmp(a, b) == cmp.Ordering.Less
}

#[inline]
proc gt[T](a: T, b: T, impl: cmp.Ord[T]) -> bool {
    give impl.cmp(a, b) == cmp.Ordering.Greater
}


<<<
numeric helpers
>>>

#[inline]
proc abs[T](v: T, impl: Neg[T], impl_ord: cmp.Ord[T]) -> T {
    if impl_ord.cmp(v, zero()) == cmp.Ordering.Less {
        give impl.neg(v)
    }
    give v
}