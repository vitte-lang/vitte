<<<
option.vit
std core option type
>>>

space std/core/option


<<<
option type
>>>

pick Option[T] {
    Some(value: T)
    None
}


<<<
constructors
>>>

#[inline]
proc some[T](value: T) -> Option[T] {
    give Option.Some(value)
}

#[inline]
proc none[T]() -> Option[T] {
    give Option.None
}


<<<
introspection
>>>

#[inline]
proc is_some[T](opt: Option[T]) -> bool {
    when opt is Option.Some {
        give true
    }
    give false
}

#[inline]
proc is_none[T](opt: Option[T]) -> bool {
    when opt is Option.None {
        give true
    }
    give false
}


<<<
unwrap
>>>

#[inline]
proc unwrap[T](opt: Option[T]) -> T {
    when opt is Option.Some {
        give opt.value
    }
    builtin.trap("called unwrap on Option.None")
}

#[inline]
proc unwrap_or[T](opt: Option[T], default: T) -> T {
    when opt is Option.Some {
        give opt.value
    }
    give default
}


<<<
mapping
>>>

#[inline]
proc map[T, U](opt: Option[T], f: proc(T) -> U) -> Option[U] {
    when opt is Option.Some {
        give Option.Some(f(opt.value))
    }
    give Option.None
}

#[inline]
proc map_or[T, U](opt: Option[T], default: U, f: proc(T) -> U) -> U {
    when opt is Option.Some {
        give f(opt.value)
    }
    give default
}


<<<
and / or
>>>

#[inline]
proc and_then[T, U](opt: Option[T], f: proc(T) -> Option[U]) -> Option[U] {
    when opt is Option.Some {
        give f(opt.value)
    }
    give Option.None
}

#[inline]
proc or_else[T](opt: Option[T], f: proc() -> Option[T]) -> Option[T] {
    when opt is Option.Some {
        give opt
    }
    give f()
}


<<<
comparison helpers
>>>

#[inline]
proc eq[T](a: Option[T], b: Option[T], impl: cmp.Eq[T]) -> bool {
    when a is Option.Some {
        when b is Option.Some {
            give impl.eq(a.value, b.value)
        }
        give false
    }
    when b is Option.None {
        give true
    }
    give false
}