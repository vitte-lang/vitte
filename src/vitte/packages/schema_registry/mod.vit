<<<
mod.vit
package vitte/schema_registry
>>>

space vitte/schema_registry

form SchemaRecord {
  subject: string
  version: int
  fingerprint: string
  fields: [string]
  active: bool
}

form SchemaRegistry {
  records: [SchemaRecord]
}

proc registry_new() -> SchemaRegistry {
  give SchemaRegistry([])
}

proc register(registry: SchemaRegistry, subject: string, version: int, fingerprint: string, fields: [string]) -> SchemaRegistry {
  let out: [SchemaRecord] = []
  let replaced: bool = false
  let i: int = 0

  loop {
    if i >= registry.records.len { break }
    let rec = registry.records[i]
    if rec.subject == subject && rec.version == version {
      out = out.push(SchemaRecord(subject, version, fingerprint, fields, true))
      replaced = true
    } else {
      out = out.push(rec)
    }
    i = i + 1
  }

  if !replaced {
    out = out.push(SchemaRecord(subject, version, fingerprint, fields, true))
  }

  give SchemaRegistry(out)
}

proc latest(registry: SchemaRegistry, subject: string) -> SchemaRecord {
  let best = SchemaRecord(subject, 0, "", [], false)
  let i: int = 0
  loop {
    if i >= registry.records.len { break }
    let rec = registry.records[i]
    if rec.active && rec.subject == subject && rec.version >= best.version {
      best = rec
    }
    i = i + 1
  }
  give best
}

proc get(registry: SchemaRegistry, subject: string, version: int) -> SchemaRecord {
  let i: int = 0
  loop {
    if i >= registry.records.len { break }
    let rec = registry.records[i]
    if rec.subject == subject && rec.version == version && rec.active {
      give rec
    }
    i = i + 1
  }
  give SchemaRecord(subject, version, "", [], false)
}

proc has(registry: SchemaRegistry, subject: string, version: int) -> bool {
  give get(registry, subject, version).active
}

proc deactivate(registry: SchemaRegistry, subject: string, version: int) -> SchemaRegistry {
  let out: [SchemaRecord] = []
  let i: int = 0
  loop {
    if i >= registry.records.len { break }
    let rec = registry.records[i]
    if rec.subject == subject && rec.version == version {
      out = out.push(SchemaRecord(rec.subject, rec.version, rec.fingerprint, rec.fields, false))
    } else {
      out = out.push(rec)
    }
    i = i + 1
  }
  give SchemaRegistry(out)
}

proc latest_version(registry: SchemaRegistry, subject: string) -> int {
  give latest(registry, subject).version
}

proc field_count(rec: SchemaRecord) -> int {
  give rec.fields.len
}

proc list_contains(items: [string], value: string) -> bool {
  let i: int = 0
  loop {
    if i >= items.len { break }
    if items[i] == value { give true }
    i = i + 1
  }
  give false
}

proc subjects(registry: SchemaRegistry) -> [string] {
  let out: [string] = []
  let i: int = 0
  loop {
    if i >= registry.records.len { break }
    let name = registry.records[i].subject
    if !list_contains(out, name) {
      out = out.push(name)
    }
    i = i + 1
  }
  give out
}

proc compatibility_level(base: SchemaRecord, next: SchemaRecord) -> string {
  if !base.active || !next.active { give "inactive" }
  if base.subject != next.subject { give "subject-mismatch" }
  if base.fingerprint == next.fingerprint { give "identical" }
  if next.version >= base.version && next.fields.len >= base.fields.len { give "backward-compatible" }
  give "breaking"
}

proc compatible(base: SchemaRecord, next: SchemaRecord) -> bool {
  if !base.active || !next.active { give false }
  if base.subject != next.subject { give false }
  if next.version < base.version { give false }
  give next.fields.len >= base.fields.len
}

proc diff(base: SchemaRecord, next: SchemaRecord) -> string {
  if base.subject != next.subject { give "breaking:subject" }
  if base.fingerprint == next.fingerprint { give "same" }
  if compatible(base, next) { give "compatible-change" }
  give "breaking-change"
}

proc count(registry: SchemaRegistry, subject: string) -> int {
  let n: int = 0
  let i: int = 0
  loop {
    if i >= registry.records.len { break }
    if registry.records[i].subject == subject && registry.records[i].active {
      n = n + 1
    }
    i = i + 1
  }
  give n
}

proc total_count(registry: SchemaRegistry) -> int {
  give registry.records.len
}

proc stats(registry: SchemaRegistry) -> string {
  give "records=" + total_count(registry).to_string() +
       ",subjects=" + subjects(registry).len.to_string()
}

proc ready() -> bool {
  give true
}


<<< ROLE-CONTRACT
package: vitte/schema_registry
role: Versionne et compare les schemas payload
input_contract: Subject version fingerprint fields explicites
output_contract: Latest compatible diff deterministes
boundary: Ne valide pas le payload runtime; gere uniquement le registre de schemas
>>>
