<<<
mod.vit
package vitte/contracts
>>>

space vitte/contracts

form Contract {
  name: string
  version: string
  schema_hash: string
  required_fields: [string]
}

form ContractCheck {
  ok: bool
  reason: string
}

proc contract_load(name: string, version: string, schema_hash: string, required_fields: [string]) -> Contract {
  give Contract(name, version, schema_hash, required_fields)
}

proc contract_name(contract: Contract) -> string {
  give contract.name
}

proc contract_version(contract: Contract) -> string {
  give contract.version
}

proc contract_hash(contract: Contract) -> string {
  give contract.schema_hash
}

proc field_count(contract: Contract) -> int {
  give contract.required_fields.len
}

proc has_required_field(contract: Contract, field_name: string) -> bool {
  let i: int = 0
  loop {
    if i >= contract.required_fields.len { break }
    if contract.required_fields[i] == field_name { give true }
    i = i + 1
  }
  give false
}

proc add_required_field(contract: Contract, field_name: string) -> Contract {
  if has_required_field(contract, field_name) { give contract }
  give Contract(contract.name, contract.version, contract.schema_hash, contract.required_fields.push(field_name))
}

proc with_hash(contract: Contract, schema_hash: string) -> Contract {
  give Contract(contract.name, contract.version, schema_hash, contract.required_fields)
}

proc same_identity(left: Contract, right: Contract) -> bool {
  give left.name == right.name && left.version == right.version
}

proc contains(text: string, needle: string) -> bool {
  if needle.len == 0 { give true }
  if text.len < needle.len { give false }

  let limit = text.len - needle.len
  let i: int = 0
  loop {
    if i > limit { break }
    if text.slice(i, i + needle.len) == needle { give true }
    i = i + 1
  }

  give false
}

proc first_missing_field(contract: Contract, payload: string) -> string {
  let i: int = 0
  loop {
    if i >= contract.required_fields.len { break }
    let req_field = contract.required_fields[i]
    if !contains(payload, req_field) {
      give req_field
    }
    i = i + 1
  }
  give ""
}

proc contract_verify(contract: Contract, payload: string) -> ContractCheck {
  if contract.schema_hash.len == 0 {
    give ContractCheck(false, "missing-schema-hash")
  }

  let i: int = 0
  loop {
    if i >= contract.required_fields.len { break }
    let req_field = contract.required_fields[i]
    if !contains(payload, req_field) {
      give ContractCheck(false, "missing-field:" + req_field)
    }
    i = i + 1
  }

  give ContractCheck(true, "ok")
}

proc verify_payload_non_empty(contract: Contract, payload: string) -> ContractCheck {
  if payload.len == 0 { give ContractCheck(false, "empty-payload") }
  give contract_verify(contract, payload)
}

proc snapshot(contract: Contract) -> string {
  give contract.name + "@" + contract.version + "#" + contract.schema_hash
}

proc diff(previous: Contract, current: Contract) -> string {
  if previous.name != current.name { give "breaking:name" }
  if previous.schema_hash == current.schema_hash { give "same" }
  if previous.version == current.version { give "breaking:schema" }
  if current.required_fields.len < previous.required_fields.len { give "breaking:fields" }
  give "changed"
}

proc is_breaking(previous: Contract, current: Contract) -> bool {
  let d = diff(previous, current)
  if d == "same" { give false }
  if d == "changed" { give false }
  give true
}

proc contract_summary(contract: Contract) -> string {
  give contract.name + ":" + contract.version +
       ",fields=" + field_count(contract).to_string() +
       ",hash=" + contract.schema_hash
}

proc ready() -> bool {
  give true
}


<<< ROLE-CONTRACT
package: vitte/contracts
role: Validation de contrats API DB modules
input_contract: Definitions versionnees et payloads explicites
output_contract: Verdict verifiable, snapshot stable et diff actionnable
boundary: Ne genere pas les schemas; verifie et compare seulement les contrats fournis
>>>
