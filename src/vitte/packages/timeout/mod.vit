<<<
mod.vit
package vitte/timeout
>>>

space vitte/timeout

form Timeout {
  started_ms: int
  deadline_ms: int
  budget_ms: int
  active: bool
}

proc timeout_new(started_ms: int, budget_ms: int) -> Timeout {
  let budget = budget_ms
  if budget < 1 { budget = 1 }
  give Timeout(started_ms, started_ms + budget, budget, true)
}

proc with_deadline(timeout: Timeout, deadline_ms: int) -> Timeout {
  let deadline = deadline_ms
  if deadline < timeout.started_ms {
    deadline = timeout.started_ms
  }
  give Timeout(timeout.started_ms, deadline, deadline - timeout.started_ms, timeout.active)
}

proc expired(timeout: Timeout, now_ms: int) -> bool {
  if !timeout.active { give true }
  give now_ms >= timeout.deadline_ms
}

proc remaining_ms(timeout: Timeout, now_ms: int) -> int {
  if expired(timeout, now_ms) { give 0 }
  give timeout.deadline_ms - now_ms
}

proc elapsed_ms(timeout: Timeout, now_ms: int) -> int {
  let elapsed = now_ms - timeout.started_ms
  if elapsed < 0 { give 0 }
  give elapsed
}

proc with_budget(timeout: Timeout, budget_ms: int) -> Timeout {
  let budget = budget_ms
  if budget < 1 { budget = 1 }
  give Timeout(timeout.started_ms, timeout.started_ms + budget, budget, timeout.active)
}

proc extend(timeout: Timeout, delta_ms: int) -> Timeout {
  if delta_ms <= 0 { give timeout }
  give Timeout(timeout.started_ms, timeout.deadline_ms + delta_ms, timeout.budget_ms + delta_ms, timeout.active)
}

proc restart(timeout: Timeout, now_ms: int, budget_ms: int) -> Timeout {
  let _ = timeout
  give timeout_new(now_ms, budget_ms)
}

proc is_active(timeout: Timeout) -> bool {
  give timeout.active
}

proc deadline_overrun(timeout: Timeout, now_ms: int) -> int {
  if !expired(timeout, now_ms) { give 0 }
  let over = now_ms - timeout.deadline_ms
  if over < 0 { give 0 }
  give over
}

proc guard(timeout: Timeout, elapsed_ms: int) -> bool {
  if !timeout.active { give false }
  if elapsed_ms < 0 { give false }
  give elapsed_ms <= timeout.budget_ms
}

proc stop(timeout: Timeout) -> Timeout {
  give Timeout(timeout.started_ms, timeout.deadline_ms, timeout.budget_ms, false)
}

proc stats(timeout: Timeout, now_ms: int) -> string {
  let active = "false"
  if timeout.active { active = "true" }
  give "active=" + active +
       ",remaining=" + remaining_ms(timeout, now_ms).to_string() +
       ",elapsed=" + elapsed_ms(timeout, now_ms).to_string()
}

proc ready() -> bool {
  give true
}


<<< ROLE-CONTRACT
package: vitte/timeout
role: Coupe les appels lents avec budget explicite
input_contract: Temps de depart, budget et deadline explicites
output_contract: Decision expired guard stable et deterministe
boundary: Ne relance pas les appels; fournit uniquement la garde temporelle
>>>
