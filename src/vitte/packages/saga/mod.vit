<<<
mod.vit
package vitte/saga
>>>

space vitte/saga

pick SagaState {
  Draft
  Running
  Succeeded
  Failed
  Compensated
}

form SagaStep {
  name: string
  done: bool
  compensated: bool
}

form Saga {
  id: string
  steps: [SagaStep]
  failed_at: int
  state: SagaState
}

proc saga_new(id: string) -> Saga {
  give Saga(id, [], -1, SagaState.Draft)
}

proc step_add(saga: Saga, name: string) -> Saga {
  let steps = saga.steps.push(SagaStep(name, false, false))
  give Saga(saga.id, steps, saga.failed_at, saga.state)
}

proc run(saga: Saga, fail_step: int) -> Saga {
  let out: [SagaStep] = []
  let failed_at = -1

  let i: int = 0
  loop {
    if i >= saga.steps.len { break }
    let step = saga.steps[i]

    if failed_at >= 0 {
      out = out.push(step)
      i = i + 1
      continue
    }

    if i == fail_step {
      out = out.push(SagaStep(step.name, false, false))
      failed_at = i
    } else {
      out = out.push(SagaStep(step.name, true, false))
    }

    i = i + 1
  }

  if failed_at >= 0 {
    give Saga(saga.id, out, failed_at, SagaState.Failed)
  }
  give Saga(saga.id, out, -1, SagaState.Succeeded)
}

proc compensate(saga: Saga) -> Saga {
  let out: [SagaStep] = []
  let i: int = 0
  loop {
    if i >= saga.steps.len { break }
    let step = saga.steps[i]
    if step.done {
      out = out.push(SagaStep(step.name, step.done, true))
    } else {
      out = out.push(step)
    }
    i = i + 1
  }

  if saga.state == SagaState.Failed {
    give Saga(saga.id, out, saga.failed_at, SagaState.Compensated)
  }
  give Saga(saga.id, out, saga.failed_at, saga.state)
}

proc add_steps(saga: Saga, names: [string]) -> Saga {
  let out = saga
  let i: int = 0
  loop {
    if i >= names.len { break }
    out = step_add(out, names[i])
    i = i + 1
  }
  give out
}

proc resume(saga: Saga) -> Saga {
  if saga.state == SagaState.Failed || saga.state == SagaState.Compensated {
    give run(saga, -1)
  }
  give saga
}

proc reset(saga: Saga) -> Saga {
  let out: [SagaStep] = []
  let i: int = 0
  loop {
    if i >= saga.steps.len { break }
    let step = saga.steps[i]
    out = out.push(SagaStep(step.name, false, false))
    i = i + 1
  }
  give Saga(saga.id, out, -1, SagaState.Draft)
}

proc step_count(saga: Saga) -> int {
  give saga.steps.len
}

proc done_count(saga: Saga) -> int {
  let n: int = 0
  let i: int = 0
  loop {
    if i >= saga.steps.len { break }
    if saga.steps[i].done {
      n = n + 1
    }
    i = i + 1
  }
  give n
}

proc pending_count(saga: Saga) -> int {
  let remain = step_count(saga) - done_count(saga)
  if remain < 0 { give 0 }
  give remain
}

proc compensated_count(saga: Saga) -> int {
  let n: int = 0
  let i: int = 0
  loop {
    if i >= saga.steps.len { break }
    if saga.steps[i].compensated {
      n = n + 1
    }
    i = i + 1
  }
  give n
}

proc failed_step(saga: Saga) -> string {
  if saga.failed_at < 0 || saga.failed_at >= saga.steps.len { give "" }
  give saga.steps[saga.failed_at].name
}

proc step_index(saga: Saga, name: string) -> int {
  let i: int = 0
  loop {
    if i >= saga.steps.len { break }
    if saga.steps[i].name == name { give i }
    i = i + 1
  }
  give -1
}

proc is_terminal(saga: Saga) -> bool {
  if saga.state == SagaState.Succeeded { give true }
  if saga.state == SagaState.Compensated { give true }
  give false
}

proc state_name(saga: Saga) -> string {
  when saga.state is SagaState.Draft { give "draft" }
  when saga.state is SagaState.Running { give "running" }
  when saga.state is SagaState.Succeeded { give "succeeded" }
  when saga.state is SagaState.Failed { give "failed" }
  give "compensated"
}

proc stats(saga: Saga) -> string {
  give "state=" + state_name(saga) +
       ",steps=" + step_count(saga).to_string() +
       ",done=" + done_count(saga).to_string() +
       ",compensated=" + compensated_count(saga).to_string()
}

proc ready() -> bool {
  give true
}


<<< ROLE-CONTRACT
package: vitte/saga
role: Orchestration de transactions distribuees
input_contract: Sequence de steps explicites et point de defaillance controle
output_contract: Etats run compensate deterministes et inspectables
boundary: Ne transporte pas les messages externes; orchestre seulement les transitions de saga
>>>
