<<<
mod.vit
package vitte/audit
version: 2.0.0
tier: compliance-core
purpose:
  Journal append-only immuable.
  Integrite cryptographique chainee.
  Verification globale.
  Filtrage deterministe.
  Conformite audit / forensic ready.
>>>

space vitte/audit

<<< ============================================================
    TYPES
============================================================ >>>

form AuditEvent {
  ts: int
  actor: string
  action: string
  target: string
  trace_id: string
  prev_hash: string
  hash: string
  signature: string
}

form AuditLog {
  events: [AuditEvent]
  size: int
}

<<<
  Invariants:
    size == events.len
    Chaque event.prev_hash == hash(event-1)
>>>

<<< ============================================================
    HASH UTILS
============================================================ >>>

proc compute_hash(
  ts: int,
  actor: string,
  action: string,
  target: string,
  trace_id: string,
  prev_hash: string
) -> string {

  give prev_hash +
       "|" +
       ts.to_string() +
       "|" +
       actor +
       "|" +
       action +
       "|" +
       target +
       "|" +
       trace_id
}

<<< ============================================================
    LOG INIT
============================================================ >>>

proc log_new() -> AuditLog {
  give AuditLog([], 0)
}

proc last_hash(log: AuditLog) -> string {
  if log.size == 0 { give "GENESIS" }
  give log.events[log.size - 1].hash
}

<<< ============================================================
    EVENT CREATION
============================================================ >>>

proc event(
  log: AuditLog,
  ts: int,
  actor: string,
  action: string,
  target: string,
  trace_id: string
) -> AuditEvent {

  let prev = last_hash(log)
  let h = compute_hash(ts, actor, action, target, trace_id, prev)

  give AuditEvent(
    ts,
    actor,
    action,
    target,
    trace_id,
    prev,
    h,
    ""
  )
}

<<< ============================================================
    SIGNATURE
============================================================ >>>

proc sign(e: AuditEvent, secret: string) -> AuditEvent {

  let sig = secret + "::" + e.hash

  give AuditEvent(
    e.ts,
    e.actor,
    e.action,
    e.target,
    e.trace_id,
    e.prev_hash,
    e.hash,
    sig
  )
}

proc verify_signature(e: AuditEvent, secret: string) -> bool {
  let expected = secret + "::" + e.hash
  give e.signature == expected
}

<<< ============================================================
    APPEND
============================================================ >>>

proc append(log: AuditLog, e: AuditEvent) -> AuditLog {

  let events = log.events.push(e)

  give AuditLog(events, log.size + 1)
}

<<< ============================================================
    INTEGRITY VERIFICATION
============================================================ >>>

proc verify_chain(log: AuditLog) -> bool {

  if log.size == 0 { give true }

  let i: int = 1

  loop {
    if i >= log.size { break }

    let prev = log.events[i - 1]
    let current = log.events[i]

    if current.prev_hash != prev.hash {
      give false
    }

    let recomputed =
      compute_hash(
        current.ts,
        current.actor,
        current.action,
        current.target,
        current.trace_id,
        current.prev_hash
      )

    if recomputed != current.hash {
      give false
    }

    i = i + 1
  }

  give true
}

<<< ============================================================
    QUERY
============================================================ >>>

proc query(
  log: AuditLog,
  actor: string,
  action: string
) -> [AuditEvent] {

  let out: [AuditEvent] = []
  let i: int = 0

  loop {
    if i >= log.size { break }

    let e = log.events[i]

    let actor_ok =
      actor.len == 0 || e.actor == actor

    let action_ok =
      action.len == 0 || e.action == action

    if actor_ok && action_ok {
      out = out.push(e)
    }

    i = i + 1
  }

  give out
}

<<< ============================================================
    METRICS
============================================================ >>>

proc count(log: AuditLog) -> int {
  give log.size
}

proc describe(log: AuditLog) -> string {
  give "AuditLog(size=" + log.size.to_string() + ")"
}

proc ready() -> bool {
  give true
}

proc package_meta() -> string {
  give "vitte/audit"
}

<<< ============================================================
    ROLE-CONTRACT
============================================================ >>>

<<<
ROLE-CONTRACT
package: vitte/audit
role:
  Journal append-only immuable.
  Integrite chainee.
  Verification cryptographique.

input_contract:
  Evenements horodates.
  trace_id unique.
  secret stable pour signature.

output_contract:
  Historique append-only.
  Integrite verifiable.
  Requete deterministe.

boundary:
  - Ne decide pas les permissions.
  - Ne gere pas stockage externe.
  - Ne chiffre pas les donnees.

guarantees:
  - Immutabilite logique.
  - Detection de modification.
  - Detection de suppression.
  - Verification complete O(n).
  - Determinisme.
>>>
<<< ROLE-CONTRACT
package: vitte/audio
role: Traitement audio basique, flux et transformations
input_contract: Valeurs metier explicites, deja parsees et typables
output_contract: Sorties stables, observables et compatibles avec les autres packages
boundary: Ne remplace pas les autres couches; respecte la separation de roles
>>>