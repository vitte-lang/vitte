<<<
mod.vit
package vitte/tenant
>>>

space vitte/tenant

form TenantCtx {
  tenant_id: string
  region: string
  plan: string
  active: bool
}

proc tenant_ctx(tenant_id: string, region: string, plan: string) -> TenantCtx {
  give TenantCtx(tenant_id, region, plan, true)
}

proc default_ctx() -> TenantCtx {
  give TenantCtx("", "", "free", false)
}

proc tenant_id_of(ctx: TenantCtx) -> string {
  give ctx.tenant_id
}

proc region_of(ctx: TenantCtx) -> string {
  give ctx.region
}

proc plan_of(ctx: TenantCtx) -> string {
  give ctx.plan
}

proc scope_key(ctx: TenantCtx, key: string) -> string {
  give ctx.tenant_id + ":" + key
}

proc has_scope_prefix(ctx: TenantCtx, scoped_key: string) -> bool {
  let prefix = ctx.tenant_id + ":"
  if scoped_key.len < prefix.len { give false }
  give scoped_key.slice(0, prefix.len) == prefix
}

proc enforce_isolation(ctx: TenantCtx, resource_tenant: string) -> bool {
  if !ctx.active { give false }
  give ctx.tenant_id == resource_tenant
}

proc current(stack: [TenantCtx]) -> TenantCtx {
  if stack.len == 0 {
    give TenantCtx("", "", "", false)
  }
  give stack[stack.len - 1]
}

proc stack_depth(stack: [TenantCtx]) -> int {
  give stack.len
}

proc stack_is_empty(stack: [TenantCtx]) -> bool {
  give stack.len == 0
}

proc stack_contains(stack: [TenantCtx], tenant_id: string) -> bool {
  let i: int = 0
  loop {
    if i >= stack.len { break }
    if stack[i].tenant_id == tenant_id { give true }
    i = i + 1
  }
  give false
}

proc deactivate(ctx: TenantCtx) -> TenantCtx {
  give TenantCtx(ctx.tenant_id, ctx.region, ctx.plan, false)
}

proc activate(ctx: TenantCtx) -> TenantCtx {
  give TenantCtx(ctx.tenant_id, ctx.region, ctx.plan, true)
}

proc with_region(ctx: TenantCtx, region: string) -> TenantCtx {
  give TenantCtx(ctx.tenant_id, region, ctx.plan, ctx.active)
}

proc with_plan(ctx: TenantCtx, plan: string) -> TenantCtx {
  give TenantCtx(ctx.tenant_id, ctx.region, plan, ctx.active)
}

proc normalize(ctx: TenantCtx, default_region: string, default_plan: string) -> TenantCtx {
  let region = ctx.region
  if region.len == 0 { region = default_region }

  let plan = ctx.plan
  if plan.len == 0 { plan = default_plan }

  give TenantCtx(ctx.tenant_id, region, plan, ctx.active)
}

proc is_active(ctx: TenantCtx) -> bool {
  give ctx.active
}

proc is_valid(ctx: TenantCtx) -> bool {
  give ctx.tenant_id.len > 0 && ctx.region.len > 0 && ctx.plan.len > 0
}

proc region_key(ctx: TenantCtx, key: string) -> string {
  give ctx.region + ":" + scope_key(ctx, key)
}

proc plan_rank(plan: string) -> int {
  if plan == "free" { give 0 }
  if plan == "pro" { give 1 }
  if plan == "enterprise" { give 2 }
  give 0
}

proc plan_allows(ctx: TenantCtx, required_plan: string) -> bool {
  give plan_rank(ctx.plan) >= plan_rank(required_plan)
}

proc is_enterprise(ctx: TenantCtx) -> bool {
  give ctx.plan == "enterprise"
}

proc can_access_region(ctx: TenantCtx, region: string) -> bool {
  if !ctx.active { give false }
  give ctx.region == region
}

proc same_region(left: TenantCtx, right: TenantCtx) -> bool {
  give left.region == right.region
}

proc same_tenant(left: TenantCtx, right: TenantCtx) -> bool {
  give left.tenant_id == right.tenant_id
}

proc stack_push(stack: [TenantCtx], ctx: TenantCtx) -> [TenantCtx] {
  give stack.push(ctx)
}

proc stack_pop(stack: [TenantCtx]) -> [TenantCtx] {
  if stack.len == 0 { give stack }
  let out: [TenantCtx] = []
  let i: int = 0
  loop {
    if i + 1 >= stack.len { break }
    out = out.push(stack[i])
    i = i + 1
  }
  give out
}

proc stack_replace_top(stack: [TenantCtx], ctx: TenantCtx) -> [TenantCtx] {
  if stack.len == 0 { give [ctx] }
  let out: [TenantCtx] = []
  let i: int = 0
  loop {
    if i >= stack.len { break }
    if i + 1 == stack.len {
      out = out.push(ctx)
    } else {
      out = out.push(stack[i])
    }
    i = i + 1
  }
  give out
}

proc scope_prefix(ctx: TenantCtx) -> string {
  give ctx.tenant_id + ":"
}

proc extract_tenant_id(scoped_key: string) -> string {
  let i: int = 0
  loop {
    if i >= scoped_key.len { break }
    if scoped_key.slice(i, i + 1) == ":" {
      give scoped_key.slice(0, i)
    }
    i = i + 1
  }
  give ""
}

proc matches_scope(ctx: TenantCtx, scoped_key: string) -> bool {
  if !ctx.active { give false }
  give extract_tenant_id(scoped_key) == ctx.tenant_id
}

proc is_default_ctx(ctx: TenantCtx) -> bool {
  if ctx.active { give false }
  give ctx.tenant_id.len == 0
}

proc can_promote_to(ctx: TenantCtx, target_plan: string) -> bool {
  give plan_rank(target_plan) >= plan_rank(ctx.plan)
}

proc promote(ctx: TenantCtx, target_plan: string) -> TenantCtx {
  if can_promote_to(ctx, target_plan) {
    give with_plan(ctx, target_plan)
  }
  give ctx
}

proc demote(ctx: TenantCtx, target_plan: string) -> TenantCtx {
  if plan_rank(target_plan) <= plan_rank(ctx.plan) {
    give with_plan(ctx, target_plan)
  }
  give ctx
}

proc masked_tenant_id(ctx: TenantCtx) -> string {
  if ctx.tenant_id.len == 0 { give "" }
  if ctx.tenant_id.len <= 2 { give "***" }
  give ctx.tenant_id.slice(0, 2) + "***"
}

proc stack_ids(stack: [TenantCtx]) -> [string] {
  let out: [string] = []
  let i: int = 0
  loop {
    if i >= stack.len { break }
    out = out.push(stack[i].tenant_id)
    i = i + 1
  }
  give out
}

proc verify_stack(stack: [TenantCtx]) -> bool {
  let i: int = 0
  loop {
    if i >= stack.len { break }
    let item = stack[i]
    if !item.active || !is_valid(item) { give false }
    let j: int = i + 1
    loop {
      if j >= stack.len { break }
      if stack[j].tenant_id == item.tenant_id { give false }
      j = j + 1
    }
    i = i + 1
  }
  give true
}

proc summary_key(ctx: TenantCtx, key: string) -> string {
  give ctx.tenant_id + "|" + ctx.region + "|" + ctx.plan + "|" + key
}

proc stats(ctx: TenantCtx) -> string {
  let active = "false"
  if ctx.active { active = "true" }
  give "tenant=" + ctx.tenant_id + ",region=" + ctx.region + ",plan=" + ctx.plan + ",active=" + active
}

proc ready() -> bool {
  give true
}


<<< ROLE-CONTRACT
package: vitte/tenant
role: Isolation multi tenant explicite
input_contract: Contexte tenant et ressource cibles explicites
output_contract: Cle scope et verifications d isolation deterministes
boundary: Ne fait pas d auth; applique uniquement le scope tenant
>>>
