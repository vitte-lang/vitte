<<<
mod.vit
package vitte/slab
>>>

space vitte/slab


form Slot {
  id: int
  value: string
  used: bool
}

form Slab {
  slots: [Slot]
}

proc slab_new() -> Slab {
  give Slab([])
}

proc contains_id(s: Slab, id: int) -> bool {
  give id >= 0 && id < s.slots.len
}

proc find_free(s: Slab) -> int {
  let i: int = 0
  loop {
    if i >= s.slots.len { break }
    if !s.slots[i].used { give i }
    i = i + 1
  }
  give -1
}

proc insert(s: Slab, value: string) -> Slab {
  let free_id = find_free(s)
  if free_id >= 0 {
    let out: [Slot] = []
    let i: int = 0
    loop {
      if i >= s.slots.len { break }
      if i == free_id {
        out = out.push(Slot(i, value, true))
      } else {
        out = out.push(s.slots[i])
      }
      i = i + 1
    }
    give Slab(out)
  }
  let id = s.slots.len
  give Slab(s.slots.push(Slot(id, value, true)))
}

proc put_at(s: Slab, id: int, value: string) -> Slab {
  if !contains_id(s, id) { give s }
  let out: [Slot] = []
  let i: int = 0
  loop {
    if i >= s.slots.len { break }
    if i == id {
      out = out.push(Slot(id, value, true))
    } else {
      out = out.push(s.slots[i])
    }
    i = i + 1
  }
  give Slab(out)
}

proc touch(s: Slab, id: int) -> Slab {
  if !contains_id(s, id) { give s }
  if !s.slots[id].used { give s }
  give put_at(s, id, s.slots[id].value)
}

proc get(s: Slab, id: int) -> string {
  if !contains_id(s, id) { give "" }
  if !s.slots[id].used { give "" }
  give s.slots[id].value
}

proc remove(s: Slab, id: int) -> Slab {
  if !contains_id(s, id) { give s }
  let out: [Slot] = []
  let i: int = 0
  loop {
    if i >= s.slots.len { break }
    if i == id {
      out = out.push(Slot(i, "", false))
    } else {
      out = out.push(s.slots[i])
    }
    i = i + 1
  }
  give Slab(out)
}

proc compact(s: Slab) -> Slab {
  let out: [Slot] = []
  let i: int = 0
  let next_id: int = 0
  loop {
    if i >= s.slots.len { break }
    if s.slots[i].used {
      out = out.push(Slot(next_id, s.slots[i].value, true))
      next_id = next_id + 1
    }
    i = i + 1
  }
  give Slab(out)
}

proc rebuild_ids(s: Slab) -> Slab {
  let out: [Slot] = []
  let i: int = 0
  loop {
    if i >= s.slots.len { break }
    out = out.push(Slot(i, s.slots[i].value, s.slots[i].used))
    i = i + 1
  }
  give Slab(out)
}

proc used_count(s: Slab) -> int {
  let c: int = 0
  let i: int = 0
  loop {
    if i >= s.slots.len { break }
    if s.slots[i].used { c = c + 1 }
    i = i + 1
  }
  give c
}

proc free_count(s: Slab) -> int {
  give s.slots.len - used_count(s)
}

proc keys(s: Slab) -> [int] {
  let out: [int] = []
  let i: int = 0
  loop {
    if i >= s.slots.len { break }
    if s.slots[i].used { out = out.push(s.slots[i].id) }
    i = i + 1
  }
  give out
}

proc values(s: Slab) -> [string] {
  let out: [string] = []
  let i: int = 0
  loop {
    if i >= s.slots.len { break }
    if s.slots[i].used { out = out.push(s.slots[i].value) }
    i = i + 1
  }
  give out
}

proc first_used_id(s: Slab) -> int {
  let i: int = 0
  loop {
    if i >= s.slots.len { break }
    if s.slots[i].used { give s.slots[i].id }
    i = i + 1
  }
  give -1
}

proc last_used_id(s: Slab) -> int {
  let i: int = s.slots.len - 1
  loop {
    if i < 0 { break }
    if s.slots[i].used { give s.slots[i].id }
    i = i - 1
  }
  give -1
}

proc filter_values_prefix(s: Slab, prefix: string) -> [string] {
  let out: [string] = []
  let i: int = 0
  loop {
    if i >= s.slots.len { break }
    if s.slots[i].used {
      let v = s.slots[i].value
      if prefix.len <= v.len && v.slice(0, prefix.len) == prefix {
        out = out.push(v)
      }
    }
    i = i + 1
  }
  give out
}

proc stats(s: Slab) -> string {
  give "used=" + used_count(s).to_string() +
       ",free=" + free_count(s).to_string() +
       ",cap=" + s.slots.len.to_string()
}

proc ready() -> bool {
  give true
}

proc package_meta() -> string {
  give "vitte/slab"
}

<<< ROLE-CONTRACT
package: vitte/slab
role: Allocation d emplacements indexes en memoire
input_contract: Valeurs serialisables en slot
output_contract: Index stables et acces O(1) simplifie
boundary: Pas de persistence disque
>>>
