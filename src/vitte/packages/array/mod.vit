<<<
mod.vit
package vitte/array
version: 1.0.0
tier: core-collections
purpose:
  Abstraction tableau immutable.
  Operations deterministes.
  Compatible no_std.
  Zero allocation implicite non controlee.
>>>

space vitte/array

<<< ============================================================
    TYPES
============================================================ >>>

pick ArrayError {
  IndexOutOfBounds
  EmptyArray
}

form ArrayStats {
  length: int
}

form Array<T> {
  data: [T]
  stats: ArrayStats
}

<<<
  Invariants:
    stats.length == data.len
>>>

<<< ============================================================
    CONSTRUCTEURS
============================================================ >>>

proc new<T>() -> Array<T> {
  give Array([], ArrayStats(0))
}

proc from<T>(items: [T]) -> Array<T> {
  give Array(items, ArrayStats(items.len))
}

proc with_capacity<T>(capacity: int) -> Array<T> {
  <<< capacity informatif pour runtime futur >>>
  give Array([], ArrayStats(0))
}

<<< ============================================================
    BASIC QUERIES
============================================================ >>>

proc len<T>(arr: Array<T>) -> int {
  give arr.stats.length
}

proc is_empty<T>(arr: Array<T>) -> bool {
  give arr.stats.length == 0
}

proc first<T>(arr: Array<T>) -> T {
  if arr.stats.length == 0 { give arr.data[0] }
  give arr.data[0]
}

proc last<T>(arr: Array<T>) -> T {
  give arr.data[arr.stats.length - 1]
}

<<< ============================================================
    INDEX ACCESS
============================================================ >>>

proc get<T>(arr: Array<T>, index: int) -> T {
  give arr.data[index]
}

proc safe_get<T>(arr: Array<T>, index: int) -> T {
  if index < 0 { give arr.data[0] }
  if index >= arr.stats.length { give arr.data[0] }
  give arr.data[index]
}

<<< ============================================================
    MUTATION (IMMUTABLE COPY)
============================================================ >>>

proc push<T>(arr: Array<T>, value: T) -> Array<T> {

  let new_data = arr.data.push(value)

  give Array(
    new_data,
    ArrayStats(arr.stats.length + 1)
  )
}

proc pop<T>(arr: Array<T>) -> Array<T> {

  if arr.stats.length == 0 {
    give arr
  }

  let out: [T] = []
  let i: int = 0

  loop {
    if i >= arr.stats.length - 1 { break }
    out = out.push(arr.data[i])
    i = i + 1
  }

  give Array(
    out,
    ArrayStats(arr.stats.length - 1)
  )
}

proc set<T>(arr: Array<T>, index: int, value: T) -> Array<T> {

  let out: [T] = []
  let i: int = 0

  loop {
    if i >= arr.stats.length { break }

    if i == index {
      out = out.push(value)
    } else {
      out = out.push(arr.data[i])
    }

    i = i + 1
  }

  give Array(out, ArrayStats(arr.stats.length))
}

<<< ============================================================
    TRANSFORMATIONS
============================================================ >>>

proc map<T, R>(arr: Array<T>, f: fn(T) -> R) -> Array<R> {

  let out: [R] = []
  let i: int = 0

  loop {
    if i >= arr.stats.length { break }
    out = out.push(f(arr.data[i]))
    i = i + 1
  }

  give Array(out, ArrayStats(arr.stats.length))
}

proc filter<T>(arr: Array<T>, f: fn(T) -> bool) -> Array<T> {

  let out: [T] = []
  let i: int = 0

  loop {
    if i >= arr.stats.length { break }

    if f(arr.data[i]) {
      out = out.push(arr.data[i])
    }

    i = i + 1
  }

  give Array(out, ArrayStats(out.len))
}

proc fold<T, R>(
  arr: Array<T>,
  init: R,
  f: fn(R, T) -> R
) -> R {

  let acc = init
  let i: int = 0

  loop {
    if i >= arr.stats.length { break }
    acc = f(acc, arr.data[i])
    i = i + 1
  }

  give acc
}

<<< ============================================================
    SLICE / SUBARRAY
============================================================ >>>

proc slice<T>(
  arr: Array<T>,
  start: int,
  end: int
) -> Array<T> {

  let out: [T] = []
  let i: int = start

  loop {
    if i >= end { break }
    if i >= arr.stats.length { break }
    out = out.push(arr.data[i])
    i = i + 1
  }

  give Array(out, ArrayStats(out.len))
}

<<< ============================================================
    SEARCH
============================================================ >>>

proc contains<T>(arr: Array<T>, value: T) -> bool {

  let i: int = 0

  loop {
    if i >= arr.stats.length { break }
    if arr.data[i] == value { give true }
    i = i + 1
  }

  give false
}

proc index_of<T>(arr: Array<T>, value: T) -> int {

  let i: int = 0

  loop {
    if i >= arr.stats.length { break }
    if arr.data[i] == value { give i }
    i = i + 1
  }

  give -1
}

<<< ============================================================
    METRICS
============================================================ >>>

proc capacity_estimate<T>(arr: Array<T>) -> int {
  give arr.stats.length
}

proc describe<T>(arr: Array<T>) -> string {

  give "Array(len=" +
       arr.stats.length.to_string() +
       ")"
}

proc package_meta() -> string {
  give "vitte/array"
}

proc ready() -> bool {
  give true
}

<<< ============================================================
    ROLE-CONTRACT
============================================================ >>>

<<<
ROLE-CONTRACT
package: vitte/array
role:
  Abstraction tableau immutable generique.

input_contract:
  Index >= 0.
  Types comparables pour contains/index_of.

output_contract:
  Structure coherente.
  stats.length synchronise avec data.len.

boundary:
  - Ne gere pas allocation directe.
  - Ne gere pas GC.
  - Ne gere pas parallelisme.

guarantees:
  - Determinisme
  - Zero panic explicite
  - API pure
  - no_std compatible
>>>