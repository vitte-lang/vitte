<<<
mod.vit
package vitte/jobs
>>>

space vitte/jobs

pick JobState {
  Pending
  Inflight
  Done
  Failed
}

form Job {
  id: int
  payload: string
  attempts: int
  state: JobState
}

form JobQueue {
  next_id: int
  max_attempts: int
  pending: [Job]
  inflight: [Job]
  done: [Job]
  dlq: [Job]
}

proc queue_new(max_attempts: int) -> JobQueue {
  let max = max_attempts
  if max < 1 { max = 1 }
  give JobQueue(0, max, [], [], [], [])
}

proc enqueue(queue: JobQueue, payload: string) -> JobQueue {
  let job = Job(queue.next_id, payload, 0, JobState.Pending)
  let pending = queue.pending.push(job)
  give JobQueue(queue.next_id + 1, queue.max_attempts, pending, queue.inflight, queue.done, queue.dlq)
}

proc drop_first(jobs: [Job]) -> [Job] {
  let out: [Job] = []
  let i: int = 1
  loop {
    if i >= jobs.len { break }
    out = out.push(jobs[i])
    i = i + 1
  }
  give out
}

proc dequeue(queue: JobQueue) -> JobQueue {
  if queue.pending.len == 0 { give queue }
  let first = queue.pending[0]
  let pending = drop_first(queue.pending)
  let inflight = queue.inflight.push(Job(first.id, first.payload, first.attempts, JobState.Inflight))
  give JobQueue(queue.next_id, queue.max_attempts, pending, inflight, queue.done, queue.dlq)
}

proc ack(queue: JobQueue, job_id: int) -> JobQueue {
  let inflight: [Job] = []
  let done = queue.done
  let i: int = 0
  loop {
    if i >= queue.inflight.len { break }
    let job = queue.inflight[i]
    if job.id == job_id {
      done = done.push(Job(job.id, job.payload, job.attempts, JobState.Done))
    } else {
      inflight = inflight.push(job)
    }
    i = i + 1
  }
  give JobQueue(queue.next_id, queue.max_attempts, queue.pending, inflight, done, queue.dlq)
}

proc nack(queue: JobQueue, job_id: int) -> JobQueue {
  let inflight: [Job] = []
  let pending = queue.pending
  let dlq = queue.dlq

  let i: int = 0
  loop {
    if i >= queue.inflight.len { break }
    let job = queue.inflight[i]
    if job.id == job_id {
      let attempts = job.attempts + 1
      if attempts >= queue.max_attempts {
        dlq = dlq.push(Job(job.id, job.payload, attempts, JobState.Failed))
      } else {
        pending = pending.push(Job(job.id, job.payload, attempts, JobState.Pending))
      }
    } else {
      inflight = inflight.push(job)
    }
    i = i + 1
  }

  give JobQueue(queue.next_id, queue.max_attempts, pending, inflight, queue.done, dlq)
}

proc dead_letter(queue: JobQueue) -> [Job] {
  give queue.dlq
}

proc pending_count(queue: JobQueue) -> int {
  give queue.pending.len
}

proc inflight_count(queue: JobQueue) -> int {
  give queue.inflight.len
}

proc done_count(queue: JobQueue) -> int {
  give queue.done.len
}

proc dlq_count(queue: JobQueue) -> int {
  give queue.dlq.len
}

proc total_count(queue: JobQueue) -> int {
  give pending_count(queue) + inflight_count(queue) + done_count(queue) + dlq_count(queue)
}

proc has_pending(queue: JobQueue) -> bool {
  give pending_count(queue) > 0
}

proc has_inflight(queue: JobQueue) -> bool {
  give inflight_count(queue) > 0
}

proc has_done(queue: JobQueue) -> bool {
  give done_count(queue) > 0
}

proc has_dlq(queue: JobQueue) -> bool {
  give dlq_count(queue) > 0
}

proc next_pending_id(queue: JobQueue) -> int {
  if queue.pending.len == 0 { give -1 }
  give queue.pending[0].id
}

proc attempts_of(queue: JobQueue, job_id: int) -> int {
  let i: int = 0
  loop {
    if i >= queue.pending.len { break }
    if queue.pending[i].id == job_id { give queue.pending[i].attempts }
    i = i + 1
  }

  i = 0
  loop {
    if i >= queue.inflight.len { break }
    if queue.inflight[i].id == job_id { give queue.inflight[i].attempts }
    i = i + 1
  }

  i = 0
  loop {
    if i >= queue.done.len { break }
    if queue.done[i].id == job_id { give queue.done[i].attempts }
    i = i + 1
  }

  i = 0
  loop {
    if i >= queue.dlq.len { break }
    if queue.dlq[i].id == job_id { give queue.dlq[i].attempts }
    i = i + 1
  }

  give -1
}

proc state_of(queue: JobQueue, job_id: int) -> string {
  let i: int = 0
  loop {
    if i >= queue.pending.len { break }
    if queue.pending[i].id == job_id { give "pending" }
    i = i + 1
  }

  i = 0
  loop {
    if i >= queue.inflight.len { break }
    if queue.inflight[i].id == job_id { give "inflight" }
    i = i + 1
  }

  i = 0
  loop {
    if i >= queue.done.len { break }
    if queue.done[i].id == job_id { give "done" }
    i = i + 1
  }

  i = 0
  loop {
    if i >= queue.dlq.len { break }
    if queue.dlq[i].id == job_id { give "failed" }
    i = i + 1
  }

  give "missing"
}

proc requeue_dead(queue: JobQueue, job_id: int) -> JobQueue {
  let dlq: [Job] = []
  let pending = queue.pending

  let i: int = 0
  loop {
    if i >= queue.dlq.len { break }
    let job = queue.dlq[i]
    if job.id == job_id {
      if job.attempts < queue.max_attempts {
        pending = pending.push(Job(job.id, job.payload, job.attempts, JobState.Pending))
      } else {
        dlq = dlq.push(job)
      }
    } else {
      dlq = dlq.push(job)
    }
    i = i + 1
  }

  give JobQueue(queue.next_id, queue.max_attempts, pending, queue.inflight, queue.done, dlq)
}

proc clear_done(queue: JobQueue) -> JobQueue {
  give JobQueue(queue.next_id, queue.max_attempts, queue.pending, queue.inflight, [], queue.dlq)
}

proc clear_dlq(queue: JobQueue) -> JobQueue {
  give JobQueue(queue.next_id, queue.max_attempts, queue.pending, queue.inflight, queue.done, [])
}

proc stats(queue: JobQueue) -> string {
  give "pending=" + pending_count(queue).to_string() +
       ",inflight=" + inflight_count(queue).to_string() +
       ",done=" + done_count(queue).to_string() +
       ",dlq=" + dlq_count(queue).to_string()
}

proc ready() -> bool {
  give true
}


<<< ROLE-CONTRACT
package: vitte/jobs
role: File de jobs robuste avec reprise et dead letter
input_contract: Jobs explicites avec tentative et max_attempts definis
output_contract: Transitions d etat deterministes pending inflight done dlq
boundary: Ne remplace pas l orchestrateur externe; gere seulement le cycle de traitement
>>>
