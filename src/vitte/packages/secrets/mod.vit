<<<
mod.vit
package vitte/secrets
>>>

space vitte/secrets

form SecretItem {
  key: string
  value: string
}

form SecretStore {
  env: [SecretItem]
  files: [SecretItem]
}

proc store_new() -> SecretStore {
  give SecretStore([], [])
}

proc put_env(store: SecretStore, key: string, value: string) -> SecretStore {
  let env = store.env.push(SecretItem(key, value))
  give SecretStore(env, store.files)
}

proc put_file(store: SecretStore, path: string, value: string) -> SecretStore {
  let files = store.files.push(SecretItem(path, value))
  give SecretStore(store.env, files)
}

proc find(items: [SecretItem], key: string) -> string {
  let i: int = 0
  loop {
    if i >= items.len { break }
    if items[i].key == key { give items[i].value }
    i = i + 1
  }
  give ""
}

proc from_env(store: SecretStore, key: string) -> string {
  give find(store.env, key)
}

proc from_file(store: SecretStore, path: string) -> string {
  give find(store.files, path)
}

proc resolve(store: SecretStore, env_key: string, file_path: string, fallback: string) -> string {
  let env_value = from_env(store, env_key)
  if env_value.len > 0 { give env_value }

  let file_value = from_file(store, file_path)
  if file_value.len > 0 { give file_value }

  give fallback
}

proc mask(secret: string) -> string {
  if secret.len <= 2 { give "**" }
  give "****" + secret.slice(secret.len - 2, secret.len)
}

proc is_valid(secret: string) -> bool {
  if secret.len < 8 { give false }
  let i: int = 0
  loop {
    if i >= secret.len { break }
    if secret.slice(i, i + 1) == " " { give false }
    i = i + 1
  }
  give true
}

proc ready() -> bool {
  give true
}


<<< ROLE-CONTRACT
package: vitte/secrets
role: Gestion des secrets hors code source
input_contract: Sources env fichier et fallback explicites
output_contract: Resolution deterministe secret masque et validation simple
boundary: Ne fait pas de crypto avancee; orchestre seulement la resolution des secrets
>>>
