vitte 1.0

space vitte/packages/abi

<<<
  ABI — Application Binary Interface Layer

  Objectifs :
  - Décrire layout mémoire des types
  - Définir conventions d’appel
  - Gérer alignement / padding
  - Fournir introspection layout
  - Support multi-architecture (x86_64, aarch64, riscv64, i386)

  Utilisé par :
  - backend codegen
  - linker
  - runtime FFI
  - JIT
>>>

pull core/mem as mem
pull core/math as math
pull core/result as result
pull core/text as text

share all

<<< ============================================================
    ARCHITECTURES
============================================================ >>>

pick Arch {
  case X86_64
  case AARCH64
  case RISCV64
  case I386
}

<<< ============================================================
    CALLING CONVENTIONS
============================================================ >>>

pick CallingConv {
  case SystemV
  case Win64
  case CDecl
  case FastCall
  case StdCall
}

<<< ============================================================
    TYPE CLASSIFICATION (ABI LOWERING)
============================================================ >>>

pick AbiKind {
  case Integer
  case Float
  case Vector
  case Pointer
  case Aggregate
  case Void
}

<<< ============================================================
    TYPE LAYOUT DESCRIPTION
============================================================ >>>

form FieldLayout {
  name    as Text
  offset  as U64
  size    as U64
  align   as U64
}

form TypeLayout {
  size        as U64
  align       as U64
  abi_kind    as AbiKind
  fields      as List<FieldLayout>
}

<<< ============================================================
    ABI ERROR
============================================================ >>>

pick AbiError {
  case InvalidType
  case UnsupportedArch
  case UnsupportedConvention
}

<<< ============================================================
    ALIGNMENT HELPERS
============================================================ >>>

proc align_to(value as U64, alignment as U64) gives U64 {
  give ((value + alignment - 1) / alignment) * alignment
}

proc max_align(a as U64, b as U64) gives U64 {
  if a > b { give a }
  give b
}

<<< ============================================================
    PRIMITIVE LAYOUT
============================================================ >>>

proc primitive_layout(size as U64,
                      align as U64,
                      kind as AbiKind)
  gives TypeLayout {

  give TypeLayout(
    size = size,
    align = align,
    abi_kind = kind,
    fields = []
  )
}

proc integer_layout(bits as U64) gives TypeLayout {
  give primitive_layout(bits / 8, bits / 8, AbiKind.Integer)
}

proc float_layout(bits as U64) gives TypeLayout {
  give primitive_layout(bits / 8, bits / 8, AbiKind.Float)
}

proc pointer_layout() gives TypeLayout {
  give primitive_layout(8, 8, AbiKind.Pointer)
}

<<< ============================================================
    STRUCT LAYOUT COMPUTATION
============================================================ >>>

proc struct_layout(fields as List<TypeLayout>)
  gives TypeLayout {

  make offset as U64 = 0
  make max_alignment as U64 = 1
  make layouts as List<FieldLayout> = []

  make index as U64 = 0

  each field in fields {

    make aligned_offset as U64 =
      align_to(offset, field.align)

    layouts.push(
      FieldLayout(
        name = text.join("field_", index.to_text()),
        offset = aligned_offset,
        size = field.size,
        align = field.align
      )
    )

    offset = aligned_offset + field.size
    max_alignment = max_align(max_alignment, field.align)
    index = index + 1
  }

  make final_size as U64 =
    align_to(offset, max_alignment)

  give TypeLayout(
    size = final_size,
    align = max_alignment,
    abi_kind = AbiKind.Aggregate,
    fields = layouts
  )
}

<<< ============================================================
    FUNCTION SIGNATURE ABI
============================================================ >>>

form FunctionAbi {
  arch        as Arch
  convention  as CallingConv
  return_type as TypeLayout
  params      as List<TypeLayout>
}

form ParamLocation {
  in_register as Bool
  register_id as U64
  stack_offset as U64
}

form LoweredSignature {
  return_via_memory as Bool
  param_locations as List<ParamLocation>
  stack_size as U64
}

<<< ============================================================
    LOWERING — SYSTEM V x86_64 (simplified)
============================================================ >>>

proc lower_sysv_x86_64(sig as FunctionAbi)
  gives LoweredSignature {

  <<< Simplification :
      - 6 registres entiers : RDI, RSI, RDX, RCX, R8, R9
      - Au-delà → stack
  >>>

  make reg_count as U64 = 6
  make used_regs as U64 = 0
  make stack_offset as U64 = 0
  make locations as List<ParamLocation> = []

  each param in sig.params {

    if param.abi_kind == AbiKind.Integer
       and used_regs < reg_count {

      locations.push(
        ParamLocation(
          in_register = true,
          register_id = used_regs,
          stack_offset = 0
        )
      )

      used_regs = used_regs + 1
    }
    otherwise {

      stack_offset =
        align_to(stack_offset, param.align)

      locations.push(
        ParamLocation(
          in_register = false,
          register_id = 0,
          stack_offset = stack_offset
        )
      )

      stack_offset =
        stack_offset + param.size
    }
  }

  make return_mem as Bool =
    sig.return_type.size > 16

  give LoweredSignature(
    return_via_memory = return_mem,
    param_locations = locations,
    stack_size = stack_offset
  )
}

<<< ============================================================
    GENERIC LOWERING ENTRY
============================================================ >>>

proc lower(sig as FunctionAbi)
  gives result.Result<LoweredSignature, AbiError> {

  select sig.arch {

    case Arch.X86_64 {

      if sig.convention == CallingConv.SystemV {
        give result.Ok(lower_sysv_x86_64(sig))
      }

      give result.Err(AbiError.UnsupportedConvention)
    }

    otherwise {
      give result.Err(AbiError.UnsupportedArch)
    }
  }
}

<<< ============================================================
    FFI BRIDGE HELPERS
============================================================ >>>

proc can_pass_in_register(layout as TypeLayout) gives Bool {
  if layout.abi_kind == AbiKind.Integer { give true }
  if layout.abi_kind == AbiKind.Pointer { give true }
  give false
}

proc is_aggregate(layout as TypeLayout) gives Bool {
  give layout.abi_kind == AbiKind.Aggregate
}

<<< ============================================================
    DEBUG / INTROSPECTION
============================================================ >>>

proc describe_layout(layout as TypeLayout) gives Text {

  make s as Text =
    text.join("size=", layout.size.to_text())

  s = text.join(s,
        text.join(" align=", layout.align.to_text()))

  give s
}
<<< ROLE-CONTRACT
package: vitte/abi
owner: @vitte/abi
stability: stable
since: 2.0.0
deprecated_in: -
role: Contrat ABI: conventions d appel et frontiere binaire
input_contract: Valeurs metier explicites, deja parsees et typables
output_contract: Sorties stables, observables et compatibles avec les autres packages
boundary: Ne remplace pas les autres couches; respecte la separation de roles
>>>
