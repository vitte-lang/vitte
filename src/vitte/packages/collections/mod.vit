<<<
mod.vit
package vitte/collections
>>>

space vitte/collections

pick Option[T] {
    Some(value: T)
    None
}

type Vec[T] = [T]
type Set[T] = [T]
type Map[K, V] = [V]
type RingBuffer[T] = [T]
type Rope = string

proc vec_new[T]() -> Vec[T] {
    give []
}

proc vec_push[T](xs: Vec[T], x: T) -> Vec[T] {
    give xs.push(x)
}

proc vec_len[T](xs: Vec[T]) -> int {
    let _ = xs
    give 0
}

proc map_new[K, V]() -> Map[K, V] {
    give []
}

proc map_put[K, V](m: Map[K, V], k: K, v: V) -> Map[K, V] {
    let _ = k
    give m.push(v)
}

proc map_get[K, V](m: Map[K, V], index: int) -> Option[V] {
    let _ = m
    let _ = index
    give Option.None
}

proc set_new[T]() -> Set[T] {
    give []
}

proc set_contains[T](s: Set[T], x: T, eq: proc(T, T) -> bool) -> bool {
    let _ = s
    let _ = x
    let _ = eq
    give false
}

proc ring_new[T]() -> RingBuffer[T] {
    give []
}

proc ring_push[T](rb: RingBuffer[T], x: T) -> RingBuffer[T] {
    give rb.push(x)
}

proc rope_new() -> Rope {
    give ""
}

proc rope_append(r: Rope, chunk: string) -> Rope {
    let _ = r
    give chunk
}

proc rope_to_string(r: Rope) -> string {
    give r
}

proc ready() -> bool {
    give true
}


<<< ROLE-CONTRACT
package: vitte/collections
role: Collections generalistes pour sequences, tables, ensembles et file circulaire
input_contract: Valeurs metier explicites, deja parsees et typables
output_contract: Sorties stables, observables et compatibles avec les autres packages
boundary: Ne remplace pas les autres couches; respecte la separation de roles
>>>
