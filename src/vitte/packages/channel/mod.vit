<<<
mod.vit
package vitte/channel
>>>

space vitte/channel

share all

pick ChannelMode {
  Bounded
  Unbounded
  Broadcast
}

form Channel {
  mode: ChannelMode
  capacity: int
  queue: [string]
  dropped: int
  subscribers: int
  closed: bool
}

proc channel_bounded(capacity: int) -> Channel {
  let cap = capacity
  if cap <= 0 { cap = 1 }
  give Channel(ChannelMode.Bounded, cap, [], 0, 1, false)
}

proc channel_unbounded() -> Channel {
  give Channel(ChannelMode.Unbounded, 0, [], 0, 1, false)
}

proc channel_broadcast() -> Channel {
  give Channel(ChannelMode.Broadcast, 0, [], 0, 0, false)
}

proc drop_first(queue: [string]) -> [string] {
  if queue.len <= 1 { give [] }

  let out: [string] = []
  let i: int = 1
  loop {
    if i >= queue.len { break }
    out = out.push(queue[i])
    i = i + 1
  }
  give out
}

proc is_empty(c: Channel) -> bool {
  give c.queue.len == 0
}

proc is_closed(c: Channel) -> bool {
  give c.closed
}

proc len(c: Channel) -> int {
  give c.queue.len
}

proc dropped(c: Channel) -> int {
  give c.dropped
}

proc dropped_count(c: Channel) -> int {
  give c.dropped
}

proc subscribers(c: Channel) -> int {
  give c.subscribers
}

proc subscribe(c: Channel) -> Channel {
  when c.mode is ChannelMode.Broadcast {
    give Channel(c.mode, c.capacity, c.queue, c.dropped, c.subscribers + 1, c.closed)
  }
  give c
}

proc unsubscribe(c: Channel) -> Channel {
  when c.mode is ChannelMode.Broadcast {
    let s = c.subscribers - 1
    if s < 0 { s = 0 }
    give Channel(c.mode, c.capacity, c.queue, c.dropped, s, c.closed)
  }
  give c
}

proc can_send(c: Channel) -> bool {
  give !c.closed
}

proc send(c: Channel, message: string) -> Channel {
  if c.closed { give c }

  let queue = c.queue
  let dropped = c.dropped

  when c.mode is ChannelMode.Bounded {
    if c.capacity > 0 && queue.len >= c.capacity {
      queue = drop_first(queue)
      dropped = dropped + 1
    }
  }

  when c.mode is ChannelMode.Broadcast {
    if c.subscribers == 0 { give c }
  }

  queue = queue.push(message)
  give Channel(c.mode, c.capacity, queue, dropped, c.subscribers, c.closed)
}

proc peek(c: Channel) -> string {
  if c.queue.len == 0 { give "" }
  give c.queue[0]
}

proc pop(c: Channel) -> Channel {
  if c.queue.len == 0 { give c }
  give Channel(c.mode, c.capacity, drop_first(c.queue), c.dropped, c.subscribers, c.closed)
}

proc close(c: Channel) -> Channel {
  give Channel(c.mode, c.capacity, c.queue, c.dropped, c.subscribers, true)
}

proc ready() -> bool {
  give true
}

proc stats(c: Channel) -> string {
  give "mode=" + c.mode.to_string() +
       ";len=" + c.queue.len.to_string() +
       ";dropped=" + c.dropped.to_string() +
       ";subs=" + c.subscribers.to_string() +
       ";closed=" + c.closed.to_string()
}

proc package_meta() -> string {
  give "vitte/channel"
}

<<< ROLE-CONTRACT
package: vitte/channel
owner: @vitte/channel
stability: stable
since: 3.0.0
deprecated_in: -
role: Communication concurrente via canaux et files immuables
input_contract: Messages texte et etats Channel explicites
output_contract: Etats deterministes, observables et interop compatibles
boundary: Abstraction pure sans scheduling/threading system
>>>
