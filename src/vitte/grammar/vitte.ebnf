<<< ========================================================= ) ( Vitte 1.0 — Grammar (surface syntax) ) ( ========================================================= >>>

program ::= WS? { toplevel WS? } ;

<<< ——————————————————— ) ( Top-level ) ( ——————————————————— >>>

toplevel ::= space_decl | pull_decl | share_decl | type_decl | proc_decl | entry_decl | comment
;

space_decl ::= “space” WS1 module_path ;
pull_decl ::= “pull” WS1 module_path [ WS1 “as” WS1 ident ] ;
share_decl ::= “share” WS1 ( “all” | ident_list ) ;

module_path ::= ident { “/” ident } ;
ident_list ::= ident { WS? “,” WS? ident } ;

<<< ——————————————————— ) ( Comments ) ( ——————————————————— >>>

comment ::= zone_comment ;

zone_comment ::= “<<<” WS? [ ident ] WS?
zone_body
“>>>” ;

zone_body ::= { ~“>>>” } ;

<<< ——————————————————— ) ( Attributes ) ( ——————————————————— >>>

attribute ::= “#[” ident “]” ;

<<< ——————————————————— ) ( Types ) ( ——————————————————— >>>

type_decl ::= form_decl | pick_decl ;

form_decl ::= “form” WS1 ident WS?
{ field_decl WS? }
“.end” ;

field_decl ::= “field” WS1 ident WS1 “as” WS1 type_expr ;

pick_decl ::= “pick” WS1 ident WS?
{ case_decl WS? }
“.end” ;

case_decl ::= “case” WS1 ident
[ “(” WS? case_payload WS? “)” ] ;

case_payload ::= case_field { WS? “,” WS? case_field } ;
case_field ::= ident WS1 “as” WS1 type_expr ;

<<< ——————————————————— ) ( Procedures ) ( ——————————————————— >>>

proc_decl ::= { attribute WS? }
“proc” WS1 ident
“(” WS? param_list? WS? “)”
WS?
block ;

param_list ::= param { WS? “,” WS? param } ;
param ::= ident ;

<<< ——————————————————— ) ( Entry point ) ( ——————————————————— >>>

entry_decl ::= “entry” WS1 ident
WS1 “at” WS1 module_path
WS?
block ;

<<< ——————————————————— ) ( Block ) ( ——————————————————— >>>

block ::= block_short ;

block_short ::= “{” WS? { stmt WS? } “}” ;

<<< ——————————————————— ) ( Statements ) ( ——————————————————— >>>

stmt ::= make_stmt | set_stmt | give_stmt | emit_stmt | if_stmt | select_stmt | return_stmt | expr_stmt
;

make_stmt ::= “make” WS1 ident
[ WS1 “as” WS1 type_expr ]
WS? “=” WS? expr ;

set_stmt ::= “set” WS1 ident
WS? “=” WS? expr ;

give_stmt ::= “give” WS1 expr ;
emit_stmt ::= “emit” WS1 expr ;
return_stmt ::= “return” [ WS1 expr ] ;

if_stmt ::= “if” WS1 expr WS?
block
[ WS? “otherwise” WS?
block ] ;

select_stmt ::= “select” WS1 expr WS?
{ when_stmt WS? }
[ WS? “otherwise” WS?
block ] ;

when_stmt ::= “when” WS1 pattern WS?
block ;

<<< ——————————————————— ) ( Expressions ) ( ——————————————————— >>>

expr ::= unary_expr { WS? bin_op WS? unary_expr } ;

unary_expr ::= “not” WS1 unary_expr | primary ;

primary ::= literal | call_expr | call_no_paren | ctor_expr | ident | “(” WS? expr WS? “)”
;

call_no_paren ::= ident WS1 expr ;

call_expr ::= primary “(” WS? arg_list? WS? “)” ;
arg_list ::= expr { WS? “,” WS? expr } ;

ctor_expr ::= type_expr “(” WS? arg_list? WS? “)” ;

bin_op ::= “+” | “-” | “*” | “/” | “==” | “!=” | “<” | “<=” | “>” | “>=” | “and” | “or”
;

<<< ——————————————————— ) ( Patterns ) ( ——————————————————— >>>

pattern ::= ident | type_expr “(” WS? pattern_args? WS? “)” ;

pattern_args ::= pattern { WS? “,” WS? pattern } ;

<<< ——————————————————— ) ( Types ) ( ——————————————————— >>>

type_expr ::= ident | ident “[” WS? type_expr { WS? “,” WS? type_expr } WS? “]” | “bool” | “string” | “int”
;

<<< ——————————————————— ) ( Literals ) ( ——————————————————— >>>

literal ::= bool_lit | int_lit | string_lit | list_lit ;

list_lit ::= “[” WS? arg_list? WS? “]” ;

bool_lit ::= “true” | “false” ;

int_lit ::= [ “-” ] DIGIT { DIGIT }
[ (“u8” | “u16” | “u32” | “u64” | “i8” | “i16” | “i32” | “i64”) ] ;

string_lit ::= “"” { string_char } “"” | raw_string_lit ;
string_char ::= “\"” | “\\\” | ~“"” ;
raw_string_lit ::= “"""” { raw_string_char } “"""” ;
raw_string_char ::= ~“"""” ;

<<< ——————————————————— ) ( Lexical ) ( ——————————————————— >>>

ident ::= (LETTER | “”)
{ LETTER | DIGIT | “” } ;

WS ::= { “ “ | “\t” | NEWLINE } ;
WS1 ::= ( “ “ | “\t” | NEWLINE )
{ “ “ | “\t” | NEWLINE } ;

NEWLINE ::= “\n” | “\r\n” ;

LETTER ::= “a”…“z” | “A”…“Z” ;
DIGIT ::= “0”…“9” ;
