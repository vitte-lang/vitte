module sema.pipeline.sema_pipeline;

use sema.core.sema_result::SemaResult;
use sema.core.sema_context::SemaContext;
use sema.integration.sema_providers::SemaProviders;
use sema.pipeline.sema_pass::SemaPass;

/// Simple, ordered list of passes.
pub struct SemaPipeline<P: SemaProviders> {
    passes: Array<Box<dyn SemaPass<P>>>,
}

impl<P: SemaProviders> SemaPipeline<P> {
    pub fn new() -> SemaPipeline<P> {
        SemaPipeline { passes: Array::new() }
    }

    pub fn push(&mut self, pass: Box<dyn SemaPass<P>>) {
        self.passes.push(pass);
    }

    pub fn run(&self, ctx: &mut SemaContext<P>) -> SemaResult<()> {
        let mut i: usize = 0;
        while i < self.passes.len() {
            let pass = &self.passes[i];
            pass.run(ctx)?;
            i = i + 1;
        }
        Ok(())
    }
}
