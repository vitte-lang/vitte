# plugins/fs_vfs/api/dir/walk.vitte
# WalkDir (optional)
# Blocks use `.end` only.
#
# A dependency-light recursive directory walker for the VFS plugin.
#
# Design:
# - No collections required: caller provides a stack buffer.
# - Uses ReadDir from `plugins.fs_vfs.api.dir.read_dir`.
# - Returns status codes:
#   - 0  : OK (out params written)
#   - 1  : End
#   - <0 : Error
#
# Notes:
# - This is a "best effort" walker.
# - Path joining is naive ("/") until path module is wired.
# - Backends should fill DirEntry.path when possible.

mod plugins.fs_vfs.api.dir.walk

pub const WD_OK: i32 = 0
pub const WD_END: i32 = 1
pub const WD_ERR: i32 = -1

# -----------------------------------------------------------------------------
# Options
# -----------------------------------------------------------------------------

pub struct WalkOptions
  # Maximum recursion depth.
  # 0 means: only entries in the root directory.
  max_depth: u32

  # Whether to yield directories as entries.
  yield_dirs: bool

  # Whether to yield files as entries.
  yield_files: bool

  # Whether to follow symlinks.
  # (Only matters when a backend can classify Symlink.)
  follow_symlinks: bool

  # Whether to include the root directory itself as the first yielded item.
  include_root: bool
.end

pub fn defaults() -> WalkOptions
  ret WalkOptions(
    max_depth: 64,
    yield_dirs: true,
    yield_files: true,
    follow_symlinks: false,
    include_root: false,
  )
.end

# -----------------------------------------------------------------------------
# Stack frame
# -----------------------------------------------------------------------------

pub struct WalkFrame
  # Directory iterator for this frame
  rd: plugins.fs_vfs.api.dir.read_dir.ReadDir

  # Directory path associated to rd
  dir_path: str

  # Current depth of this frame
  depth: u32

  # Whether this frame is open
  open: bool
.end

pub fn frame_empty(vfs: plugins.fs_vfs.api.types.Vfs) -> WalkFrame
  ret WalkFrame(
    rd: plugins.fs_vfs.api.dir.read_dir.read_dir_invalid(vfs),
    dir_path: "",
    depth: 0,
    open: false,
  )
.end

# -----------------------------------------------------------------------------
# Walker state
# -----------------------------------------------------------------------------

pub struct WalkDir
  vfs: plugins.fs_vfs.api.types.Vfs
  opts: WalkOptions

  root: str

  # stack buffer provided by caller
  frames_ptr: *WalkFrame
  frames_len: usize
  frames_cap: usize

  # internal state
  started: bool
  done: bool
.end

pub fn invalid(vfs: plugins.fs_vfs.api.types.Vfs) -> WalkDir
  ret WalkDir(
    vfs: vfs,
    opts: defaults(),
    root: "",
    frames_ptr: 0,
    frames_len: 0,
    frames_cap: 0,
    started: false,
    done: true,
  )
.end

# -----------------------------------------------------------------------------
# Helpers
# -----------------------------------------------------------------------------

pub fn error_set(out_err: *plugins.fs_vfs.api.types.Error, kind: plugins.fs_vfs.api.types.ErrorKind, code: i32, msg: str) -> ()
  if out_err == 0
    ret ()
  .end
  out_err^.kind = kind
  out_err^.code = code
  out_err^.message = msg
  ret ()
.end

pub fn error_clear(out_err: *plugins.fs_vfs.api.types.Error) -> ()
  if out_err == 0
    ret ()
  .end
  out_err^.kind = plugins.fs_vfs.api.types.ErrorKind.Other
  out_err^.code = 0
  out_err^.message = ""
  ret ()
.end

# Naive path join: base + "/" + name.
# If base is empty, returns name.
pub fn join_path(base: str, name: str) -> str
  if base == ""
    ret name
  .end
  # avoid double slash
  # (no robust normalization here)
  if base.ends_with("/")
    ret base + name
  .end
  ret base + "/" + name
.end

pub fn is_dir_entry_dir(e: plugins.fs_vfs.api.dir.read_dir.DirEntry) -> bool
  ret e.file_type == plugins.fs_vfs.api.types.FileType.Dir
.end

pub fn is_dir_entry_symlink(e: plugins.fs_vfs.api.dir.read_dir.DirEntry) -> bool
  ret e.file_type == plugins.fs_vfs.api.types.FileType.Symlink
.end

# -----------------------------------------------------------------------------
# Lifecycle
# -----------------------------------------------------------------------------

# Initialize a walker.
#
# Caller must supply a stack buffer `frames_ptr` with capacity `frames_cap`.
#
# Returns:
# - 0 on success
# - <0 on error
pub fn open(
  vfs: plugins.fs_vfs.api.types.Vfs,
  root: str,
  opts: WalkOptions,
  frames_ptr: *WalkFrame,
  frames_cap: usize,
  out: *WalkDir,
  out_err: *plugins.fs_vfs.api.types.Error,
) -> i32
  error_clear(out_err)

  if out == 0
    error_set(out_err, plugins.fs_vfs.api.types.ErrorKind.InvalidInput, -20, "walk.open: out is null")
    ret -20
  .end

  if frames_ptr == 0 || frames_cap == 0
    error_set(out_err, plugins.fs_vfs.api.types.ErrorKind.InvalidInput, -21, "walk.open: frames buffer missing")
    out^ = invalid(vfs)
    ret -21
  .end

  out^.vfs = vfs
  out^.opts = opts
  out^.root = root
  out^.frames_ptr = frames_ptr
  out^.frames_cap = frames_cap
  out^.frames_len = 0
  out^.started = false
  out^.done = false

  # Pre-open root dir as the first frame.
  let rd: plugins.fs_vfs.api.dir.read_dir.ReadDir = plugins.fs_vfs.api.dir.read_dir.read_dir_invalid(vfs)
  let rc = plugins.fs_vfs.api.dir.read_dir.open(vfs, root, &rd, out_err)
  if rc != plugins.fs_vfs.api.dir.read_dir.RD_OK
    out^.done = true
    ret rc
  .end

  # push frame 0
  (out^.frames_ptr + 0)^.rd = rd
  (out^.frames_ptr + 0)^.dir_path = root
  (out^.frames_ptr + 0)^.depth = 0
  (out^.frames_ptr + 0)^.open = true
  out^.frames_len = 1

  ret WD_OK
.end

# Close walker and all opened ReadDir handles.
pub fn close(w: *WalkDir) -> ()
  if w == 0
    ret ()
  .end

  if w^.frames_ptr != 0
    let i: usize = 0
    loop
      if i >= w^.frames_len
        break
      .end
      let f = w^.frames_ptr + i
      if f^.open
        plugins.fs_vfs.api.dir.read_dir.close(&f^.rd)
        f^.open = false
      .end
      i = i + 1
    .end
  .end

  w^.done = true
  w^.frames_len = 0
  ret ()
.end

# -----------------------------------------------------------------------------
# Iteration
# -----------------------------------------------------------------------------

# Pop one frame (closing its ReadDir).
pub fn pop_frame(w: *WalkDir) -> ()
  if w^.frames_len == 0
    ret ()
  .end

  let idx = w^.frames_len - 1
  let f = w^.frames_ptr + idx
  if f^.open
    plugins.fs_vfs.api.dir.read_dir.close(&f^.rd)
    f^.open = false
  .end

  w^.frames_len = idx
  ret ()
.end

# Push a new frame for directory `path` at `depth`.
# Returns 0 on success, <0 on error.
pub fn push_dir(w: *WalkDir, path: str, depth: u32, out_err: *plugins.fs_vfs.api.types.Error) -> i32
  if w^.frames_len >= w^.frames_cap
    error_set(out_err, plugins.fs_vfs.api.types.ErrorKind.InvalidInput, -30, "walk.push: stack overflow")
    ret -30
  .end

  let rd: plugins.fs_vfs.api.dir.read_dir.ReadDir = plugins.fs_vfs.api.dir.read_dir.read_dir_invalid(w^.vfs)
  let rc = plugins.fs_vfs.api.dir.read_dir.open(w^.vfs, path, &rd, out_err)
  if rc != plugins.fs_vfs.api.dir.read_dir.RD_OK
    ret rc
  .end

  let idx = w^.frames_len
  let f = w^.frames_ptr + idx
  f^.rd = rd
  f^.dir_path = path
  f^.depth = depth
  f^.open = true
  w^.frames_len = idx + 1

  ret WD_OK
.end

# Next entry in a depth-first traversal.
#
# Outputs:
# - out_entry: yielded entry
# - out_depth: depth of yielded entry (root entries are depth 0, children depth 1, ...)
#
# Returns:
# - 0 ok
# - 1 end
# - <0 error
pub fn next(
  w: *WalkDir,
  out_entry: *plugins.fs_vfs.api.dir.read_dir.DirEntry,
  out_depth: *u32,
  out_err: *plugins.fs_vfs.api.types.Error,
) -> i32
  error_clear(out_err)

  if w == 0
    error_set(out_err, plugins.fs_vfs.api.types.ErrorKind.InvalidInput, -40, "walk.next: w is null")
    ret -40
  .end
  if out_entry == 0
    error_set(out_err, plugins.fs_vfs.api.types.ErrorKind.InvalidInput, -41, "walk.next: out_entry is null")
    ret -41
  .end
  if out_depth == 0
    error_set(out_err, plugins.fs_vfs.api.types.ErrorKind.InvalidInput, -42, "walk.next: out_depth is null")
    ret -42
  .end

  if w^.done
    ret WD_END
  .end

  # Optionally yield root itself once.
  if !w^.started
    w^.started = true
    if w^.opts.include_root
      # synthesize a root DirEntry
      out_entry^.name = w^.root
      out_entry^.path = w^.root
      out_entry^.file_type = plugins.fs_vfs.api.types.FileType.Dir
      out_entry^.inode = 0
      out_depth^ = 0
      # do not recurse here; frames already prepared
      if !w^.opts.yield_dirs
        # skip yielding; continue walking
        # fallthrough into DFS loop
      .end
      if w^.opts.yield_dirs
        ret WD_OK
      .end
    .end
  .end

  # Depth-first traversal: work on top frame.
  loop
    if w^.frames_len == 0
      w^.done = true
      ret WD_END
    .end

    let top_idx = w^.frames_len - 1
    let f = w^.frames_ptr + top_idx

    # Pull next entry from current directory
    let e: plugins.fs_vfs.api.dir.read_dir.DirEntry = plugins.fs_vfs.api.dir.read_dir.dir_entry_empty()
    let rc = plugins.fs_vfs.api.dir.read_dir.next(&f^.rd, &e, out_err)

    if rc == plugins.fs_vfs.api.dir.read_dir.RD_END
      # finished this directory
      pop_frame(w)
      continue
    .end

    if rc != plugins.fs_vfs.api.dir.read_dir.RD_OK
      # error
      ret rc
    .end

    # Determine full path for child
    let full: str = e.path
    if full == ""
      full = join_path(f^.dir_path, e.name)
    .end

    # Decide recursion
    let is_dir = is_dir_entry_dir(e)
    let is_sym = is_dir_entry_symlink(e)

    let can_recurse = false
    if is_dir
      can_recurse = true
    .end
    if is_sym && w^.opts.follow_symlinks
      # If backend marks symlink, recursion would require resolving to dir.
      # We keep this as best-effort (host/backends can set file_type=Dir if resolved).
      can_recurse = true
    .end

    # Depth for children relative to root
    let child_depth = f^.depth

    # Should we push the directory before yielding?
    # DFS pre-order for directories: yield entry, then descend.

    # Yield decision
    if is_dir || (is_sym && w^.opts.follow_symlinks)
      # Directory-like
      if w^.opts.yield_dirs
        out_entry^.name = e.name
        out_entry^.path = full
        out_entry^.file_type = e.file_type
        out_entry^.inode = e.inode
        out_depth^ = child_depth

        # Push child directory if allowed by max_depth
        if can_recurse
          if child_depth < w^.opts.max_depth
            # child directory frame depth = child_depth + 1 for its entries
            let prc = push_dir(w, full, child_depth + 1, out_err)
            # If push fails, keep yielding the dir but do not recurse.
            # Errors are non-fatal here unless you want strict behavior.
            if prc != WD_OK
              # best-effort: ignore recursion; clear error
              error_clear(out_err)
            .end
          .end
        .end

        ret WD_OK
      .end

      # Not yielding directories; still potentially recurse
      if can_recurse
        if child_depth < w^.opts.max_depth
          let prc = push_dir(w, full, child_depth + 1, out_err)
          if prc != WD_OK
            # ignore recursion
            error_clear(out_err)
          .end
        .end
      .end

      continue
    .end

    # File-like entry
    if w^.opts.yield_files
      out_entry^.name = e.name
      out_entry^.path = full
      out_entry^.file_type = e.file_type
      out_entry^.inode = e.inode
      out_depth^ = child_depth
      ret WD_OK
    .end

    # Skip files
    continue
  .end
.end

# Convenience: count all yielded entries.
pub fn count_all(
  vfs: plugins.fs_vfs.api.types.Vfs,
  root: str,
  opts: WalkOptions,
  frames_ptr: *WalkFrame,
  frames_cap: usize,
  out_err: *plugins.fs_vfs.api.types.Error,
) -> i64
  let w: WalkDir = invalid(vfs)
  let rc = open(vfs, root, opts, frames_ptr, frames_cap, &w, out_err)
  if rc != WD_OK
    ret -1
  .end

  let n: i64 = 0
  let e: plugins.fs_vfs.api.dir.read_dir.DirEntry = plugins.fs_vfs.api.dir.read_dir.dir_entry_empty()
  let d: u32 = 0

  loop
    let r = next(&w, &e, &d, out_err)
    if r == WD_END
      break
    .end
    if r != WD_OK
      close(&w)
      ret -1
    .end
    n = n + 1
  .end

  close(&w)
  ret n
.end

.end
