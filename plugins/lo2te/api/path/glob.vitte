# plugins/fs_vfs/api/path/glob.vitte
# Glob patterns (optional)
# Blocks use `.end` only.
#
# This module provides a portable glob matcher for VFS paths.
#
# Supported syntax (ASCII-oriented, no allocation required):
# - `*`  : matches any sequence (within a segment, does not cross path sep)
# - `?`  : matches any single character (within a segment)
# - `[abc]` / `[a-z]` : character class (ranges supported)
# - `[!abc]` or `[^abc]` : negated character class
# - `\`  : escape next character (treat as literal)
# - `{a,b,c}` : brace alternation (optional)
# - `**` : globstar (optional, path mode only) matches 0+ segments
#
# Notes:
# - Matching is byte-based; case folding is ASCII-only.
# - No normalization ("..", ".") is performed; caller can normalize separately.
# - Designed to be usable in sandboxes; no filesystem access here.
#
# Status conventions:
# - 0 OK
# - 2 InvalidPattern
# - 3 Unsupported
# - <0 Error

mod plugins.fs_vfs.api.path.glob

pub const GLOB_OK: i32 = 0
pub const GLOB_INVALID: i32 = 2
pub const GLOB_UNSUPPORTED: i32 = 3
pub const GLOB_ERR: i32 = -1

# -----------------------------------------------------------------------------
# Error helpers
# -----------------------------------------------------------------------------

pub fn error_set(out_err: *plugins.fs_vfs.api.types.Error, kind: plugins.fs_vfs.api.types.ErrorKind, code: i32, msg: str) -> ()
  if out_err == 0
    ret ()
  .end
  out_err^.kind = kind
  out_err^.code = code
  out_err^.message = msg
  ret ()
.end

pub fn error_clear(out_err: *plugins.fs_vfs.api.types.Error) -> ()
  if out_err == 0
    ret ()
  .end
  out_err^.kind = plugins.fs_vfs.api.types.ErrorKind.Other
  out_err^.code = 0
  out_err^.message = ""
  ret ()
.end

# -----------------------------------------------------------------------------
# Options
# -----------------------------------------------------------------------------

pub struct GlobOptions
  # Path separator. Use '/' for portable VFS paths.
  sep: u8

  # If true, treat pattern as path-aware (segment rules + globstar).
  path_mode: bool

  # If true, enable `**` segment (globstar) in path_mode.
  allow_globstar: bool

  # If true, enable `{a,b}` brace alternation.
  allow_brace: bool

  # If true, enable `[a-z]` character classes.
  allow_class: bool

  # If false, match case-insensitively (ASCII-only folding).
  case_sensitive: bool

  # If true, treat leading '.' as special (like many shells):
  # wildcards won't match '.' unless explicitly present.
  dot_special: bool
.end

pub fn defaults() -> GlobOptions
  ret GlobOptions(
    sep: 0x2F, # '/'
    path_mode: true,
    allow_globstar: true,
    allow_brace: true,
    allow_class: true,
    case_sensitive: true,
    dot_special: true,
  )
.end

pub fn opts_segment_only() -> GlobOptions
  ret GlobOptions(
    sep: 0x2F,
    path_mode: false,
    allow_globstar: false,
    allow_brace: true,
    allow_class: true,
    case_sensitive: true,
    dot_special: false,
  )
.end

# -----------------------------------------------------------------------------
# Public API
# -----------------------------------------------------------------------------

# Match a full path string.
# If opts.path_mode is true: wildcards do not cross separators.
# If opts.path_mode is false: '*' and '?' can match any byte.
#
# Returns:
# - true if match
# - false otherwise

pub fn is_match(pattern: str, text: str, opts: GlobOptions, out_err: *plugins.fs_vfs.api.types.Error) -> bool
  error_clear(out_err)

  # Quick validation for bracket/brace balance (best-effort).
  let vrc = validate_pattern(pattern, opts, out_err)
  if vrc != GLOB_OK
    ret false
  .end

  if opts.path_mode
    ret __match_path(pattern, 0, text, 0, opts, out_err)
  .end

  ret __match_segment(pattern, 0, pattern.len(), text, 0, text.len(), opts, out_err)
.end

# Validate pattern (balanced brackets/braces, no premature end escapes).
# Returns 0 OK, 2 InvalidPattern.

pub fn validate_pattern(pattern: str, opts: GlobOptions, out_err: *plugins.fs_vfs.api.types.Error) -> i32
  error_clear(out_err)

  let i: usize = 0
  let brace_depth: i32 = 0
  let in_class: bool = false

  loop
    if i >= pattern.len()
      break
    .end

    let c: u8 = pattern.byte_at(i)

    if c == 0x5C # '\\'
      # escape: must have next char
      if i + 1 >= pattern.len()
        error_set(out_err, plugins.fs_vfs.api.types.ErrorKind.InvalidInput, GLOB_INVALID, "glob: trailing escape")
        ret GLOB_INVALID
      .end
      i = i + 2
      continue
    .end

    if in_class
      if c == 0x5D # ']'
        in_class = false
      .end
      i = i + 1
      continue
    .end

    if c == 0x5B # '['
      if !opts.allow_class
        error_set(out_err, plugins.fs_vfs.api.types.ErrorKind.Unsupported, GLOB_UNSUPPORTED, "glob: char class disabled")
        ret GLOB_UNSUPPORTED
      .end
      in_class = true
      i = i + 1
      continue
    .end

    if c == 0x7B # '{'
      if opts.allow_brace
        brace_depth = brace_depth + 1
      .end
      i = i + 1
      continue
    .end

    if c == 0x7D # '}'
      if opts.allow_brace
        brace_depth = brace_depth - 1
        if brace_depth < 0
          error_set(out_err, plugins.fs_vfs.api.types.ErrorKind.InvalidInput, GLOB_INVALID, "glob: unmatched '}'")
          ret GLOB_INVALID
        .end
      .end
      i = i + 1
      continue
    .end

    i = i + 1
  .end

  if in_class
    error_set(out_err, plugins.fs_vfs.api.types.ErrorKind.InvalidInput, GLOB_INVALID, "glob: unterminated '['")
    ret GLOB_INVALID
  .end

  if opts.allow_brace && brace_depth != 0
    error_set(out_err, plugins.fs_vfs.api.types.ErrorKind.InvalidInput, GLOB_INVALID, "glob: unterminated '{'")
    ret GLOB_INVALID
  .end

  ret GLOB_OK
.end

# -----------------------------------------------------------------------------
# Internal helpers: ASCII folding, separators
# -----------------------------------------------------------------------------

pub fn __is_sep(c: u8, opts: GlobOptions) -> bool
  if !opts.path_mode
    ret false
  .end
  ret c == opts.sep
.end

pub fn __to_lower_ascii(b: u8) -> u8
  if b >= 0x41 && b <= 0x5A
    ret b + 0x20
  .end
  ret b
.end

pub fn __eq_byte(a: u8, b: u8, opts: GlobOptions) -> bool
  if opts.case_sensitive
    ret a == b
  .end
  ret __to_lower_ascii(a) == __to_lower_ascii(b)
.end

pub fn __is_dot(c: u8) -> bool
  ret c == 0x2E
.end

# If dot_special: in a segment, a leading '.' only matches '.' literally.
# This means that if text segment begins with '.', then pattern must also begin
# with '.' (or escape '.') to match.

pub fn __dot_guard(pattern: str, p0: usize, p1: usize, text: str, t0: usize, t1: usize, opts: GlobOptions) -> bool
  if !opts.dot_special
    ret true
  .end
  if t0 >= t1
    ret true
  .end

  if !__is_dot(text.byte_at(t0))
    ret true
  .end

  # if pattern segment starts with '.' literal or escaped '.' then ok.
  if p0 >= p1
    ret false
  .end

  let c: u8 = pattern.byte_at(p0)
  if c == 0x2E
    ret true
  .end

  if c == 0x5C
    if p0 + 1 < p1
      if pattern.byte_at(p0 + 1) == 0x2E
        ret true
      .end
    .end
  .end

  ret false
.end

# -----------------------------------------------------------------------------
# Internal: segment matching (no separators crossing)
# -----------------------------------------------------------------------------

# Match pattern[p0..p1) against text[t0..t1).
#
# Wildcards:
# - '*' matches 0+ chars (not sep in path_mode)
# - '?' matches 1 char (not sep in path_mode)
# - classes and braces handled if enabled

pub fn __match_segment(
  pattern: str,
  p0: usize,
  p1: usize,
  text: str,
  t0: usize,
  t1: usize,
  opts: GlobOptions,
  out_err: *plugins.fs_vfs.api.types.Error,
) -> bool
  # dot guard
  if !__dot_guard(pattern, p0, p1, text, t0, t1, opts)
    ret false
  .end

  ret __match_segment_at(pattern, p0, p1, text, t0, t1, p0, t0, opts, out_err)
.end

# Internal recursive matcher with absolute bounds.
# p and t are current indices.

pub fn __match_segment_at(
  pattern: str,
  p0: usize,
  p1: usize,
  text: str,
  t0: usize,
  t1: usize,
  p: usize,
  t: usize,
  opts: GlobOptions,
  out_err: *plugins.fs_vfs.api.types.Error,
) -> bool
  loop
    if p >= p1
      ret t >= t1
    .end

    let pc: u8 = pattern.byte_at(p)

    # Escape
    if pc == 0x5C
      if p + 1 >= p1
        error_set(out_err, plugins.fs_vfs.api.types.ErrorKind.InvalidInput, GLOB_INVALID, "glob: trailing escape")
        ret false
      .end

      let lit: u8 = pattern.byte_at(p + 1)
      if t >= t1
        ret false
      .end
      let tc: u8 = text.byte_at(t)
      if __is_sep(tc, opts)
        # within a segment matcher, we should not see sep, but be defensive
        ret false
      .end
      if !__eq_byte(lit, tc, opts)
        ret false
      .end

      p = p + 2
      t = t + 1
      continue
    .end

    # Brace alternation
    if pc == 0x7B && opts.allow_brace
      # parse {alt1,alt2,...}
      let endb: usize = 0
      let rc = __find_matching_brace(pattern, p, p1, &endb)
      if rc != 0
        error_set(out_err, plugins.fs_vfs.api.types.ErrorKind.InvalidInput, GLOB_INVALID, "glob: unterminated '{'")
        ret false
      .end

      # Try each alternative by splicing: alt + rest
      # No allocation: we match alt then continue with rest.
      ret __match_brace_alts(pattern, p, endb, p1, text, t0, t1, t, opts, out_err)
    .end

    # Character class
    if pc == 0x5B && opts.allow_class
      if t >= t1
        ret false
      .end

      let tc: u8 = text.byte_at(t)
      if __is_sep(tc, opts)
        ret false
      .end

      let nextp: usize = 0
      let ok = __match_class(pattern, p, p1, tc, &nextp, opts, out_err)
      if !ok
        ret false
      .end

      p = nextp
      t = t + 1
      continue
    .end

    # '?' wildcard
    if pc == 0x3F
      if t >= t1
        ret false
      .end

      let tc: u8 = text.byte_at(t)
      if __is_sep(tc, opts)
        ret false
      .end

      p = p + 1
      t = t + 1
      continue
    .end

    # '*' wildcard
    if pc == 0x2A
      # collapse consecutive '*'
      let pp = p
      loop
        if pp < p1 && pattern.byte_at(pp) == 0x2A
          pp = pp + 1
          continue
        .end
        break
      .end

      # If '*' at end => match rest of segment (up to sep)
      if pp >= p1
        # In segment mode, consume everything
        ret true
      .end

      # Try all possible consumptions (greedy/backtracking)
      let tt: usize = t
      loop
        # Try match remaining pattern from pp with current tt
        if __match_segment_at(pattern, p0, p1, text, t0, t1, pp, tt, opts, out_err)
          ret true
        .end

        if tt >= t1
          break
        .end

        let c: u8 = text.byte_at(tt)
        if __is_sep(c, opts)
          break
        .end

        tt = tt + 1
      .end

      ret false
    .end

    # Literal
    if t >= t1
      ret false
    .end

    let tc: u8 = text.byte_at(t)
    if __is_sep(tc, opts)
      ret false
    .end

    if !__eq_byte(pc, tc, opts)
      ret false
    .end

    p = p + 1
    t = t + 1
  .end
.end

# -----------------------------------------------------------------------------
# Character class: [..]
# -----------------------------------------------------------------------------

# Match a single byte `ch` against class starting at '['.
# Writes nextp = index after closing ']'.
# Returns true if matched.

pub fn __match_class(
  pattern: str,
  p: usize,
  p1: usize,
  ch: u8,
  out_nextp: *usize,
  opts: GlobOptions,
  out_err: *plugins.fs_vfs.api.types.Error,
) -> bool
  if out_nextp != 0
    out_nextp^ = p
  .end

  if p >= p1 || pattern.byte_at(p) != 0x5B
    error_set(out_err, plugins.fs_vfs.api.types.ErrorKind.InvalidInput, GLOB_INVALID, "glob: class expected")
    ret false
  .end

  let i: usize = p + 1
  if i >= p1
    error_set(out_err, plugins.fs_vfs.api.types.ErrorKind.InvalidInput, GLOB_INVALID, "glob: unterminated '['")
    ret false
  .end

  let neg: bool = false
  let c0: u8 = pattern.byte_at(i)
  if c0 == 0x21 || c0 == 0x5E
    neg = true
    i = i + 1
  .end

  let matched: bool = false
  let first: bool = true

  # Empty class is invalid
  if i >= p1
    error_set(out_err, plugins.fs_vfs.api.types.ErrorKind.InvalidInput, GLOB_INVALID, "glob: empty class")
    ret false
  .end

  loop
    if i >= p1
      error_set(out_err, plugins.fs_vfs.api.types.ErrorKind.InvalidInput, GLOB_INVALID, "glob: unterminated '['")
      ret false
    .end

    let c: u8 = pattern.byte_at(i)

    if c == 0x5D
      # end
      i = i + 1
      break
    .end

    # Allow ']' as first literal
    if first && c == 0x5D
      # handled above
      .end

    first = false

    # Read literal/escaped
    let lo: u8 = 0
    if c == 0x5C
      if i + 1 >= p1
        error_set(out_err, plugins.fs_vfs.api.types.ErrorKind.InvalidInput, GLOB_INVALID, "glob: class escape")
        ret false
      .end
      lo = pattern.byte_at(i + 1)
      i = i + 2
    .end

    if c != 0x5C
      lo = c
      i = i + 1
    .end

    # Range?
    if i + 1 < p1
      let dash = pattern.byte_at(i)
      let nxt = pattern.byte_at(i + 1)
      if dash == 0x2D && nxt != 0x5D
        # parse hi
        i = i + 1
        let hi: u8 = 0
        let hc: u8 = pattern.byte_at(i)
        if hc == 0x5C
          if i + 1 >= p1
            error_set(out_err, plugins.fs_vfs.api.types.ErrorKind.InvalidInput, GLOB_INVALID, "glob: class range escape")
            ret false
          .end
          hi = pattern.byte_at(i + 1)
          i = i + 2
        .end
        if hc != 0x5C
          hi = hc
          i = i + 1
        .end

        let a = lo
        let b = hi
        let x = ch

        if !opts.case_sensitive
          a = __to_lower_ascii(a)
          b = __to_lower_ascii(b)
          x = __to_lower_ascii(x)
        .end

        if a <= b
          if x >= a && x <= b
            matched = true
          .end
        .end
        if a > b
          # reversed range: treat as literal '-' behavior (conservative)
          if __eq_byte(lo, ch, opts)
            matched = true
          .end
          if __eq_byte(0x2D, ch, opts)
            matched = true
          .end
          if __eq_byte(hi, ch, opts)
            matched = true
          .end
        .end

        continue
      .end
    .end

    # Single literal
    if __eq_byte(lo, ch, opts)
      matched = true
    .end
  .end

  if out_nextp != 0
    out_nextp^ = i
  .end

  if neg
    ret !matched
  .end
  ret matched
.end

# -----------------------------------------------------------------------------
# Brace alternation: {a,b,c}
# -----------------------------------------------------------------------------

# Find matching '}' for '{' at p.
# Writes out_end = index of '}' (inclusive).
# Returns 0 on success, -1 on failure.

pub fn __find_matching_brace(pattern: str, p: usize, p1: usize, out_end: *usize) -> i32
  if out_end != 0
    out_end^ = p
  .end

  if p >= p1 || pattern.byte_at(p) != 0x7B
    ret -1
  .end

  let depth: i32 = 0
  let i: usize = p

  loop
    if i >= p1
      break
    .end

    let c: u8 = pattern.byte_at(i)

    if c == 0x5C
      # skip escaped
      if i + 1 < p1
        i = i + 2
        continue
      .end
      i = i + 1
      continue
    .end

    if c == 0x5B
      # skip class entirely (so braces inside class don't count)
      let j: usize = __skip_class(pattern, i, p1)
      if j == i
        ret -1
      .end
      i = j
      continue
    .end

    if c == 0x7B
      depth = depth + 1
    .end

    if c == 0x7D
      depth = depth - 1
      if depth == 0
        if out_end != 0
          out_end^ = i
        .end
        ret 0
      .end
    .end

    i = i + 1
  .end

  ret -1
.end

# Skip class starting at '['; returns index after closing ']' or same index on failure.

pub fn __skip_class(pattern: str, p: usize, p1: usize) -> usize
  if p >= p1
    ret p
  .end
  if pattern.byte_at(p) != 0x5B
    ret p
  .end

  let i: usize = p + 1
  loop
    if i >= p1
      ret p
    .end

    let c: u8 = pattern.byte_at(i)
    if c == 0x5C
      if i + 1 < p1
        i = i + 2
        continue
      .end
      i = i + 1
      continue
    .end

    if c == 0x5D
      ret i + 1
    .end

    i = i + 1
  .end
.end

# Try each brace alternative.
# brace_open is index of '{', brace_close is index of matching '}'.
# Rest of pattern continues after brace_close.

pub fn __match_brace_alts(
  pattern: str,
  brace_open: usize,
  brace_close: usize,
  p1: usize,
  text: str,
  t0: usize,
  t1: usize,
  t: usize,
  opts: GlobOptions,
  out_err: *plugins.fs_vfs.api.types.Error,
) -> bool
  # inside content: (brace_open+1 .. brace_close)
  let i: usize = brace_open + 1
  let alt_start: usize = i
  let depth: i32 = 0

  loop
    if i > brace_close
      break
    .end

    let at_end = i == brace_close
    let c: u8 = 0
    if !at_end
      c = pattern.byte_at(i)
    .end

    if !at_end
      if c == 0x5C
        if i + 1 < brace_close
          i = i + 2
          continue
        .end
        i = i + 1
        continue
      .end

      if c == 0x5B
        let j = __skip_class(pattern, i, brace_close)
        if j == i
          # invalid class
          ret false
        .end
        i = j
        continue
      .end

      if c == 0x7B
        depth = depth + 1
      .end

      if c == 0x7D
        if depth > 0
          depth = depth - 1
        .end
      .end
    .end

    let is_split = false
    if at_end
      is_split = true
    .end
    if !at_end && depth == 0 && c == 0x2C # ','
      is_split = true
    .end

    if is_split
      let alt_end = i

      # Match alt segment (as pattern slice) at current text index `t`, then match the rest.
      # We match: alt + rest_after_brace.

      # First match alt against remaining text with segment matcher, but we need to continue
      # with rest of pattern after brace.
      # Implement by trying to match alt as prefix of pattern:

      if __match_concat(pattern, alt_start, alt_end, brace_close + 1, p1, text, t0, t1, t, opts, out_err)
        ret true
      .end

      alt_start = i + 1
    .end

    i = i + 1
  .end

  ret false
.end

# Match concatenation of two pattern slices: patA[a0..a1) then patB[b0..b1)
# against text starting at t.

pub fn __match_concat(
  pattern: str,
  a0: usize,
  a1: usize,
  b0: usize,
  b1: usize,
  text: str,
  t0: usize,
  t1: usize,
  t: usize,
  opts: GlobOptions,
  out_err: *plugins.fs_vfs.api.types.Error,
) -> bool
  # Strategy: perform a temporary match of A by embedding into segment matcher.
  # Because our segment matcher takes contiguous pattern bounds, we handle by:
  # - Try all possible split points of text where A could end, by backtracking:
  #   if A matches text[t..k) and B matches text[k..).

  let k: usize = t
  loop
    if k > t1
      break
    .end

    if __match_segment(pattern, a0, a1, text, t, k, GlobOptions(
      sep: opts.sep,
      path_mode: false,
      allow_globstar: false,
      allow_brace: opts.allow_brace,
      allow_class: opts.allow_class,
      case_sensitive: opts.case_sensitive,
      dot_special: false,
    ), out_err)
      # Now match B against remaining tail using original segment rules.
      if __match_segment_at(pattern, b0, b1, text, t0, t1, b0, k, opts, out_err)
        ret true
      .end
    .end

    # advance k by one char
    if k == t1
      break
    .end
    k = k + 1
  .end

  ret false
.end

# -----------------------------------------------------------------------------
# Path matching with globstar
# -----------------------------------------------------------------------------

# Match as path: pattern may include separators.
# Uses recursion on indices; globstar works as segment "**".

pub fn __match_path(pattern: str, p: usize, text: str, t: usize, opts: GlobOptions, out_err: *plugins.fs_vfs.api.types.Error) -> bool
  # Consume consecutive separators in both
  p = __skip_seps(pattern, p, opts)
  t = __skip_seps(text, t, opts)

  # End cases
  if p >= pattern.len()
    ret t >= text.len()
  .end

  if t > text.len()
    ret false
  .end

  # Identify next pattern segment bounds [ps0..ps1)
  let ps0: usize = p
  let ps1: usize = __next_sep(pattern, ps0, opts)

  # Identify next text segment bounds [ts0..ts1)
  let ts0: usize = t
  let ts1: usize = __next_sep(text, ts0, opts)

  # Detect globstar segment "**" (exactly two '*' and nothing else)
  let is_globstar = false
  if opts.allow_globstar
    if (ps1 - ps0) == 2
      if pattern.byte_at(ps0) == 0x2A && pattern.byte_at(ps0 + 1) == 0x2A
        is_globstar = true
      .end
    .end
  .end

  if is_globstar
    # Case 1: ** matches zero segments: skip this pattern segment
    let p_next = __skip_seps(pattern, ps1, opts)
    if __match_path(pattern, p_next, text, t, opts, out_err)
      ret true
    .end

    # Case 2: ** matches one or more segments: consume one text segment and retry with same pattern
    if ts0 < text.len()
      # move t to after this segment
      let t_next = __skip_seps(text, ts1, opts)
      if __match_path(pattern, ps0, text, t_next, opts, out_err)
        ret true
      .end
    .end

    ret false
  .end

  # Normal segment: must have a text segment to match
  if ts0 >= text.len()
    ret false
  .end

  # Match this segment using segment matcher (path_mode true, so wildcards won't cross sep)
  let ok = __match_segment(pattern, ps0, ps1, text, ts0, ts1, opts, out_err)
  if !ok
    ret false
  .end

  # Recurse on remainder
  let p_next = __skip_seps(pattern, ps1, opts)
  let t_next = __skip_seps(text, ts1, opts)

  ret __match_path(pattern, p_next, text, t_next, opts, out_err)
.end

pub fn __skip_seps(s: str, i: usize, opts: GlobOptions) -> usize
  if !opts.path_mode
    ret i
  .end

  let j: usize = i
  loop
    if j >= s.len()
      break
    .end
    if s.byte_at(j) != opts.sep
      break
    .end
    j = j + 1
  .end

  ret j
.end

pub fn __next_sep(s: str, i: usize, opts: GlobOptions) -> usize
  if !opts.path_mode
    ret s.len()
  .end

  let j: usize = i
  loop
    if j >= s.len()
      break
    .end
    if s.byte_at(j) == opts.sep
      break
    .end
    j = j + 1
  .end

  ret j
.end

# -----------------------------------------------------------------------------
# Self-tests (optional)
# -----------------------------------------------------------------------------

pub fn __assert(b: bool) -> ()
  if !b
    # In a real test harness, you'd return error. Here it's a placeholder.
    ret ()
  .end
  ret ()
.end

pub fn self_test() -> i32
  let err: plugins.fs_vfs.api.types.Error = plugins.fs_vfs.api.types.error_empty()

  let o = defaults()

  __assert(is_match("a*.txt", "abc.txt", o, &err) == true)
  __assert(is_match("a?.txt", "ab.txt", o, &err) == true)
  __assert(is_match("a?.txt", "abc.txt", o, &err) == false)

  __assert(is_match("src/**/main.vitte", "src/main.vitte", o, &err) == true)
  __assert(is_match("src/**/main.vitte", "src/a/b/main.vitte", o, &err) == true)

  __assert(is_match("[a-c]x", "bx", opts_segment_only(), &err) == true)
  __assert(is_match("[!a-c]x", "bx", opts_segment_only(), &err) == false)

  let o2 = opts_segment_only()
  __assert(is_match("{foo,bar}.v", "foo.v", o2, &err) == true)
  __assert(is_match("{foo,bar}.v", "bar.v", o2, &err) == true)
  __assert(is_match("{foo,bar}.v", "baz.v", o2, &err) == false)

  ret 0
.end

.end
