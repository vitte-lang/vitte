# plugins/fs_vfs/api/path/join_split.vitte
# Join/split helpers
# Blocks use `.end` only.
#
# This module provides low-level, allocation-optional path manipulation helpers
# intended for VFS plugins.
#
# Goals
# -----
# - No mandatory heap allocation: all "write" APIs take caller-provided buffers.
# - Portable semantics with configurable separator.
# - Conservative normalization that does not touch filesystem.
# - Works on UTF-8 strings (byte-based). For OS-specific encodings, see
#   `plugins.fs_vfs.api.path.encoding`.
#
# Status conventions
# ------------------
# - 0  : OK
# - 1  : NeedsMoreSpace
# - 2  : InvalidInput
# - 3  : Unsupported
# - <0 : Error

mod plugins.fs_vfs.api.path.join_split

pub const PATH_OK: i32 = 0
pub const PATH_MORE: i32 = 1
pub const PATH_INVALID: i32 = 2
pub const PATH_UNSUPPORTED: i32 = 3
pub const PATH_ERR: i32 = -1

# -----------------------------------------------------------------------------
# Error helpers
# -----------------------------------------------------------------------------

pub fn error_set(out_err: *plugins.fs_vfs.api.types.Error, kind: plugins.fs_vfs.api.types.ErrorKind, code: i32, msg: str) -> ()
  if out_err == 0
    ret ()
  .end
  out_err^.kind = kind
  out_err^.code = code
  out_err^.message = msg
  ret ()
.end

pub fn error_clear(out_err: *plugins.fs_vfs.api.types.Error) -> ()
  if out_err == 0
    ret ()
  .end
  out_err^.kind = plugins.fs_vfs.api.types.ErrorKind.Other
  out_err^.code = 0
  out_err^.message = ""
  ret ()
.end

# -----------------------------------------------------------------------------
# Types
# -----------------------------------------------------------------------------

# Buffer descriptor for "write into caller buffer" APIs.

pub struct OutBytes
  ptr: *u8
  cap: usize
.end

pub fn out_bytes(ptr: *u8, cap: usize) -> OutBytes
  ret OutBytes(ptr: ptr, cap: cap)
.end

# A (ptr,len) view over a sub-slice of a string.
# Used to return split parts without allocation.

pub struct StrView
  ptr: *u8
  len: usize
.end

pub fn str_view(ptr: *u8, len: usize) -> StrView
  ret StrView(ptr: ptr, len: len)
.end

pub fn str_view_empty() -> StrView
  ret StrView(ptr: 0, len: 0)
.end

# Segment iterator over a path string.
# This is a pure splitter: it yields segments between separators.
# By default it skips empty segments caused by consecutive seps.

pub struct SegIter
  s: str
  sep: u8
  i: usize
  skip_empty: bool
.end

pub fn seg_iter_new(s: str, sep: u8, skip_empty: bool) -> SegIter
  ret SegIter(s: s, sep: sep, i: 0, skip_empty: skip_empty)
.end

# Next segment.
#
# Returns:
# - 0 OK (out set)
# - 1 End

pub fn seg_iter_next(it: *SegIter, out: *StrView) -> i32
  if out != 0
    out^ = str_view_empty()
  .end

  if it == 0
    ret 1
  .end

  let n = it^.s.len()
  let i = it^.i

  if i >= n
    ret 1
  .end

  # skip separators
  let j: usize = i
  loop
    if j >= n
      break
    .end
    if it^.s.byte_at(j) != it^.sep
      break
    .end
    j = j + 1
  .end

  if j >= n
    it^.i = n
    ret 1
  .end

  # find next separator
  let k: usize = j
  loop
    if k >= n
      break
    .end
    if it^.s.byte_at(k) == it^.sep
      break
    .end
    k = k + 1
  .end

  it^.i = k

  let seg_len = k - j
  if seg_len == 0 && it^.skip_empty
    # continue
    ret seg_iter_next(it, out)
  .end

  if out != 0
    # StrView points into original string bytes.
    out^.ptr = it^.s.as_ptr() + j
    out^.len = seg_len
  .end

  ret 0
.end

# -----------------------------------------------------------------------------
# Options
# -----------------------------------------------------------------------------

pub struct PathOptions
  sep: u8

  # If true, treat leading sep as root indicator.
  # Example: "/a/b" is absolute.
  allow_absolute: bool

  # If true, collapse consecutive seps when joining/normalizing.
  collapse_seps: bool

  # If true, keep trailing separator when normalizing.
  keep_trailing_sep: bool

  # If true, interpret '.' and '..' and normalize them.
  # Note: this is purely syntactic. It will not resolve symlinks.
  normalize_dots: bool
.end

pub fn defaults() -> PathOptions
  ret PathOptions(
    sep: 0x2F, # '/'
    allow_absolute: true,
    collapse_seps: true,
    keep_trailing_sep: false,
    normalize_dots: true,
  )
.end

pub fn posix() -> PathOptions
  ret defaults()
.end

pub fn windows_like() -> PathOptions
  # Only for "portable" windows-like VFS paths.
  # We do not implement drive letters or UNC in this plugin module.
  ret PathOptions(
    sep: 0x5C, # '\\'
    allow_absolute: true,
    collapse_seps: true,
    keep_trailing_sep: false,
    normalize_dots: true,
  )
.end

# -----------------------------------------------------------------------------
# Predicates
# -----------------------------------------------------------------------------

pub fn is_sep_byte(b: u8, sep: u8) -> bool
  ret b == sep
.end

pub fn has_trailing_sep(path: str, sep: u8) -> bool
  if path.len() == 0
    ret false
  .end
  ret path.byte_at(path.len() - 1) == sep
.end

pub fn is_absolute(path: str, opts: PathOptions) -> bool
  if !opts.allow_absolute
    ret false
  .end
  if path.len() == 0
    ret false
  .end
  ret path.byte_at(0) == opts.sep
.end

pub fn is_empty(path: str) -> bool
  ret path.len() == 0
.end

pub fn basename_view(path: str, sep: u8) -> StrView
  if path.len() == 0
    ret str_view_empty()
  .end

  # strip trailing seps
  let end = path.len()
  let i = end
  loop
    if i == 0
      break
    .end
    if path.byte_at(i - 1) != sep
      break
    .end
    i = i - 1
  .end

  if i == 0
    # path is all seps => basename is sep
    ret str_view(path.as_ptr(), 1)
  .end

  # find last sep before i
  let j: usize = i
  loop
    if j == 0
      break
    .end
    if path.byte_at(j - 1) == sep
      break
    .end
    j = j - 1
  .end

  ret str_view(path.as_ptr() + j, i - j)
.end

pub fn dirname_view(path: str, sep: u8) -> StrView
  if path.len() == 0
    ret str_view_empty()
  .end

  # strip trailing seps
  let end = path.len()
  let i = end
  loop
    if i == 0
      break
    .end
    if path.byte_at(i - 1) != sep
      break
    .end
    i = i - 1
  .end

  if i == 0
    # all seps => dirname is sep
    ret str_view(path.as_ptr(), 1)
  .end

  # find last sep
  let j: usize = i
  loop
    if j == 0
      break
    .end
    if path.byte_at(j - 1) == sep
      break
    .end
    j = j - 1
  .end

  if j == 0
    # no sep
    ret str_view_empty()
  .end

  # collapse multiple seps at end of dirname
  let k: usize = j
  loop
    if k == 0
      break
    .end
    if path.byte_at(k - 1) != sep
      break
    .end
    k = k - 1
  .end

  if k == 0
    # root
    ret str_view(path.as_ptr(), 1)
  .end

  ret str_view(path.as_ptr(), k)
.end

# Extension view (portion after last '.' in basename), without dot.
# Returns empty if none or if basename begins with '.' and contains no other '.'

pub fn extension_view(path: str, sep: u8) -> StrView
  let base = basename_view(path, sep)
  if base.len == 0
    ret str_view_empty()
  .end

  # search last '.'
  let i: usize = base.len
  loop
    if i == 0
      break
    .end
    if (base.ptr + i - 1)^ == 0x2E
      break
    .end
    i = i - 1
  .end

  if i == 0
    ret str_view_empty()
  .end

  # if dot is first char => hidden file, not an extension unless another dot exists
  if i == 1
    # check any other '.'
    let j: usize = 1
    let found: bool = false
    loop
      if j >= base.len
        break
      .end
      if (base.ptr + j)^ == 0x2E
        found = true
        break
      .end
      j = j + 1
    .end

    if !found
      ret str_view_empty()
    .end
  .end

  # if dot is last char => no extension
  if i == base.len
    ret str_view_empty()
  .end

  ret str_view(base.ptr + i, base.len - i)
.end

# -----------------------------------------------------------------------------
# Join
# -----------------------------------------------------------------------------

# Join two path parts into out buffer.
# Rules (path-only, no FS):
# - If rhs is absolute and allow_absolute => result is rhs.
# - Else result is lhs + sep + rhs (with collapse rules).
# - Handles empty parts.
#
# Returns 0 OK, 1 NeedsMoreSpace, 2 InvalidInput.

pub fn join2(lhs: str, rhs: str, opts: PathOptions, out: OutBytes, out_len: *usize, out_err: *plugins.fs_vfs.api.types.Error) -> i32
  error_clear(out_err)

  if out_len != 0
    out_len^ = 0
  .end

  if out.ptr == 0 && out.cap != 0
    error_set(out_err, plugins.fs_vfs.api.types.ErrorKind.InvalidInput, PATH_INVALID, "path.join2: out.ptr null")
    ret PATH_INVALID
  .end

  # If rhs absolute => rhs
  if is_absolute(rhs, opts)
    ret write_str(rhs, out, out_len, out_err)
  .end

  if lhs.len() == 0
    ret write_str(rhs, out, out_len, out_err)
  .end
  if rhs.len() == 0
    ret write_str(lhs, out, out_len, out_err)
  .end

  # Determine whether we need a separator
  let need_sep = true
  if has_trailing_sep(lhs, opts.sep)
    need_sep = false
  .end
  if rhs.len() > 0 && rhs.byte_at(0) == opts.sep
    # rhs begins with sep but is not absolute (allow_absolute false) => avoid double sep
    need_sep = false
  .end

  # Collapse seps if requested
  # We'll compute effective boundaries.

  let lhs_end = lhs.len()
  let rhs_start: usize = 0

  if opts.collapse_seps
    # strip trailing seps from lhs
    let i = lhs_end
    loop
      if i == 0
        break
      .end
      if lhs.byte_at(i - 1) != opts.sep
        break
      .end
      i = i - 1
    .end
    lhs_end = i

    # strip leading seps from rhs
    let j: usize = 0
    loop
      if j >= rhs.len()
        break
      .end
      if rhs.byte_at(j) != opts.sep
        break
      .end
      j = j + 1
    .end
    rhs_start = j

    # if lhs becomes empty but was absolute root '/', keep one sep
    if lhs.len() > 0 && lhs.byte_at(0) == opts.sep && lhs_end == 0
      lhs_end = 1
    .end

    # recompute need_sep
    need_sep = true
    if lhs_end > 0 && lhs.byte_at(lhs_end - 1) == opts.sep
      need_sep = false
    .end
    if rhs_start < rhs.len() && rhs.byte_at(rhs_start) == opts.sep
      need_sep = false
    .end
  .end

  # length check
  let total = lhs_end + (if need_sep then 1 else 0) + (rhs.len() - rhs_start)
  if total > out.cap
    error_set(out_err, plugins.fs_vfs.api.types.ErrorKind.InvalidInput, PATH_MORE, "path.join2: out too small")
    ret PATH_MORE
  .end

  let k: usize = 0

  # copy lhs[0..lhs_end)
  let i: usize = 0
  loop
    if i >= lhs_end
      break
    .end
    (out.ptr + k)^ = lhs.byte_at(i)
    i = i + 1
    k = k + 1
  .end

  if need_sep
    (out.ptr + k)^ = opts.sep
    k = k + 1
  .end

  # copy rhs[rhs_start..)
  let j: usize = rhs_start
  loop
    if j >= rhs.len()
      break
    .end
    (out.ptr + k)^ = rhs.byte_at(j)
    j = j + 1
    k = k + 1
  .end

  if out_len != 0
    out_len^ = k
  .end

  ret PATH_OK
.end

# Join many parts.
#
# Caller provides:
# - parts_ptr: pointer to array of str (or slice-like) is not available, so this is
#   a placeholder signature. In Vitte, adapt to your slice semantics.
#
# For now we provide join3 and join4 helpers.

pub fn join3(a: str, b: str, c: str, opts: PathOptions, out: OutBytes, out_len: *usize, out_err: *plugins.fs_vfs.api.types.Error) -> i32
  # tmp buffer is not available; do two-stage into out by computing joined length.
  # We do: join2(a,b) into out then join2(result,c) into out again using a memmove.
  # Because we cannot allocate a second buffer, we do a direct writer.

  # Simple approach: join2(a,b) into out, then join_suffix(out, len, c).

  let len1: usize = 0
  let rc1 = join2(a, b, opts, out, &len1, out_err)
  if rc1 != PATH_OK
    ret rc1
  .end

  # Now append c to existing prefix in out.
  let prefix = __view_out(out, len1)
  let rc2 = join2(prefix, c, opts, out, out_len, out_err)
  ret rc2
.end

pub fn join4(a: str, b: str, c: str, d: str, opts: PathOptions, out: OutBytes, out_len: *usize, out_err: *plugins.fs_vfs.api.types.Error) -> i32
  let len1: usize = 0
  let rc1 = join3(a, b, c, opts, out, &len1, out_err)
  if rc1 != PATH_OK
    ret rc1
  .end

  let prefix = __view_out(out, len1)
  ret join2(prefix, d, opts, out, out_len, out_err)
.end

# Create a temporary string view of the current out buffer content.
# WARNING: assumes out currently contains valid UTF-8 bytes.

pub fn __view_out(out: OutBytes, len: usize) -> str
  # Placeholder: in a real runtime, provide str.from_ptr_len.
  # Here we assume `str.from_ptr_len(ptr,len)` exists.
  ret str.from_ptr_len(out.ptr, len)
.end

# Copy a string into out buffer.

pub fn write_str(s: str, out: OutBytes, out_len: *usize, out_err: *plugins.fs_vfs.api.types.Error) -> i32
  error_clear(out_err)

  if out_len != 0
    out_len^ = 0
  .end

  if s.len() > out.cap
    error_set(out_err, plugins.fs_vfs.api.types.ErrorKind.InvalidInput, PATH_MORE, "path.write_str: out too small")
    ret PATH_MORE
  .end

  let i: usize = 0
  loop
    if i >= s.len()
      break
    .end
    (out.ptr + i)^ = s.byte_at(i)
    i = i + 1
  .end

  if out_len != 0
    out_len^ = s.len()
  .end

  ret PATH_OK
.end

# -----------------------------------------------------------------------------
# Normalize
# -----------------------------------------------------------------------------

# Normalize a path syntactically.
#
# Operations:
# - collapse seps (if enabled)
# - resolve '.' and '..' segments (if enabled)
# - preserve leading root sep for absolute paths
# - optionally preserve trailing sep
#
# Returns 0 OK, 1 NeedsMoreSpace, 2 InvalidInput.

pub fn normalize(path: str, opts: PathOptions, out: OutBytes, out_len: *usize, out_err: *plugins.fs_vfs.api.types.Error) -> i32
  error_clear(out_err)

  if out_len != 0
    out_len^ = 0
  .end

  if out.ptr == 0 && out.cap != 0
    error_set(out_err, plugins.fs_vfs.api.types.ErrorKind.InvalidInput, PATH_INVALID, "path.normalize: out.ptr null")
    ret PATH_INVALID
  .end

  # Special cases
  if path.len() == 0
    ret write_str("", out, out_len, out_err)
  .end

  # We'll write into out incrementally, using a stack of segment start offsets
  # stored in caller buffer tail is not available; instead we implement a simple
  # in-place algorithm:
  # - write root if absolute
  # - iterate segments; for each:
  #   - skip empty segments
  #   - if '.' => ignore
  #   - if '..' => pop previous segment (if any) else keep if relative
  #
  # This requires ability to "pop" from output: we keep an array of offsets
  # in a caller-provided scratch. Since we do not have it, we implement a bounded
  # pop by rescanning backward to previous sep.

  let k: usize = 0

  let abs = is_absolute(path, opts)
  if abs
    if k + 1 > out.cap
      error_set(out_err, plugins.fs_vfs.api.types.ErrorKind.InvalidInput, PATH_MORE, "path.normalize: out too small")
      ret PATH_MORE
    .end
    (out.ptr + k)^ = opts.sep
    k = k + 1
  .end

  # Track whether original had trailing sep
  let want_trailing = false
  if opts.keep_trailing_sep
    want_trailing = has_trailing_sep(path, opts.sep)
  .end

  let it: SegIter = seg_iter_new(path, opts.sep, true)
  let seg: StrView = str_view_empty()

  # Iterate segments
  loop
    let rc = seg_iter_next(&it, &seg)
    if rc != 0
      break
    .end

    # interpret segment
    if opts.normalize_dots
      if __seg_eq(seg, ".")
        continue
      .end
      if __seg_eq(seg, "..")
        # pop one segment from output
        if abs
          # cannot go above root; just pop if possible
          __pop_segment(out, &k, opts.sep)
          continue
        .end
        # relative: if there is a segment to pop, pop; else append '..'
        let popped = __pop_segment(out, &k, opts.sep)
        if popped
          continue
        .end
        # append '..'
        let rc2 = __push_segment(out, &k, "..", opts)
        if rc2 != PATH_OK
          ret rc2
        .end
        continue
      .end
    .end

    # normal segment
    let rc3 = __push_segment_view(out, &k, seg, opts)
    if rc3 != PATH_OK
      ret rc3
    .end
  .end

  # Remove trailing sep unless requested
  if !want_trailing
    # strip trailing seps except root
    loop
      if k == 0
        break
      .end
      if k == 1 && abs
        break
      .end
      if (out.ptr + k - 1)^ != opts.sep
        break
      .end
      k = k - 1
    .end
  .end

  if want_trailing
    # ensure one trailing sep if non-empty and not already
    if k > 0
      if (out.ptr + k - 1)^ != opts.sep
        if k + 1 > out.cap
          error_set(out_err, plugins.fs_vfs.api.types.ErrorKind.InvalidInput, PATH_MORE, "path.normalize: out too small for trailing sep")
          ret PATH_MORE
        .end
        (out.ptr + k)^ = opts.sep
        k = k + 1
      .end
    .end
  .end

  if out_len != 0
    out_len^ = k
  .end

  ret PATH_OK
.end

# Compare StrView to literal ascii string.

pub fn __seg_eq(seg: StrView, lit: str) -> bool
  if seg.len != lit.len()
    ret false
  .end
  let i: usize = 0
  loop
    if i >= seg.len
      break
    .end
    if (seg.ptr + i)^ != lit.byte_at(i)
      ret false
    .end
    i = i + 1
  .end
  ret true
.end

# Pop the last segment in output buffer, adjusting k.
# Returns true if something was popped.

pub fn __pop_segment(out: OutBytes, io_k: *usize, sep: u8) -> bool
  if io_k == 0
    ret false
  .end

  let k = io_k^

  # Strip trailing seps
  loop
    if k == 0
      break
    .end
    if (out.ptr + k - 1)^ != sep
      break
    .end
    k = k - 1
  .end

  if k == 0
    io_k^ = 0
    ret false
  .end

  # Find previous sep
  let j: usize = k
  loop
    if j == 0
      break
    .end
    if (out.ptr + j - 1)^ == sep
      break
    .end
    j = j - 1
  .end

  # If at root (j==1 and first char is sep), keep root
  if j == 0
    io_k^ = 0
    ret true
  .end

  # If j==1 and out[0]==sep, keep one sep
  if j == 1 && (out.ptr + 0)^ == sep
    io_k^ = 1
    ret true
  .end

  io_k^ = j
  ret true
.end

# Push a literal segment.

pub fn __push_segment(out: OutBytes, io_k: *usize, seg: str, opts: PathOptions) -> i32
  let sv = str_view(seg.as_ptr(), seg.len())
  ret __push_segment_view(out, io_k, sv, opts)
.end

# Push a segment view, adding separators as needed.

pub fn __push_segment_view(out: OutBytes, io_k: *usize, seg: StrView, opts: PathOptions) -> i32
  if io_k == 0
    ret PATH_INVALID
  .end

  if seg.len == 0
    ret PATH_OK
  .end

  let k = io_k^

  # Add sep if needed
  if k > 0
    if (out.ptr + k - 1)^ != opts.sep
      if k + 1 > out.cap
        ret PATH_MORE
      .end
      (out.ptr + k)^ = opts.sep
      k = k + 1
    .end
  .end

  # If output is empty but absolute path root should already be added

  if k + seg.len > out.cap
    ret PATH_MORE
  .end

  let i: usize = 0
  loop
    if i >= seg.len
      break
    .end
    (out.ptr + k + i)^ = (seg.ptr + i)^
    i = i + 1
  .end

  k = k + seg.len
  io_k^ = k
  ret PATH_OK
.end

# -----------------------------------------------------------------------------
# Split APIs
# -----------------------------------------------------------------------------

# Split once at last separator.
#
# Outputs:
# - out_dir: dirname view
# - out_base: basename view

pub fn split_dir_base(path: str, sep: u8, out_dir: *StrView, out_base: *StrView) -> i32
  if out_dir != 0
    out_dir^ = dirname_view(path, sep)
  .end
  if out_base != 0
    out_base^ = basename_view(path, sep)
  .end
  ret PATH_OK
.end

# Split extension.
# Outputs:
# - out_stem: basename without extension
# - out_ext: extension without '.'

pub fn split_ext(path: str, sep: u8, out_stem: *StrView, out_ext: *StrView) -> i32
  let base = basename_view(path, sep)
  let ext = extension_view(path, sep)

  if out_ext != 0
    out_ext^ = ext
  .end

  if out_stem != 0
    if ext.len == 0
      out_stem^ = base
      ret PATH_OK
    .end

    # stem is base[0..base.len - ext.len - 1]
    let stem_len = base.len - ext.len - 1
    out_stem^.ptr = base.ptr
    out_stem^.len = stem_len
  .end

  ret PATH_OK
.end

# -----------------------------------------------------------------------------
# Relativize
# -----------------------------------------------------------------------------

# Compute a relative path from base to target.
#
# Example:
# - base: /a/b/c
# - target: /a/d/e
# => ../../d/e
#
# Constraints:
# - purely syntactic
# - both should be either absolute or relative; if mismatch => Invalid
#
# Returns 0 OK, 1 NeedsMoreSpace, 2 Invalid.

pub fn relative(base: str, target: str, opts: PathOptions, out: OutBytes, out_len: *usize, out_err: *plugins.fs_vfs.api.types.Error) -> i32
  error_clear(out_err)

  if out_len != 0
    out_len^ = 0
  .end

  let base_abs = is_absolute(base, opts)
  let targ_abs = is_absolute(target, opts)
  if base_abs != targ_abs
    error_set(out_err, plugins.fs_vfs.api.types.ErrorKind.InvalidInput, PATH_INVALID, "path.relative: abs mismatch")
    ret PATH_INVALID
  .end

  # Normalize both into temporary views? No heap. We'll do segment iteration and find common prefix.
  # Approach:
  # - Find common prefix segments count.
  # - Count remaining segments in base => add '..' for each.
  # - Append remaining target segments.

  let itb: SegIter = seg_iter_new(base, opts.sep, true)
  let itt: SegIter = seg_iter_new(target, opts.sep, true)

  # First pass: collect common prefix by iterating simultaneously.
  # Without storage, we rescan later. We'll count common segments by comparing views.

  let common: usize = 0
  let sb: StrView = str_view_empty()
  let st: StrView = str_view_empty()

  loop
    let rb = seg_iter_next(&itb, &sb)
    let rt = seg_iter_next(&itt, &st)

    if rb != 0 || rt != 0
      break
    .end

    if !__view_eq(sb, st)
      break
    .end

    common = common + 1
  .end

  # Count remaining base segments after common.
  let up: usize = __count_segments_after(base, opts.sep, common)

  # Now write into out
  let k: usize = 0

  # Write ".." segments
  let u: usize = 0
  loop
    if u >= up
      break
    .end

    let rc = __write_part(out, &k, "..", opts)
    if rc != PATH_OK
      error_set(out_err, plugins.fs_vfs.api.types.ErrorKind.InvalidInput, rc, "path.relative: out too small")
      ret rc
    .end

    u = u + 1
  .end

  # Append target segments after common
  let rc2 = __append_segments_after(target, opts.sep, common, out, &k, opts)
  if rc2 != PATH_OK
    error_set(out_err, plugins.fs_vfs.api.types.ErrorKind.InvalidInput, rc2, "path.relative: out too small")
    ret rc2
  .end

  if k == 0
    # same path => "."
    let rc3 = write_str(".", out, &k, out_err)
    if rc3 != PATH_OK
      ret rc3
    .end
  .end

  if out_len != 0
    out_len^ = k
  .end

  ret PATH_OK
.end

pub fn __view_eq(a: StrView, b: StrView) -> bool
  if a.len != b.len
    ret false
  .end
  let i: usize = 0
  loop
    if i >= a.len
      break
    .end
    if (a.ptr + i)^ != (b.ptr + i)^
      ret false
    .end
    i = i + 1
  .end
  ret true
.end

# Count segments after skipping first `skip` segments.

pub fn __count_segments_after(path: str, sep: u8, skip: usize) -> usize
  let it: SegIter = seg_iter_new(path, sep, true)
  let seg: StrView = str_view_empty()

  let idx: usize = 0
  let count: usize = 0

  loop
    let rc = seg_iter_next(&it, &seg)
    if rc != 0
      break
    .end

    if idx >= skip
      count = count + 1
    .end

    idx = idx + 1
  .end

  ret count
.end

# Append segments after skipping first `skip` segments.

pub fn __append_segments_after(path: str, sep: u8, skip: usize, out: OutBytes, io_k: *usize, opts: PathOptions) -> i32
  let it: SegIter = seg_iter_new(path, sep, true)
  let seg: StrView = str_view_empty()

  let idx: usize = 0

  loop
    let rc = seg_iter_next(&it, &seg)
    if rc != 0
      break
    .end

    if idx >= skip
      # write segment
      let rc2 = __write_part_view(out, io_k, seg, opts)
      if rc2 != PATH_OK
        ret rc2
      .end
    .end

    idx = idx + 1
  .end

  ret PATH_OK
.end

# Write a part ensuring separators between parts.

pub fn __write_part(out: OutBytes, io_k: *usize, part: str, opts: PathOptions) -> i32
  let sv = str_view(part.as_ptr(), part.len())
  ret __write_part_view(out, io_k, sv, opts)
.end

pub fn __write_part_view(out: OutBytes, io_k: *usize, part: StrView, opts: PathOptions) -> i32
  if io_k == 0
    ret PATH_INVALID
  .end

  let k = io_k^

  if k != 0
    if (out.ptr + k - 1)^ != opts.sep
      if k + 1 > out.cap
        ret PATH_MORE
      .end
      (out.ptr + k)^ = opts.sep
      k = k + 1
    .end
  .end

  if k + part.len > out.cap
    ret PATH_MORE
  .end

  let i: usize = 0
  loop
    if i >= part.len
      break
    .end
    (out.ptr + k + i)^ = (part.ptr + i)^
    i = i + 1
  .end

  k = k + part.len
  io_k^ = k
  ret PATH_OK
.end

# -----------------------------------------------------------------------------
# Common prefix
# -----------------------------------------------------------------------------

# Returns number of shared leading segments.

pub fn common_prefix_segments(a: str, b: str, sep: u8) -> usize
  let ita: SegIter = seg_iter_new(a, sep, true)
  let itb: SegIter = seg_iter_new(b, sep, true)

  let sa: StrView = str_view_empty()
  let sb: StrView = str_view_empty()

  let n: usize = 0

  loop
    let ra = seg_iter_next(&ita, &sa)
    let rb = seg_iter_next(&itb, &sb)

    if ra != 0 || rb != 0
      break
    .end

    if !__view_eq(sa, sb)
      break
    .end

    n = n + 1
  .end

  ret n
.end

# -----------------------------------------------------------------------------
# Self-tests (placeholder)
# -----------------------------------------------------------------------------

pub fn __assert(b: bool) -> ()
  if !b
    ret ()
  .end
  ret ()
.end

pub fn self_test() -> i32
  let err: plugins.fs_vfs.api.types.Error = plugins.fs_vfs.api.types.error_empty()
  let opts = defaults()

  # join
  let buf: [512]u8
  let n: usize = 0
  __assert(join2("/a/b", "c", opts, out_bytes(&buf[0], 512), &n, &err) == PATH_OK)

  # normalize
  let n2: usize = 0
  __assert(normalize("/a//b/./c/..", opts, out_bytes(&buf[0], 512), &n2, &err) == PATH_OK)

  # split
  let d: StrView = str_view_empty()
  let b: StrView = str_view_empty()
  split_dir_base("/a/b/c.txt", opts.sep, &d, &b)
  __assert(b.len != 0)

  # relative
  let n3: usize = 0
  __assert(relative("/a/b/c", "/a/d/e", opts, out_bytes(&buf[0], 512), &n3, &err) == PATH_OK)

  ret 0
.end

.end
