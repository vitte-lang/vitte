# plugins/beryl-crypto/primitives/curve25519/montgomery.vitte
# Curve25519 Montgomery form (X25519) â€” MAX+++
# Blocks use `.end` only.
#
# Implements:
#   - X25519 scalar multiplication on Montgomery curve (RFC 7748)
#   - Montgomery ladder with constant-time conditional swaps (best-effort)
#   - Decode/encode u-coordinate (32 bytes LE)
#   - Scalar clamping (X25519)
#
# Dependencies:
#   - Reuses GF(p) field implementation from `plugins.crypto.primitives.curve25519.field`
#
# Notes:
#   - Constant-time is best-effort and compiler/runtime dependent.
#   - This is a primitives module; higher layers may wrap with providers/handles.

module plugins.crypto.primitives.curve25519.montgomery

import std.collections as coll

import plugins.crypto.api.types as t
import plugins.crypto.host.time_const as ct

import plugins.crypto.primitives.curve25519.field as fe

# ============================================================================
# Types / status
# ============================================================================

enum X25519Error
  Ok
  InvalidLen
  InvalidInput
.end

struct X25519Status
  err : X25519Error
.end

fn x25519_ok() -> X25519Status
  let s : X25519Status = X25519Status
  s.err = X25519Error.Ok
  return s
.end

fn x25519_err(e : X25519Error) -> X25519Status
  let s : X25519Status = X25519Status
  s.err = e
  return s
.end

# Internal point in projective (X:Z) for u-coordinate.
struct MontPoint
  X : fe.Fe
  Z : fe.Fe
.end

fn mont_point_new(X : fe.Fe, Z : fe.Fe) -> MontPoint
  let p : MontPoint = MontPoint
  p.X = X
  p.Z = Z
  return p
.end

# ============================================================================
# Constants
# ============================================================================

# A24 = (486662 + 2) / 4
const A24 : u64 = 121666

# Basepoint u = 9
fn basepoint_u_bytes() -> coll.Vec[u8]
  let v : coll.Vec[u8] = coll.Vec[u8]
  let i : u32 = 0
  while i < 32
    v.push(0)
    i += 1
  .end
  v[0] = 9
  return v
.end

# ============================================================================
# Helpers
# ============================================================================

fn scalar_get_bit_le(s : t.ByteSlice, i : u32) -> u8
  # Little-endian scalar bit i.
  let byte_i : u32 = i / 8
  let bit_i : u32 = i % 8
  if (byte_i as u64) >= s.len
    return 0
  .end
  return (s[byte_i as u64] >> bit_i) & 1
.end

fn clamp_x25519_scalar(s_in : coll.Vec[u8]) -> coll.Vec[u8]
  # X25519 clamping (RFC 7748):
  #   k[0] &= 248
  #   k[31] &= 127
  #   k[31] |= 64
  let s : coll.Vec[u8] = s_in
  if s.len() < 32
    return s
  .end

  s[0] &= 248
  s[31] &= 127
  s[31] |= 64

  return s
.end

fn copy_32_from_slice(src : t.ByteSlice) -> (coll.Vec[u8], bool)
  let v : coll.Vec[u8] = coll.Vec[u8]

  if src.len < 32
    return (v, false)
  .end

  let i : u32 = 0
  while i < 32
    v.push(src[i as u64])
    i += 1
  .end

  return (v, true)
.end

fn fe_from_u_bytes(u_in : t.ByteSlice) -> (fe.Fe, bool)
  if u_in.len < 32
    return (fe.fe_zero(), false)
  .end

  # Copy and clear top bit (per RFC 7748 decoding)
  let tmp : coll.Vec[u8] = coll.Vec[u8]
  let i : u32 = 0
  while i < 32
    tmp.push(u_in[i as u64])
    i += 1
  .end
  tmp[31] &= 127

  let s : t.ByteSlice = t.ByteSlice
  s.ptr = tmp.ptr()
  s.len = 32

  let x : fe.Fe = fe.fe_from_bytes(s)
  return (x, true)
.end

fn fe_to_u_bytes(out32 : t.MutByteSlice, x : fe.Fe)
  fe.fe_to_bytes(out32, x)
.end

fn mont_cswap(a_in : MontPoint, b_in : MontPoint, bit : u8) -> (MontPoint, MontPoint)
  let a : MontPoint = a_in
  let b : MontPoint = b_in

  let sx = fe.fe_ct_cswap(a.X, b.X, bit)
  a.X = sx.0
  b.X = sx.1

  let sz = fe.fe_ct_cswap(a.Z, b.Z, bit)
  a.Z = sz.0
  b.Z = sz.1

  return (a, b)
.end

# ============================================================================
# Montgomery ladder (RFC 7748)
# ============================================================================

fn mont_ladder_u(u : fe.Fe, scalar_le_32 : t.ByteSlice) -> fe.Fe
  # Ladder variables
  let x1 : fe.Fe = u

  let x2 : fe.Fe = fe.fe_one()
  let z2 : fe.Fe = fe.fe_zero()

  let x3 : fe.Fe = u
  let z3 : fe.Fe = fe.fe_one()

  let r2 : MontPoint = mont_point_new(x2, z2)
  let r3 : MontPoint = mont_point_new(x3, z3)

  let swap : u8 = 0

  # Bits 254..0 (255 bits)
  let i : i32 = 254
  while i >= 0
    let bit : u8 = scalar_get_bit_le(scalar_le_32, i as u32)
    let do_swap : u8 = bit ^ swap

    let sw = mont_cswap(r2, r3, do_swap)
    r2 = sw.0
    r3 = sw.1

    swap = bit

    # A = X2 + Z2
    let A : fe.Fe = fe.fe_add(r2.X, r2.Z)
    # AA = A^2
    let AA : fe.Fe = fe.fe_sqr(A)

    # B = X2 - Z2
    let B : fe.Fe = fe.fe_sub(r2.X, r2.Z)
    # BB = B^2
    let BB : fe.Fe = fe.fe_sqr(B)

    # E = AA - BB
    let E : fe.Fe = fe.fe_sub(AA, BB)

    # C = X3 + Z3
    let C : fe.Fe = fe.fe_add(r3.X, r3.Z)

    # D = X3 - Z3
    let D : fe.Fe = fe.fe_sub(r3.X, r3.Z)

    # DA = D * A
    let DA : fe.Fe = fe.fe_mul(D, A)

    # CB = C * B
    let CB : fe.Fe = fe.fe_mul(C, B)

    # X3 = (DA + CB)^2
    let DApCB : fe.Fe = fe.fe_add(DA, CB)
    let X3n : fe.Fe = fe.fe_sqr(DApCB)

    # Z3 = x1 * (DA - CB)^2
    let DAmCB : fe.Fe = fe.fe_sub(DA, CB)
    let Z3n : fe.Fe = fe.fe_mul(x1, fe.fe_sqr(DAmCB))

    # X2 = AA * BB
    let X2n : fe.Fe = fe.fe_mul(AA, BB)

    # Z2 = E * (AA + A24*E)
    let a24e : fe.Fe = fe.fe_mul_small(E, A24)
    let AAa : fe.Fe = fe.fe_add(AA, a24e)
    let Z2n : fe.Fe = fe.fe_mul(E, AAa)

    r3.X = X3n
    r3.Z = Z3n

    r2.X = X2n
    r2.Z = Z2n

    i -= 1
  .end

  let swf = mont_cswap(r2, r3, swap)
  r2 = swf.0

  # affine u = X2 / Z2
  let invz : fe.Fe = fe.fe_invert(r2.Z)
  let out : fe.Fe = fe.fe_mul(r2.X, invz)

  return out
.end

# ============================================================================
# Public API
# ============================================================================

fn x25519_view(out32 : t.MutByteSlice, scalar32 : t.ByteSlice, u32 : t.ByteSlice) -> X25519Status
  if out32.len < 32
    return x25519_err(X25519Error.InvalidLen)
  .end
  if (scalar32.len < 32) or (u32.len < 32)
    return x25519_err(X25519Error.InvalidLen)
  .end

  # Copy scalar and clamp
  let s = copy_32_from_slice(scalar32)
  if not s.1
    return x25519_err(X25519Error.InvalidLen)
  .end

  let sv : coll.Vec[u8] = clamp_x25519_scalar(s.0)

  let ss : t.ByteSlice = t.ByteSlice
  ss.ptr = sv.ptr()
  ss.len = 32

  # Decode u
  let uu = fe_from_u_bytes(u32)
  if not uu.1
    return x25519_err(X25519Error.InvalidInput)
  .end

  let x : fe.Fe = mont_ladder_u(uu.0, ss)

  fe_to_u_bytes(out32, x)

  return x25519_ok()
.end

fn x25519_base_view(out32 : t.MutByteSlice, scalar32 : t.ByteSlice) -> X25519Status
  let bp : coll.Vec[u8] = basepoint_u_bytes()
  let u : t.ByteSlice = t.ByteSlice
  u.ptr = bp.ptr()
  u.len = 32

  return x25519_view(out32, scalar32, u)
.end

# Convenience: owned vectors
fn x25519(scalar32 : coll.Vec[u8], u32 : coll.Vec[u8]) -> (coll.Vec[u8], X25519Status)
  let out : coll.Vec[u8] = coll.Vec[u8]
  let i : u32 = 0
  while i < 32
    out.push(0)
    i += 1
  .end

  let o : t.MutByteSlice = t.MutByteSlice
  o.ptr = out.ptr()
  o.len = 32

  let s : t.ByteSlice = t.ByteSlice
  s.ptr = scalar32.ptr()
  s.len = scalar32.len()

  let u : t.ByteSlice = t.ByteSlice
  u.ptr = u32.ptr()
  u.len = u32.len()

  let st : X25519Status = x25519_view(o, s, u)
  return (out, st)
.end

fn x25519_base(scalar32 : coll.Vec[u8]) -> (coll.Vec[u8], X25519Status)
  let bp : coll.Vec[u8] = basepoint_u_bytes()
  return x25519(scalar32, bp)
.end

# ============================================================================
# Smoke tests (pure)
# ============================================================================

fn test_basepoint_encode_decode() -> bool
  let bp : coll.Vec[u8] = basepoint_u_bytes()

  let u : t.ByteSlice = t.ByteSlice
  u.ptr = bp.ptr()
  u.len = 32

  let x = fe_from_u_bytes(u)
  if not x.1
    return false
  .end

  let out : coll.Vec[u8] = coll.Vec[u8]
  let i : u32 = 0
  while i < 32
    out.push(0)
    i += 1
  .end

  let o : t.MutByteSlice = t.MutByteSlice
  o.ptr = out.ptr()
  o.len = 32

  fe_to_u_bytes(o, x.0)

  # canonical u=9 is 0x09 followed by zeros
  if out[0] != 9
    return false
  .end
  let j : u32 = 1
  while j < 32
    if out[j] != 0
      return false
    .end
    j += 1
  .end

  return true
.end

fn test_basepoint_consistency() -> bool
  # x25519_base(k) == x25519(k, basepoint)
  let k : coll.Vec[u8] = coll.Vec[u8]
  let i : u32 = 0
  while i < 32
    k.push((i as u8) + 1)
    i += 1
  .end

  let a = x25519_base(k)
  if a.1.err != X25519Error.Ok
    return false
  .end

  let bp : coll.Vec[u8] = basepoint_u_bytes()
  let b = x25519(k, bp)
  if b.1.err != X25519Error.Ok
    return false
  .end

  let as : t.ByteSlice = t.ByteSlice
  as.ptr = a.0.ptr()
  as.len = 32

  let bs : t.ByteSlice = t.ByteSlice
  bs.ptr = b.0.ptr()
  bs.len = 32

  return ct.ct_eq_bytes(as, bs) == 1
.end

fn test_nonzero_output_for_fixed_scalar() -> bool
  let k : coll.Vec[u8] = coll.Vec[u8]
  let i : u32 = 0
  while i < 32
    # simple deterministic scalar
    k.push((0xA5 ^ (i as u8)) as u8)
    i += 1
  .end

  let r = x25519_base(k)
  if r.1.err != X25519Error.Ok
    return false
  .end

  # not all zeros
  let z : u32 = 0
  while z < 32
    if r.0[z] != 0
      return true
    .end
    z += 1
  .end

  return false
.end

fn run_smoke_tests() -> bool
  if not test_basepoint_encode_decode()
    return false
  .end
  if not test_basepoint_consistency()
    return false
  .end
  if not test_nonzero_output_for_fixed_scalar()
    return false
  .end
  return true
.end

.end
