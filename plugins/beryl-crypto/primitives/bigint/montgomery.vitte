# plugins/crypto/primitives/bigint/montgomery.vitte
# Montgomery
# Blocks use `.end` only.

mod plugins.crypto.primitives.bigint.montgomery

# TODO

.end

# plugins/beryl-crypto/primitives/bigint/montgomery.vitte
# Montgomery arithmetic for big integers â€” MAX+++
# Blocks use `.end` only.
#
# Scope:
#   - Pure, portable Montgomery core (no platform intrinsics).
#   - Limb base: 64-bit (u64).
#   - Variable-length limbs stored little-endian (limbs[0] is least significant).
#
# Notes:
#   - This is a *primitives* layer; higher-level APIs (RSA/ECC) build on it.
#   - Constant-time properties are best-effort: avoid secret-dependent branches where feasible.
#   - Prefer provider-verified primitives if available.

module plugins.crypto.primitives.bigint.montgomery

import std.collections as coll

import plugins.crypto.api.types as t
import plugins.crypto.host.time_const as ct

# ============================================================================
# Types
# ============================================================================

type Limb = u64

type DLimb = u128

struct BigInt
  # little-endian limbs
  limbs : coll.Vec[Limb]
.end

struct BigIntView
  limbs : t.U64Slice
.end

struct BigIntMutView
  limbs : t.MutU64Slice
.end

# A scratch workspace to reduce allocations.
struct BigScratch
  tmp0 : coll.Vec[Limb]
  tmp1 : coll.Vec[Limb]
  tmp2 : coll.Vec[Limb]
.end

fn scratch_new() -> BigScratch
  let s : BigScratch = BigScratch
  s.tmp0 = coll.Vec[Limb]
  s.tmp1 = coll.Vec[Limb]
  s.tmp2 = coll.Vec[Limb]
  return s
.end

# ============================================================================
# Errors
# ============================================================================

enum MontError
  Ok

  InvalidModulus
  InvalidLen

  NonOddModulus
  ZeroModulus

  Unsupported

  BufferTooSmall

  InternalError
.end

struct MontStatus
  err      : MontError
  written  : u64
  required : u64
.end

fn mont_ok() -> MontStatus
  let s : MontStatus = MontStatus
  s.err = MontError.Ok
  s.written = 0
  s.required = 0
  return s
.end

fn mont_err(err : MontError) -> MontStatus
  let s : MontStatus = MontStatus
  s.err = err
  s.written = 0
  s.required = 0
  return s
.end

# ============================================================================
# Montgomery context
# ============================================================================

# Context for a fixed modulus N (odd), with word size w=64.
# We work in radix R = 2^(64*k) where k = number of limbs.
# Precompute:
#   - n0_inv: -N^{-1} mod 2^64
#   - r2: R^2 mod N (used to map into Montgomery domain)
#
# Representation:
#   - modulus: k limbs
#   - r2:      k limbs

struct MontCtx
  k        : u32

  modulus  : coll.Vec[Limb]
  n0_inv   : Limb
  r2       : coll.Vec[Limb]

  # Optional limits
  msg_max  : u64
.end

fn mont_ctx_default() -> MontCtx
  let c : MontCtx = MontCtx
  c.k = 0
  c.modulus = coll.Vec[Limb]
  c.n0_inv = 0
  c.r2 = coll.Vec[Limb]
  c.msg_max = 0
  return c
.end

# ============================================================================
# Small utilities
# ============================================================================

fn limb_is_zero(x : Limb) -> bool
  return x == 0
.end

fn bigint_new_with_len(k : u32) -> BigInt
  let b : BigInt = BigInt
  b.limbs = coll.Vec[Limb]

  # allocate k zeros (requires Vec reserve/push)
  let i : u32 = 0
  while i < k
    b.limbs.push(0)
    i += 1
  .end

  return b
.end

fn bigint_trim_in_place(b_in : BigInt) -> BigInt
  # Remove high zero limbs (not constant-time). Use only for public values.
  let b : BigInt = b_in
  while (b.limbs.len() > 0) and (b.limbs[b.limbs.len() - 1] == 0)
    b.limbs.pop()
  .end
  return b
.end

fn bigint_is_zero_view(x : t.U64Slice) -> bool
  let i : u64 = 0
  while i < x.len
    if x[i] != 0
      return false
    .end
    i += 1
  .end
  return true
.end

fn bigint_is_odd_view(x : t.U64Slice) -> bool
  if x.len == 0
    return false
  .end
  return (x[0] & 1) == 1
.end

# Constant-time compare: returns mask all-ones if a >= b, else 0.
fn ct_ge_u64_slices(a : t.U64Slice, b : t.U64Slice) -> ct.CtMask64
  # Compare from high limb to low limb.
  # This assumes same length.
  let n : u64 = a.len
  let gt : ct.CtMask64 = 0
  let eq : ct.CtMask64 = ~0

  let i : u64 = 0
  while i < n
    let j : u64 = (n - 1) - i

    let ai : u64 = a[j]
    let bi : u64 = b[j]

    let lt : ct.CtMask64 = ct.ct_lt_u64(ai, bi)
    let gt_i : ct.CtMask64 = ct.ct_lt_u64(bi, ai)
    let eq_i : ct.CtMask64 = ct.ct_eq_u64(ai, bi)

    gt |= gt_i & eq
    eq &= eq_i

    # if lt and still eq so far, then a < b; gt remains 0, and eq cleared.
    eq &= ~lt

    i += 1
  .end

  # a >= b iff (gt == 1) or (eq == 1)
  # We have gt mask for a>b, eq mask for equality (after loop).
  return gt | eq
.end

# Constant-time conditional subtract: if x >= m then x -= m.
fn ct_cond_sub_mod(x : t.MutU64Slice, m : t.U64Slice)
  let ge : ct.CtMask64 = ct_ge_u64_slices(x, m)

  # x = x - m if ge == all-ones
  let borrow : u64 = 0
  let i : u64 = 0
  while i < x.len
    let xi : u64 = x[i]
    let mi : u64 = m[i]

    # subtract with borrow: t = xi - mi - borrow
    let t0 : u128 = (xi as u128) - (mi as u128) - (borrow as u128)
    let ti : u64 = (t0 & 0xFFFF_FFFF_FFFF_FFFF) as u64
    let new_borrow : u64 = ((t0 >> 127) & 1) as u64

    # select updated limb or keep original
    x[i] = ct.ct_select_u64(ge, ti, xi)
    borrow = ct.ct_select_u64(ge, new_borrow, borrow)

    i += 1
  .end
.end

# ============================================================================
# Multiplication helpers (schoolbook)
# ============================================================================

fn mul_schoolbook(out : t.MutU64Slice, a : t.U64Slice, b : t.U64Slice)
  # out length must be a.len + b.len, and zeroed by caller.
  let i : u64 = 0
  while i < a.len
    let carry : u128 = 0
    let ai : u128 = a[i] as u128

    let j : u64 = 0
    while j < b.len
      let idx : u64 = i + j
      let cur : u128 = out[idx] as u128

      let prod : u128 = ai * (b[j] as u128)
      let sum : u128 = cur + prod + carry

      out[idx] = (sum & 0xFFFF_FFFF_FFFF_FFFF) as u64
      carry = sum >> 64

      j += 1
    .end

    out[i + b.len] = ((out[i + b.len] as u128) + carry) as u64

    i += 1
  .end
.end

fn sqr_schoolbook(out : t.MutU64Slice, a : t.U64Slice)
  # Simple fallback: mul(a,a)
  mul_schoolbook(out, a, a)
.end

# ============================================================================
# Montgomery n0_inv computation
# ============================================================================

# Compute n0_inv = -N^{-1} mod 2^64, for odd N.
# Uses Newton-Raphson inversion in Z/2^64.
fn mont_compute_n0_inv(n0 : Limb) -> Limb
  # inv = n0^{-1} mod 2^64
  # start with inv = 1 (works for odd), refine inv = inv * (2 - n0*inv)
  let inv : u64 = 1

  # 6 iterations enough for 64-bit (doubling bits each time)
  let i : u32 = 0
  let x : u64 = inv
  while i < 6
    let prod : u128 = (n0 as u128) * (x as u128)
    let two_minus : u64 = (2 - (prod as u64))
    let prod2 : u128 = (x as u128) * (two_minus as u128)
    x = prod2 as u64
    i += 1
  .end

  # n0_inv = -inv mod 2^64
  return (0 - x) as u64
.end

# ============================================================================
# Montgomery reduction
# ============================================================================

# Reduce T (2k limbs) into k limbs: res = T * R^{-1} mod N.
# Classic Coarsely Integrated Operand Scanning (CIOS).
#
# Inputs:
#   - t: 2k limbs (little-endian)
#   - n: k limbs
#   - n0_inv: -n^{-1} mod 2^64
# Output:
#   - out: k limbs
#
# This function uses a local mutable buffer (tbuf) to allow in-place style.

fn mont_reduce_cios(out : t.MutU64Slice, tbuf : t.MutU64Slice, n : t.U64Slice, n0_inv : Limb)
  let k : u64 = n.len

  let i : u64 = 0
  while i < k
    # m = t[i] * n0_inv mod 2^64
    let ti : u64 = tbuf[i]
    let m : u64 = (ti * n0_inv) as u64

    # t += m * n * b^i
    let carry : u128 = 0
    let c : u128 = 0

    let j : u64 = 0
    let cc : u128 = 0
    while j < k
      let idx : u64 = i + j

      let cur : u128 = tbuf[idx] as u128
      let add : u128 = (m as u128) * (n[j] as u128)

      let sum : u128 = cur + add + cc
      tbuf[idx] = (sum & 0xFFFF_FFFF_FFFF_FFFF) as u64
      cc = sum >> 64

      j += 1
    .end

    # propagate carry to t[i+k]
    let idx2 : u64 = i + k
    let sum2 : u128 = (tbuf[idx2] as u128) + cc
    tbuf[idx2] = (sum2 & 0xFFFF_FFFF_FFFF_FFFF) as u64

    # Further carry propagation if sum2 overflowed
    let carry2 : u128 = sum2 >> 64
    if carry2 != 0
      let z : u64 = idx2 + 1
      while carry2 != 0
        if z >= tbuf.len
          # should not happen for correct sizes
          break
        .end
        let s3 : u128 = (tbuf[z] as u128) + carry2
        tbuf[z] = (s3 & 0xFFFF_FFFF_FFFF_FFFF) as u64
        carry2 = s3 >> 64
        z += 1
      .end
    .end

    i += 1
  .end

  # result is upper k limbs of tbuf
  let j2 : u64 = 0
  while j2 < k
    out[j2] = tbuf[j2 + k]
    j2 += 1
  .end

  # conditional subtract modulus
  ct_cond_sub_mod(out, n)
.end

# ============================================================================
# Montgomery multiplication / squaring
# ============================================================================

fn mont_mul(out : t.MutU64Slice, aM : t.U64Slice, bM : t.U64Slice, ctx : MontCtx, scratch : BigScratch) -> MontStatus
  if (aM.len != ctx.k as u64) or (bM.len != ctx.k as u64) or (out.len != ctx.k as u64)
    return mont_err(MontError.InvalidLen)
  .end

  let k : u64 = ctx.k as u64

  # tbuf = 2k limbs
  scratch.tmp0.clear()
  let i : u64 = 0
  while i < (2 * k)
    scratch.tmp0.push(0)
    i += 1
  .end

  # multiply into tmp0
  let tview : t.MutU64Slice = t.MutU64Slice
  tview.ptr = scratch.tmp0.ptr()
  tview.len = 2 * k

  let av : t.U64Slice = t.U64Slice
  av.ptr = aM.ptr
  av.len = k

  let bv : t.U64Slice = t.U64Slice
  bv.ptr = bM.ptr
  bv.len = k

  mul_schoolbook(tview, av, bv)

  # reduction in-place
  let outv : t.MutU64Slice = out

  let nv : t.U64Slice = t.U64Slice
  nv.ptr = ctx.modulus.ptr()
  nv.len = k

  mont_reduce_cios(outv, tview, nv, ctx.n0_inv)

  return mont_ok()
.end

fn mont_sqr(out : t.MutU64Slice, aM : t.U64Slice, ctx : MontCtx, scratch : BigScratch) -> MontStatus
  if (aM.len != ctx.k as u64) or (out.len != ctx.k as u64)
    return mont_err(MontError.InvalidLen)
  .end

  let k : u64 = ctx.k as u64

  scratch.tmp0.clear()
  let i : u64 = 0
  while i < (2 * k)
    scratch.tmp0.push(0)
    i += 1
  .end

  let tview : t.MutU64Slice = t.MutU64Slice
  tview.ptr = scratch.tmp0.ptr()
  tview.len = 2 * k

  let av : t.U64Slice = t.U64Slice
  av.ptr = aM.ptr
  av.len = k

  sqr_schoolbook(tview, av)

  let nv : t.U64Slice = t.U64Slice
  nv.ptr = ctx.modulus.ptr()
  nv.len = k

  mont_reduce_cios(out, tview, nv, ctx.n0_inv)

  return mont_ok()
.end

# ============================================================================
# Conversion to/from Montgomery domain
# ============================================================================

# out = a * R mod N  (Montgomery form)
# Implemented as mont_mul(a, R^2) -> aR.

fn mont_to(out : t.MutU64Slice, a : t.U64Slice, ctx : MontCtx, scratch : BigScratch) -> MontStatus
  if (a.len != ctx.k as u64) or (out.len != ctx.k as u64)
    return mont_err(MontError.InvalidLen)
  .end

  let r2v : t.U64Slice = t.U64Slice
  r2v.ptr = ctx.r2.ptr()
  r2v.len = ctx.k as u64

  return mont_mul(out, a, r2v, ctx, scratch)
.end

# out = aM * 1 mod N  (back to normal)
# Implemented as mont_mul(aM, 1).

fn mont_from(out : t.MutU64Slice, aM : t.U64Slice, ctx : MontCtx, scratch : BigScratch) -> MontStatus
  if (aM.len != ctx.k as u64) or (out.len != ctx.k as u64)
    return mont_err(MontError.InvalidLen)
  .end

  # one in normal domain
  scratch.tmp1.clear()
  let i : u64 = 0
  while i < (ctx.k as u64)
    scratch.tmp1.push(0)
    i += 1
  .end
  scratch.tmp1[0] = 1

  let onev : t.U64Slice = t.U64Slice
  onev.ptr = scratch.tmp1.ptr()
  onev.len = ctx.k as u64

  return mont_mul(out, aM, onev, ctx, scratch)
.end

# ============================================================================
# Exponentiation (Montgomery ladder)
# ============================================================================

# Exponent is provided as big-endian bits from a byte slice.
# Computes out = (base^exp) mod N.
# base is normal domain (not Montgomery).

fn mont_pow_ladder(out : t.MutU64Slice, base : t.U64Slice, exp_be : t.ByteSlice, ctx : MontCtx, scratch : BigScratch) -> MontStatus
  if (base.len != ctx.k as u64) or (out.len != ctx.k as u64)
    return mont_err(MontError.InvalidLen)
  .end

  let k : u64 = ctx.k as u64

  # r0 = 1 (Mont), r1 = base (Mont)
  scratch.tmp0.clear()
  scratch.tmp1.clear()

  let i0 : u64 = 0
  while i0 < k
    scratch.tmp0.push(0)
    scratch.tmp1.push(0)
    i0 += 1
  .end

  scratch.tmp0[0] = 1

  let r0 : t.MutU64Slice = t.MutU64Slice
  r0.ptr = scratch.tmp0.ptr()
  r0.len = k

  let r1 : t.MutU64Slice = t.MutU64Slice
  r1.ptr = scratch.tmp1.ptr()
  r1.len = k

  # Convert r0 and r1 to Montgomery domain
  let st0 : MontStatus = mont_to(r0, r0, ctx, scratch)
  if st0.err != MontError.Ok
    return st0
  .end

  let st1 : MontStatus = mont_to(r1, base, ctx, scratch)
  if st1.err != MontError.Ok
    return st1
  .end

  # Process exponent bits MSB->LSB
  let bi : u64 = 0
  while bi < exp_be.len
    let byte : u8 = exp_be[bi]

    let bit_i : u32 = 0
    while bit_i < 8
      let bitpos : u32 = 7 - bit_i
      let bit : u8 = (byte >> bitpos) & 1
      let mask8 : ct.CtMask8 = ct.ct_mask8_from_bit(bit)

      # if bit == 0:
      #   r1 = r0*r1
      #   r0 = r0*r0
      # else:
      #   r0 = r0*r1
      #   r1 = r1*r1
      # Use conditional swap to keep pattern constant.

      ct.ct_cond_swap(mask8, r0, r1)

      # r0 = r0 * r1
      scratch.tmp2.clear()
      let z : u64 = 0
      while z < k
        scratch.tmp2.push(0)
        z += 1
      .end

      let prod : t.MutU64Slice = t.MutU64Slice
      prod.ptr = scratch.tmp2.ptr()
      prod.len = k

      let s2 : MontStatus = mont_mul(prod, r0, r1, ctx, scratch)
      if s2.err != MontError.Ok
        return s2
      .end

      # r1 = r1 * r1
      let s3 : MontStatus = mont_sqr(r1, r1, ctx, scratch)
      if s3.err != MontError.Ok
        return s3
      .end

      # r0 = prod
      # constant-time copy
      let dv : t.MutU64Slice = r0
      let sv : t.U64Slice = t.U64Slice
      sv.ptr = scratch.tmp2.ptr()
      sv.len = k
      ct.ct_cond_copy(0xFF as u8, dv, sv)

      ct.ct_cond_swap(mask8, r0, r1)

      bit_i += 1
    .end

    bi += 1
  .end

  # Convert r0 back
  let stf : MontStatus = mont_from(out, r0, ctx, scratch)
  return stf
.end

# ============================================================================
# R^2 mod N computation (naive)
# ============================================================================

# Compute r2 = (R mod N)^2 mod N.
# Here R = 2^(64k). R mod N is 0 in limbs domain but we can compute r2 as:
#   r2 = ( (2^(64k) mod N) * (2^(64k) mod N) ) mod N
# In practice, compute r2 by reducing a 2k-limb number with 1 at position 2k.
#
# This is a portable but not optimized approach.

fn mont_compute_r2(k : u32, n : t.U64Slice, n0_inv : Limb, scratch : BigScratch) -> coll.Vec[Limb]
  let kk : u64 = k as u64

  scratch.tmp0.clear()
  let i : u64 = 0
  while i < (2 * kk)
    scratch.tmp0.push(0)
    i += 1
  .end

  # Set tbuf = R^2 = 2^(128k) which in 2k limbs is 1 at index 2k (out of range).
  # Instead, set tbuf = 0 and interpret mont_reduce to compute (t * R^{-1}) mod N.
  # A standard trick: compute r2 = (R mod N) in Montgomery by converting 1: mont_to(1).
  # We'll do:
  #   r2 = mont_to(1) * mont_to(1) in normal domain? Too circular.
  #
  # Practical portable approach:
  #   compute r2 = ( (1 << (64k)) mod N ) * (1 << (64k)) mod N via repeated doubling.
  # This is O(k^2*64k) but acceptable for context setup.

  # start x = 1
  scratch.tmp1.clear()
  let j : u64 = 0
  while j < kk
    scratch.tmp1.push(0)
    j += 1
  .end
  scratch.tmp1[0] = 1

  # perform 2*64k doublings mod N: x = x * 2^(128k) mod N => x = R^2 mod N
  let steps : u64 = 128 * kk

  let step : u64 = 0
  while step < steps
    # x = x + x mod N
    let carry : u64 = 0
    let idx : u64 = 0
    while idx < kk
      let sum : u128 = (scratch.tmp1[idx] as u128) + (scratch.tmp1[idx] as u128) + (carry as u128)
      scratch.tmp1[idx] = (sum & 0xFFFF_FFFF_FFFF_FFFF) as u64
      carry = (sum >> 64) as u64
      idx += 1
    .end

    # if carry, subtract N (still needs mod). We just do conditional subtract.
    let xv : t.MutU64Slice = t.MutU64Slice
    xv.ptr = scratch.tmp1.ptr()
    xv.len = kk

    ct_cond_sub_mod(xv, n)

    step += 1
  .end

  # r2 in tmp1
  let r2 : coll.Vec[Limb] = coll.Vec[Limb]
  let ii : u64 = 0
  while ii < kk
    r2.push(scratch.tmp1[ii])
    ii += 1
  .end

  return r2
.end

# ============================================================================
# Context init
# ============================================================================

fn mont_ctx_init_from_modulus(modulus : coll.Vec[Limb]) -> (MontCtx, MontStatus)
  let ctx : MontCtx = mont_ctx_default()

  if modulus.len() == 0
    return (ctx, mont_err(MontError.ZeroModulus))
  .end

  # modulus must be odd for Montgomery
  # Build a slice view.
  let nv : t.U64Slice = t.U64Slice
  nv.ptr = modulus.ptr()
  nv.len = modulus.len()

  if not bigint_is_odd_view(nv)
    return (ctx, mont_err(MontError.NonOddModulus))
  .end

  if bigint_is_zero_view(nv)
    return (ctx, mont_err(MontError.ZeroModulus))
  .end

  ctx.k = modulus.len() as u32
  ctx.modulus = modulus

  # n0_inv uses lowest limb
  ctx.n0_inv = mont_compute_n0_inv(ctx.modulus[0])

  let scratch : BigScratch = scratch_new()

  # compute r2
  let nview : t.U64Slice = t.U64Slice
  nview.ptr = ctx.modulus.ptr()
  nview.len = ctx.k as u64

  ctx.r2 = mont_compute_r2(ctx.k, nview, ctx.n0_inv, scratch)

  return (ctx, mont_ok())
.end

# ============================================================================
# Public convenience APIs (owned buffers)
# ============================================================================

fn mont_mul_owned(aM : BigInt, bM : BigInt, ctx : MontCtx) -> (BigInt, MontStatus)
  let out : BigInt = bigint_new_with_len(ctx.k)
  let scratch : BigScratch = scratch_new()

  let av : t.U64Slice = t.U64Slice
  av.ptr = aM.limbs.ptr()
  av.len = ctx.k as u64

  let bv : t.U64Slice = t.U64Slice
  bv.ptr = bM.limbs.ptr()
  bv.len = ctx.k as u64

  let ov : t.MutU64Slice = t.MutU64Slice
  ov.ptr = out.limbs.ptr()
  ov.len = ctx.k as u64

  let st : MontStatus = mont_mul(ov, av, bv, ctx, scratch)
  return (out, st)
.end

fn mont_pow_owned(base : BigInt, exp_be : t.ByteSlice, ctx : MontCtx) -> (BigInt, MontStatus)
  let out : BigInt = bigint_new_with_len(ctx.k)
  let scratch : BigScratch = scratch_new()

  let bv : t.U64Slice = t.U64Slice
  bv.ptr = base.limbs.ptr()
  bv.len = ctx.k as u64

  let ov : t.MutU64Slice = t.MutU64Slice
  ov.ptr = out.limbs.ptr()
  ov.len = ctx.k as u64

  let st : MontStatus = mont_pow_ladder(ov, bv, exp_be, ctx, scratch)
  return (out, st)
.end

# ============================================================================
# Tests (pure)
# ============================================================================

fn test_n0_inv_basic() -> bool
  # For odd n0, inv = n0 * (-n0_inv) == 1 mod 2^64
  let n0 : u64 = 0xF13B_7A2D_9C01_0001
  let n0_inv : u64 = mont_compute_n0_inv(n0)
  let inv : u64 = (0 - n0_inv) as u64
  let prod : u64 = (n0 * inv) as u64
  if prod != 1
    return false
  .end
  return true
.end

fn test_mul_reduce_small() -> bool
  # Tiny modulus: 17
  let m : coll.Vec[u64] = coll.Vec[u64]
  m.push(17)

  let tup = mont_ctx_init_from_modulus(m)
  let ctx : MontCtx = tup.0
  let st : MontStatus = tup.1
  if st.err != MontError.Ok
    return false
  .end

  let scratch : BigScratch = scratch_new()

  # a=5, b=7
  let a : coll.Vec[u64] = coll.Vec[u64]
  a.push(5)
  let b : coll.Vec[u64] = coll.Vec[u64]
  b.push(7)

  let av : t.U64Slice = t.U64Slice
  av.ptr = a.ptr()
  av.len = 1

  let bv : t.U64Slice = t.U64Slice
  bv.ptr = b.ptr()
  bv.len = 1

  # to mont
  let aMbuf : coll.Vec[u64] = coll.Vec[u64]
  aMbuf.push(0)
  let bMbuf : coll.Vec[u64] = coll.Vec[u64]
  bMbuf.push(0)

  let aMv : t.MutU64Slice = t.MutU64Slice
  aMv.ptr = aMbuf.ptr()
  aMv.len = 1

  let bMv : t.MutU64Slice = t.MutU64Slice
  bMv.ptr = bMbuf.ptr()
  bMv.len = 1

  let s0 : MontStatus = mont_to(aMv, av, ctx, scratch)
  if s0.err != MontError.Ok
    return false
  .end

  let s1 : MontStatus = mont_to(bMv, bv, ctx, scratch)
  if s1.err != MontError.Ok
    return false
  .end

  # mul
  let outMbuf : coll.Vec[u64] = coll.Vec[u64]
  outMbuf.push(0)
  let outMv : t.MutU64Slice = t.MutU64Slice
  outMv.ptr = outMbuf.ptr()
  outMv.len = 1

  let aMs : t.U64Slice = t.U64Slice
  aMs.ptr = aMbuf.ptr()
  aMs.len = 1

  let bMs : t.U64Slice = t.U64Slice
  bMs.ptr = bMbuf.ptr()
  bMs.len = 1

  let s2 : MontStatus = mont_mul(outMv, aMs, bMs, ctx, scratch)
  if s2.err != MontError.Ok
    return false
  .end

  # from mont
  let outbuf : coll.Vec[u64] = coll.Vec[u64]
  outbuf.push(0)
  let outv : t.MutU64Slice = t.MutU64Slice
  outv.ptr = outbuf.ptr()
  outv.len = 1

  let outMs : t.U64Slice = t.U64Slice
  outMs.ptr = outMbuf.ptr()
  outMs.len = 1

  let s3 : MontStatus = mont_from(outv, outMs, ctx, scratch)
  if s3.err != MontError.Ok
    return false
  .end

  # 5*7 mod 17 = 1
  if outbuf[0] != 1
    return false
  .end

  return true
.end

fn run_smoke_tests() -> bool
  if not test_n0_inv_basic()
    return false
  .end
  if not test_mul_reduce_small()
    return false
  .end
  return true
.end

.end