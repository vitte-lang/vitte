# plugins/beryl-crypto/host/audit.vitte
# Audit channel (host/runtime) — MAX+++
# Blocks use `.end` only.
#
# Objectifs:
#   - Schéma stable d’évènements audit (crypto operations)
#   - Redaction systématique (aucun secret / clé / plaintext)
#   - Hooks runtime (sink) + buffers + filtering
#   - ABI-friendly structs (marshalling)
#
# NOTE:
#   - Audit ≠ logging debug. Audit doit être stable, minimal, non-secret.
#   - L’audit doit survivre aux erreurs (best-effort, pas de panic).

module plugins.crypto.host.audit

import std.collections as coll

import plugins.crypto.api.types as t

# ============================================================================
# Errors / status
# ============================================================================

enum AuditError
  Ok
  Unsupported
  Disabled
  BufferTooSmall
  InvalidInput
  RateLimited
  InternalError
.end

struct AuditStatus
  err     : AuditError
  written : u64
  dropped : u64
.end

fn audit_ok(written : u64) -> AuditStatus
  let s : AuditStatus = AuditStatus
  s.err = AuditError.Ok
  s.written = written
  s.dropped = 0
  return s
.end

fn audit_err(err : AuditError) -> AuditStatus
  let s : AuditStatus = AuditStatus
  s.err = err
  s.written = 0
  s.dropped = 0
  return s
.end

# ============================================================================
# Core enums
# ============================================================================

enum AuditLevel
  Info
  Warn
  Error
.end

enum AuditFamily
  Host
  Rand
  Entropy
  Aead
  Cipher
  Hash
  Mac
  Kex
  Sign
  Registry
.end

enum AuditAction
  Enumerate
  Query
  Select

  Create
  Destroy

  Generate
  Import
  Export

  Seal
  Open

  Encrypt
  Decrypt

  Start
  Update
  Finish

  Fill
  Reseed
  HealthCheck
.end

enum AuditOutcome
  Ok
  Err
  Unsupported
  Denied
.end

# ============================================================================
# Redaction policy
# ============================================================================

enum RedactionMode
  # strict: never include payload bytes
  Strict

  # allow metadata only: sizes, ids, flags
  MetaOnly

  # allow hashed identifiers (no raw)
  HashedIds
.end

struct AuditRedaction
  mode            : RedactionMode

  # if HashedIds: include truncated digest of ids (provider-defined)
  hash_ids        : bool
  hash_trunc      : u32

  # if true: include message lengths and buffer sizes
  include_sizes   : bool

  # if true: include error codes but not stack/context
  include_errors  : bool
.end

fn audit_redaction_default() -> AuditRedaction
  let r : AuditRedaction = AuditRedaction
  r.mode = RedactionMode.Strict
  r.hash_ids = false
  r.hash_trunc = 0
  r.include_sizes = true
  r.include_errors = true
  return r
.end

# ============================================================================
# Event schema (stable)
# ============================================================================

struct AuditIds
  provider_id : string
  alg_id      : string

  # opaque handles (slot+gen) rendered as u64, no pointer addresses
  key_handle  : u64
  ctx_handle  : u64
  stream_handle : u64
.end

fn audit_ids_default() -> AuditIds
  let i : AuditIds = AuditIds
  i.provider_id = ""
  i.alg_id = ""
  i.key_handle = 0
  i.ctx_handle = 0
  i.stream_handle = 0
  return i
.end

struct AuditSizes
  msg_len   : u64
  aad_len   : u64
  out_len   : u64

  nonce_len : u64
  tag_len   : u64
  key_len   : u64
.end

fn audit_sizes_default() -> AuditSizes
  let s : AuditSizes = AuditSizes
  s.msg_len = 0
  s.aad_len = 0
  s.out_len = 0
  s.nonce_len = 0
  s.tag_len = 0
  s.key_len = 0
  return s
.end

struct AuditErrorInfo
  code    : u32
  domain  : string
  reason  : string
.end

fn audit_error_info_default() -> AuditErrorInfo
  let e : AuditErrorInfo = AuditErrorInfo
  e.code = 0
  e.domain = ""
  e.reason = ""
  return e
.end

struct AuditEvent
  # stable header
  level     : AuditLevel
  family    : AuditFamily
  action    : AuditAction
  outcome   : AuditOutcome

  # time/id
  ts_ms     : u64
  seq       : u64

  # identity + sizes
  ids       : AuditIds
  sizes     : AuditSizes

  # optional flags (policy bits, caps bits, etc.)
  flags     : u64

  # errors (redacted)
  err       : AuditErrorInfo

  # generic note (no secrets)
  note      : string
.end

fn audit_event_default() -> AuditEvent
  let ev : AuditEvent = AuditEvent
  ev.level = AuditLevel.Info
  ev.family = AuditFamily.Host
  ev.action = AuditAction.Query
  ev.outcome = AuditOutcome.Ok
  ev.ts_ms = 0
  ev.seq = 0
  ev.ids = audit_ids_default()
  ev.sizes = audit_sizes_default()
  ev.flags = 0
  ev.err = audit_error_info_default()
  ev.note = ""
  return ev
.end

# ============================================================================
# Filters / routing
# ============================================================================

struct AuditFilter
  enabled : bool

  min_level : AuditLevel

  allow_host     : bool
  allow_registry : bool

  allow_rand     : bool
  allow_entropy  : bool

  allow_aead     : bool
  allow_cipher   : bool
  allow_hash     : bool
  allow_mac      : bool
  allow_kex      : bool
  allow_sign     : bool

  # if non-empty: only these providers/algs
  provider_allow : coll.Vec[string]
  alg_allow      : coll.Vec[string]
.end

fn audit_filter_default() -> AuditFilter
  let f : AuditFilter = AuditFilter
  f.enabled = true
  f.min_level = AuditLevel.Info

  f.allow_host = true
  f.allow_registry = true

  f.allow_rand = true
  f.allow_entropy = true

  f.allow_aead = true
  f.allow_cipher = true
  f.allow_hash = true
  f.allow_mac = true
  f.allow_kex = true
  f.allow_sign = true

  f.provider_allow = coll.Vec[string]
  f.alg_allow = coll.Vec[string]
  return f
.end

fn audit_level_ge(a : AuditLevel, b : AuditLevel) -> bool
  # Info < Warn < Error
  if a == b
    return true
  .end
  if a == AuditLevel.Error
    return true
  .end
  if (a == AuditLevel.Warn) and (b == AuditLevel.Info)
    return true
  .end
  return false
.end

fn audit_family_allowed(f : AuditFilter, fam : AuditFamily) -> bool
  if fam == AuditFamily.Host
    return f.allow_host
  .end
  if fam == AuditFamily.Registry
    return f.allow_registry
  .end
  if fam == AuditFamily.Rand
    return f.allow_rand
  .end
  if fam == AuditFamily.Entropy
    return f.allow_entropy
  .end
  if fam == AuditFamily.Aead
    return f.allow_aead
  .end
  if fam == AuditFamily.Cipher
    return f.allow_cipher
  .end
  if fam == AuditFamily.Hash
    return f.allow_hash
  .end
  if fam == AuditFamily.Mac
    return f.allow_mac
  .end
  if fam == AuditFamily.Kex
    return f.allow_kex
  .end
  if fam == AuditFamily.Sign
    return f.allow_sign
  .end
  return false
.end

fn vec_contains_str(v : coll.Vec[string], s : string) -> bool
  let i : u64 = 0
  while i < v.len()
    if v[i] == s
      return true
    .end
    i += 1
  .end
  return false
.end

fn audit_filter_match(f : AuditFilter, ev : AuditEvent) -> bool
  if not f.enabled
    return false
  .end

  if not audit_level_ge(ev.level, f.min_level)
    return false
  .end

  if not audit_family_allowed(f, ev.family)
    return false
  .end

  if f.provider_allow.len() != 0
    if not vec_contains_str(f.provider_allow, ev.ids.provider_id)
      return false
    .end
  .end

  if f.alg_allow.len() != 0
    if not vec_contains_str(f.alg_allow, ev.ids.alg_id)
      return false
    .end
  .end

  return true
.end

# ============================================================================
# Redaction
# ============================================================================

fn audit_redact_in_place(red : AuditRedaction, ev_in : AuditEvent) -> AuditEvent
  let ev : AuditEvent = ev_in

  # Always remove anything that could be sensitive.
  # (This schema already avoids payload bytes; keep it defensive.)

  if red.mode == RedactionMode.Strict
    # drop note by default to avoid accidental secrets
    ev.note = ""
  .end

  if not red.include_sizes
    ev.sizes = audit_sizes_default()
  .end

  if not red.include_errors
    ev.err = audit_error_info_default()
  .end

  # HashedIds is provider/runtime-defined; we only gate what fields may remain.
  if red.mode == RedactionMode.MetaOnly
    # keep ids but still safe (ids are strings, could leak tenant); let caller decide
  .end

  return ev
.end

# ============================================================================
# Sink interface (runtime hook)
# ============================================================================

# The runtime supplies a sink; host code calls `audit_emit`.
# The sink is responsible for IO, storage, upload, etc.

struct AuditSink
  # placeholder opaque reference to runtime sink (handle)
  h : u64
.end

struct AuditConfig
  enabled   : bool
  filter    : AuditFilter
  redaction : AuditRedaction

  # rate limiting (best-effort)
  rate_per_sec : u32
  burst        : u32
.end

fn audit_config_default() -> AuditConfig
  let c : AuditConfig = AuditConfig
  c.enabled = false
  c.filter = audit_filter_default()
  c.redaction = audit_redaction_default()
  c.rate_per_sec = 0
  c.burst = 0
  return c
.end

struct AuditRuntimeState
  seq       : u64
  dropped   : u64
.end

fn audit_state_default() -> AuditRuntimeState
  let s : AuditRuntimeState = AuditRuntimeState
  s.seq = 0
  s.dropped = 0
  return s
.end

fn audit_sink_default() -> AuditSink
  let s : AuditSink = AuditSink
  s.h = 0
  return s
.end

fn audit_sink_write_event(sink : AuditSink, ev : AuditEvent) -> AuditError
  # runtime hook: persist/forward event
  # default: unsupported
  return AuditError.Unsupported
.end

fn audit_emit(cfg : AuditConfig, state_in : AuditRuntimeState, sink : AuditSink, ev_in : AuditEvent) -> AuditRuntimeState
  let state : AuditRuntimeState = state_in

  if not cfg.enabled
    return state
  .end

  # assign seq (monotonic best-effort; thread-safe sequencing is runtime responsibility)
  state.seq += 1

  let ev0 : AuditEvent = ev_in
  ev0.seq = state.seq

  # filter
  if not audit_filter_match(cfg.filter, ev0)
    return state
  .end

  # redact
  let ev : AuditEvent = audit_redact_in_place(cfg.redaction, ev0)

  let werr : AuditError = audit_sink_write_event(sink, ev)
  if werr != AuditError.Ok
    state.dropped += 1
  .end

  return state
.end

# ============================================================================
# Helpers to build common events (no secrets)
# ============================================================================

fn audit_event_op(fam : AuditFamily, act : AuditAction, ok : bool) -> AuditEvent
  let ev : AuditEvent = audit_event_default()
  ev.family = fam
  ev.action = act
  if ok
    ev.outcome = AuditOutcome.Ok
    ev.level = AuditLevel.Info
  .end
  if not ok
    ev.outcome = AuditOutcome.Err
    ev.level = AuditLevel.Error
  .end
  return ev
.end

fn audit_set_ids(ev_in : AuditEvent, provider_id : string, alg_id : string, key : u64, ctx : u64, stream : u64) -> AuditEvent
  let ev : AuditEvent = ev_in
  ev.ids.provider_id = provider_id
  ev.ids.alg_id = alg_id
  ev.ids.key_handle = key
  ev.ids.ctx_handle = ctx
  ev.ids.stream_handle = stream
  return ev
.end

fn audit_set_sizes_aead(ev_in : AuditEvent, msg : u64, aad : u64, out : u64, nonce : u64, tag : u64, key : u64) -> AuditEvent
  let ev : AuditEvent = ev_in
  ev.sizes.msg_len = msg
  ev.sizes.aad_len = aad
  ev.sizes.out_len = out
  ev.sizes.nonce_len = nonce
  ev.sizes.tag_len = tag
  ev.sizes.key_len = key
  return ev
.end

fn audit_set_error(ev_in : AuditEvent, domain : string, code : u32, reason : string) -> AuditEvent
  let ev : AuditEvent = ev_in
  ev.err.domain = domain
  ev.err.code = code
  ev.err.reason = reason
  ev.outcome = AuditOutcome.Err
  ev.level = AuditLevel.Error
  return ev
.end

# ============================================================================
# Smoke tests
# ============================================================================

fn test_filter_basic() -> bool
  let f : AuditFilter = audit_filter_default()
  let ev : AuditEvent = audit_event_default()
  ev.family = AuditFamily.Aead
  ev.level = AuditLevel.Info
  if not audit_filter_match(f, ev)
    return false
  .end

  f.allow_aead = false
  if audit_filter_match(f, ev)
    return false
  .end

  return true
.end

fn test_redaction_strict() -> bool
  let r : AuditRedaction = audit_redaction_default()
  r.mode = RedactionMode.Strict
  r.include_sizes = false
  r.include_errors = false

  let ev : AuditEvent = audit_event_default()
  ev.note = "should disappear"
  ev.sizes.msg_len = 123
  ev.err.domain = "x"

  let out : AuditEvent = audit_redact_in_place(r, ev)
  if out.note != ""
    return false
  .end
  if out.sizes.msg_len != 0
    return false
  .end
  if out.err.domain != ""
    return false
  .end
  return true
.end

fn run_smoke_tests() -> bool
  if not test_filter_basic()
    return false
  .end
  if not test_redaction_strict()
    return false
  .end
  return true
.end

.end