

# plugins/beryl-crypto/primitives/bigint/mod.vitte
# BigInt primitives umbrella — MAX++ (2025)
# Blocks use `.end` only.
#
# Purpose:
#   - Provide a stable entry module for bigint primitives.
#   - Re-export reduce + montgomery.
#   - Add small glue helpers so higher layers (RSA/ECC) don’t import internals directly.

module plugins.crypto.primitives.bigint

import std.collections as coll

import plugins.crypto.api.types as t

import plugins.crypto.primitives.bigint.reduce as red
import plugins.crypto.primitives.bigint.montgomery as mont

# ============================================================================
# Re-exports (type aliases)
# ============================================================================

type Limb = u64

type BigInt = red.BigInt

type BigScratch = red.BigScratch

type ReduceStatus = red.ReduceStatus

type ReduceError = red.ReduceError

type BarrettCtx = red.BarrettCtx


type MontCtx = mont.MontCtx

type MontStatus = mont.MontStatus

type MontError = mont.MontError

# ============================================================================
# Constructors / conversions
# ============================================================================

fn scratch_new() -> BigScratch
  return red.scratch_new()
.end

fn bigint_new() -> BigInt
  let b : BigInt = BigInt
  b.limbs = coll.Vec[Limb]
  return b
.end

fn bigint_new_with_len(k : u32) -> BigInt
  # fixed-len, zeroed
  let b : BigInt = BigInt
  b.limbs = coll.Vec[Limb]

  let i : u32 = 0
  while i < k
    b.limbs.push(0)
    i += 1
  .end

  return b
.end

fn bigint_trim_public(x : BigInt) -> BigInt
  # Not constant-time; only for public values.
  return red.trim_in_place(x)
.end

fn limbs_from_be_bytes(dst : coll.Vec[Limb], be : t.ByteSlice, k : u32) -> coll.Vec[Limb]
  return red.limbs_from_be_bytes(dst, be, k)
.end

fn be_bytes_from_limbs(out : t.MutByteSlice, x : t.U64Slice)
  red.be_bytes_from_limbs(out, x)
.end

# ============================================================================
# Basic comparison helpers
# ============================================================================

fn cmp_k(a : t.U64Slice, b : t.U64Slice) -> i32
  return red.cmp(a, b)
.end

fn is_zero_k(x : t.U64Slice) -> bool
  return red.is_zero_view(x)
.end

# ============================================================================
# Reduction and modular arithmetic (Barrett-based)
# ============================================================================

fn barrett_ctx_init(modulus : coll.Vec[Limb]) -> (BarrettCtx, ReduceStatus)
  return red.barrett_ctx_init(modulus)
.end

fn mod_add_k(out : t.MutU64Slice, a : t.U64Slice, b : t.U64Slice, m : t.U64Slice) -> ReduceStatus
  return red.mod_add_k(out, a, b, m)
.end

fn mod_sub_k(out : t.MutU64Slice, a : t.U64Slice, b : t.U64Slice, m : t.U64Slice) -> ReduceStatus
  return red.mod_sub_k(out, a, b, m)
.end

fn mod_mul_k_barrett(out : t.MutU64Slice, a : t.U64Slice, b : t.U64Slice, ctx : BarrettCtx, scratch : BigScratch) -> ReduceStatus
  return red.mod_mul_k(out, a, b, ctx, scratch)
.end

fn reduce_u64(x : t.U64Slice, m : u64) -> u64
  return red.mod_u64_from_limbs(x, m)
.end

# ============================================================================
# Montgomery arithmetic (modexp / fast mul)
# ============================================================================

fn mont_ctx_init_from_modulus(modulus : coll.Vec[Limb]) -> (MontCtx, MontStatus)
  return mont.mont_ctx_init_from_modulus(modulus)
.end

fn mont_to(out : t.MutU64Slice, a : t.U64Slice, ctx : MontCtx, scratch : mont.BigScratch) -> MontStatus
  return mont.mont_to(out, a, ctx, scratch)
.end

fn mont_from(out : t.MutU64Slice, aM : t.U64Slice, ctx : MontCtx, scratch : mont.BigScratch) -> MontStatus
  return mont.mont_from(out, aM, ctx, scratch)
.end

fn mont_mul(out : t.MutU64Slice, aM : t.U64Slice, bM : t.U64Slice, ctx : MontCtx, scratch : mont.BigScratch) -> MontStatus
  return mont.mont_mul(out, aM, bM, ctx, scratch)
.end

fn mont_pow(out : t.MutU64Slice, base : t.U64Slice, exp_be : t.ByteSlice, ctx : MontCtx, scratch : mont.BigScratch) -> MontStatus
  return mont.mont_pow_ladder(out, base, exp_be, ctx, scratch)
.end

# Convenience: allocate scratch and compute pow.
fn mont_pow_owned(base : BigInt, exp_be : t.ByteSlice, ctx : MontCtx) -> (BigInt, MontStatus)
  return mont.mont_pow_owned(base, exp_be, ctx)
.end

# ============================================================================
# Policy glue for higher layers
# ============================================================================

# Normalize operand into [0..m) for public values.
# Uses naive reduction for same-len inputs.
fn normalize_public_mod_k(out : t.MutU64Slice, x : t.U64Slice, m : t.U64Slice) -> ReduceStatus
  let s : red.BigScratch = red.scratch_new()
  return red.reduce_mod_naive_k(out, x, m, s)
.end

# ============================================================================
# Smoke tests
# ============================================================================

fn run_smoke_tests() -> bool
  if not red.run_smoke_tests()
    return false
  .end
  if not mont.run_smoke_tests()
    return false
  .end
  return true
.end

.end