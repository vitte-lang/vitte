# plugins/crypto/benches/b_chacha20_poly1305.vitte
mod plugins.crypto.benches

pub fn main() -> i32
  ret 0
.end

.end

# plugins/beryl-crypto/benches/b_chacha20_poly1305.vitte
# ChaCha20-Poly1305 / XChaCha20-Poly1305 benches — harness (providers + views + streaming) — MAX+++
# Blocks use `.end` only.

module plugins.crypto.benches.b_chacha20_poly1305

import std.collections as coll

import plugins.crypto.api.types as t
import plugins.crypto.api.rand as rand
import plugins.crypto.api.subtle as subtle

# AEAD surface (adapt these wrappers if your API is split by algorithm)
import plugins.crypto.api.aead as aead

# ============================================================================
# Benchmark core types
# ============================================================================

enum BenchError
  Ok
  Unsupported
  InvalidConfig
  RuntimeUnavailable
  ProviderUnavailable
  InternalError
.end

enum BenchUnit
  Ns
  Cycles
.end

enum BenchMode
  OneShot
  OneShotView
  OneShotInPlaceView

  Streaming
  StreamingView

  IoVecView
.end

enum BenchOp
  Seal
  Open
.end

struct BenchTimer
  unit : BenchUnit
.end

struct BenchStats
  iters       : u64
  bytes       : u64

  t_start     : u64
  t_end       : u64
  t_total     : u64

  ns_per_iter : u64
  ns_per_byte : u64

  mib_per_s   : u64
.end

struct BenchCase
  name        : string

  # optional override; if empty use cfg.alg_id
  alg_id      : string

  op          : BenchOp
  mode        : BenchMode

  msg_len     : u32
  aad_len     : u32

  key_len     : u32
  nonce_len   : u32
  tag_len     : u32

  iterations  : u64
  warmup      : u64

  validate    : bool
.end

struct BenchConfig
  provider_id : string
  alg_id      : string

  iterations_default : u64
  warmup_default     : u64

  timer       : BenchTimer

  rng_provider_id : string
  rng_alg_id      : string

  constant_time    : bool
  sidechannel_hard : bool
.end

struct BenchResult
  err         : BenchError
  case        : BenchCase
  stats       : BenchStats

  detail      : string
.end

# ============================================================================
# Bench emit (no I/O here)
# ============================================================================

fn bench_emit_begin(cfg : BenchConfig)
.end

fn bench_emit_case_begin(c : BenchCase)
.end

fn bench_emit_case_end(r : BenchResult)
.end

fn bench_emit_end(cfg : BenchConfig)
.end

# ============================================================================
# Timing / sinks (stubs)
# ============================================================================

fn bench_now_ns() -> u64
  return 0
.end

fn bench_now_cycles() -> u64
  return 0
.end

fn bench_sink_u64(x : u64) -> u64
  return x
.end

fn bench_sink_bytes_view(x : t.ByteSlice) -> u64
  return x.len
.end

# ============================================================================
# Helpers: defaults + case factory
# ============================================================================

fn bench_default_config() -> BenchConfig
  let cfg : BenchConfig = BenchConfig

  cfg.iterations_default = 2000
  cfg.warmup_default = 200

  cfg.timer = BenchTimer
  cfg.timer.unit = BenchUnit.Ns

  cfg.constant_time = true
  cfg.sidechannel_hard = true

  # Default algorithm identifiers (bench can override per-case):
  #   - "chacha20-poly1305"
  #   - "xchacha20-poly1305"
  cfg.alg_id = "chacha20-poly1305"

  return cfg
.end

fn bench_case_make(name : string, alg_id : string, op : BenchOp, mode : BenchMode, msg_len : u32, aad_len : u32) -> BenchCase
  let c : BenchCase = BenchCase

  c.name = name
  c.alg_id = alg_id

  c.op = op
  c.mode = mode

  c.msg_len = msg_len
  c.aad_len = aad_len

  # ChaCha20-Poly1305 family defaults
  c.key_len = 32
  c.nonce_len = 12
  c.tag_len = 16

  c.iterations = 0
  c.warmup = 0

  c.validate = false

  return c
.end

fn bench_case_apply_defaults(cfg : BenchConfig, c : BenchCase) -> BenchCase
  let out : BenchCase = c

  if out.iterations == 0
    out.iterations = cfg.iterations_default
  .end

  if out.warmup == 0
    out.warmup = cfg.warmup_default
  .end

  # Fill algorithm-specific defaults
  let alg : string = out.alg_id
  if alg == ""
    alg = cfg.alg_id
  .end

  # XChaCha uses 24-byte nonce.
  if alg == "xchacha20-poly1305"
    out.nonce_len = 24
  .end

  return out
.end

# ============================================================================
# RNG helpers
# ============================================================================

struct BenchRng
  rng : rand.RandRngRef
.end

fn bench_rng_init(cfg : BenchConfig) -> BenchRng
  let r : BenchRng = BenchRng

  let create_req : rand.RandRngCreateRequest = rand.RandRngCreateRequest
  create_req.provider_id = cfg.rng_provider_id
  create_req.alg_id = cfg.rng_alg_id
  create_req.policy = rand.rand_default_policy_csprng()

  rand.rand_rng_create(create_req)

  return r
.end

fn bench_rng_fill_view(rng : BenchRng, out : t.MutByteSlice)
  let req : rand.RandFillRequestView = rand.RandFillRequestView
  req.rng = rng.rng
  req.output = out
  rand.rand_fill_view(req)
.end

# ============================================================================
# AEAD setup wrappers
# ============================================================================

struct BenchAead
  ctx : aead.AeadContextRef

  alg_id      : string

  key_len     : u32
  nonce_len   : u32
  tag_len     : u32
.end

fn bench_aead_effective_alg_id(cfg : BenchConfig, c : BenchCase) -> string
  if c.alg_id != ""
    return c.alg_id
  .end
  return cfg.alg_id
.end

fn bench_aead_init(cfg : BenchConfig, c : BenchCase, key_bytes : coll.Vec[u8]) -> BenchAead
  let a : BenchAead = BenchAead

  a.alg_id = bench_aead_effective_alg_id(cfg, c)

  # Select provider/alg
  let sel_req : aead.AeadProviderSelectRequest = aead.AeadProviderSelectRequest
  sel_req.provider_id = cfg.provider_id
  sel_req.alg_id = a.alg_id
  aead.aead_provider_select(sel_req)

  # Import key
  let key_req : aead.AeadKeyImportRequest = aead.AeadKeyImportRequest
  key_req.provider_id = cfg.provider_id
  key_req.alg_id = a.alg_id
  key_req.key_bytes = key_bytes
  key_req.usage = aead.AeadKeyUsage.SealAndOpen
  aead.aead_key_import(key_req)

  # Create context
  let pol : aead.AeadPolicy = aead.AeadPolicy
  pol.constant_time = cfg.constant_time
  pol.sidechannel_hard = cfg.sidechannel_hard

  let ctx_req : aead.AeadContextCreateRequest = aead.AeadContextCreateRequest
  ctx_req.provider_id = cfg.provider_id
  ctx_req.alg_id = a.alg_id
  ctx_req.policy = pol
  aead.aead_context_create(ctx_req)

  a.key_len = c.key_len
  a.nonce_len = c.nonce_len
  a.tag_len = c.tag_len

  return a
.end

# ============================================================================
# Buffers
# ============================================================================

struct BenchBuffers
  key    : coll.Vec[u8]
  nonce  : coll.Vec[u8]
  aad    : coll.Vec[u8]

  msg    : coll.Vec[u8]

  out    : coll.Vec[u8]
  tag    : coll.Vec[u8]

  dec    : coll.Vec[u8]
.end

fn bench_buffers_make(rng : BenchRng, c : BenchCase) -> BenchBuffers
  let b : BenchBuffers = BenchBuffers

  # NOTE: Vec allocations are placeholders until Vec API exists.
  # Fill key/nonce/aad/msg using RNG when possible.
  b.key = coll.Vec[u8]
  b.nonce = coll.Vec[u8]
  b.aad = coll.Vec[u8]
  b.msg = coll.Vec[u8]

  b.out = coll.Vec[u8]
  b.tag = coll.Vec[u8]

  b.dec = coll.Vec[u8]

  return b
.end

# ============================================================================
# Stats helpers
# ============================================================================

fn bench_stats_finish(timer : BenchTimer, iters : u64, bytes : u64, t0 : u64, t1 : u64) -> BenchStats
  let s : BenchStats = BenchStats
  s.iters = iters
  s.bytes = bytes
  s.t_start = t0
  s.t_end = t1

  if t1 >= t0
    s.t_total = t1 - t0
  .end

  if iters > 0
    s.ns_per_iter = s.t_total / iters
  .end

  if bytes > 0
    s.ns_per_byte = s.t_total / bytes
  .end

  if s.t_total > 0
    s.mib_per_s = (bytes * 1000000000) / (s.t_total * 1024 * 1024)
  .end

  return s
.end

# ============================================================================
# Warmup + measure
# ============================================================================

fn bench_warmup(cfg : BenchConfig, a : BenchAead, c : BenchCase, b : BenchBuffers)
  let i : u64 = 0
  while i < c.warmup
    bench_kernel_once(cfg, a, c, b)
    i += 1
  .end
.end

fn bench_measure(cfg : BenchConfig, a : BenchAead, c : BenchCase, b : BenchBuffers) -> BenchStats
  let t0 : u64 = 0
  let t1 : u64 = 0

  if cfg.timer.unit == BenchUnit.Ns
    t0 = bench_now_ns()
  .end
  if cfg.timer.unit == BenchUnit.Cycles
    t0 = bench_now_cycles()
  .end

  let i : u64 = 0
  while i < c.iterations
    bench_kernel_once(cfg, a, c, b)
    i += 1
  .end

  if cfg.timer.unit == BenchUnit.Ns
    t1 = bench_now_ns()
  .end
  if cfg.timer.unit == BenchUnit.Cycles
    t1 = bench_now_cycles()
  .end

  let bytes : u64 = (c.msg_len as u64) * c.iterations
  return bench_stats_finish(cfg.timer, c.iterations, bytes, t0, t1)
.end

# ============================================================================
# Kernel dispatcher
# ============================================================================

fn bench_kernel_once(cfg : BenchConfig, a : BenchAead, c : BenchCase, b : BenchBuffers)
  if c.op == BenchOp.Seal
    bench_kernel_seal(cfg, a, c, b)
  .end
  if c.op == BenchOp.Open
    bench_kernel_open(cfg, a, c, b)
  .end
.end

fn bench_kernel_seal(cfg : BenchConfig, a : BenchAead, c : BenchCase, b : BenchBuffers)
  if c.mode == BenchMode.OneShot
    bench_kernel_seal_one_shot(cfg, a, c, b)
  .end

  if c.mode == BenchMode.OneShotView
    bench_kernel_seal_view(cfg, a, c, b)
  .end

  if c.mode == BenchMode.OneShotInPlaceView
    bench_kernel_seal_in_place_view(cfg, a, c, b)
  .end

  if c.mode == BenchMode.Streaming
    bench_kernel_seal_streaming(cfg, a, c, b)
  .end

  if c.mode == BenchMode.StreamingView
    bench_kernel_seal_streaming_view(cfg, a, c, b)
  .end

  if c.mode == BenchMode.IoVecView
    bench_kernel_seal_iovec_view(cfg, a, c, b)
  .end
.end

fn bench_kernel_open(cfg : BenchConfig, a : BenchAead, c : BenchCase, b : BenchBuffers)
  if c.mode == BenchMode.OneShot
    bench_kernel_open_one_shot(cfg, a, c, b)
  .end

  if c.mode == BenchMode.OneShotView
    bench_kernel_open_view(cfg, a, c, b)
  .end

  if c.mode == BenchMode.Streaming
    bench_kernel_open_streaming(cfg, a, c, b)
  .end

  if c.mode == BenchMode.StreamingView
    bench_kernel_open_streaming_view(cfg, a, c, b)
  .end

  if c.mode == BenchMode.IoVecView
    bench_kernel_open_iovec_view(cfg, a, c, b)
  .end
.end

# ============================================================================
# Kernels (AEAD)
# ============================================================================

fn bench_kernel_seal_one_shot(cfg : BenchConfig, a : BenchAead, c : BenchCase, b : BenchBuffers)
  let req : aead.AeadSealRequest = aead.AeadSealRequest
  req.ctx = a.ctx
  req.nonce = b.nonce
  req.aad = b.aad
  req.plaintext = b.msg
  aead.aead_seal(req)
.end

fn bench_kernel_open_one_shot(cfg : BenchConfig, a : BenchAead, c : BenchCase, b : BenchBuffers)
  let req : aead.AeadOpenRequest = aead.AeadOpenRequest
  req.ctx = a.ctx
  req.nonce = b.nonce
  req.aad = b.aad
  req.ciphertext = b.out
  req.tag = b.tag
  aead.aead_open(req)
.end

fn bench_kernel_seal_view(cfg : BenchConfig, a : BenchAead, c : BenchCase, b : BenchBuffers)
  let req : aead.AeadSealRequestView = aead.AeadSealRequestView
  req.ctx = a.ctx

  req.nonce = t.ByteSlice
  req.aad = t.ByteSlice
  req.plaintext = t.ByteSlice

  req.output_ciphertext = t.MutByteSlice
  req.output_tag = t.MutByteSlice

  aead.aead_seal_view(req)

  bench_sink_u64(req.output_ciphertext.len)
.end

fn bench_kernel_open_view(cfg : BenchConfig, a : BenchAead, c : BenchCase, b : BenchBuffers)
  let req : aead.AeadOpenRequestView = aead.AeadOpenRequestView
  req.ctx = a.ctx

  req.nonce = t.ByteSlice
  req.aad = t.ByteSlice
  req.ciphertext = t.ByteSlice
  req.tag = t.ByteSlice

  req.output_plaintext = t.MutByteSlice

  aead.aead_open_view(req)

  if c.validate
    # validate best effort using subtle constant-time compare
    subtle.ct_eq_bytes_view(req.output_plaintext as t.ByteSlice, req.output_plaintext as t.ByteSlice)
  .end
.end

fn bench_kernel_seal_in_place_view(cfg : BenchConfig, a : BenchAead, c : BenchCase, b : BenchBuffers)
  let req : aead.AeadSealInPlaceRequestView = aead.AeadSealInPlaceRequestView
  req.ctx = a.ctx

  req.nonce = t.ByteSlice
  req.aad = t.ByteSlice

  req.buffer = t.MutByteSlice
  req.output_tag = t.MutByteSlice

  aead.aead_seal_in_place_view(req)
.end

# Streaming (structure placeholders)
fn bench_kernel_seal_streaming(cfg : BenchConfig, a : BenchAead, c : BenchCase, b : BenchBuffers)
  let sreq : aead.AeadStreamStartRequest = aead.AeadStreamStartRequest
  sreq.ctx = a.ctx
  sreq.nonce = b.nonce
  sreq.aad = b.aad
  aead.aead_stream_start(sreq)

  let ureq : aead.AeadStreamUpdateRequest = aead.AeadStreamUpdateRequest
  ureq.stream = aead.AeadStreamRef
  ureq.chunk = b.msg
  aead.aead_stream_update(ureq)

  let freq : aead.AeadStreamFinishRequest = aead.AeadStreamFinishRequest
  freq.stream = aead.AeadStreamRef
  aead.aead_stream_finish(freq)
.end

fn bench_kernel_open_streaming(cfg : BenchConfig, a : BenchAead, c : BenchCase, b : BenchBuffers)
  let sreq : aead.AeadStreamStartRequest = aead.AeadStreamStartRequest
  sreq.ctx = a.ctx
  sreq.nonce = b.nonce
  sreq.aad = b.aad
  aead.aead_stream_start(sreq)

  let ureq : aead.AeadStreamUpdateRequest = aead.AeadStreamUpdateRequest
  ureq.stream = aead.AeadStreamRef
  ureq.chunk = b.out
  aead.aead_stream_update(ureq)

  let freq : aead.AeadStreamFinishRequest = aead.AeadStreamFinishRequest
  freq.stream = aead.AeadStreamRef
  aead.aead_stream_finish(freq)
.end

fn bench_kernel_seal_streaming_view(cfg : BenchConfig, a : BenchAead, c : BenchCase, b : BenchBuffers)
  let sreq : aead.AeadStreamStartRequestView = aead.AeadStreamStartRequestView
  sreq.ctx = a.ctx
  sreq.nonce = t.ByteSlice
  sreq.aad = t.ByteSlice
  aead.aead_stream_start_view(sreq)

  let ureq : aead.AeadStreamUpdateRequestView = aead.AeadStreamUpdateRequestView
  ureq.stream = aead.AeadStreamRef
  ureq.chunk = t.ByteSlice
  aead.aead_stream_update_view(ureq)

  let freq : aead.AeadStreamFinishRequestView = aead.AeadStreamFinishRequestView
  freq.stream = aead.AeadStreamRef
  freq.output_tag = t.MutByteSlice
  aead.aead_stream_finish_view(freq)
.end

fn bench_kernel_open_streaming_view(cfg : BenchConfig, a : BenchAead, c : BenchCase, b : BenchBuffers)
  let sreq : aead.AeadStreamStartRequestView = aead.AeadStreamStartRequestView
  sreq.ctx = a.ctx
  sreq.nonce = t.ByteSlice
  sreq.aad = t.ByteSlice
  aead.aead_stream_start_view(sreq)

  let ureq : aead.AeadStreamUpdateRequestView = aead.AeadStreamUpdateRequestView
  ureq.stream = aead.AeadStreamRef
  ureq.chunk = t.ByteSlice
  aead.aead_stream_update_view(ureq)

  let freq : aead.AeadStreamFinishRequestView = aead.AeadStreamFinishRequestView
  freq.stream = aead.AeadStreamRef
  freq.output_plaintext = t.MutByteSlice
  aead.aead_stream_finish_view(freq)
.end

fn bench_kernel_seal_iovec_view(cfg : BenchConfig, a : BenchAead, c : BenchCase, b : BenchBuffers)
  let req : aead.AeadSealIoVecRequestView = aead.AeadSealIoVecRequestView
  req.ctx = a.ctx
  req.nonce = t.ByteSlice
  req.aad = t.ByteSlice
  req.plaintext = t.IoVec
  req.output_ciphertext = t.MutIoVec
  req.output_tag = t.MutByteSlice
  aead.aead_seal_iovec_view(req)
.end

fn bench_kernel_open_iovec_view(cfg : BenchConfig, a : BenchAead, c : BenchCase, b : BenchBuffers)
  let req : aead.AeadOpenIoVecRequestView = aead.AeadOpenIoVecRequestView
  req.ctx = a.ctx
  req.nonce = t.ByteSlice
  req.aad = t.ByteSlice
  req.ciphertext = t.IoVec
  req.tag = t.ByteSlice
  req.output_plaintext = t.MutIoVec
  aead.aead_open_iovec_view(req)
.end

# ============================================================================
# Run cases
# ============================================================================

fn bench_run_case(cfg : BenchConfig, c_in : BenchCase) -> BenchResult
  let r : BenchResult = BenchResult

  let c : BenchCase = bench_case_apply_defaults(cfg, c_in)
  r.case = c

  bench_emit_case_begin(c)

  let rng : BenchRng = bench_rng_init(cfg)
  let bufs : BenchBuffers = bench_buffers_make(rng, c)

  let a : BenchAead = bench_aead_init(cfg, c, bufs.key)

  bench_warmup(cfg, a, c, bufs)

  let stats : BenchStats = bench_measure(cfg, a, c, bufs)
  r.stats = stats
  r.err = BenchError.Ok

  bench_emit_case_end(r)
  return r
.end

fn bench_build_cases_max() -> coll.Vec[BenchCase]
  let v : coll.Vec[BenchCase] = coll.Vec[BenchCase]

  # Algorithms
  let alg_c : string = "chacha20-poly1305"
  let alg_x : string = "xchacha20-poly1305"

  # Message sizes
  #   - tiny (packets), small, medium, large
  # AAD sizes: 0, 16, 32

  # ChaCha20-Poly1305
  v.push(bench_case_make("c20p1305/seal/oneshot/64", alg_c, BenchOp.Seal, BenchMode.OneShot, 64, 16))
  v.push(bench_case_make("c20p1305/seal/oneshot/1k", alg_c, BenchOp.Seal, BenchMode.OneShot, 1024, 16))
  v.push(bench_case_make("c20p1305/seal/oneshot/16k", alg_c, BenchOp.Seal, BenchMode.OneShot, 16384, 16))
  v.push(bench_case_make("c20p1305/seal/oneshot/256k", alg_c, BenchOp.Seal, BenchMode.OneShot, 262144, 16))

  v.push(bench_case_make("c20p1305/seal/view/16k", alg_c, BenchOp.Seal, BenchMode.OneShotView, 16384, 16))
  v.push(bench_case_make("c20p1305/seal/inplace/1k", alg_c, BenchOp.Seal, BenchMode.OneShotInPlaceView, 1024, 16))

  v.push(bench_case_make("c20p1305/seal/stream/16k", alg_c, BenchOp.Seal, BenchMode.Streaming, 16384, 16))
  v.push(bench_case_make("c20p1305/seal/stream_view/16k", alg_c, BenchOp.Seal, BenchMode.StreamingView, 16384, 16))

  v.push(bench_case_make("c20p1305/open/oneshot/16k", alg_c, BenchOp.Open, BenchMode.OneShot, 16384, 16))
  let oc : BenchCase = bench_case_make("c20p1305/open/view/16k", alg_c, BenchOp.Open, BenchMode.OneShotView, 16384, 16)
  oc.validate = true
  v.push(oc)

  v.push(bench_case_make("c20p1305/seal/iovec/16k", alg_c, BenchOp.Seal, BenchMode.IoVecView, 16384, 16))
  v.push(bench_case_make("c20p1305/open/iovec/16k", alg_c, BenchOp.Open, BenchMode.IoVecView, 16384, 16))

  # XChaCha20-Poly1305 (24-byte nonce)
  v.push(bench_case_make("xc20p1305/seal/oneshot/1k", alg_x, BenchOp.Seal, BenchMode.OneShot, 1024, 16))
  v.push(bench_case_make("xc20p1305/seal/oneshot/16k", alg_x, BenchOp.Seal, BenchMode.OneShot, 16384, 16))
  v.push(bench_case_make("xc20p1305/seal/view/16k", alg_x, BenchOp.Seal, BenchMode.OneShotView, 16384, 16))

  v.push(bench_case_make("xc20p1305/open/oneshot/16k", alg_x, BenchOp.Open, BenchMode.OneShot, 16384, 16))
  let ox : BenchCase = bench_case_make("xc20p1305/open/view/16k", alg_x, BenchOp.Open, BenchMode.OneShotView, 16384, 16)
  ox.validate = true
  v.push(ox)

  return v
.end

# ============================================================================
# Entrypoint
# ============================================================================

fn main() -> i32
  let cfg : BenchConfig = bench_default_config()

  # Default provider id should be set by harness/runner.
  # Example:
  #   cfg.provider_id = "default"
  #   cfg.alg_id = "chacha20-poly1305"

  bench_emit_begin(cfg)

  let cases : coll.Vec[BenchCase] = bench_build_cases_max()

  let i : u64 = 0
  while i < cases.len()
    let c : BenchCase = cases[i]
    bench_run_case(cfg, c)
    i += 1
  .end

  bench_emit_end(cfg)
  return 0
.end

.end