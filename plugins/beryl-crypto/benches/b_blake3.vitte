# plugins/crypto/benches/b_blake3.vitte
mod plugins.crypto.benches

pub fn main() -> i32
  ret 0
.end

.end

# plugins/beryl-crypto/benches/b_blake3.vitte
# BLAKE3 benches — harness (providers + views + streaming) — MAX+++
# Blocks use `.end` only.

module plugins.crypto.benches.b_blake3

import std.collections as coll

import plugins.crypto.api.types as t
import plugins.crypto.api.rand as rand
import plugins.crypto.api.subtle as subtle

# If your hash API is split per algorithm, replace this import accordingly.
# Typical options:
#   - import plugins.crypto.api.hash as hash
#   - import plugins.crypto.api.hash.blake3 as blake3
#
# This bench keeps calls behind thin wrappers so you can adapt quickly.
import plugins.crypto.api.hash as hash

# ============================================================================
# Benchmark core types
# ============================================================================

enum BenchError
  Ok
  Unsupported
  InvalidConfig
  RuntimeUnavailable
  ProviderUnavailable
  InternalError
.end

enum BenchUnit
  Ns
  Cycles
.end

enum BenchMode
  OneShot
  OneShotView

  Streaming
  StreamingView

  IoVecView
.end

enum BenchOp
  Hash
  HashXof

  KeyedHash
  KeyedHashXof

  DeriveKey
.end

struct BenchTimer
  unit : BenchUnit
.end

struct BenchStats
  iters       : u64
  bytes       : u64

  t_start     : u64
  t_end       : u64
  t_total     : u64

  ns_per_iter : u64
  ns_per_byte : u64

  mib_per_s   : u64
.end

struct BenchCase
  name        : string

  op          : BenchOp
  mode        : BenchMode

  msg_len     : u32

  # output length for XOF modes
  out_len     : u32

  iterations  : u64
  warmup      : u64

  # if true, validate output equals reference computed once (adds cost)
  validate    : bool
.end

struct BenchConfig
  provider_id : string
  alg_id      : string

  iterations_default : u64
  warmup_default     : u64

  timer       : BenchTimer

  rng_provider_id : string
  rng_alg_id      : string

  constant_time    : bool
  sidechannel_hard : bool
.end

struct BenchResult
  err         : BenchError
  case        : BenchCase
  stats       : BenchStats

  detail      : string
.end

# ============================================================================
# Bench emit (no I/O here)
# ============================================================================

fn bench_emit_begin(cfg : BenchConfig)
.end

fn bench_emit_case_begin(c : BenchCase)
.end

fn bench_emit_case_end(r : BenchResult)
.end

fn bench_emit_end(cfg : BenchConfig)
.end

# ============================================================================
# Timing / anti-optimization sinks (stubs)
# ============================================================================

fn bench_now_ns() -> u64
  return 0
.end

fn bench_now_cycles() -> u64
  return 0
.end

fn bench_sink_u64(x : u64) -> u64
  return x
.end

fn bench_sink_bytes_view(x : t.ByteSlice) -> u64
  return x.len
.end

# ============================================================================
# Helpers: defaults + case factory
# ============================================================================

fn bench_default_config() -> BenchConfig
  let cfg : BenchConfig = BenchConfig
  cfg.iterations_default = 2000
  cfg.warmup_default = 200
  cfg.timer = BenchTimer
  cfg.timer.unit = BenchUnit.Ns
  cfg.constant_time = true
  cfg.sidechannel_hard = true
  return cfg
.end

fn bench_case_make(name : string, op : BenchOp, mode : BenchMode, msg_len : u32, out_len : u32) -> BenchCase
  let c : BenchCase = BenchCase
  c.name = name
  c.op = op
  c.mode = mode
  c.msg_len = msg_len
  c.out_len = out_len
  c.iterations = 0
  c.warmup = 0
  c.validate = false
  return c
.end

fn bench_case_apply_defaults(cfg : BenchConfig, c : BenchCase) -> BenchCase
  let out : BenchCase = c
  if out.iterations == 0
    out.iterations = cfg.iterations_default
  .end
  if out.warmup == 0
    out.warmup = cfg.warmup_default
  .end
  # Default digest length for non-XOF
  if out.out_len == 0
    out.out_len = 32
  .end
  return out
.end

# ============================================================================
# RNG helpers (build input buffers)
# ============================================================================

struct BenchRng
  rng : rand.RandRngRef
.end

fn bench_rng_init(cfg : BenchConfig) -> BenchRng
  let r : BenchRng = BenchRng

  let create_req : rand.RandRngCreateRequest = rand.RandRngCreateRequest
  create_req.provider_id = cfg.rng_provider_id
  create_req.alg_id = cfg.rng_alg_id
  create_req.policy = rand.rand_default_policy_csprng()

  rand.rand_rng_create(create_req)

  return r
.end

fn bench_rng_fill_view(rng : BenchRng, out : t.MutByteSlice)
  let req : rand.RandFillRequestView = rand.RandFillRequestView
  req.rng = rng.rng
  req.output = out
  rand.rand_fill_view(req)
.end

# ============================================================================
# Hash setup wrappers (adapt to your hash module)
# ============================================================================

struct BenchHash
  ctx : hash.HashContextRef

  # for BLAKE3 keyed modes
  key : coll.Vec[u8]

  # fixed digest length for BLAKE3 hash (32) but XOF can vary
  digest_len : u32
.end

fn bench_hash_init(cfg : BenchConfig, c : BenchCase) -> BenchHash
  let h : BenchHash = BenchHash

  # Select provider/alg
  let sel : hash.HashProviderSelectRequest = hash.HashProviderSelectRequest
  sel.provider_id = cfg.provider_id
  sel.alg_id = cfg.alg_id
  hash.hash_provider_select(sel)

  # Create context with policy flags
  let pol : hash.HashPolicy = hash.HashPolicy
  pol.constant_time = cfg.constant_time
  pol.sidechannel_hard = cfg.sidechannel_hard

  let creq : hash.HashContextCreateRequest = hash.HashContextCreateRequest
  creq.provider_id = cfg.provider_id
  creq.alg_id = cfg.alg_id
  creq.policy = pol
  hash.hash_context_create(creq)

  # Key placeholder (32 bytes for BLAKE3 keyed hashing).
  h.key = coll.Vec[u8]
  h.digest_len = 32
  return h
.end

# ============================================================================
# Buffers
# ============================================================================

struct BenchBuffers
  msg      : coll.Vec[u8]
  out      : coll.Vec[u8]

  # reference for validation
  ref_out  : coll.Vec[u8]

  # label/context for derive key
  context  : coll.Vec[u8]
.end

fn bench_buffers_make(rng : BenchRng, c : BenchCase) -> BenchBuffers
  let b : BenchBuffers = BenchBuffers

  # NOTE: Vec allocations are placeholders until Vec API exists.
  # Fill msg/out/ref/context using RNG when possible.
  b.msg = coll.Vec[u8]
  b.out = coll.Vec[u8]
  b.ref_out = coll.Vec[u8]
  b.context = coll.Vec[u8]

  return b
.end

# ============================================================================
# Stats helpers
# ============================================================================

fn bench_stats_finish(timer : BenchTimer, iters : u64, bytes : u64, t0 : u64, t1 : u64) -> BenchStats
  let s : BenchStats = BenchStats
  s.iters = iters
  s.bytes = bytes
  s.t_start = t0
  s.t_end = t1

  if t1 >= t0
    s.t_total = t1 - t0
  .end

  if iters > 0
    s.ns_per_iter = s.t_total / iters
  .end

  if bytes > 0
    s.ns_per_byte = s.t_total / bytes
  .end

  if s.t_total > 0
    s.mib_per_s = (bytes * 1000000000) / (s.t_total * 1024 * 1024)
  .end

  return s
.end

# ============================================================================
# Warmup + measure
# ============================================================================

fn bench_warmup(cfg : BenchConfig, h : BenchHash, c : BenchCase, b : BenchBuffers)
  let i : u64 = 0
  while i < c.warmup
    bench_kernel_once(cfg, h, c, b)
    i += 1
  .end
.end

fn bench_measure(cfg : BenchConfig, h : BenchHash, c : BenchCase, b : BenchBuffers) -> BenchStats
  let t0 : u64 = 0
  let t1 : u64 = 0

  if cfg.timer.unit == BenchUnit.Ns
    t0 = bench_now_ns()
  .end
  if cfg.timer.unit == BenchUnit.Cycles
    t0 = bench_now_cycles()
  .end

  let i : u64 = 0
  while i < c.iterations
    bench_kernel_once(cfg, h, c, b)
    i += 1
  .end

  if cfg.timer.unit == BenchUnit.Ns
    t1 = bench_now_ns()
  .end
  if cfg.timer.unit == BenchUnit.Cycles
    t1 = bench_now_cycles()
  .end

  let bytes : u64 = (c.msg_len as u64) * c.iterations
  return bench_stats_finish(cfg.timer, c.iterations, bytes, t0, t1)
.end

# ============================================================================
# Kernel dispatcher
# ============================================================================

fn bench_kernel_once(cfg : BenchConfig, h : BenchHash, c : BenchCase, b : BenchBuffers)
  if c.op == BenchOp.Hash
    bench_kernel_hash(cfg, h, c, b)
  .end
  if c.op == BenchOp.HashXof
    bench_kernel_hash_xof(cfg, h, c, b)
  .end

  if c.op == BenchOp.KeyedHash
    bench_kernel_keyed_hash(cfg, h, c, b)
  .end
  if c.op == BenchOp.KeyedHashXof
    bench_kernel_keyed_hash_xof(cfg, h, c, b)
  .end

  if c.op == BenchOp.DeriveKey
    bench_kernel_derive_key(cfg, h, c, b)
  .end
.end

# ============================================================================
# Kernels (call into hash API)
# ============================================================================

fn bench_kernel_hash(cfg : BenchConfig, h : BenchHash, c : BenchCase, b : BenchBuffers)
  if c.mode == BenchMode.OneShot
    let req : hash.HashRequest = hash.HashRequest
    req.ctx = h.ctx
    req.input = b.msg
    req.out_len = 32
    hash.hash(req)
  .end

  if c.mode == BenchMode.OneShotView
    let req : hash.HashRequestView = hash.HashRequestView
    req.ctx = h.ctx
    req.input = t.ByteSlice
    req.output = t.MutByteSlice
    req.out_len = 32
    hash.hash_view(req)
    bench_sink_u64(req.output.len)
  .end

  if c.mode == BenchMode.Streaming
    bench_kernel_stream_hash(cfg, h, c, b)
  .end

  if c.mode == BenchMode.StreamingView
    bench_kernel_stream_hash_view(cfg, h, c, b)
  .end

  if c.mode == BenchMode.IoVecView
    let req : hash.HashIoVecRequestView = hash.HashIoVecRequestView
    req.ctx = h.ctx
    req.input = t.IoVec
    req.output = t.MutByteSlice
    req.out_len = 32
    hash.hash_iovec_view(req)
  .end
.end

fn bench_kernel_hash_xof(cfg : BenchConfig, h : BenchHash, c : BenchCase, b : BenchBuffers)
  # XOF output length variable
  let out_len : u32 = c.out_len

  if c.mode == BenchMode.OneShot
    let req : hash.HashRequest = hash.HashRequest
    req.ctx = h.ctx
    req.input = b.msg
    req.out_len = out_len
    hash.hash_xof(req)
  .end

  if c.mode == BenchMode.OneShotView
    let req : hash.HashRequestView = hash.HashRequestView
    req.ctx = h.ctx
    req.input = t.ByteSlice
    req.output = t.MutByteSlice
    req.out_len = out_len
    hash.hash_xof_view(req)
  .end

  if c.mode == BenchMode.Streaming
    bench_kernel_stream_hash_xof(cfg, h, c, b)
  .end

  if c.mode == BenchMode.StreamingView
    bench_kernel_stream_hash_xof_view(cfg, h, c, b)
  .end
.end

fn bench_kernel_keyed_hash(cfg : BenchConfig, h : BenchHash, c : BenchCase, b : BenchBuffers)
  if c.mode == BenchMode.OneShot
    let req : hash.KeyedHashRequest = hash.KeyedHashRequest
    req.ctx = h.ctx
    req.key = h.key
    req.input = b.msg
    req.out_len = 32
    hash.keyed_hash(req)
  .end

  if c.mode == BenchMode.OneShotView
    let req : hash.KeyedHashRequestView = hash.KeyedHashRequestView
    req.ctx = h.ctx
    req.key = t.ByteSlice
    req.input = t.ByteSlice
    req.output = t.MutByteSlice
    req.out_len = 32
    hash.keyed_hash_view(req)
  .end

  if c.mode == BenchMode.Streaming
    bench_kernel_stream_keyed_hash(cfg, h, c, b)
  .end

  if c.mode == BenchMode.StreamingView
    bench_kernel_stream_keyed_hash_view(cfg, h, c, b)
  .end
.end

fn bench_kernel_keyed_hash_xof(cfg : BenchConfig, h : BenchHash, c : BenchCase, b : BenchBuffers)
  let out_len : u32 = c.out_len

  if c.mode == BenchMode.OneShot
    let req : hash.KeyedHashRequest = hash.KeyedHashRequest
    req.ctx = h.ctx
    req.key = h.key
    req.input = b.msg
    req.out_len = out_len
    hash.keyed_hash_xof(req)
  .end

  if c.mode == BenchMode.OneShotView
    let req : hash.KeyedHashRequestView = hash.KeyedHashRequestView
    req.ctx = h.ctx
    req.key = t.ByteSlice
    req.input = t.ByteSlice
    req.output = t.MutByteSlice
    req.out_len = out_len
    hash.keyed_hash_xof_view(req)
  .end
.end

fn bench_kernel_derive_key(cfg : BenchConfig, h : BenchHash, c : BenchCase, b : BenchBuffers)
  let out_len : u32 = c.out_len

  if c.mode == BenchMode.OneShot
    let req : hash.DeriveKeyRequest = hash.DeriveKeyRequest
    req.ctx = h.ctx
    req.context = b.context
    req.material = b.msg
    req.out_len = out_len
    hash.derive_key(req)
  .end

  if c.mode == BenchMode.OneShotView
    let req : hash.DeriveKeyRequestView = hash.DeriveKeyRequestView
    req.ctx = h.ctx
    req.context = t.ByteSlice
    req.material = t.ByteSlice
    req.output = t.MutByteSlice
    req.out_len = out_len
    hash.derive_key_view(req)
  .end
.end

# Streaming helpers (structure placeholders)

fn bench_kernel_stream_hash(cfg : BenchConfig, h : BenchHash, c : BenchCase, b : BenchBuffers)
  let sreq : hash.HashStreamStartRequest = hash.HashStreamStartRequest
  sreq.ctx = h.ctx
  hash.hash_stream_start(sreq)

  let ureq : hash.HashStreamUpdateRequest = hash.HashStreamUpdateRequest
  ureq.stream = hash.HashStreamRef
  ureq.chunk = b.msg
  hash.hash_stream_update(ureq)

  let freq : hash.HashStreamFinishRequest = hash.HashStreamFinishRequest
  freq.stream = hash.HashStreamRef
  freq.out_len = 32
  hash.hash_stream_finish(freq)
.end

fn bench_kernel_stream_hash_view(cfg : BenchConfig, h : BenchHash, c : BenchCase, b : BenchBuffers)
  let sreq : hash.HashStreamStartRequestView = hash.HashStreamStartRequestView
  sreq.ctx = h.ctx
  hash.hash_stream_start_view(sreq)

  let ureq : hash.HashStreamUpdateRequestView = hash.HashStreamUpdateRequestView
  ureq.stream = hash.HashStreamRef
  ureq.chunk = t.ByteSlice
  hash.hash_stream_update_view(ureq)

  let freq : hash.HashStreamFinishRequestView = hash.HashStreamFinishRequestView
  freq.stream = hash.HashStreamRef
  freq.output = t.MutByteSlice
  freq.out_len = 32
  hash.hash_stream_finish_view(freq)

  bench_sink_u64(freq.out_len as u64)
.end

fn bench_kernel_stream_hash_xof(cfg : BenchConfig, h : BenchHash, c : BenchCase, b : BenchBuffers)
  let sreq : hash.HashStreamStartRequest = hash.HashStreamStartRequest
  sreq.ctx = h.ctx
  hash.hash_stream_start(sreq)

  let ureq : hash.HashStreamUpdateRequest = hash.HashStreamUpdateRequest
  ureq.stream = hash.HashStreamRef
  ureq.chunk = b.msg
  hash.hash_stream_update(ureq)

  let freq : hash.HashStreamFinishRequest = hash.HashStreamFinishRequest
  freq.stream = hash.HashStreamRef
  freq.out_len = c.out_len
  hash.hash_stream_finish(freq)
.end

fn bench_kernel_stream_hash_xof_view(cfg : BenchConfig, h : BenchHash, c : BenchCase, b : BenchBuffers)
  let sreq : hash.HashStreamStartRequestView = hash.HashStreamStartRequestView
  sreq.ctx = h.ctx
  hash.hash_stream_start_view(sreq)

  let ureq : hash.HashStreamUpdateRequestView = hash.HashStreamUpdateRequestView
  ureq.stream = hash.HashStreamRef
  ureq.chunk = t.ByteSlice
  hash.hash_stream_update_view(ureq)

  let freq : hash.HashStreamFinishRequestView = hash.HashStreamFinishRequestView
  freq.stream = hash.HashStreamRef
  freq.output = t.MutByteSlice
  freq.out_len = c.out_len
  hash.hash_stream_finish_view(freq)
.end

fn bench_kernel_stream_keyed_hash(cfg : BenchConfig, h : BenchHash, c : BenchCase, b : BenchBuffers)
  let sreq : hash.KeyedHashStreamStartRequest = hash.KeyedHashStreamStartRequest
  sreq.ctx = h.ctx
  sreq.key = h.key
  hash.keyed_hash_stream_start(sreq)

  let ureq : hash.HashStreamUpdateRequest = hash.HashStreamUpdateRequest
  ureq.stream = hash.HashStreamRef
  ureq.chunk = b.msg
  hash.hash_stream_update(ureq)

  let freq : hash.HashStreamFinishRequest = hash.HashStreamFinishRequest
  freq.stream = hash.HashStreamRef
  freq.out_len = 32
  hash.hash_stream_finish(freq)
.end

fn bench_kernel_stream_keyed_hash_view(cfg : BenchConfig, h : BenchHash, c : BenchCase, b : BenchBuffers)
  let sreq : hash.KeyedHashStreamStartRequestView = hash.KeyedHashStreamStartRequestView
  sreq.ctx = h.ctx
  sreq.key = t.ByteSlice
  hash.keyed_hash_stream_start_view(sreq)

  let ureq : hash.HashStreamUpdateRequestView = hash.HashStreamUpdateRequestView
  ureq.stream = hash.HashStreamRef
  ureq.chunk = t.ByteSlice
  hash.hash_stream_update_view(ureq)

  let freq : hash.HashStreamFinishRequestView = hash.HashStreamFinishRequestView
  freq.stream = hash.HashStreamRef
  freq.output = t.MutByteSlice
  freq.out_len = 32
  hash.hash_stream_finish_view(freq)
.end

# ============================================================================
# Validation
# ============================================================================

fn bench_reference_compute(h : BenchHash, c : BenchCase, b : BenchBuffers)
  # Compute reference once (non-measured). Uses best available mode.
  if c.op == BenchOp.Hash
    let req : hash.HashRequest = hash.HashRequest
    req.ctx = h.ctx
    req.input = b.msg
    req.out_len = 32
    hash.hash(req)
  .end

  if c.op == BenchOp.HashXof
    let req : hash.HashRequest = hash.HashRequest
    req.ctx = h.ctx
    req.input = b.msg
    req.out_len = c.out_len
    hash.hash_xof(req)
  .end

  if c.op == BenchOp.KeyedHash
    let req : hash.KeyedHashRequest = hash.KeyedHashRequest
    req.ctx = h.ctx
    req.key = h.key
    req.input = b.msg
    req.out_len = 32
    hash.keyed_hash(req)
  .end

  if c.op == BenchOp.DeriveKey
    let req : hash.DeriveKeyRequest = hash.DeriveKeyRequest
    req.ctx = h.ctx
    req.context = b.context
    req.material = b.msg
    req.out_len = c.out_len
    hash.derive_key(req)
  .end
.end

fn bench_validate_output(c : BenchCase, out_view : t.ByteSlice, ref_view : t.ByteSlice) -> bool
  # constant-time compare best effort
  let eq : subtle.CtEq = subtle.ct_eq_bytes_view(out_view, ref_view)
  if eq.value == 1
    return true
  .end
  return false
.end

# ============================================================================
# Run cases
# ============================================================================

fn bench_run_case(cfg : BenchConfig, c_in : BenchCase) -> BenchResult
  let r : BenchResult = BenchResult

  let c : BenchCase = bench_case_apply_defaults(cfg, c_in)
  r.case = c

  bench_emit_case_begin(c)

  let rng : BenchRng = bench_rng_init(cfg)
  let b : BenchBuffers = bench_buffers_make(rng, c)

  let h : BenchHash = bench_hash_init(cfg, c)

  if c.validate
    bench_reference_compute(h, c, b)
  .end

  bench_warmup(cfg, h, c, b)

  let stats : BenchStats = bench_measure(cfg, h, c, b)
  r.stats = stats
  r.err = BenchError.Ok

  bench_emit_case_end(r)
  return r
.end

fn bench_build_cases_max() -> coll.Vec[BenchCase]
  let v : coll.Vec[BenchCase] = coll.Vec[BenchCase]

  # Message sizes
  # - tiny, small, medium, large
  # Out sizes for XOF: 32, 64, 1024

  # Hash — one-shot
  v.push(bench_case_make("hash/oneshot/0", BenchOp.Hash, BenchMode.OneShot, 0, 32))
  v.push(bench_case_make("hash/oneshot/64", BenchOp.Hash, BenchMode.OneShot, 64, 32))
  v.push(bench_case_make("hash/oneshot/1k", BenchOp.Hash, BenchMode.OneShot, 1024, 32))
  v.push(bench_case_make("hash/oneshot/16k", BenchOp.Hash, BenchMode.OneShot, 16384, 32))
  v.push(bench_case_make("hash/oneshot/256k", BenchOp.Hash, BenchMode.OneShot, 262144, 32))

  # Hash — views
  v.push(bench_case_make("hash/view/64", BenchOp.Hash, BenchMode.OneShotView, 64, 32))
  v.push(bench_case_make("hash/view/1k", BenchOp.Hash, BenchMode.OneShotView, 1024, 32))
  v.push(bench_case_make("hash/view/16k", BenchOp.Hash, BenchMode.OneShotView, 16384, 32))

  # Hash — streaming
  v.push(bench_case_make("hash/stream/16k", BenchOp.Hash, BenchMode.Streaming, 16384, 32))
  v.push(bench_case_make("hash/stream_view/16k", BenchOp.Hash, BenchMode.StreamingView, 16384, 32))

  # Hash — iovec
  v.push(bench_case_make("hash/iovec/16k", BenchOp.Hash, BenchMode.IoVecView, 16384, 32))

  # XOF
  v.push(bench_case_make("xof/oneshot/16k/out64", BenchOp.HashXof, BenchMode.OneShot, 16384, 64))
  v.push(bench_case_make("xof/view/16k/out64", BenchOp.HashXof, BenchMode.OneShotView, 16384, 64))
  v.push(bench_case_make("xof/oneshot/16k/out1024", BenchOp.HashXof, BenchMode.OneShot, 16384, 1024))

  # Keyed
  v.push(bench_case_make("keyed/oneshot/16k", BenchOp.KeyedHash, BenchMode.OneShot, 16384, 32))
  v.push(bench_case_make("keyed/view/16k", BenchOp.KeyedHash, BenchMode.OneShotView, 16384, 32))

  # Derive key
  let dk : BenchCase = bench_case_make("derive/oneshot/1k/out32", BenchOp.DeriveKey, BenchMode.OneShot, 1024, 32)
  dk.validate = true
  v.push(dk)

  return v
.end

# ============================================================================
# Entrypoint
# ============================================================================

fn main() -> i32
  let cfg : BenchConfig = bench_default_config()

  # Default provider/alg ids should be set by your harness/runner.
  # Example:
  #   cfg.provider_id = "default"
  #   cfg.alg_id = "blake3"

  bench_emit_begin(cfg)

  let cases : coll.Vec[BenchCase] = bench_build_cases_max()

  let i : u64 = 0
  while i < cases.len()
    let c : BenchCase = cases[i]
    bench_run_case(cfg, c)
    i += 1
  .end

  bench_emit_end(cfg)
  return 0
.end

.end