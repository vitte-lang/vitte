# plugins/crypto/benches/b_x25519.vitte
mod plugins.crypto.benches

pub fn main() -> i32
  ret 0
.end

.end

# plugins/beryl-crypto/benches/b_x25519.vitte
# X25519 benches — harness (keygen + scalar mult) — MAX+++
# Blocks use `.end` only.

module plugins.crypto.benches.b_x25519

import std.collections as coll

import plugins.crypto.api.types as t
import plugins.crypto.api.rand as rand
import plugins.crypto.api.subtle as subtle

# DH/KEX API surface (adapt wrappers if split per algorithm)
import plugins.crypto.api.kex as kex

# ============================================================================
# Benchmark core types
# ============================================================================

enum BenchError
  Ok
  Unsupported
  InvalidConfig
  RuntimeUnavailable
  ProviderUnavailable
  InternalError
.end

enum BenchUnit
  Ns
  Cycles
.end

enum BenchMode
  OneShot
  OneShotView
  IoVecView
.end

enum BenchOp
  KeyGen
  SharedSecret

  SharedSecretFixedBase
  SharedSecretVariableBase

  BatchSharedSecret
.end

struct BenchTimer
  unit : BenchUnit
.end

struct BenchStats
  iters       : u64
  bytes       : u64

  t_start     : u64
  t_end       : u64
  t_total     : u64

  ns_per_iter : u64
  ns_per_byte : u64

  mib_per_s   : u64
.end

struct BenchCase
  name        : string

  op          : BenchOp
  mode        : BenchMode

  # X25519 operates on 32-byte scalars and 32-byte u-coordinates
  scalar_len  : u32
  public_len  : u32
  secret_len  : u32

  # for batch
  batch_n     : u32

  iterations  : u64
  warmup      : u64

  validate    : bool

  # If true, regenerate scalar/public per iter using RNG
  rng_inputs  : bool
.end

struct BenchConfig
  provider_id : string
  alg_id      : string

  iterations_default : u64
  warmup_default     : u64

  timer       : BenchTimer

  rng_provider_id : string
  rng_alg_id      : string

  constant_time    : bool
  sidechannel_hard : bool

  # prefer fixed-base ladder (if provider supports)
  prefer_fixed_base : bool

  # enable batch bench (if provider supports)
  enable_batch      : bool
.end

struct BenchResult
  err         : BenchError
  case        : BenchCase
  stats       : BenchStats

  detail      : string
.end

# ============================================================================
# Bench emit (no I/O)
# ============================================================================

fn bench_emit_begin(cfg : BenchConfig)
.end

fn bench_emit_case_begin(c : BenchCase)
.end

fn bench_emit_case_end(r : BenchResult)
.end

fn bench_emit_end(cfg : BenchConfig)
.end

# ============================================================================
# Timing / sinks (stubs)
# ============================================================================

fn bench_now_ns() -> u64
  return 0
.end

fn bench_now_cycles() -> u64
  return 0
.end

fn bench_sink_u64(x : u64) -> u64
  return x
.end

fn bench_sink_bytes_view(x : t.ByteSlice) -> u64
  return x.len
.end

# ============================================================================
# Defaults + cases
# ============================================================================

fn bench_default_config() -> BenchConfig
  let cfg : BenchConfig = BenchConfig

  cfg.iterations_default = 20000
  cfg.warmup_default = 2000

  cfg.timer = BenchTimer
  cfg.timer.unit = BenchUnit.Ns

  cfg.constant_time = true
  cfg.sidechannel_hard = true

  cfg.alg_id = "x25519"

  cfg.prefer_fixed_base = true
  cfg.enable_batch = true

  return cfg
.end

fn bench_case_make(name : string, op : BenchOp, mode : BenchMode) -> BenchCase
  let c : BenchCase = BenchCase

  c.name = name
  c.op = op
  c.mode = mode

  c.scalar_len = 32
  c.public_len = 32
  c.secret_len = 32

  c.batch_n = 0

  c.iterations = 0
  c.warmup = 0

  c.validate = false
  c.rng_inputs = false

  return c
.end

fn bench_case_apply_defaults(cfg : BenchConfig, c : BenchCase) -> BenchCase
  let out : BenchCase = c

  if out.iterations == 0
    out.iterations = cfg.iterations_default
  .end

  if out.warmup == 0
    out.warmup = cfg.warmup_default
  .end

  if out.batch_n == 0
    out.batch_n = 128
  .end

  return out
.end

# ============================================================================
# RNG helpers
# ============================================================================

struct BenchRng
  rng : rand.RandRngRef
.end

fn bench_rng_init(cfg : BenchConfig) -> BenchRng
  let r : BenchRng = BenchRng

  let create_req : rand.RandRngCreateRequest = rand.RandRngCreateRequest
  create_req.provider_id = cfg.rng_provider_id
  create_req.alg_id = cfg.rng_alg_id
  create_req.policy = rand.rand_default_policy_csprng()

  rand.rand_rng_create(create_req)

  return r
.end

fn bench_rng_fill_view(rng : BenchRng, out : t.MutByteSlice)
  let req : rand.RandFillRequestView = rand.RandFillRequestView
  req.rng = rng.rng
  req.output = out
  rand.rand_fill_view(req)
.end

# ============================================================================
# KEX setup wrappers
# ============================================================================

struct BenchKex
  provider_id : string
  alg_id      : string

  policy      : kex.KexPolicy

  # key handles (optional in API)
  keypair     : kex.KexKeyPairRef

  # cached values
  public_key  : coll.Vec[u8]
  private_key : coll.Vec[u8]
.end

fn bench_kex_init(cfg : BenchConfig) -> BenchKex
  let k : BenchKex = BenchKex

  k.provider_id = cfg.provider_id
  k.alg_id = cfg.alg_id

  # select provider/alg
  let sel : kex.KexProviderSelectRequest = kex.KexProviderSelectRequest
  sel.provider_id = cfg.provider_id
  sel.alg_id = cfg.alg_id
  kex.kex_provider_select(sel)

  let pol : kex.KexPolicy = kex.KexPolicy
  pol.constant_time = cfg.constant_time
  pol.sidechannel_hard = cfg.sidechannel_hard
  k.policy = pol

  # generate a keypair for shared-secret benches
  let gen : kex.KexKeyPairGenerateRequest = kex.KexKeyPairGenerateRequest
  gen.provider_id = cfg.provider_id
  gen.alg_id = cfg.alg_id
  gen.policy = pol
  kex.kex_keypair_generate(gen)

  # cache bytes (placeholders)
  k.public_key = coll.Vec[u8]
  k.private_key = coll.Vec[u8]

  return k
.end

# ============================================================================
# Buffers
# ============================================================================

struct BenchBuffers
  scalar   : coll.Vec[u8]
  public   : coll.Vec[u8]
  secret   : coll.Vec[u8]

  # batch
  scalars  : coll.Vec[coll.Vec[u8]]
  publics  : coll.Vec[coll.Vec[u8]]
  secrets  : coll.Vec[coll.Vec[u8]]
.end

fn bench_buffers_make(rng : BenchRng, c : BenchCase) -> BenchBuffers
  let b : BenchBuffers = BenchBuffers

  # NOTE: Vec allocations are placeholders until Vec API exists.
  b.scalar = coll.Vec[u8]
  b.public = coll.Vec[u8]
  b.secret = coll.Vec[u8]

  b.scalars = coll.Vec[coll.Vec[u8]]
  b.publics = coll.Vec[coll.Vec[u8]]
  b.secrets = coll.Vec[coll.Vec[u8]]

  return b
.end

# ============================================================================
# Stats
# ============================================================================

fn bench_stats_finish(timer : BenchTimer, iters : u64, bytes : u64, t0 : u64, t1 : u64) -> BenchStats
  let s : BenchStats = BenchStats
  s.iters = iters
  s.bytes = bytes
  s.t_start = t0
  s.t_end = t1

  if t1 >= t0
    s.t_total = t1 - t0
  .end

  if iters > 0
    s.ns_per_iter = s.t_total / iters
  .end

  if bytes > 0
    s.ns_per_byte = s.t_total / bytes
  .end

  if s.t_total > 0
    s.mib_per_s = (bytes * 1000000000) / (s.t_total * 1024 * 1024)
  .end

  return s
.end

# ============================================================================
# Warmup + measure
# ============================================================================

fn bench_warmup(cfg : BenchConfig, k : BenchKex, rng : BenchRng, c : BenchCase, b : BenchBuffers)
  let i : u64 = 0
  while i < c.warmup
    bench_kernel_once(cfg, k, rng, c, b)
    i += 1
  .end
.end

fn bench_measure(cfg : BenchConfig, k : BenchKex, rng : BenchRng, c : BenchCase, b : BenchBuffers) -> BenchStats
  let t0 : u64 = 0
  let t1 : u64 = 0

  if cfg.timer.unit == BenchUnit.Ns
    t0 = bench_now_ns()
  .end
  if cfg.timer.unit == BenchUnit.Cycles
    t0 = bench_now_cycles()
  .end

  let i : u64 = 0
  while i < c.iterations
    bench_kernel_once(cfg, k, rng, c, b)
    i += 1
  .end

  if cfg.timer.unit == BenchUnit.Ns
    t1 = bench_now_ns()
  .end
  if cfg.timer.unit == BenchUnit.Cycles
    t1 = bench_now_cycles()
  .end

  # bytes processed: treat scalar+public as input size
  let bytes_per : u64 = (c.scalar_len as u64) + (c.public_len as u64)
  let bytes : u64 = bytes_per * c.iterations
  return bench_stats_finish(cfg.timer, c.iterations, bytes, t0, t1)
.end

# ============================================================================
# Kernel dispatcher
# ============================================================================

fn bench_kernel_once(cfg : BenchConfig, k : BenchKex, rng : BenchRng, c : BenchCase, b : BenchBuffers)
  if c.rng_inputs
    bench_rng_fill_view(rng, t.MutByteSlice)
    bench_rng_fill_view(rng, t.MutByteSlice)
  .end

  if c.op == BenchOp.KeyGen
    bench_kernel_keygen(cfg, k)
  .end

  if c.op == BenchOp.SharedSecret
    bench_kernel_shared_secret(cfg, k, c, b)
  .end

  if c.op == BenchOp.SharedSecretFixedBase
    bench_kernel_shared_secret_fixed_base(cfg, k, c, b)
  .end

  if c.op == BenchOp.SharedSecretVariableBase
    bench_kernel_shared_secret_variable_base(cfg, k, c, b)
  .end

  if c.op == BenchOp.BatchSharedSecret
    bench_kernel_batch_shared_secret(cfg, k, c, b)
  .end
.end

# ============================================================================
# Kernels (KEX API)
# ============================================================================

fn bench_kernel_keygen(cfg : BenchConfig, k : BenchKex)
  let gen : kex.KexKeyPairGenerateRequest = kex.KexKeyPairGenerateRequest
  gen.provider_id = cfg.provider_id
  gen.alg_id = cfg.alg_id
  gen.policy = k.policy
  kex.kex_keypair_generate(gen)
.end

fn bench_kernel_shared_secret(cfg : BenchConfig, k : BenchKex, c : BenchCase, b : BenchBuffers)
  # Generic shared-secret interface.
  if c.mode == BenchMode.OneShot
    let req : kex.KexSharedSecretRequest = kex.KexSharedSecretRequest
    req.keypair = k.keypair
    req.peer_public = b.public
    kex.kex_shared_secret(req)
  .end

  if c.mode == BenchMode.OneShotView
    let req : kex.KexSharedSecretRequestView = kex.KexSharedSecretRequestView
    req.keypair = k.keypair
    req.peer_public = t.ByteSlice
    req.output = t.MutByteSlice
    kex.kex_shared_secret_view(req)
    bench_sink_u64(req.output.len)
  .end

  if c.mode == BenchMode.IoVecView
    let req : kex.KexSharedSecretIoVecRequestView = kex.KexSharedSecretIoVecRequestView
    req.keypair = k.keypair
    req.peer_public = t.IoVec
    req.output = t.MutByteSlice
    kex.kex_shared_secret_iovec_view(req)
  .end
.end

fn bench_kernel_shared_secret_fixed_base(cfg : BenchConfig, k : BenchKex, c : BenchCase, b : BenchBuffers)
  # Optional optimized interface; provider may return Unsupported.
  let req : kex.KexSharedSecretFixedBaseRequest = kex.KexSharedSecretFixedBaseRequest
  req.scalar = b.scalar
  kex.kex_shared_secret_fixed_base(req)
.end

fn bench_kernel_shared_secret_variable_base(cfg : BenchConfig, k : BenchKex, c : BenchCase, b : BenchBuffers)
  # Optional variable-base interface; provider may map to generic ladder.
  let req : kex.KexSharedSecretVarBaseRequest = kex.KexSharedSecretVarBaseRequest
  req.scalar = b.scalar
  req.public = b.public
  kex.kex_shared_secret_var_base(req)
.end

fn bench_kernel_batch_shared_secret(cfg : BenchConfig, k : BenchKex, c : BenchCase, b : BenchBuffers)
  # Optional batch interface.
  let req : kex.KexBatchSharedSecretRequest = kex.KexBatchSharedSecretRequest
  req.scalars = b.scalars
  req.publics = b.publics
  req.outputs = b.secrets
  req.batch_n = c.batch_n
  kex.kex_batch_shared_secret(req)
.end

# ============================================================================
# Run case
# ============================================================================

fn bench_run_case(cfg : BenchConfig, c_in : BenchCase) -> BenchResult
  let r : BenchResult = BenchResult

  let c : BenchCase = bench_case_apply_defaults(cfg, c_in)
  r.case = c

  bench_emit_case_begin(c)

  let rng : BenchRng = bench_rng_init(cfg)
  let b : BenchBuffers = bench_buffers_make(rng, c)

  let k : BenchKex = bench_kex_init(cfg)

  # For shared-secret benches, ensure peer public exists (placeholder).
  bench_sink_u64(b.public.len as u64)

  # Batch bench placeholder population
  if c.op == BenchOp.BatchSharedSecret
    bench_sink_u64(c.batch_n as u64)
  .end

  bench_warmup(cfg, k, rng, c, b)

  let stats : BenchStats = bench_measure(cfg, k, rng, c, b)
  r.stats = stats
  r.err = BenchError.Ok

  bench_emit_case_end(r)
  return r
.end

fn bench_build_cases_max() -> coll.Vec[BenchCase]
  let v : coll.Vec[BenchCase] = coll.Vec[BenchCase]

  # Keygen
  v.push(bench_case_make("keygen", BenchOp.KeyGen, BenchMode.OneShot))

  # Generic shared secret
  let ss : BenchCase = bench_case_make("shared_secret/oneshot", BenchOp.SharedSecret, BenchMode.OneShot)
  v.push(ss)

  let sv : BenchCase = bench_case_make("shared_secret/view", BenchOp.SharedSecret, BenchMode.OneShotView)
  sv.validate = true
  v.push(sv)

  let si : BenchCase = bench_case_make("shared_secret/iovec", BenchOp.SharedSecret, BenchMode.IoVecView)
  v.push(si)

  # Fixed-base and variable-base hooks
  v.push(bench_case_make("shared_secret/fixed_base", BenchOp.SharedSecretFixedBase, BenchMode.OneShot))
  v.push(bench_case_make("shared_secret/variable_base", BenchOp.SharedSecretVariableBase, BenchMode.OneShot))

  # RNG input variants
  let rr : BenchCase = bench_case_make("shared_secret/oneshot_rng", BenchOp.SharedSecret, BenchMode.OneShot)
  rr.rng_inputs = true
  v.push(rr)

  # Batch
  let bb : BenchCase = bench_case_make("batch_shared_secret/128", BenchOp.BatchSharedSecret, BenchMode.OneShot)
  bb.batch_n = 128
  v.push(bb)

  return v
.end

# ============================================================================
# Entrypoint
# ============================================================================

fn main() -> i32
  let cfg : BenchConfig = bench_default_config()

  # Default provider/alg ids should be set by harness/runner.
  # Example:
  #   cfg.provider_id = "default"
  #   cfg.alg_id = "x25519"

  bench_emit_begin(cfg)

  let cases : coll.Vec[BenchCase] = bench_build_cases_max()

  let i : u64 = 0
  while i < cases.len()
    let c : BenchCase = cases[i]
    bench_run_case(cfg, c)
    i += 1
  .end

  bench_emit_end(cfg)
  return 0
.end

.end