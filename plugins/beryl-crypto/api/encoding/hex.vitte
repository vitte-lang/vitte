# plugins/crypto/api/encoding/hex.vitte
# Hex
# Blocks use `.end` only.

mod plugins.crypto.api.encoding.hex

# TODO

.end

# plugins/beryl/api/encoding/hex.vitte
# Hex / HexLower / HexUpper — API contract (data-first, backend-agnostic) — MAX++
# Blocks use `.end` only.
#
# Objectifs:
#   - Contrat d'encodage/décodage hex complet:
#       * casse (lower/upper), préfixe optionnel (0x), séparateurs optionnels
#       * modes strict vs permissif (whitespace/underscore/colon/dash)
#       * one-shot + streaming (incremental)
#       * views (zero-copy) optionnelles
#   - Aucun I/O ici.
#
# Notes:
#   - Encodage: 1 byte -> 2 chars (nibbles).
#   - Décodage: accepte éventuellement un nombre impair de nibbles selon policy.

module plugins.crypto.api.encoding.hex

import std.collections as coll

# ============================================================================
# Versioning
# ============================================================================

const HEX_API_VERSION_MAJOR : u32 = 1
const HEX_API_VERSION_MINOR : u32 = 0
const HEX_API_VERSION_PATCH : u32 = 0

# ============================================================================
# Errors
# ============================================================================

enum HexError
  Ok
  Unsupported

  InvalidProvider
  InvalidPolicy

  InvalidInput
  InvalidOutput
  InvalidLength
  InvalidCharacter

  BufferTooSmall
  OutputTooLarge

  ProviderUnavailable
  ProviderBusy
  RateLimited
  Timeout

  MalformedInput
  SerializationError
  DeserializationError

  InternalError
.end

# ============================================================================
# Variants / policy
# ============================================================================

enum HexCase
  Lower
  Upper
.end

enum HexPrefix
  None
  Ox
.end

enum HexWhitespace
  Reject
  Allow
.end

enum HexSeparators
  Reject
  Allow
.end

enum HexOddLength
  Reject
  AllowLeadingNibble
.end

struct HexPolicy
  case           : HexCase
  prefix         : HexPrefix

  # decoding controls
  whitespace     : HexWhitespace
  separators     : HexSeparators

  # allow odd number of hex digits
  odd_length     : HexOddLength

  # whether to accept 0x prefix on decode even if prefix==None
  accept_0x      : bool

  # safety
  strict_length  : bool
.end

# ============================================================================
# Provider metadata
# ============================================================================

type HexProviderId = string

enum HexBackendKind
  Unknown
  Software
  Hardware
  Remote
.end

const HEX_FLAG_ENCODE_ONE_SHOT      : u32 = 1
const HEX_FLAG_DECODE_ONE_SHOT      : u32 = 2
const HEX_FLAG_STREAMING_ENCODE     : u32 = 4
const HEX_FLAG_STREAMING_DECODE     : u32 = 8
const HEX_FLAG_VIEWS                : u32 = 16

const HEX_FLAG_SIMD                 : u32 = 32

const HEX_PROVIDER_FLAG_SOFTWARE    : u32 = 1
const HEX_PROVIDER_FLAG_HARDWARE    : u32 = 2
const HEX_PROVIDER_FLAG_REMOTE      : u32 = 4
const HEX_PROVIDER_FLAG_THREADSAFE  : u32 = 8
const HEX_PROVIDER_FLAG_SANDBOXED   : u32 = 16

struct HexLimits
  in_max          : u64
  out_max         : u64
.end

struct HexProviderInfo
  id              : HexProviderId
  name            : string
  vendor          : string
  version         : string

  backend         : HexBackendKind
  priority        : i32
  flags           : u32

  build           : string
  device          : string
  location        : string

  limits          : HexLimits
.end

# ============================================================================
# Views (zero-copy optional)
# ============================================================================

struct ByteSlice
  ptr             : u64
  len             : u64
.end

struct MutByteSlice
  ptr             : u64
  len             : u64
.end

# ============================================================================
# Owned payload containers
# ============================================================================

struct HexBytes
  bytes           : coll.Vec[u8]
.end

struct HexText
  text            : string
.end

# ============================================================================
# One-shot encode/decode
# ============================================================================

struct HexEncodeRequest
  policy          : HexPolicy
  input           : HexBytes
.end

struct HexEncodeResponse
  err             : HexError
  output          : HexText
.end

struct HexDecodeRequest
  policy          : HexPolicy
  input           : HexText
.end

struct HexDecodeResponse
  err             : HexError
  output          : HexBytes
.end

# Views one-shot
struct HexEncodeRequestView
  policy          : HexPolicy
  input           : ByteSlice
  output          : MutByteSlice
.end

struct HexEncodeResponseView
  err             : HexError
  written         : u64
.end

struct HexDecodeRequestView
  policy          : HexPolicy
  input           : ByteSlice
  output          : MutByteSlice
.end

struct HexDecodeResponseView
  err             : HexError
  written         : u64
.end

# ============================================================================
# Streaming encode/decode
# ============================================================================

enum HexStreamKind
  Encode
  Decode
.end

enum HexStreamState
  Init
  Data
  Final
  Closed
.end

struct HexStreamInfo
  provider_id     : HexProviderId
  kind            : HexStreamKind
  policy          : HexPolicy
  state           : HexStreamState

  buffered_in     : u32
  buffered_out    : u32
  flags           : u32
.end

# Opaque handle (slot+generation impl côté runtime)
struct HexStream
  handle          : u64
  info            : HexStreamInfo
.end

struct HexStreamStartRequest
  provider_id     : HexProviderId
  kind            : HexStreamKind
  policy          : HexPolicy
.end

struct HexStreamStartResponse
  err             : HexError
  stream          : HexStream
.end

struct HexStreamUpdateRequest
  stream          : HexStream
  input           : HexBytes
.end

struct HexStreamUpdateResponse
  err             : HexError
  output          : HexText
.end

struct HexStreamUpdateRequestView
  stream          : HexStream
  input           : ByteSlice
  output          : MutByteSlice
.end

struct HexStreamUpdateResponseView
  err             : HexError
  written         : u64
.end

struct HexStreamFinishRequest
  stream          : HexStream
.end

struct HexStreamFinishResponse
  err             : HexError
  output          : HexText
.end

struct HexStreamFinishResponseView
  err             : HexError
  written         : u64
.end

# ============================================================================
# ABI outputs (runtime provided)
# ============================================================================

fn abi_out_provider_info_struct(info : HexProviderInfo)
.end

fn abi_out_encode_response(resp : HexEncodeResponse)
.end

fn abi_out_decode_response(resp : HexDecodeResponse)
.end

fn abi_out_encode_response_view(resp : HexEncodeResponseView)
.end

fn abi_out_decode_response_view(resp : HexDecodeResponseView)
.end

fn abi_out_stream_start_response(resp : HexStreamStartResponse)
.end

fn abi_out_stream_update_response(resp : HexStreamUpdateResponse)
.end

fn abi_out_stream_update_response_view(resp : HexStreamUpdateResponseView)
.end

fn abi_out_stream_finish_response(resp : HexStreamFinishResponse)
.end

fn abi_out_stream_finish_response_view(resp : HexStreamFinishResponseView)
.end

fn abi_out_error(err : HexError)
.end

# ============================================================================
# Provider surface (typed entrypoints)
# ============================================================================

fn hex_provider_enumerate()
.end

fn hex_provider_query(provider_id : HexProviderId)
.end

fn hex_encode(req : HexEncodeRequest)
.end

fn hex_decode(req : HexDecodeRequest)
.end

fn hex_encode_view(req : HexEncodeRequestView)
.end

fn hex_decode_view(req : HexDecodeRequestView)
.end

fn hex_stream_start(req : HexStreamStartRequest)
.end

fn hex_stream_update(req : HexStreamUpdateRequest)
.end

fn hex_stream_update_view(req : HexStreamUpdateRequestView)
.end

fn hex_stream_finish(req : HexStreamFinishRequest)
.end

fn hex_stream_destroy(stream : HexStream)
.end

# ============================================================================
# Size helpers (pure)
# ============================================================================

# Worst-case encoded length for `n` bytes, including optional prefix and separators.
fn hex_encoded_len(n : u64, policy : HexPolicy) -> u64
  return 0
.end

# Worst-case decoded length for `n` chars, under policy.
fn hex_decoded_len(n : u64, policy : HexPolicy) -> u64
  return 0
.end

# ============================================================================
# Default policies
# ============================================================================

fn hex_policy_lower() -> HexPolicy
  let p : HexPolicy = HexPolicy
  return p
.end

fn hex_policy_upper() -> HexPolicy
  let p : HexPolicy = HexPolicy
  return p
.end

fn hex_policy_permissive() -> HexPolicy
  let p : HexPolicy = HexPolicy
  return p
.end

# ============================================================================
# TODO checklist (impl réelle) — MAX++
# ============================================================================

# Providers
# - Impl enumerate/query + HexProviderInfo (software, SIMD, remote).
# - Remplacer toute sortie "texte" par ABI structs.

# Encode
# - Impl encode nibbles -> chars:
#     * case lower/upper.
#     * prefix 0x optional.
#     * option separators (si introduits par policy future).
# - Streaming encode:
#     * output incremental, BufferTooSmall + written.

# Decode
# - Validation chars:
#     * accept 0-9 a-f A-F.
#     * reject or skip separators/whitespace depending on policy.
# - odd_length:
#     * Reject: InvalidLength.
#     * AllowLeadingNibble: treat first nibble as 0x0? + stable behavior.
# - accept_0x:
#     * strip optional 0x/0X.
# - Streaming decode:
#     * buffer single nibble when chunk splits.

# Hardening
# - Robustness against malicious input sizes, overflow in len computations.

# Tests
# - Vectors:
#     * known pairs (00 -> "00", ff -> "ff" etc.).
# - Negative:
#     * invalid chars, odd length reject, prefix invalid.
# - Streaming:
#     * random chunk boundaries match one-shot.
# - Fuzz:
#     * random strings with separators/whitespace.

# Bench
# - microbench encode/decode + SIMD path.

.end