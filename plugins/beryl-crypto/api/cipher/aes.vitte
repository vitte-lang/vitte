# plugins/beryl/api/cipher/aes.vitte
# AES (block cipher) — API contract (data-first, backend-agnostic) — MAX++
# Blocks use `.end` only.
#
# Objectifs:
#   - Définir un contrat AES maximal: providers, algos, handles, contexts, one-shot, streaming.
#   - Aucun I/O, aucune crypto réelle dans ce fichier.
#   - Sorties typées (structs) via ABI runtime (marshalling).
#   - Option zéro-copy via views (slices) si backend supporté.
#
# Notes:
#   - AES est un cipher bloc (16 bytes). Les modes (ECB/CBC/CTR/XTS/...) sont exposés ici.
#   - Les providers peuvent implémenter un sous-ensemble (flags). Toute fonction peut renvoyer Unsupported.

module plugins.crypto.api.cipher.aes

import std.collections as coll

# ============================================================================
# Versioning
# ============================================================================

const AES_API_VERSION_MAJOR : u32 = 1
const AES_API_VERSION_MINOR : u32 = 0
const AES_API_VERSION_PATCH : u32 = 0

# ============================================================================
# Constants
# ============================================================================

const AES_BLOCK_LEN : u32 = 16

const AES_KEY_LEN_128 : u32 = 16
const AES_KEY_LEN_192 : u32 = 24
const AES_KEY_LEN_256 : u32 = 32

# ============================================================================
# Errors
# ============================================================================

enum AesError
  Ok
  Unsupported

  InvalidProvider
  InvalidAlgorithm
  InvalidKey
  InvalidContext
  InvalidInput
  InvalidOutput
  InvalidIv
  InvalidNonce
  InvalidTweak
  InvalidPolicy

  BufferTooSmall
  MessageTooLarge

  ProviderUnavailable
  ProviderBusy
  PermissionDenied
  RateLimited
  Timeout

  MalformedInput
  SerializationError
  DeserializationError

  InternalError
.end

# ============================================================================
# Identifiers / metadata
# ============================================================================

type AesProviderId = string

enum AesBackendKind
  Unknown
  Software
  Hardware
  Kms
  Remote
.end

enum AesFamily
  Aes
.end

enum AesAlg
  Aes128
  Aes192
  Aes256
.end

enum AesMode
  Ecb
  Cbc
  Ctr
  Xts
.end

enum AesPadding
  None
  Pkcs7
.end

enum AesDirection
  Encrypt
  Decrypt
.end

enum AesKeyUsage
  EncryptOnly
  DecryptOnly
  EncryptAndDecrypt
.end

# ============================================================================
# Capability flags
# ============================================================================

const AES_FLAG_BLOCK_ENCRYPT       : u32 = 1
const AES_FLAG_BLOCK_DECRYPT       : u32 = 2
const AES_FLAG_ECB                 : u32 = 4
const AES_FLAG_CBC                 : u32 = 8
const AES_FLAG_CTR                 : u32 = 16
const AES_FLAG_XTS                 : u32 = 32
const AES_FLAG_STREAMING           : u32 = 64
const AES_FLAG_HW_ACCEL            : u32 = 128
const AES_FLAG_FIPS                : u32 = 256
const AES_FLAG_SIDECHANNEL_HARD    : u32 = 512
const AES_FLAG_CONSTANT_TIME       : u32 = 1024

const AES_PROVIDER_FLAG_SOFTWARE   : u32 = 1
const AES_PROVIDER_FLAG_HARDWARE   : u32 = 2
const AES_PROVIDER_FLAG_KMS        : u32 = 4
const AES_PROVIDER_FLAG_REMOTE     : u32 = 8
const AES_PROVIDER_FLAG_THREADSAFE : u32 = 16
const AES_PROVIDER_FLAG_SANDBOXED  : u32 = 32

# ============================================================================
# Limits / lens
# ============================================================================

struct AesLimits
  key_min     : u32
  key_max     : u32
  iv_min      : u32
  iv_max      : u32
  nonce_min   : u32
  nonce_max   : u32
  tweak_min   : u32
  tweak_max   : u32

  aad_max     : u64
  msg_max     : u64
.end

struct AesLenSet
  min         : u32
  max         : u32
  step        : u32
  preferred   : coll.Vec[u32]
.end

struct AesAlgInfo
  alg         : AesAlg
  name        : string
  family      : AesFamily

  block_len   : u32
  key_lens    : AesLenSet
  iv_lens     : AesLenSet
  nonce_lens  : AesLenSet
  tweak_lens  : AesLenSet

  flags       : u32
  limits      : AesLimits
.end

struct AesProviderInfo
  id          : AesProviderId
  name        : string
  vendor      : string
  version     : string

  backend     : AesBackendKind
  priority    : i32
  flags       : u32

  build       : string
  device      : string
  location    : string

  algorithms  : coll.Vec[AesAlgInfo]
.end

# ============================================================================
# Handles (opaque)
# ============================================================================

type AesHandle = u64

enum AesHandleKind
  None
  Provider
  Key
  Context
  Stream
.end

struct AesOpaque
  kind        : AesHandleKind
  value       : AesHandle
.end

# ============================================================================
# Views (zero-copy optional)
# ============================================================================

struct ByteSlice
  ptr         : u64
  len         : u64
.end

struct MutByteSlice
  ptr         : u64
  len         : u64
.end

struct IoVec
  slices      : coll.Vec[ByteSlice]
  total_len   : u64
.end

struct MutIoVec
  slices      : coll.Vec[MutByteSlice]
  total_len   : u64
.end

# ============================================================================
# Key / context model
# ============================================================================

struct AesKeyConstraints
  usage       : AesKeyUsage
  fips        : bool
  allow_hw    : bool
.end

struct AesKeyInfo
  provider_id : AesProviderId
  alg         : AesAlg
  key_id      : string

  usage       : AesKeyUsage
  key_len     : u32

  created_ms  : u64
  expires_ms  : u64

  flags       : u32
  constraints : AesKeyConstraints
.end

struct AesKeyRef
  key         : AesOpaque
  info        : AesKeyInfo
.end

struct AesContextPolicy
  mode        : AesMode
  dir         : AesDirection
  padding     : AesPadding
  strict_len  : bool
.end

struct AesContextInfo
  provider_id : AesProviderId
  alg         : AesAlg
  key         : AesOpaque
  flags       : u32
  policy      : AesContextPolicy
.end

struct AesContextRef
  ctx         : AesOpaque
  info        : AesContextInfo
.end

# ============================================================================
# Owned payload containers
# ============================================================================

struct AesBytes
  bytes       : coll.Vec[u8]
.end

struct AesBlock
  bytes       : coll.Vec[u8]
.end

struct AesIv
  bytes       : coll.Vec[u8]
.end

struct AesNonce
  bytes       : coll.Vec[u8]
.end

struct AesTweak
  bytes       : coll.Vec[u8]
.end

# ============================================================================
# Views payload containers
# ============================================================================

struct AesBlockView
  bytes       : ByteSlice
.end

struct AesIvView
  bytes       : ByteSlice
.end

struct AesNonceView
  bytes       : ByteSlice
.end

struct AesTweakView
  bytes       : ByteSlice
.end

# ============================================================================
# One-shot operations (block / buffer)
# ============================================================================

struct AesBlockOptions
  mode        : AesMode
  padding     : AesPadding
.end

struct AesEncryptBlockRequest
  ctx         : AesContextRef
  in_block    : AesBlock
  options     : AesBlockOptions
.end

struct AesDecryptBlockRequest
  ctx         : AesContextRef
  in_block    : AesBlock
  options     : AesBlockOptions
.end

struct AesEncryptBlockResponse
  err         : AesError
  out_block   : AesBlock
.end

struct AesDecryptBlockResponse
  err         : AesError
  out_block   : AesBlock
.end

struct AesCryptBufferOptions
  mode        : AesMode
  padding     : AesPadding
.end

struct AesCryptBufferRequest
  ctx         : AesContextRef
  iv          : AesIv
  nonce       : AesNonce
  tweak       : AesTweak

  in_bytes    : AesBytes
  options     : AesCryptBufferOptions
.end

struct AesCryptBufferResponse
  err         : AesError
  out_bytes   : AesBytes
.end

# Zero-copy one-shot
struct AesEncryptBlockRequestView
  ctx         : AesContextRef
  in_block    : AesBlockView
  options     : AesBlockOptions
.end

struct AesDecryptBlockRequestView
  ctx         : AesContextRef
  in_block    : AesBlockView
  options     : AesBlockOptions
.end

struct AesEncryptBlockResponseView
  err         : AesError
  out_block   : AesBlockView
.end

struct AesDecryptBlockResponseView
  err         : AesError
  out_block   : AesBlockView
.end

struct AesCryptBufferRequestView
  ctx         : AesContextRef
  iv          : AesIvView
  nonce       : AesNonceView
  tweak       : AesTweakView

  in_bytes    : ByteSlice
  options     : AesCryptBufferOptions
.end

struct AesCryptBufferResponseView
  err         : AesError
  out_bytes   : ByteSlice
.end

# ============================================================================
# Streaming (optional)
# ============================================================================

enum AesStreamState
  Init
  Iv
  Data
  Final
  Closed
.end

struct AesStreamInfo
  provider_id : AesProviderId
  alg         : AesAlg
  ctx         : AesOpaque
  mode        : AesMode
  dir         : AesDirection
  state       : AesStreamState
  flags       : u32
.end

struct AesStreamRef
  stream      : AesOpaque
  info        : AesStreamInfo
.end

struct AesStreamStartRequest
  ctx         : AesContextRef
  iv          : AesIv
  nonce       : AesNonce
  tweak       : AesTweak
.end

struct AesStreamStartResponse
  err         : AesError
  stream      : AesStreamRef
.end

struct AesStreamUpdateRequest
  stream      : AesStreamRef
  chunk       : AesBytes
.end

struct AesStreamUpdateResponse
  err         : AesError
  out_chunk   : AesBytes
.end

struct AesStreamFinishRequest
  stream      : AesStreamRef
.end

struct AesStreamFinishResponse
  err         : AesError
.end

# ============================================================================
# ABI outputs (runtime provided)
# ============================================================================

fn abi_out_provider_info_struct(info : AesProviderInfo)
.end

fn abi_out_alg_info_struct(info : AesAlgInfo)
.end

fn abi_out_select(provider_id : AesProviderId, alg : AesAlg)
.end

fn abi_out_key_ref_struct(key_ref : AesKeyRef)
.end

fn abi_out_ctx_ref_struct(ctx_ref : AesContextRef)
.end

fn abi_out_encrypt_block_response(resp : AesEncryptBlockResponse)
.end

fn abi_out_decrypt_block_response(resp : AesDecryptBlockResponse)
.end

fn abi_out_crypt_buffer_response(resp : AesCryptBufferResponse)
.end

fn abi_out_encrypt_block_response_view(resp : AesEncryptBlockResponseView)
.end

fn abi_out_decrypt_block_response_view(resp : AesDecryptBlockResponseView)
.end

fn abi_out_crypt_buffer_response_view(resp : AesCryptBufferResponseView)
.end

fn abi_out_stream_start_response(resp : AesStreamStartResponse)
.end

fn abi_out_stream_update_response(resp : AesStreamUpdateResponse)
.end

fn abi_out_stream_finish_response(resp : AesStreamFinishResponse)
.end

fn abi_out_error(err : AesError)
.end

# ============================================================================
# Provider surface (typed entrypoints)
# ============================================================================

fn aes_provider_enumerate()
.end

fn aes_provider_query(provider_id : AesProviderId)
.end

fn aes_provider_select(provider_id : AesProviderId, alg : AesAlg)
.end

fn aes_key_generate(provider_id : AesProviderId, alg : AesAlg, usage : AesKeyUsage)
.end

fn aes_key_import(provider_id : AesProviderId, alg : AesAlg, usage : AesKeyUsage, key_bytes : coll.Vec[u8])
.end

fn aes_key_destroy(key : AesOpaque)
.end

fn aes_context_create(key : AesOpaque, flags : u32, policy : AesContextPolicy)
.end

fn aes_context_destroy(ctx : AesOpaque)
.end

fn aes_encrypt_block(req : AesEncryptBlockRequest)
.end

fn aes_decrypt_block(req : AesDecryptBlockRequest)
.end

fn aes_crypt_buffer(req : AesCryptBufferRequest)
.end

# Optional zero-copy
fn aes_encrypt_block_view(req : AesEncryptBlockRequestView)
.end

fn aes_decrypt_block_view(req : AesDecryptBlockRequestView)
.end

fn aes_crypt_buffer_view(req : AesCryptBufferRequestView)
.end

# Streaming
fn aes_stream_start(req : AesStreamStartRequest)
.end

fn aes_stream_update(req : AesStreamUpdateRequest)
.end

fn aes_stream_finish(req : AesStreamFinishRequest)
.end

fn aes_stream_destroy(stream : AesOpaque)
.end

# ============================================================================
# Minimal helpers
# ============================================================================

fn aes_block_len() -> u32
  return AES_BLOCK_LEN
.end

fn aes_key_len_for_alg(alg : AesAlg) -> u32
  return 0
.end

fn aes_error_name(err : AesError) -> string
  return "AesError"
.end

# ============================================================================
# TODO checklist (impl réelle)
# ============================================================================

# Providers / registry
# - Impl `aes_provider_enumerate/query/select` et remplir `AesProviderInfo`/`AesAlgInfo`.
# - Remplacer toute sortie "texte" par ABI structs (`abi_out_*_struct`) (marshalling runtime).
# - Définir une politique de priorité/choix (software vs hw vs kms/remote) + fallback.
# - Exposer `AES_PROVIDER_FLAG_THREADSAFE/SANDBOXED` correctement.

# Handles (slot + generation)
# - Impl tables handles: slot + generation, O(1) lookup, thread-safe.
# - Séparer espaces de handles (Provider/Key/Context/Stream) + validation `AesHandleKind`.
# - Impl destroy idempotent + poison d’objets libérés (détecter use-after-free logique).

# Key management
# - Impl `aes_key_generate` (128/192/256) + `aes_key_import`.
# - Vérifier longueur de clé selon `AesAlg` + `AesLenSet` + `AesLimits`.
# - Impl `AesKeyUsage` (enforcement côté provider) + constraints (FIPS, allow_hw).
# - Secure memory:
#     * key bytes en mémoire protégée si possible (mlock / guard pages) côté runtime.
#     * memwipe systématique des buffers temporaires.

# Contexts
# - Impl `aes_context_create/destroy`:
#     * policy: mode/dir/padding/strict_len.
#     * validation flags (ex: XTS nécessite tweak).
# - Normaliser erreurs: InvalidIv/InvalidNonce/InvalidTweak/InvalidPolicy.

# AES core (block cipher)
# - Impl AES block encrypt/decrypt (16 bytes):
#     * AES-NI (x86) / ARMv8 Crypto Extensions (aarch64) quand dispo.
#     * fallback software constant-time (bitsliced / T-tables interdites si CT requis).
# - Impl key schedule (expand) + cache/ownership dans Key/Context.
# - Interdire branches/memory access dépendantes du secret (side-channel).

# Modes (one-shot)
# - Impl ECB (debug/testing only) avec warning: jamais en prod.
# - Impl CBC:
#     * IV obligatoire, longueur multiple du bloc.
#     * padding: None / PKCS7 (const-time sur validation padding si possible).
# - Impl CTR:
#     * nonce/IV: définir mapping (IV=counter block) et incrément 128-bit.
#     * support streaming naturel (update arbitraire).
# - Impl XTS:
#     * key split (2x keys) + tweak validation.
#     * alignement secteurs (ou définir règle claire) + tests NIST XTS.

# Zero-copy views
# - Impl variantes `*_view` si runtime supporte ByteSlice/MutByteSlice.
# - Garantir que `out_bytes`/`out_block` views pointent vers des buffers valides (ownership clarifiée).
# - Ajouter I/O scatter/gather (IoVec/MutIoVec) si besoin performance.

# Streaming
# - Impl `aes_stream_start/update/finish/destroy`:
#     * state machine `AesStreamState` stricte.
#     * CTR: update arbitraire.
#     * CBC: update en multiples de blocs, finish gère padding.
#     * finish idempotent, destroy safe.
# - Impl backpressure / BufferTooSmall si sortie insuffisante.

# Validation / limits
# - Impl checks `AesLimits`:
#     * msg_max, aad_max (si utilisé dans futurs modes/AEAD wrappers).
# - Refuser tailles incohérentes (InvalidInput/InvalidOutput/MessageTooLarge).

# Hardening
# - Constant-time compare quand pertinent (padding, contrôles sensibles).
# - secret-independent memory access.
# - memwipe: clés temporaires, round keys, buffers intermédiaires.
# - Option `AES_FLAG_SIDECHANNEL_HARD`/`AES_FLAG_CONSTANT_TIME` enforceable.

# Tests
# - Vectors:
#     * NIST SP 800-38A: AES-ECB/CBC/CTR (KAT).
#     * NIST SP 800-38E: XTS-AES.
# - Differential tests:
#     * comparer fallback software vs hw accel (mêmes entrées => mêmes sorties).
# - Property tests:
#     * decrypt(encrypt(m)) == m (selon mode/padding).
# - Fuzz:
#     * inputs malformés (tailles, padding, IV/tweak invalides).
#     * streaming state machine (séquences invalides) => erreurs stables.

# Bench / perf (optionnel)
# - Microbench AES block + CBC/CTR + XTS.
# - Mesurer overhead handles + marshalling.

.end