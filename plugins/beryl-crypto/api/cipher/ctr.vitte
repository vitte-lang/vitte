# plugins/beryl/api/cipher/ctr.vitte
# CTR mode — API contract (wrapper over cipher.block) — MAX++ (aligned)
# Blocks use `.end` only.
#
# Objectifs:
#   - API CTR générique au-dessus de `plugins.crypto.api.cipher.block`.
#   - One-shot + streaming + views (zero-copy) optionnelles.
#   - Validation claire: counter block (IV) obligatoire, incrément 128-bit, overflow policy.
#   - Aucun calcul crypto réel ici (contrat + ABI only).
#
# Notes:
#   - CTR = stream mode (XOR keystream): encrypt/decrypt identiques.
#   - Convention inputs:
#       * `iv` = counter block initial (taille == block_len)
#       * `nonce` inutilisé ici (réservé)
#       * `tweak` inutilisé

module plugins.crypto.api.cipher.ctr

import std.collections as coll
import plugins.crypto.api.cipher.block as blk

# ============================================================================
# Versioning
# ============================================================================

const CTR_API_VERSION_MAJOR : u32 = 1
const CTR_API_VERSION_MINOR : u32 = 0
const CTR_API_VERSION_PATCH : u32 = 0

# Convention: mode_id côté `cipher.block`
const CTR_BLOCK_MODE_ID : string = "ctr"

# ============================================================================
# Errors
# ============================================================================

enum CtrError
  Ok
  Unsupported

  InvalidProvider
  InvalidCipher
  InvalidKey
  InvalidContext
  InvalidStream

  InvalidInput
  InvalidOutput
  InvalidIv
  InvalidCounter
  InvalidPolicy

  BufferTooSmall
  MessageTooLarge

  ProviderUnavailable
  ProviderBusy
  PermissionDenied
  RateLimited
  Timeout

  MalformedInput
  SerializationError
  DeserializationError

  InternalError
.end

# ============================================================================
# Policy / counter model
# ============================================================================

# CTR increments a counter block (typically 128-bit). Policy defines layout.

enum CtrCounterEndian
  Big
  Little
.end

# How to interpret/advance counter within the IV.
struct CtrCounterLayout
  # offset in bytes within IV where counter starts
  offset      : u32
  # length in bytes of counter region (1..block_len)
  length      : u32
  endian      : CtrCounterEndian
.end

# Overflow policy when counter wraps.

enum CtrOverflowPolicy
  Error
  Wrap
.end

struct CtrPolicy
  layout       : CtrCounterLayout
  overflow     : CtrOverflowPolicy
  strict_iv    : bool
.end

# CTR context = wrapper around a `BlockContextRef` whose policy.mode_id == "ctr".
struct CtrContext
  block_ctx     : blk.BlockContextRef
  block_len     : u32
  policy        : CtrPolicy
.end

# ============================================================================
# Requests / responses — one-shot (owned)
# ============================================================================

struct CtrCryptRequest
  ctx           : CtrContext
  iv            : blk.BlockIv
  input         : blk.BlockBytes
.end

struct CtrCryptResponse
  err           : CtrError
  output        : blk.BlockBytes
.end

# ============================================================================
# Requests / responses — one-shot (views / zero-copy)
# ============================================================================

struct CtrCryptRequestView
  ctx           : CtrContext
  iv            : blk.BlockIvView
  input         : blk.ByteSlice
  output        : blk.MutByteSlice
.end

struct CtrCryptResponseView
  err           : CtrError
  written       : u64
.end

# ============================================================================
# Streaming
# ============================================================================

# CTR streaming wrappe un `BlockStreamRef` (mode_id == "ctr")
struct CtrStream
  block_stream  : blk.BlockStreamRef
  block_len     : u32
  policy        : CtrPolicy
.end

struct CtrStreamStartRequest
  ctx           : CtrContext
  iv            : blk.BlockIv
.end

struct CtrStreamStartResponse
  err           : CtrError
  stream        : CtrStream
.end

struct CtrStreamUpdateRequest
  stream        : CtrStream
  chunk         : blk.BlockBytes
.end

struct CtrStreamUpdateResponse
  err           : CtrError
  out_chunk     : blk.BlockBytes
.end

struct CtrStreamFinishRequest
  stream        : CtrStream
.end

struct CtrStreamFinishResponse
  err           : CtrError
.end

# ============================================================================
# ABI outputs (runtime provided)
# ============================================================================

fn abi_out_ctx_struct(ctx : CtrContext)
.end

fn abi_out_crypt_response(resp : CtrCryptResponse)
.end

fn abi_out_crypt_response_view(resp : CtrCryptResponseView)
.end

fn abi_out_stream_start_response(resp : CtrStreamStartResponse)
.end

fn abi_out_stream_update_response(resp : CtrStreamUpdateResponse)
.end

fn abi_out_stream_finish_response(resp : CtrStreamFinishResponse)
.end

fn abi_out_error(err : CtrError)
.end

# ============================================================================
# Surface API (typed entrypoints)
# ============================================================================

# Build CTR context from an already-created BlockContextRef (must be CTR mode).
fn ctr_context_from_block_ctx(block_ctx : blk.BlockContextRef, block_len : u32, policy : CtrPolicy)
.end

# Create CTR context from a BlockKeyRef (implementation dispatches to `cipher.block`).
fn ctr_context_create_from_key(key : blk.BlockKeyRef, block_len : u32, policy : CtrPolicy, flags : u32)
.end

fn ctr_context_destroy(ctx : CtrContext)
.end

fn ctr_crypt(req : CtrCryptRequest)
.end

fn ctr_crypt_view(req : CtrCryptRequestView)
.end

fn ctr_stream_start(req : CtrStreamStartRequest)
.end

fn ctr_stream_update(req : CtrStreamUpdateRequest)
.end

fn ctr_stream_finish(req : CtrStreamFinishRequest)
.end

fn ctr_stream_destroy(stream : CtrStream)
.end

# ============================================================================
# TODO checklist (impl réelle) — MAX++
# ============================================================================

# Intégration `cipher.block`
# - Enforcer `CTR_BLOCK_MODE_ID`:
#     * context_from_block_ctx: vérifier `block_ctx.info.policy.mode_id == "ctr"` sinon InvalidPolicy.
#     * context_create_from_key: construire `blk.BlockContextPolicy` avec mode_id="ctr".
# - Clarifier `BlockPadding` pour CTR: doit être None (CTR n'utilise pas padding).
# - Mapping erreurs BlockError -> CtrError (stable).

# Counter / IV semantics
# - Validation IV:
#     * `len(iv) == block_len` si `strict_iv`.
#     * layout.offset+layout.length <= block_len.
# - Incrément:
#     * big-endian ou little-endian sur la région counter.
#     * carry propagation.
# - Overflow:
#     * Error: renvoyer InvalidCounter/MessageTooLarge.
#     * Wrap: autoriser wrap (risque sécurité selon usage) — documenter.

# One-shot
# - Impl `ctr_crypt` via `blk.block_crypt_buffer`:
#     * iv = counter block
#     * nonce/tweak vides
#     * input arbitraire (pas de multiple de bloc requis)
# - Views:
#     * `ctr_crypt_view` support in-place si output alias input.
#     * BufferTooSmall + written.

# Streaming
# - Impl start/update/finish via `blk.block_stream_*`.
# - CTR update arbitraire:
#     * conserver offset intra-bloc (keystream remainder) côté provider.
# - finish idempotent.

# Side-channel hardening
# - constant-time best effort (cipher core dépend du provider).
# - memwipe: counter tmp / buffers.

# Tests
# - Vectors:
#     * NIST SP 800-38A CTR-AES.
# - Properties:
#     * decrypt(encrypt(m)) == m.
#     * streaming == one-shot.
# - Negative:
#     * IV invalid / layout invalid.
#     * overflow policy Error.
# - Fuzz:
#     * tailles aléatoires + layout aléatoire (contraint) + sequences streaming.

.end
# plugins/crypto/api/cipher/ctr.vitte
# CTR mode
# Blocks use `.end` only.

mod plugins.crypto.api.cipher.ctr

# TODO

.end
