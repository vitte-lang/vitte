# plugins/crypto/api/subtle.vitte
# Constant-time helpers
# Blocks use `.end` only.

mod plugins.crypto.api.subtle

# TODO

.end

# plugins/beryl-crypto/api/subtle.vitte
# Constant-time primitives — unified contract (data-first, backend-agnostic) — MAX+++
# Blocks use `.end` only.
#
# Objectifs:
#   - Fournir les primitives "subtle" nécessaires au hardening crypto:
#       * compares constant-time (eq, cmp, verify)
#       * conditional move / select
#       * masked operations, safe zeroing
#       * timing-safe memcmp + helpers for padding/tag verify
#       * utilities for secret-independent branching
#   - Pas d'impl spécifique ici; backends peuvent lier vers runtime/asm.

module plugins.crypto.api.subtle

import std.collections as coll

# ============================================================================
# Versioning
# ============================================================================

const SUBTLE_API_VERSION_MAJOR : u32 = 1
const SUBTLE_API_VERSION_MINOR : u32 = 0
const SUBTLE_API_VERSION_PATCH : u32 = 0

# ============================================================================
# Errors
# ============================================================================

enum SubtleError
  Ok
  Unsupported

  InvalidInput
  InvalidLength

  BufferTooSmall

  InternalError
.end

# ============================================================================
# Views / iovec
# ============================================================================

struct ByteSlice
  ptr  : u64
  len  : u64
.end

struct MutByteSlice
  ptr  : u64
  len  : u64
.end

struct IoVec
  slices     : coll.Vec[ByteSlice]
  total_len  : u64
.end

struct MutIoVec
  slices     : coll.Vec[MutByteSlice]
  total_len  : u64
.end

# ============================================================================
# Mask types
# ============================================================================

# A mask value must be either 0x00..00 or 0xFF..FF (all bits same).
# The representation is provider-defined but these helpers assume all-ones/all-zeros.

type MaskU8  = u8

type MaskU32 = u32

type MaskU64 = u64

# ============================================================================
# Results
# ============================================================================

struct CtEq
  # 1 if equal else 0
  value : u32
.end

struct CtCmp
  # -1,0,1 (encoded as i32)
  value : i32
.end

struct CtMask
  # all-ones or all-zeros mask
  value : u64
.end

# ============================================================================
# Flags / limits
# ============================================================================

const SUBTLE_FLAG_VIEWS          : u32 = 1
const SUBTLE_FLAG_IOVEC          : u32 = 2

const SUBTLE_FLAG_CT_COMPARE     : u32 = 4
const SUBTLE_FLAG_CT_SELECT      : u32 = 8
const SUBTLE_FLAG_CT_MEMWIPE     : u32 = 16
const SUBTLE_FLAG_CT_PAD_VERIFY  : u32 = 32

struct SubtleLimits
  max_len     : u64
  iovec_max   : u32
.end

# ============================================================================
# Provider info (optional)
# ============================================================================

# Subtle can be provided by runtime; still expose provider shape for symmetry.

type SubtleProviderId = string

type SubtleAlgId = string

enum SubtleBackendKind
  Unknown
  Software
  Hardware
  Remote
.end

struct SubtleAlgInfo
  id       : SubtleAlgId
  name     : string
  flags    : u32
  limits   : SubtleLimits
.end

struct SubtleProviderInfo
  id       : SubtleProviderId
  name     : string
  vendor   : string
  version  : string

  backend  : SubtleBackendKind
  priority : i32
  flags    : u32

  build    : string
  device   : string

  algorithms : coll.Vec[SubtleAlgInfo]
  limits     : SubtleLimits
.end

# ============================================================================
# Constant-time primitives (contracts)
# ============================================================================

# Return mask: all-ones if x == y else 0.
fn ct_mask_eq_u8(x : u8, y : u8) -> MaskU8
.end

fn ct_mask_eq_u32(x : u32, y : u32) -> MaskU32
.end

fn ct_mask_eq_u64(x : u64, y : u64) -> MaskU64
.end

# Less-than masks
fn ct_mask_lt_u32(x : u32, y : u32) -> MaskU32
.end

fn ct_mask_lt_u64(x : u64, y : u64) -> MaskU64
.end

# Constant-time select
fn ct_select_u8(mask : MaskU8, a : u8, b : u8) -> u8
.end

fn ct_select_u32(mask : MaskU32, a : u32, b : u32) -> u32
.end

fn ct_select_u64(mask : MaskU64, a : u64, b : u64) -> u64
.end

# Constant-time conditional move: if mask==all-ones then *dst = src else keep.
fn ct_cmov_u8(mask : MaskU8, dst : u8, src : u8) -> u8
.end

fn ct_cmov_u32(mask : MaskU32, dst : u32, src : u32) -> u32
.end

fn ct_cmov_u64(mask : MaskU64, dst : u64, src : u64) -> u64
.end

# Constant-time byte compare.
# Returns CtEq.value in {0,1}. Must run in time independent from data.
fn ct_eq_bytes(a : coll.Vec[u8], b : coll.Vec[u8]) -> CtEq
.end

fn ct_eq_bytes_view(a : ByteSlice, b : ByteSlice) -> CtEq
.end

fn ct_eq_iovec_view(a : IoVec, b : IoVec) -> CtEq
.end

# Timing-safe memcmp: returns CtCmp.value in {-1,0,1}.
# Must NOT early-return based on first difference.
fn ct_cmp_bytes(a : coll.Vec[u8], b : coll.Vec[u8]) -> CtCmp
.end

fn ct_cmp_bytes_view(a : ByteSlice, b : ByteSlice) -> CtCmp
.end

# Verify tag in constant time. Returns Ok on match else InvalidInput (or InternalError).
fn ct_verify_tag(tag : coll.Vec[u8], expected : coll.Vec[u8]) -> SubtleError
.end

fn ct_verify_tag_view(tag : ByteSlice, expected : ByteSlice) -> SubtleError
.end

# Pad verification helper (e.g. PKCS7).
# Returns Ok if padding valid else InvalidInput.
fn ct_verify_pkcs7_padding(block : coll.Vec[u8], block_len : u32) -> SubtleError
.end

fn ct_verify_pkcs7_padding_view(block : ByteSlice, block_len : u32) -> SubtleError
.end

# ============================================================================
# Memory wipe (best-effort constant-time)
# ============================================================================

# Wipes the buffer contents. Provider must ensure compiler does not optimize out.
fn memwipe(buf : coll.Vec[u8]) -> SubtleError
.end

fn memwipe_view(buf : MutByteSlice) -> SubtleError
.end

fn memwipe_iovec_view(buf : MutIoVec) -> SubtleError
.end

# Wipe a range.
fn memwipe_range_view(buf : MutByteSlice, offset : u64, len : u64) -> SubtleError
.end

# ============================================================================
# Helpers for secret-independent control flow (contracts)
# ============================================================================

# Convert CtEq to mask.
fn ct_mask_from_eq(eq : CtEq) -> CtMask
.end

# Convert boolean (0/1) to mask.
fn ct_mask_from_u32(x : u32) -> CtMask
.end

# Merge masks (AND/OR)
fn ct_mask_and(a : CtMask, b : CtMask) -> CtMask
.end

fn ct_mask_or(a : CtMask, b : CtMask) -> CtMask
.end

fn ct_mask_not(a : CtMask) -> CtMask
.end

# Select between two ByteSlices without branching (conceptual).
# Semantics: returns `a` if mask all-ones else `b`.
fn ct_select_byteslice(mask : CtMask, a : ByteSlice, b : ByteSlice) -> ByteSlice
.end

# ============================================================================
# Provider surface (optional)
# ============================================================================

fn subtle_provider_enumerate()
.end

fn subtle_provider_query(provider_id : SubtleProviderId)
.end

fn subtle_provider_select(provider_id : SubtleProviderId, alg_id : SubtleAlgId)
.end

# ============================================================================
# ABI outputs
# ============================================================================

fn abi_out_provider_info_struct(info : SubtleProviderInfo)
.end

fn abi_out_alg_info_struct(info : SubtleAlgInfo)
.end

fn abi_out_error(err : SubtleError)
.end

# ============================================================================
# TODO checklist (impl réelle) — MAX+++
# ============================================================================

# Core
# - Implement ct_mask_eq/lt using constant-time bit tricks.
# - Implement ct_select/cmov with mask semantics (all-ones/all-zeros).
#
# Compare
# - ct_eq_bytes/ct_cmp_bytes: iterate full length, handle length mismatch without data-dependent early exit.
# - iovec variants: constant-time over total_len; define semantics if lengths differ.
#
# Tag/padding
# - ct_verify_tag: constant-time compare and stable error.
# - ct_verify_pkcs7_padding: constant-time validation (avoid secret-dependent branches/memory).
#
# Memwipe
# - Use volatile writes or runtime intrinsic to avoid optimization.
# - Wipe temporaries in crypto modules using these hooks.
#
# Tests
# - Property tests for mask/select.
# - Compare correctness vs naive ops.
# - Microbench to ensure no early-exit behavior.

.end