# plugins/crypto/api/kdf/pbkdf2.vitte
# PBKDF2
# Blocks use `.end` only.

mod plugins.crypto.api.kdf.pbkdf2

# TODO

.end

# plugins/beryl-crypto/api/kdf/pbkdf2.vitte
# PBKDF2 (RFC 8018 / PKCS #5) — KDF / password hashing — API contract (data-first, backend-agnostic) — MAX++
# Blocks use `.end` only.
#
# Objectifs:
#   - Contrat PBKDF2 maximal:
#       * PRF = HMAC(hash) (SHA-256/384/512 + SHA-1 legacy)
#       * one-shot KDF (DK) + verify
#       * views (zero-copy) optionnelles
#       * providers/caps/limits
#       * politiques (strict RFC, disallow SHA-1, constant-time verify)
#   - Aucun I/O ici. Aucune impl crypto réelle.
#
# Notes:
#   - PBKDF2(PRF, P, S, c, dkLen)
#   - RFC 8018 bound: dkLen <= (2^32 - 1) * hLen
#   - U_1 = PRF(P, S || INT(i)); U_j = PRF(P, U_{j-1}); T_i = U_1 xor ... xor U_c

module plugins.crypto.api.kdf.pbkdf2

import std.collections as coll

# ============================================================================
# Versioning
# ============================================================================

const PBKDF2_API_VERSION_MAJOR : u32 = 1
const PBKDF2_API_VERSION_MINOR : u32 = 0
const PBKDF2_API_VERSION_PATCH : u32 = 0

# ============================================================================
# Hash selection (PRF = HMAC(hash))
# ============================================================================

enum Pbkdf2Hash
  Sha1
  Sha256
  Sha384
  Sha512
.end

# Canonical digest lengths (bytes)
const PBKDF2_SHA1_LEN   : u32 = 20
const PBKDF2_SHA256_LEN : u32 = 32
const PBKDF2_SHA384_LEN : u32 = 48
const PBKDF2_SHA512_LEN : u32 = 64

# RFC bound: dkLen <= (2^32 - 1) * hLen (fit into u64 here)
const PBKDF2_MAX_BLOCKS_U32 : u64 = 4294967295

# ============================================================================
# Errors
# ============================================================================

enum Pbkdf2Error
  Ok
  Unsupported

  InvalidProvider
  InvalidPolicy
  InvalidHash

  InvalidInput
  InvalidOutput
  InvalidLength

  InvalidPassword
  InvalidSalt
  InvalidIterations

  VerifyFailed

  BufferTooSmall
  OutputTooLarge
  MessageTooLarge

  ProviderUnavailable
  ProviderBusy
  RateLimited
  Timeout

  MalformedInput
  SerializationError
  DeserializationError

  InternalError
.end

# ============================================================================
# Provider metadata
# ============================================================================

type Pbkdf2ProviderId = string

enum Pbkdf2BackendKind
  Unknown
  Software
  Hardware
  Remote
.end

const PBKDF2_FLAG_KDF_ONE_SHOT        : u32 = 1
const PBKDF2_FLAG_VERIFY             : u32 = 2
const PBKDF2_FLAG_VIEWS              : u32 = 4

const PBKDF2_FLAG_HASH_SHA1           : u32 = 16
const PBKDF2_FLAG_HASH_SHA256         : u32 = 32
const PBKDF2_FLAG_HASH_SHA384         : u32 = 64
const PBKDF2_FLAG_HASH_SHA512         : u32 = 128

const PBKDF2_FLAG_SIMD                : u32 = 256
const PBKDF2_FLAG_PARALLEL            : u32 = 512

const PBKDF2_PROVIDER_FLAG_SOFTWARE   : u32 = 1
const PBKDF2_PROVIDER_FLAG_HARDWARE   : u32 = 2
const PBKDF2_PROVIDER_FLAG_REMOTE     : u32 = 4
const PBKDF2_PROVIDER_FLAG_THREADSAFE : u32 = 8
const PBKDF2_PROVIDER_FLAG_SANDBOXED  : u32 = 16

struct Pbkdf2Limits
  pwd_max             : u32
  salt_max            : u32
  out_max             : u32

  # iterations
  iter_min            : u32
  iter_max            : u32

  # RFC bound (max blocks of hLen)
  max_blocks          : u32

  # operational
  max_ops_per_sec     : u32
.end

struct Pbkdf2AlgInfo
  hash                : Pbkdf2Hash
  name                : string
  hlen                : u32
  flags               : u32
  limits              : Pbkdf2Limits
.end

struct Pbkdf2ProviderInfo
  id                  : Pbkdf2ProviderId
  name                : string
  vendor              : string
  version             : string

  backend             : Pbkdf2BackendKind
  priority            : i32
  flags               : u32

  build               : string
  device              : string
  location            : string

  algorithms          : coll.Vec[Pbkdf2AlgInfo]
  limits              : Pbkdf2Limits
.end

# ============================================================================
# Views (zero-copy optional)
# ============================================================================

struct ByteSlice
  ptr                 : u64
  len                 : u64
.end

struct MutByteSlice
  ptr                 : u64
  len                 : u64
.end

# ============================================================================
# Params / policy
# ============================================================================

struct Pbkdf2Params
  hash                : Pbkdf2Hash
  iterations          : u32
  out_len             : u32
.end

struct Pbkdf2Policy
  params              : Pbkdf2Params

  # strictness
  strict_rfc8018      : bool

  # If true, reject SHA-1 unless explicitly allowed.
  disallow_sha1       : bool

  # If true, reject iterations < 1.
  strict_iterations   : bool

  # hardening
  constant_time_verify : bool

  # limits overrides (optional: 0 means "use provider defaults")
  pwd_max_override     : u32
  salt_max_override    : u32
  out_max_override     : u32
.end

# ============================================================================
# Inputs / outputs (owned)
# ============================================================================

struct Pbkdf2Password
  bytes               : coll.Vec[u8]
.end

struct Pbkdf2Salt
  bytes               : coll.Vec[u8]
.end

struct Pbkdf2Dk
  bytes               : coll.Vec[u8]
.end

# ============================================================================
# One-shot KDF
# ============================================================================

struct Pbkdf2KdfRequest
  provider_id          : Pbkdf2ProviderId
  policy               : Pbkdf2Policy

  password             : Pbkdf2Password
  salt                 : Pbkdf2Salt
.end

struct Pbkdf2KdfResponse
  err                  : Pbkdf2Error
  dk                   : Pbkdf2Dk
.end

struct Pbkdf2KdfRequestView
  provider_id          : Pbkdf2ProviderId
  policy               : Pbkdf2Policy

  password             : ByteSlice
  salt                 : ByteSlice

  output_dk            : MutByteSlice
.end

struct Pbkdf2KdfResponseView
  err                  : Pbkdf2Error
  written              : u64
.end

# ============================================================================
# Verify (derived key compare)
# ============================================================================

struct Pbkdf2VerifyRequest
  provider_id          : Pbkdf2ProviderId
  policy               : Pbkdf2Policy

  password             : Pbkdf2Password
  salt                 : Pbkdf2Salt
  expected             : Pbkdf2Dk
.end

struct Pbkdf2VerifyResponse
  err                  : Pbkdf2Error
  ok                   : bool
.end

struct Pbkdf2VerifyRequestView
  provider_id          : Pbkdf2ProviderId
  policy               : Pbkdf2Policy

  password             : ByteSlice
  salt                 : ByteSlice
  expected             : ByteSlice
.end

struct Pbkdf2VerifyResponseView
  err                  : Pbkdf2Error
  ok                   : bool
.end

# ============================================================================
# ABI outputs (runtime provided)
# ============================================================================

fn abi_out_provider_info_struct(info : Pbkdf2ProviderInfo)
.end

fn abi_out_alg_info_struct(info : Pbkdf2AlgInfo)
.end

fn abi_out_kdf_response(resp : Pbkdf2KdfResponse)
.end

fn abi_out_kdf_response_view(resp : Pbkdf2KdfResponseView)
.end

fn abi_out_verify_response(resp : Pbkdf2VerifyResponse)
.end

fn abi_out_verify_response_view(resp : Pbkdf2VerifyResponseView)
.end

fn abi_out_error(err : Pbkdf2Error)
.end

# ============================================================================
# Provider surface (typed entrypoints)
# ============================================================================

fn pbkdf2_provider_enumerate()
.end

fn pbkdf2_provider_query(provider_id : Pbkdf2ProviderId)
.end

fn pbkdf2_kdf(req : Pbkdf2KdfRequest)
.end

fn pbkdf2_kdf_view(req : Pbkdf2KdfRequestView)
.end

fn pbkdf2_verify(req : Pbkdf2VerifyRequest)
.end

fn pbkdf2_verify_view(req : Pbkdf2VerifyRequestView)
.end

# ============================================================================
# Helpers (pure)
# ============================================================================

fn pbkdf2_hash_len(hash : Pbkdf2Hash) -> u32
  return 0
.end

fn pbkdf2_max_out_len(hash : Pbkdf2Hash) -> u64
  return 0
.end

fn pbkdf2_default_params_sha256() -> Pbkdf2Params
  let p : Pbkdf2Params = Pbkdf2Params
  return p
.end

fn pbkdf2_default_policy_sha256() -> Pbkdf2Policy
  let p : Pbkdf2Policy = Pbkdf2Policy
  return p
.end

fn pbkdf2_default_policy_sha512() -> Pbkdf2Policy
  let p : Pbkdf2Policy = Pbkdf2Policy
  return p
.end

# ============================================================================
# TODO checklist (impl réelle) — MAX++
# ============================================================================

# Providers
# - Impl enumerate/query + `Pbkdf2ProviderInfo`/`Pbkdf2AlgInfo`.
# - Remplacer toute sortie "texte" par ABI structs.
# - Politique de choix provider (software vs SIMD vs hw vs remote) + fallback.

# Core PBKDF2 (RFC 8018)
# - Dépendance HMAC(hash):
#     * intégrer hmac provider existant
#     * hash selection -> hmac backend selection
# - Impl F(P, S, c, i):
#     * U_1 = PRF(P, S || INT(i))
#     * U_j = PRF(P, U_{j-1}) for j=2..c
#     * T_i = U_1 xor ... xor U_c
# - Impl DK generation:
#     * l = ceil(dkLen / hLen)
#     * r = dkLen - (l-1)*hLen
#     * DK = T_1 || ... || T_l (truncate to dkLen)
# - INT(i) big-endian u32.

# Validation
# - Enforce iterations >= 1 when strict_iterations.
# - Enforce salt len > 0 or policy-defined minimums.
# - Enforce disallow_sha1 unless explicitly allowed.
# - Enforce dkLen within provider limits.
# - strict_rfc8018:
#     * dkLen <= (2^32 - 1) * hLen
#     * l must fit in u32
# - Return OutputTooLarge on bound violation.

# One-shot
# - Impl `pbkdf2_kdf` / view:
#     * BufferTooSmall + written
#     * output stable

# Verify
# - Impl `pbkdf2_verify` / view:
#     * recompute DK and constant-time compare to expected
#     * constant_time_verify best effort
#     * err: VerifyFailed vs ok=false policy

# Side-channel hardening
# - constant-time compare (verify) + avoid secret-dependent branches.
# - memwipe: U buffers, T blocks, intermediate PRF outputs.

# Tests
# - RFC 8018 PBKDF2-HMAC-SHA1 vectors (legacy) + SHA256 vectors.
# - Properties:
#     * view == owned.
#     * verify(pass,salt,dk)==true.
# - Negative:
#     * iterations=0, dkLen too large, buffer too small.
# - Fuzz:
#     * random params within bounds.
#     * verify parser (if later encoded formats are added).

# Bench
# - microbench varying iterations and dkLen.
# - provider comparison.

.end