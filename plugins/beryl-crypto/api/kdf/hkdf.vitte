# plugins/crypto/api/kdf/hkdf.vitte
# HKDF
# Blocks use `.end` only.

mod plugins.crypto.api.kdf.hkdf

# TODO

.end

# plugins/beryl/api/kdf/hkdf.vitte
# HKDF (RFC 5869) — KDF (extract+expand) — API contract (data-first, backend-agnostic) — MAX++
# Blocks use `.end` only.
#
# Objectifs:
#   - Contrat HKDF maximal:
#       * Extract (PRK) + Expand (OKM)
#       * one-shot HKDF (extract+expand)
#       * streaming expand (read) optionnel
#       * views (zero-copy) optionnelles
#       * providers/caps/limits
#       * hash selection abstraction (SHA-256/SHA-384/SHA-512/SHA-1 legacy)
#   - Aucun I/O ici. Aucune impl crypto réelle.
#
# Notes:
#   - HKDF s'appuie sur HMAC(hash).
#   - L = out_len <= 255 * HashLen (RFC 5869).
#   - Extract: PRK = HMAC(salt, IKM)
#   - Expand: T(0)=empty; T(i)=HMAC(PRK, T(i-1)|info|i)

module plugins.crypto.api.kdf.hkdf

import std.collections as coll

# ============================================================================
# Versioning
# ============================================================================

const HKDF_API_VERSION_MAJOR : u32 = 1
const HKDF_API_VERSION_MINOR : u32 = 0
const HKDF_API_VERSION_PATCH : u32 = 0

# ============================================================================
# Hash selection
# ============================================================================

enum HkdfHash
  Sha1
  Sha256
  Sha384
  Sha512
.end

# Canonical digest lengths (bytes)
const HKDF_SHA1_LEN   : u32 = 20
const HKDF_SHA256_LEN : u32 = 32
const HKDF_SHA384_LEN : u32 = 48
const HKDF_SHA512_LEN : u32 = 64

# RFC bound: 255 * HashLen
const HKDF_MAX_NBLOCKS : u32 = 255

# ============================================================================
# Errors
# ============================================================================

enum HkdfError
  Ok
  Unsupported

  InvalidProvider
  InvalidPolicy
  InvalidHash

  InvalidInput
  InvalidOutput
  InvalidLength

  InvalidIkm
  InvalidSalt
  InvalidInfo
  InvalidPrk

  BufferTooSmall
  OutputTooLarge
  MessageTooLarge

  ProviderUnavailable
  ProviderBusy
  RateLimited
  Timeout

  MalformedInput
  SerializationError
  DeserializationError

  InternalError
.end

# ============================================================================
# Provider metadata
# ============================================================================

type HkdfProviderId = string

enum HkdfBackendKind
  Unknown
  Software
  Hardware
  Remote
.end

const HKDF_FLAG_EXTRACT_ONE_SHOT      : u32 = 1
const HKDF_FLAG_EXPAND_ONE_SHOT       : u32 = 2
const HKDF_FLAG_HKDF_ONE_SHOT         : u32 = 4
const HKDF_FLAG_STREAMING_EXPAND      : u32 = 8
const HKDF_FLAG_VIEWS                 : u32 = 16

const HKDF_FLAG_HASH_SHA1             : u32 = 32
const HKDF_FLAG_HASH_SHA256           : u32 = 64
const HKDF_FLAG_HASH_SHA384           : u32 = 128
const HKDF_FLAG_HASH_SHA512           : u32 = 256

const HKDF_PROVIDER_FLAG_SOFTWARE     : u32 = 1
const HKDF_PROVIDER_FLAG_HARDWARE     : u32 = 2
const HKDF_PROVIDER_FLAG_REMOTE       : u32 = 4
const HKDF_PROVIDER_FLAG_THREADSAFE   : u32 = 8
const HKDF_PROVIDER_FLAG_SANDBOXED    : u32 = 16

struct HkdfLimits
  ikm_max             : u32
  salt_max            : u32
  info_max            : u32

  prk_max             : u32
  out_max             : u32

  # 255 * hash_len bound
  max_blocks          : u32

  # operational
  max_ops_per_sec     : u32
.end

struct HkdfAlgInfo
  hash                : HkdfHash
  name                : string
  hash_len            : u32
  flags               : u32
  limits              : HkdfLimits
.end

struct HkdfProviderInfo
  id                  : HkdfProviderId
  name                : string
  vendor              : string
  version             : string

  backend             : HkdfBackendKind
  priority            : i32
  flags               : u32

  build               : string
  device              : string
  location            : string

  algorithms          : coll.Vec[HkdfAlgInfo]
  limits              : HkdfLimits
.end

# ============================================================================
# Views (zero-copy optional)
# ============================================================================

struct ByteSlice
  ptr                 : u64
  len                 : u64
.end

struct MutByteSlice
  ptr                 : u64
  len                 : u64
.end

# ============================================================================
# Policy
# ============================================================================

struct HkdfPolicy
  hash                : HkdfHash

  # If true, enforce RFC bound: out_len <= 255 * hash_len
  strict_rfc5869      : bool

  # If true, reject SHA-1 unless explicitly allowed.
  disallow_sha1       : bool

  # Hardening
  constant_time       : bool
.end

# ============================================================================
# Inputs / outputs (owned)
# ============================================================================

struct HkdfBytes
  bytes               : coll.Vec[u8]
.end

struct HkdfIkm
  bytes               : coll.Vec[u8]
.end

struct HkdfSalt
  bytes               : coll.Vec[u8]
.end

struct HkdfInfo
  bytes               : coll.Vec[u8]
.end

struct HkdfPrk
  bytes               : coll.Vec[u8]
.end

struct HkdfOkm
  bytes               : coll.Vec[u8]
.end

# ============================================================================
# One-shot: Extract
# ============================================================================

struct HkdfExtractRequest
  provider_id          : HkdfProviderId
  policy               : HkdfPolicy

  ikm                  : HkdfIkm
  salt                 : HkdfSalt
.end

struct HkdfExtractResponse
  err                  : HkdfError
  prk                  : HkdfPrk
.end

struct HkdfExtractRequestView
  provider_id          : HkdfProviderId
  policy               : HkdfPolicy

  ikm                  : ByteSlice
  salt                 : ByteSlice
  output_prk           : MutByteSlice
.end

struct HkdfExtractResponseView
  err                  : HkdfError
  written              : u64
.end

# ============================================================================
# One-shot: Expand
# ============================================================================

struct HkdfExpandRequest
  provider_id          : HkdfProviderId
  policy               : HkdfPolicy

  prk                  : HkdfPrk
  info                 : HkdfInfo

  out_len              : u32
.end

struct HkdfExpandResponse
  err                  : HkdfError
  okm                  : HkdfOkm
.end

struct HkdfExpandRequestView
  provider_id          : HkdfProviderId
  policy               : HkdfPolicy

  prk                  : ByteSlice
  info                 : ByteSlice

  output_okm           : MutByteSlice
.end

struct HkdfExpandResponseView
  err                  : HkdfError
  written              : u64
.end

# ============================================================================
# One-shot: HKDF (Extract + Expand)
# ============================================================================

struct HkdfRequest
  provider_id          : HkdfProviderId
  policy               : HkdfPolicy

  ikm                  : HkdfIkm
  salt                 : HkdfSalt
  info                 : HkdfInfo

  out_len              : u32
.end

struct HkdfResponse
  err                  : HkdfError
  prk                  : HkdfPrk
  okm                  : HkdfOkm
.end

struct HkdfRequestView
  provider_id          : HkdfProviderId
  policy               : HkdfPolicy

  ikm                  : ByteSlice
  salt                 : ByteSlice
  info                 : ByteSlice

  output_prk           : MutByteSlice
  output_okm           : MutByteSlice
.end

struct HkdfResponseView
  err                  : HkdfError
  prk_written          : u64
  okm_written          : u64
.end

# ============================================================================
# Streaming expand (optional)
# ============================================================================

enum HkdfStreamState
  Init
  Expanding
  Final
  Closed
.end

struct HkdfStreamInfo
  provider_id          : HkdfProviderId
  policy               : HkdfPolicy
  state                : HkdfStreamState

  hash_len             : u32
  nblocks              : u32

  total_out            : u64
  flags                : u32
.end

struct HkdfStream
  handle               : u64
  info                 : HkdfStreamInfo
.end

struct HkdfStreamStartRequest
  provider_id          : HkdfProviderId
  policy               : HkdfPolicy

  prk                  : HkdfPrk
  info                 : HkdfInfo
.end

struct HkdfStreamStartResponse
  err                  : HkdfError
  stream               : HkdfStream
.end

# Read arbitrary bytes from HKDF-Expand stream.
struct HkdfStreamReadRequest
  stream               : HkdfStream
  want                 : u64
.end

struct HkdfStreamReadResponse
  err                  : HkdfError
  output               : HkdfBytes
.end

struct HkdfStreamReadRequestView
  stream               : HkdfStream
  output               : MutByteSlice
.end

struct HkdfStreamReadResponseView
  err                  : HkdfError
  written              : u64
.end

struct HkdfStreamFinishRequest
  stream               : HkdfStream
.end

struct HkdfStreamFinishResponse
  err                  : HkdfError
.end

# ============================================================================
# ABI outputs (runtime provided)
# ============================================================================

fn abi_out_provider_info_struct(info : HkdfProviderInfo)
.end

fn abi_out_alg_info_struct(info : HkdfAlgInfo)
.end

fn abi_out_extract_response(resp : HkdfExtractResponse)
.end

fn abi_out_extract_response_view(resp : HkdfExtractResponseView)
.end

fn abi_out_expand_response(resp : HkdfExpandResponse)
.end

fn abi_out_expand_response_view(resp : HkdfExpandResponseView)
.end

fn abi_out_hkdf_response(resp : HkdfResponse)
.end

fn abi_out_hkdf_response_view(resp : HkdfResponseView)
.end

fn abi_out_stream_start_response(resp : HkdfStreamStartResponse)
.end

fn abi_out_stream_read_response(resp : HkdfStreamReadResponse)
.end

fn abi_out_stream_read_response_view(resp : HkdfStreamReadResponseView)
.end

fn abi_out_stream_finish_response(resp : HkdfStreamFinishResponse)
.end

fn abi_out_error(err : HkdfError)
.end

# ============================================================================
# Provider surface (typed entrypoints)
# ============================================================================

fn hkdf_provider_enumerate()
.end

fn hkdf_provider_query(provider_id : HkdfProviderId)
.end

fn hkdf_extract(req : HkdfExtractRequest)
.end

fn hkdf_extract_view(req : HkdfExtractRequestView)
.end

fn hkdf_expand(req : HkdfExpandRequest)
.end

fn hkdf_expand_view(req : HkdfExpandRequestView)
.end

fn hkdf(req : HkdfRequest)
.end

fn hkdf_view(req : HkdfRequestView)
.end

fn hkdf_stream_start(req : HkdfStreamStartRequest)
.end

fn hkdf_stream_read(req : HkdfStreamReadRequest)
.end

fn hkdf_stream_read_view(req : HkdfStreamReadRequestView)
.end

fn hkdf_stream_finish(req : HkdfStreamFinishRequest)
.end

fn hkdf_stream_destroy(stream : HkdfStream)
.end

# ============================================================================
# Helpers (pure)
# ============================================================================

fn hkdf_hash_len(hash : HkdfHash) -> u32
  return 0
.end

fn hkdf_max_out_len(hash : HkdfHash) -> u32
  return 0
.end

fn hkdf_default_policy_sha256() -> HkdfPolicy
  let p : HkdfPolicy = HkdfPolicy
  return p
.end

fn hkdf_default_policy_sha512() -> HkdfPolicy
  let p : HkdfPolicy = HkdfPolicy
  return p
.end

# ============================================================================
# TODO checklist (impl réelle) — MAX++
# ============================================================================

# Providers
# - Impl enumerate/query + `HkdfProviderInfo`/`HkdfAlgInfo`.
# - Remplacer toute sortie "texte" par ABI structs.
# - Politique de choix provider (software vs hw vs remote) + fallback.

# Core HKDF (RFC 5869)
# - Impl HMAC(hash) integration:
#     * reuse hmac module/provider (if available)
#     * hash selection -> hmac backend selection
# - Extract:
#     * if salt empty => salt = zeros(HashLen)
#     * PRK = HMAC(salt, IKM)
# - Expand:
#     * enforce out_len <= 255 * HashLen (strict_rfc5869)
#     * T(0)=empty; for i=1..N: T(i)=HMAC(PRK, T(i-1)|info|i)
#     * OKM = T(1)|T(2)|... truncated to out_len

# One-shot
# - Impl `hkdf_extract` / view:
#     * output PRK len = HashLen
#     * BufferTooSmall + written
# - Impl `hkdf_expand` / view:
#     * output OKM len = requested out_len
#     * BufferTooSmall + written
# - Impl `hkdf` / view:
#     * extract+expand pipeline
#     * optionally return PRK too

# Streaming expand
# - Optional:
#     * create state holding PRK, info, previous T
#     * allow reading arbitrary bytes across blocks
#     * enforce max_blocks and x255 bound
# - Finish idempotent, destroy safe, memwipe state.

# Validation / limits
# - Enforce ikm/salt/info lengths within provider limits.
# - Enforce disallow_sha1 policy unless explicitly allowed.
# - Return OutputTooLarge when out_len exceeds RFC bound.

# Side-channel hardening
# - constant-time best effort.
# - memwipe: PRK, T blocks, temp buffers.

# Tests
# - RFC 5869 test vectors (SHA-256 and SHA-1 legacy).
# - Properties:
#     * streaming == one-shot expand.
# - Negative:
#     * out_len too large, buffer too small.
# - Fuzz:
#     * random chunking for stream read.

# Bench
# - microbench extract/expand throughput.

.end