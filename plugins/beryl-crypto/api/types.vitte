# plugins/crypto/api/types.vitte
mod plugins.crypto.api.types

pub enum ErrorKind
  InvalidInput
  Unsupported
  VerificationFailed
  EntropyUnavailable
  Internal
.end

pub struct Error
  kind: ErrorKind
  code: i32
  message: str
.end

# Placeholder Result alias
# pub type Result[T] = core.result.Result[T, Error]

pub struct BytesView
  ptr: *u8
  len: usize
.end

pub struct Secret
  ptr: *u8
  len: usize
.end

pub fn zeroize(_s: Secret) -> ()
  # TODO: constant-time wipe
  ret ()
.end

.end

# plugins/beryl-crypto/api/types.vitte
# beryl-crypto — shared API types (errors, views, iovec, limits, handles) — MAX+++
# Blocks use `.end` only.
#
# Note:
#   - Ces types sont volontairement "data-first" et backend-agnostic.
#   - Les modules (aead/tls/x509/rand/seal/subtle/…) peuvent importer ici pour éviter les duplications.

module plugins.crypto.api.types

import std.collections as coll

# ============================================================================
# Versioning
# ============================================================================

const CRYPTO_TYPES_API_VERSION_MAJOR : u32 = 1
const CRYPTO_TYPES_API_VERSION_MINOR : u32 = 0
const CRYPTO_TYPES_API_VERSION_PATCH : u32 = 0

# ============================================================================
# Error model (unified)
# ============================================================================

enum ErrorKind
  Ok

  InvalidInput
  InvalidOutput
  InvalidLength
  InvalidPolicy

  Unsupported
  NotImplemented

  VerificationFailed
  AuthenticationFailed

  EntropyUnavailable
  EntropyInsufficient

  BufferTooSmall
  OutputTooLarge
  MessageTooLarge

  ProviderUnavailable
  ProviderBusy
  PermissionDenied
  RateLimited
  Timeout

  MalformedInput
  SerializationError
  DeserializationError

  Internal
.end

struct Error
  kind     : ErrorKind
  code     : i32

  # short human message (stable where possible)
  message  : string

  # optional detail (debug, provider-specific)
  detail   : string

  # optional origin identifier (module/provider)
  source   : string
.end

fn error_ok() -> Error
  let e : Error = Error
  return e
.end

fn error_make(kind : ErrorKind, code : i32, message : string) -> Error
  let e : Error = Error
  return e
.end

fn error_with_detail(kind : ErrorKind, code : i32, message : string, detail : string) -> Error
  let e : Error = Error
  return e
.end

# ============================================================================
# Views / iovec (zero-copy)
# ============================================================================

struct ByteSlice
  # Opaque pointer address (runtime address space)
  ptr  : u64
  len  : u64
.end

struct MutByteSlice
  ptr  : u64
  len  : u64
.end

struct IoVec
  slices     : coll.Vec[ByteSlice]
  total_len  : u64
.end

struct MutIoVec
  slices     : coll.Vec[MutByteSlice]
  total_len  : u64
.end

fn byteslice_empty() -> ByteSlice
  let s : ByteSlice = ByteSlice
  return s
.end

fn mutbyteslice_empty() -> MutByteSlice
  let s : MutByteSlice = MutByteSlice
  return s
.end

fn iovec_empty() -> IoVec
  let v : IoVec = IoVec
  return v
.end

fn mutiovec_empty() -> MutIoVec
  let v : MutIoVec = MutIoVec
  return v
.end

# ============================================================================
# Length sets / limits helper
# ============================================================================

struct LenSet
  min        : u32
  max        : u32
  step       : u32
  preferred  : coll.Vec[u32]
.end

fn lenset_fixed(n : u32) -> LenSet
  let s : LenSet = LenSet
  return s
.end

fn lenset_range(min : u32, max : u32) -> LenSet
  let s : LenSet = LenSet
  return s
.end

# ============================================================================
# Opaque handles (slot+generation in runtime)
# ============================================================================

# Value is typically an encoded handle id; runtime validates kind+generation.

type Handle = u64

struct Opaque
  kind   : u32
  value  : Handle
.end

fn opaque_none() -> Opaque
  let o : Opaque = Opaque
  return o
.end

# ============================================================================
# Sensitive bytes (logical contract)
# ============================================================================

enum WipeMode
  None
  BestEffort
  Always
.end

struct SecretBytes
  ptr       : u64
  len       : u64

  # if true, exporting plaintext bytes is forbidden by policy
  no_export : bool

  # wipe policy on drop/destroy
  wipe      : WipeMode
.end

# Wipe helpers (best effort). Implementations should be non-optimizable.
fn memwipe_view(buf : MutByteSlice) -> ErrorKind
.end

fn memwipe_iovec_view(buf : MutIoVec) -> ErrorKind
.end

fn memwipe_secret(s : SecretBytes) -> ErrorKind
.end

# ============================================================================
# ABI outputs (runtime marshalling)
# ============================================================================

fn abi_out_error_struct(err : Error)
.end

fn abi_out_errorkind(kind : ErrorKind)
.end

fn abi_out_byteslice(slice : ByteSlice)
.end

# ============================================================================
# TODO checklist (impl réelle)
# ============================================================================

# - Impl constructors for LenSet that fill preferred list correctly.
# - Impl memwipe_* using runtime intrinsic (volatile) to avoid optimization.
# - Standardize `Opaque.kind` registry across all crypto modules.
# - Provide optional "Result" encoding once generics/type-alias params exist.

.end

# Export surface
export ErrorKind, Error
export ByteSlice, MutByteSlice, IoVec, MutIoVec
export LenSet, Opaque, Handle
export SecretBytes, WipeMode
export error_ok, error_make, error_with_detail
export byteslice_empty, mutbyteslice_empty, iovec_empty, mutiovec_empty
export lenset_fixed, lenset_range
export memwipe_view, memwipe_iovec_view, memwipe_secret
export abi_out_error_struct, abi_out_errorkind, abi_out_byteslice

.end