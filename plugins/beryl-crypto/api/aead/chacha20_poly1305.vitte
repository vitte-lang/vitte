# plugins/beryl/api/aead/chacha20_poly1305.vitte
# ChaCha20-Poly1305 provider (Beryl) — aligned to aead.vitte (owned + view stubs) — MAX++

module plugins.crypto.api.aead.chacha20_poly1305

import std.collections as coll
import plugins.crypto.api.aead.aead as aead

# ============================================================================
# Provider identity
# ============================================================================

const PROVIDER_ID       : aead.AeadProviderId  = "beryl.software.chacha20_poly1305.stub"
const PROVIDER_NAME     : string              = "Beryl ChaCha20-Poly1305 (stub)"
const PROVIDER_VENDOR   : string              = "vitte-core"
const PROVIDER_VERSION  : string              = "0.0.0"

const PROVIDER_BACKEND  : aead.AeadBackendKind = aead.AeadBackendKind.Software
const PROVIDER_FLAGS    : u32                 = aead.AEAD_PROVIDER_FLAG_SOFTWARE + aead.AEAD_PROVIDER_FLAG_THREADSAFE
const PROVIDER_PRIORITY : i32                 = 30

const PROVIDER_BUILD    : string              = ""
const PROVIDER_DEVICE   : string              = ""
const PROVIDER_LOCATION : string              = ""

# ============================================================================
# Algorithm identity & parameters
# ============================================================================

const ALG_ID        : aead.AeadAlgId   = "chacha20-poly1305"
const ALG_NAME      : string          = "ChaCha20-Poly1305"
const ALG_FAMILY    : aead.AeadFamily  = aead.AeadFamily.ChaCha20Poly1305

const KEY_LEN       : u32 = 32
const NONCE_LEN     : u32 = 12
const TAG_LEN       : u32 = 16

const LIMIT_AAD_MAX : u64 = 1_073_741_824
const LIMIT_MSG_MAX : u64 = 1_073_741_824
const LIMIT_CIPH_MAX: u64 = 1_073_741_824 + 16

const ALG_FLAGS     : u32 = aead.AEAD_FLAG_DETACHED + aead.AEAD_FLAG_CONSTANT_TIME

# ============================================================================
# ABI stubs
# ============================================================================

fn abi_now_ms() -> u64
  return 0
.end

fn abi_vec_len_u8(v : coll.Vec[u8]) -> u64
  return 0
.end

fn abi_copy_from_slice(src : aead.ByteSlice) -> coll.Vec[u8]
  return coll.Vec[u8]()
.end

fn abi_bytes_concat(a : coll.Vec[u8], b : coll.Vec[u8]) -> coll.Vec[u8]
  return coll.Vec[u8]()
.end

fn abi_split_combined(combined : coll.Vec[u8], tag_len : u32) -> aead.AeadDetached
  return aead.AeadDetached { cipher = aead.AeadCiphertext { bytes = coll.Vec[u8]() }, tag = aead.AeadTag { bytes = coll.Vec[u8]() } }
.end

fn abi_out_provider_info_struct(info : aead.AeadProviderInfo)
.end

fn abi_out_alg_info_struct(info : aead.AeadAlgInfo)
.end

fn abi_out_select(provider_id : aead.AeadProviderId, alg_id : aead.AeadAlgId)
.end

fn abi_out_key_ref_struct(key_ref : aead.AeadKeyRef)
.end

fn abi_out_ctx_ref_struct(ctx_ref : aead.AeadContextRef)
.end

fn abi_out_seal_response(resp : aead.AeadSealResponse)
.end

fn abi_out_open_response(resp : aead.AeadOpenResponse)
.end

fn abi_out_seal_response_view(resp : aead.AeadSealResponseView)
.end

fn abi_out_open_response_view(resp : aead.AeadOpenResponseView)
.end

fn abi_out_error(err : aead.AeadError)
.end

fn abi_nonce_check_and_record(key_handle : u64, nonce : coll.Vec[u8], strict : bool) -> aead.AeadError
  return aead.AeadError.Unsupported
.end

fn abi_handles_new_key(provider_id : aead.AeadProviderId, alg_id : aead.AeadAlgId) -> u64
  return 0
.end

fn abi_handles_new_ctx(provider_id : aead.AeadProviderId, alg_id : aead.AeadAlgId, key_handle : u64) -> u64
  return 0
.end

fn abi_handles_drop(kind : aead.AeadHandleKind, handle : u64)
.end

# Crypto backend hooks
fn backend_chacha20_poly1305_seal_detached(key_handle : u64, nonce : coll.Vec[u8], aad : coll.Vec[u8], plaintext : coll.Vec[u8]) -> aead.AeadDetached
  return aead.AeadDetached { cipher = aead.AeadCiphertext { bytes = coll.Vec[u8]() }, tag = aead.AeadTag { bytes = coll.Vec[u8]() } }
.end

fn backend_chacha20_poly1305_open_detached(key_handle : u64, nonce : coll.Vec[u8], aad : coll.Vec[u8], cipher : coll.Vec[u8], tag : coll.Vec[u8]) -> aead.AeadPlaintext
  return aead.AeadPlaintext { bytes = coll.Vec[u8]() }
.end

# ============================================================================
# Helpers
# ============================================================================

fn make_len_set_fixed(n : u32) -> aead.AeadLenSet
  return aead.AeadLenSet { min = n, max = n, step = 0, preferred = coll.Vec[u32]() }
.end

fn make_limits() -> aead.AeadLimits
  return aead.AeadLimits {
    key_min = KEY_LEN,
    key_max = KEY_LEN,
    nonce_min = NONCE_LEN,
    nonce_max = NONCE_LEN,
    tag_min = TAG_LEN,
    tag_max = TAG_LEN,
    aad_max = LIMIT_AAD_MAX,
    msg_max = LIMIT_MSG_MAX,
    cipher_max = LIMIT_CIPH_MAX,
  }
.end

fn validate_nonce_len(nonce : aead.AeadNonce) -> aead.AeadError
  let n : u64 = abi_vec_len_u8(nonce.bytes)
  if n == 0
    return aead.AeadError.Ok
  .end
  if n != NONCE_LEN
    return aead.AeadError.InvalidNonce
  .end
  return aead.AeadError.Ok
.end

fn validate_tag_len(tag : aead.AeadTag) -> aead.AeadError
  let n : u64 = abi_vec_len_u8(tag.bytes)
  if n == 0
    return aead.AeadError.Ok
  .end
  if n != TAG_LEN
    return aead.AeadError.InvalidTag
  .end
  return aead.AeadError.Ok
.end

# ============================================================================
# Provider surface
# ============================================================================

fn aead_provider_enumerate()
  abi_out_provider_info_struct(aead.AeadProviderInfo {
    id = PROVIDER_ID,
    name = PROVIDER_NAME,
    vendor = PROVIDER_VENDOR,
    version = PROVIDER_VERSION,
    backend = PROVIDER_BACKEND,
    priority = PROVIDER_PRIORITY,
    flags = PROVIDER_FLAGS,
    build = PROVIDER_BUILD,
    device = PROVIDER_DEVICE,
    location = PROVIDER_LOCATION,
    algorithms = coll.Vec[aead.AeadAlgInfo](),
  })

  abi_out_alg_info_struct(aead.AeadAlgInfo {
    id = ALG_ID,
    name = ALG_NAME,
    family = ALG_FAMILY,
    key_lens = make_len_set_fixed(KEY_LEN),
    nonce_lens = make_len_set_fixed(NONCE_LEN),
    tag_lens = make_len_set_fixed(TAG_LEN),
    tag_mode = aead.AeadTagMode.Fixed,
    flags = ALG_FLAGS,
    limits = make_limits(),
  })
.end

fn aead_provider_query(provider_id : aead.AeadProviderId)
  if provider_id != PROVIDER_ID
    abi_out_error(aead.AeadError.InvalidProvider)
    return
  .end
  aead_provider_enumerate()
.end

fn aead_provider_select(opts : aead.AeadSessionOptions)
  abi_out_select(PROVIDER_ID, ALG_ID)
.end

fn aead_key_generate(provider_id : aead.AeadProviderId, alg_id : aead.AeadAlgId, usage : aead.AeadKeyUsage)
  if provider_id != PROVIDER_ID
    abi_out_error(aead.AeadError.ProviderUnavailable)
    return
  .end
  if alg_id != ALG_ID
    abi_out_error(aead.AeadError.Unsupported)
    return
  .end

  let h : u64 = abi_handles_new_key(PROVIDER_ID, ALG_ID)
  if h == 0
    abi_out_error(aead.AeadError.ProviderBusy)
    return
  .end

  abi_out_key_ref_struct(aead.AeadKeyRef {
    key = aead.AeadOpaque { kind = aead.AeadHandleKind.Key, value = h },
    info = aead.AeadKeyInfo {
      provider_id = PROVIDER_ID,
      alg_id = ALG_ID,
      key_id = "",
      usage = usage,
      origin = aead.AeadKeyOrigin.Generated,
      export_policy = aead.AeadKeyExportPolicy.NonExportable,
      key_len = KEY_LEN,
      created_ms = abi_now_ms(),
      expires_ms = 0,
      flags = ALG_FLAGS,
      constraints = aead.AeadKeyConstraints { nonce_mode = aead.AeadNonceMode.External, strict_nonce = true, export_policy = aead.AeadKeyExportPolicy.NonExportable, max_ops = 0, max_bytes = 0 },
    },
  })
.end

fn aead_key_import(provider_id : aead.AeadProviderId, alg_id : aead.AeadAlgId, usage : aead.AeadKeyUsage, key_bytes : coll.Vec[u8])
  aead_key_generate(provider_id, alg_id, usage)
.end

fn aead_key_destroy(key : aead.AeadOpaque)
  if key.value == 0
    abi_out_error(aead.AeadError.InvalidKey)
    return
  .end
  abi_handles_drop(aead.AeadHandleKind.Key, key.value)
.end

fn aead_context_create(key : aead.AeadOpaque, flags : u32)
  if key.value == 0
    abi_out_error(aead.AeadError.InvalidKey)
    return
  .end

  let ctx_h : u64 = abi_handles_new_ctx(PROVIDER_ID, ALG_ID, key.value)
  if ctx_h == 0
    abi_out_error(aead.AeadError.ProviderBusy)
    return
  .end

  abi_out_ctx_ref_struct(aead.AeadContextRef {
    ctx = aead.AeadOpaque { kind = aead.AeadHandleKind.Context, value = ctx_h },
    info = aead.AeadContextInfo {
      provider_id = PROVIDER_ID,
      alg_id = ALG_ID,
      key = key,
      flags = flags,
      policy = aead.AeadContextPolicy { format_default = aead.AeadFormat.Detached, audit_level = aead.AeadAuditLevel.ErrorsOnly, nonce_mode = aead.AeadNonceMode.External, strict_nonce = true, allow_xnonce = false },
    },
  })
.end

fn aead_context_destroy(ctx : aead.AeadOpaque)
  if ctx.value == 0
    abi_out_error(aead.AeadError.InvalidContext)
    return
  .end
  abi_handles_drop(aead.AeadHandleKind.Context, ctx.value)
.end

fn aead_rekey(ctx : aead.AeadOpaque)
  abi_out_error(aead.AeadError.Unsupported)
.end

fn aead_seal(req : aead.AeadSealRequest)
  let e_nonce : aead.AeadError = validate_nonce_len(req.nonce)
  if e_nonce != aead.AeadError.Ok
    abi_out_seal_response(aead.AeadSealResponse { err = e_nonce, nonce_used = req.nonce, detached = aead.AeadDetached { cipher = aead.AeadCiphertext { bytes = coll.Vec[u8]() }, tag = aead.AeadTag { bytes = coll.Vec[u8]() } }, combined = aead.AeadCombined { bytes = coll.Vec[u8]() } })
    return
  .end

  let key_handle : u64 = req.ctx.info.key.value
  let e_np : aead.AeadError = abi_nonce_check_and_record(key_handle, req.nonce.bytes, req.ctx.info.policy.strict_nonce)
  if e_np != aead.AeadError.Ok
    abi_out_seal_response(aead.AeadSealResponse { err = e_np, nonce_used = req.nonce, detached = aead.AeadDetached { cipher = aead.AeadCiphertext { bytes = coll.Vec[u8]() }, tag = aead.AeadTag { bytes = coll.Vec[u8]() } }, combined = aead.AeadCombined { bytes = coll.Vec[u8]() } })
    return
  .end

  let detached : aead.AeadDetached = backend_chacha20_poly1305_seal_detached(key_handle, req.nonce.bytes, req.aad.bytes, req.plaintext.bytes)

  if req.options.format == aead.AeadFormat.Detached
    abi_out_seal_response(aead.AeadSealResponse { err = aead.AeadError.Ok, nonce_used = req.nonce, detached = detached, combined = aead.AeadCombined { bytes = coll.Vec[u8]() } })
    return
  .end

  let combined_bytes : coll.Vec[u8] = abi_bytes_concat(detached.cipher.bytes, detached.tag.bytes)
  abi_out_seal_response(aead.AeadSealResponse { err = aead.AeadError.Ok, nonce_used = req.nonce, detached = aead.AeadDetached { cipher = aead.AeadCiphertext { bytes = coll.Vec[u8]() }, tag = aead.AeadTag { bytes = coll.Vec[u8]() } }, combined = aead.AeadCombined { bytes = combined_bytes } })
.end

fn aead_open(req : aead.AeadOpenRequest)
  let e_nonce : aead.AeadError = validate_nonce_len(req.nonce)
  if e_nonce != aead.AeadError.Ok
    abi_out_open_response(aead.AeadOpenResponse { err = e_nonce, plaintext = aead.AeadPlaintext { bytes = coll.Vec[u8]() } })
    return
  .end

  let key_handle : u64 = req.ctx.info.key.value
  let e_np : aead.AeadError = abi_nonce_check_and_record(key_handle, req.nonce.bytes, req.ctx.info.policy.strict_nonce)
  if e_np != aead.AeadError.Ok
    abi_out_open_response(aead.AeadOpenResponse { err = e_np, plaintext = aead.AeadPlaintext { bytes = coll.Vec[u8]() } })
    return
  .end

  let mut cipher_bytes : coll.Vec[u8] = req.cipher.bytes
  let mut tag_bytes : coll.Vec[u8] = req.tag.bytes

  if req.options.format == aead.AeadFormat.Combined
    let d : aead.AeadDetached = abi_split_combined(req.combined.bytes, TAG_LEN)
    cipher_bytes = d.cipher.bytes
    tag_bytes = d.tag.bytes
  .end

  let e_tag : aead.AeadError = validate_tag_len(aead.AeadTag { bytes = tag_bytes })
  if e_tag != aead.AeadError.Ok
    abi_out_open_response(aead.AeadOpenResponse { err = e_tag, plaintext = aead.AeadPlaintext { bytes = coll.Vec[u8]() } })
    return
  .end

  let pt : aead.AeadPlaintext = backend_chacha20_poly1305_open_detached(key_handle, req.nonce.bytes, req.aad.bytes, cipher_bytes, tag_bytes)
  abi_out_open_response(aead.AeadOpenResponse { err = aead.AeadError.Ok, plaintext = pt })
.end

fn aead_seal_view(req : aead.AeadSealRequestView)
  let _owned : aead.AeadSealRequest = aead.AeadSealRequest {
    ctx = req.ctx,
    nonce = aead.AeadNonce { bytes = abi_copy_from_slice(req.nonce.bytes) },
    aad = aead.AeadAad { bytes = abi_copy_from_slice(req.aad.bytes) },
    plaintext = aead.AeadPlaintext { bytes = abi_copy_from_slice(req.plaintext.bytes) },
    options = req.options,
  }

  abi_out_seal_response_view(aead.AeadSealResponseView {
    err = aead.AeadError.Unsupported,
    nonce_used = aead.AeadNonceView { bytes = req.nonce.bytes },
    detached = aead.AeadDetachedView { cipher = aead.AeadCiphertextView { bytes = aead.ByteSlice { ptr = 0, len = 0 } }, tag = aead.AeadTagView { bytes = aead.ByteSlice { ptr = 0, len = 0 } } },
    combined = aead.AeadCombinedView { bytes = aead.ByteSlice { ptr = 0, len = 0 } },
  })
.end

fn aead_open_view(req : aead.AeadOpenRequestView)
  let _owned : aead.AeadOpenRequest = aead.AeadOpenRequest {
    ctx = req.ctx,
    nonce = aead.AeadNonce { bytes = abi_copy_from_slice(req.nonce.bytes) },
    aad = aead.AeadAad { bytes = abi_copy_from_slice(req.aad.bytes) },
    cipher = aead.AeadCiphertext { bytes = coll.Vec[u8]() },
    tag = aead.AeadTag { bytes = coll.Vec[u8]() },
    combined = aead.AeadCombined { bytes = abi_copy_from_slice(req.combined.bytes) },
    options = req.options,
  }

  abi_out_open_response_view(aead.AeadOpenResponseView { err = aead.AeadError.Unsupported, plaintext = aead.AeadPlaintextView { bytes = aead.ByteSlice { ptr = 0, len = 0 } } })
.end

# Minimal stubs for the rest
fn aead_stream_start(req : aead.AeadStreamStartRequest)
.end
fn aead_stream_aad(req : aead.AeadStreamAadRequest)
.end
fn aead_stream_update(req : aead.AeadStreamUpdateRequest)
.end
fn aead_stream_finish(req : aead.AeadStreamFinishRequest)
.end
fn aead_stream_destroy(stream : aead.AeadOpaque)
.end
fn aead_keystore_put(req : aead.AeadKeyStorePutRequest)
.end
fn aead_keystore_get(req : aead.AeadKeyStoreGetRequest)
.end
fn aead_key_wrap(req : aead.AeadKeyWrapRequest)
.end
fn aead_key_unwrap(req : aead.AeadKeyUnwrapRequest)
.end
fn aead_audit_pull(provider_id : aead.AeadProviderId)
.end