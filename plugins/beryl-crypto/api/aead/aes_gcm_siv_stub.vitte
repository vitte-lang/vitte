# plugins/beryl/api/aead/aes_gcm_siv_stub.vitte
# AES-GCM-SIV provider (Beryl) — aligned to aead.vitte (owned + view stubs) — MAX++

module plugins.crypto.api.aead.aes_gcm_siv_stub

import std.collections as coll
import plugins.crypto.api.aead.aead as aead

# ============================================================================
# Provider identity
# ============================================================================

const PROVIDER_ID       : aead.AeadProviderId   = "beryl.software.aes_gcm_siv.stub"
const PROVIDER_NAME     : string               = "Beryl AES-GCM-SIV (stub)"
const PROVIDER_VENDOR   : string               = "vitte-core"
const PROVIDER_VERSION  : string               = "0.0.0"

const PROVIDER_BACKEND  : aead.AeadBackendKind  = aead.AeadBackendKind.Software
const PROVIDER_FLAGS    : u32                  = aead.AEAD_PROVIDER_FLAG_SOFTWARE + aead.AEAD_PROVIDER_FLAG_THREADSAFE
const PROVIDER_PRIORITY : i32                  = 20

const PROVIDER_BUILD    : string               = ""
const PROVIDER_DEVICE   : string               = ""
const PROVIDER_LOCATION : string               = ""

# ============================================================================
# Algorithm identity & parameters (AES-GCM-SIV)
# ============================================================================

const ALG_ID        : aead.AeadAlgId   = "aes-gcm-siv"
const ALG_NAME      : string          = "AES-GCM-SIV"
const ALG_FAMILY    : aead.AeadFamily = aead.AeadFamily.AesGcmSiv

const KEY_LEN_128   : u32 = 16
const KEY_LEN_256   : u32 = 32
const NONCE_LEN     : u32 = 12
const TAG_LEN       : u32 = 16

const LIMIT_AAD_MAX : u64 = 1_073_741_824
const LIMIT_MSG_MAX : u64 = 1_073_741_824
const LIMIT_CIPH_MAX: u64 = 1_073_741_824 + 16

const ALG_FLAGS     : u32 = aead.AEAD_FLAG_DETACHED + aead.AEAD_FLAG_NONCE_MISUSE_RES + aead.AEAD_FLAG_CONSTANT_TIME

# ============================================================================
# ABI stubs (runtime/loader provided)
# ============================================================================

fn abi_now_ms() -> u64
  return 0
.end

fn abi_vec_len_u8(v : coll.Vec[u8]) -> u64
  return 0
.end

fn abi_copy_from_slice(src : aead.ByteSlice) -> coll.Vec[u8]
  return coll.Vec[u8]()
.end

fn abi_out_provider_info_struct(info : aead.AeadProviderInfo)
.end

fn abi_out_alg_info_struct(info : aead.AeadAlgInfo)
.end

fn abi_out_select(provider_id : aead.AeadProviderId, alg_id : aead.AeadAlgId)
.end

fn abi_out_key_ref_struct(key_ref : aead.AeadKeyRef)
.end

fn abi_out_ctx_ref_struct(ctx_ref : aead.AeadContextRef)
.end

fn abi_out_seal_response(resp : aead.AeadSealResponse)
.end

fn abi_out_open_response(resp : aead.AeadOpenResponse)
.end

fn abi_out_seal_response_view(resp : aead.AeadSealResponseView)
.end

fn abi_out_open_response_view(resp : aead.AeadOpenResponseView)
.end

fn abi_out_stream_start_response(resp : aead.AeadStreamStartResponse)
.end

fn abi_out_stream_aad_response(resp : aead.AeadStreamAadResponse)
.end

fn abi_out_stream_update_response(resp : aead.AeadStreamUpdateResponse)
.end

fn abi_out_stream_finish_response(resp : aead.AeadStreamFinishResponse)
.end

fn abi_out_keystore_get_response(resp : aead.AeadKeyStoreGetResponse)
.end

fn abi_out_key_wrap_response(resp : aead.AeadKeyWrapResponse)
.end

fn abi_out_key_unwrap_response(resp : aead.AeadKeyUnwrapResponse)
.end

fn abi_out_audit_event_struct(ev : aead.AeadAuditEvent)
.end

fn abi_out_error(err : aead.AeadError)
.end

# Handles
fn abi_handles_new_key(provider_id : aead.AeadProviderId, alg_id : aead.AeadAlgId) -> u64
  return 0
.end

fn abi_handles_new_ctx(provider_id : aead.AeadProviderId, alg_id : aead.AeadAlgId, key_handle : u64) -> u64
  return 0
.end

fn abi_handles_new_stream(provider_id : aead.AeadProviderId, alg_id : aead.AeadAlgId, ctx_handle : u64) -> u64
  return 0
.end

fn abi_handles_drop(kind : aead.AeadHandleKind, handle : u64)
.end

fn abi_handles_validate(kind : aead.AeadHandleKind, handle : u64) -> bool
  return false
.end

# Nonce policy
fn abi_nonce_check_and_record(key_handle : u64, nonce : coll.Vec[u8], strict : bool) -> aead.AeadError
  return aead.AeadError.Unsupported
.end

# Keystore / wrapping
fn abi_keystore_put(provider_id : aead.AeadProviderId, key_id : aead.AeadKeyId, key_handle : u64) -> aead.AeadError
  return aead.AeadError.Unsupported
.end

fn abi_keystore_get(provider_id : aead.AeadProviderId, key_id : aead.AeadKeyId) -> u64
  return 0
.end

fn abi_key_wrap_impl(wrapping_key_handle : u64, target_key_handle : u64) -> coll.Vec[u8]
  return coll.Vec[u8]()
.end

fn abi_key_unwrap_impl(wrapping_key_handle : u64, wrapped : coll.Vec[u8], usage : aead.AeadKeyUsage, alg_id : aead.AeadAlgId) -> u64
  return 0
.end

# Crypto backend hooks (RFC 8452)
fn backend_aes_gcm_siv_seal_detached(key_handle : u64, nonce : coll.Vec[u8], aad : coll.Vec[u8], plaintext : coll.Vec[u8]) -> aead.AeadDetached
  return aead.AeadDetached {
    cipher = aead.AeadCiphertext { bytes = coll.Vec[u8]() },
    tag = aead.AeadTag { bytes = coll.Vec[u8]() },
  }
.end

fn backend_aes_gcm_siv_open_detached(key_handle : u64, nonce : coll.Vec[u8], aad : coll.Vec[u8], cipher : coll.Vec[u8], tag : coll.Vec[u8]) -> aead.AeadPlaintext
  return aead.AeadPlaintext { bytes = coll.Vec[u8]() }
.end

# Streaming backend (optional)
fn backend_stream_supported() -> bool
  return false
.end

# ============================================================================
# Helpers
# ============================================================================

fn make_len_set_fixed(n : u32) -> aead.AeadLenSet
  return aead.AeadLenSet { min = n, max = n, step = 0, preferred = coll.Vec[u32]() }
.end

fn make_limits() -> aead.AeadLimits
  return aead.AeadLimits {
    key_min = KEY_LEN_128,
    key_max = KEY_LEN_256,
    nonce_min = NONCE_LEN,
    nonce_max = NONCE_LEN,
    tag_min = TAG_LEN,
    tag_max = TAG_LEN,
    aad_max = LIMIT_AAD_MAX,
    msg_max = LIMIT_MSG_MAX,
    cipher_max = LIMIT_CIPH_MAX,
  }
.end

fn audit_emit(kind : aead.AeadAuditEventKind, ok : bool, err : aead.AeadError, key_id : aead.AeadKeyId, aad_bytes : u64, msg_bytes : u64)
  let ev : aead.AeadAuditEvent = aead.AeadAuditEvent {
    kind = kind,
    when_ms = abi_now_ms(),
    provider_id = PROVIDER_ID,
    alg_id = ALG_ID,
    key_id = key_id,
    ok = ok,
    err = err,
    aad_bytes = aad_bytes,
    msg_bytes = msg_bytes,
  }
  abi_out_audit_event_struct(ev)
.end

# ============================================================================
# Provider surface
# ============================================================================

fn emit_provider_info()
  let info : aead.AeadProviderInfo = aead.AeadProviderInfo {
    id = PROVIDER_ID,
    name = PROVIDER_NAME,
    vendor = PROVIDER_VENDOR,
    version = PROVIDER_VERSION,
    backend = PROVIDER_BACKEND,
    priority = PROVIDER_PRIORITY,
    flags = PROVIDER_FLAGS,
    build = PROVIDER_BUILD,
    device = PROVIDER_DEVICE,
    location = PROVIDER_LOCATION,
    algorithms = coll.Vec[aead.AeadAlgInfo](),
  }
  abi_out_provider_info_struct(info)
.end

fn emit_alg_info()
  let info : aead.AeadAlgInfo = aead.AeadAlgInfo {
    id = ALG_ID,
    name = ALG_NAME,
    family = ALG_FAMILY,
    key_lens = aead.AeadLenSet { min = KEY_LEN_128, max = KEY_LEN_256, step = KEY_LEN_128, preferred = coll.Vec[u32]() },
    nonce_lens = make_len_set_fixed(NONCE_LEN),
    tag_lens = make_len_set_fixed(TAG_LEN),
    tag_mode = aead.AeadTagMode.Fixed,
    flags = ALG_FLAGS,
    limits = make_limits(),
  }
  abi_out_alg_info_struct(info)
.end

fn aead_provider_enumerate()
  emit_provider_info()
  emit_alg_info()
.end

fn aead_provider_query(provider_id : aead.AeadProviderId)
  if provider_id != PROVIDER_ID
    abi_out_error(aead.AeadError.InvalidProvider)
    return
  .end
  emit_provider_info()
  emit_alg_info()
.end

fn aead_provider_select(opts : aead.AeadSessionOptions)
  abi_out_select(PROVIDER_ID, ALG_ID)
.end

# ============================================================================
# Keys / contexts (stubs)
# ============================================================================

fn aead_key_generate(provider_id : aead.AeadProviderId, alg_id : aead.AeadAlgId, usage : aead.AeadKeyUsage)
  if provider_id != PROVIDER_ID
    abi_out_error(aead.AeadError.ProviderUnavailable)
    return
  .end
  if alg_id != ALG_ID
    abi_out_error(aead.AeadError.Unsupported)
    return
  .end

  let h : u64 = abi_handles_new_key(PROVIDER_ID, ALG_ID)
  if h == 0
    abi_out_error(aead.AeadError.ProviderBusy)
    return
  .end

  let now : u64 = abi_now_ms()
  let key_id : aead.AeadKeyId = ""

  let constraints : aead.AeadKeyConstraints = aead.AeadKeyConstraints {
    nonce_mode = aead.AeadNonceMode.External,
    strict_nonce = false,
    export_policy = aead.AeadKeyExportPolicy.NonExportable,
    max_ops = 0,
    max_bytes = 0,
  }

  abi_out_key_ref_struct(aead.AeadKeyRef {
    key = aead.AeadOpaque { kind = aead.AeadHandleKind.Key, value = h },
    info = aead.AeadKeyInfo {
      provider_id = PROVIDER_ID,
      alg_id = ALG_ID,
      key_id = key_id,
      usage = usage,
      origin = aead.AeadKeyOrigin.Generated,
      export_policy = aead.AeadKeyExportPolicy.NonExportable,
      key_len = KEY_LEN_256,
      created_ms = now,
      expires_ms = 0,
      flags = ALG_FLAGS,
      constraints = constraints,
    },
  })
  audit_emit(aead.AeadAuditEventKind.KeyCreate, true, aead.AeadError.Ok, key_id, 0, 0)
.end

fn aead_key_import(provider_id : aead.AeadProviderId, alg_id : aead.AeadAlgId, usage : aead.AeadKeyUsage, key_bytes : coll.Vec[u8])
  if provider_id != PROVIDER_ID
    abi_out_error(aead.AeadError.ProviderUnavailable)
    return
  .end
  if alg_id != ALG_ID
    abi_out_error(aead.AeadError.Unsupported)
    return
  .end

  let h : u64 = abi_handles_new_key(PROVIDER_ID, ALG_ID)
  if h == 0
    abi_out_error(aead.AeadError.ProviderBusy)
    return
  .end

  let now : u64 = abi_now_ms()
  let key_id : aead.AeadKeyId = ""

  abi_out_key_ref_struct(aead.AeadKeyRef {
    key = aead.AeadOpaque { kind = aead.AeadHandleKind.Key, value = h },
    info = aead.AeadKeyInfo {
      provider_id = PROVIDER_ID,
      alg_id = ALG_ID,
      key_id = key_id,
      usage = usage,
      origin = aead.AeadKeyOrigin.Imported,
      export_policy = aead.AeadKeyExportPolicy.NonExportable,
      key_len = 0,
      created_ms = now,
      expires_ms = 0,
      flags = ALG_FLAGS,
      constraints = aead.AeadKeyConstraints { nonce_mode = aead.AeadNonceMode.External, strict_nonce = false, export_policy = aead.AeadKeyExportPolicy.NonExportable, max_ops = 0, max_bytes = 0 },
    },
  })
  audit_emit(aead.AeadAuditEventKind.KeyImport, true, aead.AeadError.Ok, key_id, 0, 0)
.end

fn aead_key_destroy(key : aead.AeadOpaque)
  if key.value == 0
    abi_out_error(aead.AeadError.InvalidKey)
    return
  .end
  abi_handles_drop(aead.AeadHandleKind.Key, key.value)
  audit_emit(aead.AeadAuditEventKind.KeyDestroy, true, aead.AeadError.Ok, "", 0, 0)
.end

fn aead_context_create(key : aead.AeadOpaque, flags : u32)
  if key.value == 0
    abi_out_error(aead.AeadError.InvalidKey)
    return
  .end
  if not abi_handles_validate(aead.AeadHandleKind.Key, key.value)
    abi_out_error(aead.AeadError.InvalidKey)
    return
  .end

  let ctx_h : u64 = abi_handles_new_ctx(PROVIDER_ID, ALG_ID, key.value)
  if ctx_h == 0
    abi_out_error(aead.AeadError.ProviderBusy)
    return
  .end

  abi_out_ctx_ref_struct(aead.AeadContextRef {
    ctx = aead.AeadOpaque { kind = aead.AeadHandleKind.Context, value = ctx_h },
    info = aead.AeadContextInfo {
      provider_id = PROVIDER_ID,
      alg_id = ALG_ID,
      key = key,
      flags = flags,
      policy = aead.AeadContextPolicy {
        format_default = aead.AeadFormat.Detached,
        audit_level = aead.AeadAuditLevel.ErrorsOnly,
        nonce_mode = aead.AeadNonceMode.External,
        strict_nonce = false,
        allow_xnonce = false,
      },
    },
  })
.end

fn aead_context_destroy(ctx : aead.AeadOpaque)
  if ctx.value == 0
    abi_out_error(aead.AeadError.InvalidContext)
    return
  .end
  abi_handles_drop(aead.AeadHandleKind.Context, ctx.value)
.end

fn aead_rekey(ctx : aead.AeadOpaque)
  abi_out_error(aead.AeadError.Unsupported)
.end

# ============================================================================
# One-shot (owned)
# ============================================================================

fn aead_seal(req : aead.AeadSealRequest)
  let key_handle : u64 = req.ctx.info.key.value
  let strict : bool = req.ctx.info.policy.strict_nonce

  let e_np : aead.AeadError = abi_nonce_check_and_record(key_handle, req.nonce.bytes, strict)
  if e_np != aead.AeadError.Ok
    abi_out_seal_response(aead.AeadSealResponse { err = e_np, nonce_used = req.nonce, detached = aead.AeadDetached { cipher = aead.AeadCiphertext { bytes = coll.Vec[u8]() }, tag = aead.AeadTag { bytes = coll.Vec[u8]() } }, combined = aead.AeadCombined { bytes = coll.Vec[u8]() } })
    return
  .end

  let detached : aead.AeadDetached = backend_aes_gcm_siv_seal_detached(key_handle, req.nonce.bytes, req.aad.bytes, req.plaintext.bytes)
  abi_out_seal_response(aead.AeadSealResponse { err = aead.AeadError.Ok, nonce_used = req.nonce, detached = detached, combined = aead.AeadCombined { bytes = coll.Vec[u8]() } })
.end

fn aead_open(req : aead.AeadOpenRequest)
  let key_handle : u64 = req.ctx.info.key.value
  let strict : bool = req.ctx.info.policy.strict_nonce

  let e_np : aead.AeadError = abi_nonce_check_and_record(key_handle, req.nonce.bytes, strict)
  if e_np != aead.AeadError.Ok
    abi_out_open_response(aead.AeadOpenResponse { err = e_np, plaintext = aead.AeadPlaintext { bytes = coll.Vec[u8]() } })
    return
  .end

  let pt : aead.AeadPlaintext = backend_aes_gcm_siv_open_detached(key_handle, req.nonce.bytes, req.aad.bytes, req.cipher.bytes, req.tag.bytes)
  abi_out_open_response(aead.AeadOpenResponse { err = aead.AeadError.Ok, plaintext = pt })
.end

# ============================================================================
# Zero-copy one-shot entrypoints (views)
# ============================================================================

fn aead_seal_view(req : aead.AeadSealRequestView)
  let _owned : aead.AeadSealRequest = aead.AeadSealRequest {
    ctx = req.ctx,
    nonce = aead.AeadNonce { bytes = abi_copy_from_slice(req.nonce.bytes) },
    aad = aead.AeadAad { bytes = abi_copy_from_slice(req.aad.bytes) },
    plaintext = aead.AeadPlaintext { bytes = abi_copy_from_slice(req.plaintext.bytes) },
    options = req.options,
  }

  abi_out_seal_response_view(aead.AeadSealResponseView {
    err = aead.AeadError.Unsupported,
    nonce_used = aead.AeadNonceView { bytes = req.nonce.bytes },
    detached = aead.AeadDetachedView {
      cipher = aead.AeadCiphertextView { bytes = aead.ByteSlice { ptr = 0, len = 0 } },
      tag = aead.AeadTagView { bytes = aead.ByteSlice { ptr = 0, len = 0 } },
    },
    combined = aead.AeadCombinedView { bytes = aead.ByteSlice { ptr = 0, len = 0 } },
  })
.end

fn aead_open_view(req : aead.AeadOpenRequestView)
  let _owned : aead.AeadOpenRequest = aead.AeadOpenRequest {
    ctx = req.ctx,
    nonce = aead.AeadNonce { bytes = abi_copy_from_slice(req.nonce.bytes) },
    aad = aead.AeadAad { bytes = abi_copy_from_slice(req.aad.bytes) },
    cipher = aead.AeadCiphertext { bytes = coll.Vec[u8]() },
    tag = aead.AeadTag { bytes = coll.Vec[u8]() },
    combined = aead.AeadCombined { bytes = abi_copy_from_slice(req.combined.bytes) },
    options = req.options,
  }

  abi_out_open_response_view(aead.AeadOpenResponseView {
    err = aead.AeadError.Unsupported,
    plaintext = aead.AeadPlaintextView { bytes = aead.ByteSlice { ptr = 0, len = 0 } },
  })
.end

# ============================================================================
# Streaming / keystore / wrap / audit
# ============================================================================

fn aead_stream_start(req : aead.AeadStreamStartRequest)
  abi_out_stream_start_response(aead.AeadStreamStartResponse {
    err = aead.AeadError.Unsupported,
    stream = aead.AeadStreamRef {
      stream = aead.AeadOpaque { kind = aead.AeadHandleKind.Stream, value = 0 },
      info = aead.AeadStreamInfo { provider_id = PROVIDER_ID, alg_id = ALG_ID, ctx = req.ctx.ctx, role = req.role, state = aead.AeadStreamState.Closed, flags = 0 },
    },
    nonce_used = req.nonce,
  })
.end

fn aead_stream_aad(req : aead.AeadStreamAadRequest)
  abi_out_stream_aad_response(aead.AeadStreamAadResponse { err = aead.AeadError.Unsupported })
.end

fn aead_stream_update(req : aead.AeadStreamUpdateRequest)
  abi_out_stream_update_response(aead.AeadStreamUpdateResponse { err = aead.AeadError.Unsupported, out_chunk = aead.AeadBytes { bytes = coll.Vec[u8]() } })
.end

fn aead_stream_finish(req : aead.AeadStreamFinishRequest)
  abi_out_stream_finish_response(aead.AeadStreamFinishResponse { err = aead.AeadError.Unsupported, tag = aead.AeadTag { bytes = coll.Vec[u8]() } })
.end

fn aead_stream_destroy(stream : aead.AeadOpaque)
  abi_out_error(aead.AeadError.Unsupported)
.end

fn aead_keystore_put(req : aead.AeadKeyStorePutRequest)
  abi_out_error(aead.AeadError.Unsupported)
.end

fn aead_keystore_get(req : aead.AeadKeyStoreGetRequest)
  abi_out_keystore_get_response(aead.AeadKeyStoreGetResponse { err = aead.AeadError.Unsupported, key_ref = aead.AeadKeyRef { key = aead.AeadOpaque { kind = aead.AeadHandleKind.Key, value = 0 }, info = aead.AeadKeyInfo { provider_id = PROVIDER_ID, alg_id = ALG_ID, key_id = req.key_id, usage = aead.AeadKeyUsage.SealAndOpen, origin = aead.AeadKeyOrigin.External, export_policy = aead.AeadKeyExportPolicy.NonExportable, key_len = 0, created_ms = 0, expires_ms = 0, flags = 0, constraints = aead.AeadKeyConstraints { nonce_mode = aead.AeadNonceMode.External, strict_nonce = false, export_policy = aead.AeadKeyExportPolicy.NonExportable, max_ops = 0, max_bytes = 0 } } } })
.end

fn aead_key_wrap(req : aead.AeadKeyWrapRequest)
  abi_out_key_wrap_response(aead.AeadKeyWrapResponse { err = aead.AeadError.Unsupported, wrapped = aead.AeadWrappedKey { bytes = coll.Vec[u8]() } })
.end

fn aead_key_unwrap(req : aead.AeadKeyUnwrapRequest)
  abi_out_key_unwrap_response(aead.AeadKeyUnwrapResponse { err = aead.AeadError.Unsupported, key_ref = aead.AeadKeyRef { key = aead.AeadOpaque { kind = aead.AeadHandleKind.Key, value = 0 }, info = aead.AeadKeyInfo { provider_id = PROVIDER_ID, alg_id = req.alg_id, key_id = "", usage = req.usage, origin = aead.AeadKeyOrigin.External, export_policy = aead.AeadKeyExportPolicy.NonExportable, key_len = 0, created_ms = 0, expires_ms = 0, flags = 0, constraints = aead.AeadKeyConstraints { nonce_mode = aead.AeadNonceMode.External, strict_nonce = false, export_policy = aead.AeadKeyExportPolicy.NonExportable, max_ops = 0, max_bytes = 0 } } } })
.end

fn aead_audit_pull(provider_id : aead.AeadProviderId)
  if provider_id != PROVIDER_ID
    abi_out_error(aead.AeadError.InvalidProvider)
    return
  .end
.end