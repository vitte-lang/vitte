# plugins/beryl-crypto/host/entropy.vitte
# Host entropy model — sources, collection policy, health tests — MAX+++
# Blocks use `.end` only.

module plugins.crypto.host.entropy

import std.collections as coll

import plugins.crypto.api.types as t

# ============================================================================
# Overview
#   - Defines host-side entropy abstractions used by RNG providers.
#   - Does NOT implement platform collection; only describes contracts.
#   - Runtime should bind platform sources (getrandom, /dev/urandom, RDRAND, etc.).
# ============================================================================

# ============================================================================
# Errors
# ============================================================================

enum EntropyError
  Ok

  Unsupported
  Unavailable

  InvalidInput
  BufferTooSmall

  HealthTestFailed
  ReseedRequired
  ReseedFailed

  Timeout
  RateLimited

  InternalError
.end

struct EntropyStatus
  err      : EntropyError
  written  : u64
  required : u64
.end

fn entropy_status_ok(written : u64) -> EntropyStatus
  let s : EntropyStatus = EntropyStatus
  s.err = EntropyError.Ok
  s.written = written
  s.required = 0
  return s
.end

fn entropy_status_err(err : EntropyError) -> EntropyStatus
  let s : EntropyStatus = EntropyStatus
  s.err = err
  s.written = 0
  s.required = 0
  return s
.end

# ============================================================================
# Quality model
# ============================================================================

enum EntropyQuality
  # Not suitable for cryptography
  Low

  # Medium quality (may be used to seed stronger mechanisms)
  Medium

  # Cryptographic quality
  High

  # Hardware-backed (may be High but with different trust properties)
  Hardware

  # Verified / certified quality (e.g., FIPS validated source)
  Certified
.end

enum EntropyCategory
  OsCsprng
  DeviceUrandom
  DeviceRandom

  CpuRdrand
  CpuRdseed

  HardwareTrng

  RemoteKms
  RemoteAttested

  DeterministicTest
.end

# ============================================================================
# Source descriptors
# ============================================================================

const ENTROPY_SRC_FLAG_THREADSAFE     : u64 = 1
const ENTROPY_SRC_FLAG_NONBLOCKING   : u64 = 2
const ENTROPY_SRC_FLAG_BLOCKING      : u64 = 4

const ENTROPY_SRC_FLAG_RATE_LIMITED  : u64 = 8
const ENTROPY_SRC_FLAG_REQUIRES_INIT : u64 = 16

const ENTROPY_SRC_FLAG_HEALTH_TESTS  : u64 = 32
const ENTROPY_SRC_FLAG_PREDICT_RESIST: u64 = 64

const ENTROPY_SRC_FLAG_REMOTE        : u64 = 128
const ENTROPY_SRC_FLAG_ATTESTED      : u64 = 256

struct EntropySourceInfo
  source_id    : string
  name         : string

  category     : EntropyCategory
  quality      : EntropyQuality

  flags        : u64

  min_bytes    : u32
  max_bytes    : u32

  # Estimated entropy per byte (0..8). If unknown, set 0.
  entropy_bits_per_byte : u8

  # optional
  notes        : string
.end

struct EntropySourceList
  sources : coll.Vec[EntropySourceInfo]
.end

# ============================================================================
# Collection policy
# ============================================================================

enum EntropyMixMode
  # Use a single preferred source
  Single

  # Mix multiple sources (xor/concat + KDF) (runtime/provider-defined)
  Mix

  # Reseed from sources periodically
  Periodic
.end

enum EntropyRequestKind
  Seed
  Reseed
  Random
.end

struct EntropyLimits
  req_max_bytes      : u32
  rate_max_per_sec   : u32
  rate_burst_bytes   : u32
  timeout_ms         : u32
.end

fn entropy_limits_default() -> EntropyLimits
  let l : EntropyLimits = EntropyLimits
  l.req_max_bytes = 1_048_576
  l.rate_max_per_sec = 0
  l.rate_burst_bytes = 0
  l.timeout_ms = 0
  return l
.end

struct EntropyPolicy
  # requested minimum quality tier
  min_quality        : EntropyQuality

  # selection
  preferred_source_id: string

  # mixing
  mix_mode           : EntropyMixMode
  mix_min_sources    : u32

  # health tests
  require_health_tests : bool

  # limits
  limits             : EntropyLimits

  # audit
  audit              : bool
.end

fn entropy_policy_default() -> EntropyPolicy
  let p : EntropyPolicy = EntropyPolicy
  p.min_quality = EntropyQuality.High
  p.preferred_source_id = "default"
  p.mix_mode = EntropyMixMode.Single
  p.mix_min_sources = 1
  p.require_health_tests = true
  p.limits = entropy_limits_default()
  p.audit = false
  return p
.end

# ============================================================================
# Health tests
# ============================================================================

enum HealthTestKind
  # Repetition Count Test
  Rct

  # Adaptive Proportion Test
  Apt

  # Continuous RNG test (generic)
  Continuous

  # Provider-defined
  Custom
.end

enum HealthTestStatus
  Ok
  Failed
  NotRun
.end

struct HealthTestParams
  kind        : HealthTestKind

  # Common knobs (provider-defined semantics)
  window      : u32
  threshold   : u32

  notes       : string
.end

fn health_test_params_default(kind : HealthTestKind) -> HealthTestParams
  let p : HealthTestParams = HealthTestParams
  p.kind = kind
  p.window = 0
  p.threshold = 0
  p.notes = ""
  return p
.end

struct HealthTestReport
  kind        : HealthTestKind
  status      : HealthTestStatus

  samples     : u64
  failures    : u64

  detail      : string
.end

struct HealthTestSuite
  tests       : coll.Vec[HealthTestParams]
.end

fn health_test_suite_default() -> HealthTestSuite
  let s : HealthTestSuite = HealthTestSuite
  s.tests = coll.Vec[HealthTestParams]
  s.tests.push(health_test_params_default(HealthTestKind.Continuous))
  return s
.end

# ============================================================================
# Reseed model
# ============================================================================

struct ReseedPolicy
  # reseed interval in bytes and/or time
  reseed_bytes_interval : u64
  reseed_time_ms        : u32

  # maximum bytes between reseeds
  max_bytes_without_reseed : u64

  # if true, require reseed on first use
  reseed_on_start : bool
.end

fn reseed_policy_default() -> ReseedPolicy
  let r : ReseedPolicy = ReseedPolicy
  r.reseed_bytes_interval = 1_048_576
  r.reseed_time_ms = 0
  r.max_bytes_without_reseed = 16_777_216
  r.reseed_on_start = true
  return r
.end

struct EntropyRuntimeState
  # updated by runtime/provider
  bytes_since_reseed : u64
  last_reseed_ms     : u64

  health_last        : HealthTestStatus
.end

fn entropy_state_default() -> EntropyRuntimeState
  let s : EntropyRuntimeState = EntropyRuntimeState
  s.bytes_since_reseed = 0
  s.last_reseed_ms = 0
  s.health_last = HealthTestStatus.NotRun
  return s
.end

# ============================================================================
# ABI-friendly request/response structs
# ============================================================================

# The runtime may marshal these structures across boundaries.

struct EntropyEnumerateRequest
  # reserved for future filtering
  min_quality : EntropyQuality
.end

struct EntropyEnumerateResponse
  err   : EntropyError
  list  : EntropySourceList
.end

struct EntropyGetInfoRequest
  source_id : string
.end

struct EntropyGetInfoResponse
  err  : EntropyError
  info : EntropySourceInfo
.end

struct EntropyFillRequest
  source_id : string
  policy    : EntropyPolicy

  kind      : EntropyRequestKind
  len       : u32

  out       : coll.Vec[u8]
.end

struct EntropyFillRequestView
  source_id : string
  policy    : EntropyPolicy

  kind      : EntropyRequestKind

  output    : t.MutByteSlice
.end

struct EntropyFillIoVecRequestView
  source_id : string
  policy    : EntropyPolicy

  kind      : EntropyRequestKind

  output    : t.MutIoVec
.end

struct EntropyFillResponse
  err      : EntropyError
  written  : u64
  required : u64
.end

struct EntropyHealthCheckRequest
  source_id : string
  suite     : HealthTestSuite
.end

struct EntropyHealthCheckResponse
  err       : EntropyError
  reports   : coll.Vec[HealthTestReport]
.end

struct EntropyReseedRequest
  source_id : string
  policy    : EntropyPolicy
  reseed    : ReseedPolicy
.end

struct EntropyReseedResponse
  err       : EntropyError
.end

# ============================================================================
# Audit hooks
# ============================================================================

enum EntropyAuditEventKind
  Enumerate
  GetInfo
  Fill
  HealthCheck
  Reseed
  Error
.end

struct EntropyAuditEvent
  kind      : EntropyAuditEventKind

  source_id : string
  category  : EntropyCategory
  quality   : EntropyQuality

  requested : u64
  written   : u64

  err       : EntropyError

  # Optional timestamp/id
  ts_ms     : u64

  note      : string
.end

fn entropy_audit_emit(ev : EntropyAuditEvent)
  # Runtime integrates this with audit channel.
.end

# ============================================================================
# API hooks (stubs)
# ============================================================================

# These are the host-facing contracts. Implementations live in runtime/provider.

fn entropy_enumerate(req : EntropyEnumerateRequest) -> EntropyEnumerateResponse
  let r : EntropyEnumerateResponse = EntropyEnumerateResponse
  r.err = EntropyError.Unsupported
  r.list = EntropySourceList
  r.list.sources = coll.Vec[EntropySourceInfo]
  return r
.end

fn entropy_get_info(req : EntropyGetInfoRequest) -> EntropyGetInfoResponse
  let r : EntropyGetInfoResponse = EntropyGetInfoResponse
  r.err = EntropyError.Unsupported
  r.info = EntropySourceInfo
  return r
.end

fn entropy_fill(req : EntropyFillRequest) -> EntropyFillResponse
  let r : EntropyFillResponse = EntropyFillResponse
  r.err = EntropyError.Unsupported
  r.written = 0
  r.required = req.len as u64
  return r
.end

fn entropy_fill_view(req : EntropyFillRequestView) -> EntropyFillResponse
  let r : EntropyFillResponse = EntropyFillResponse
  r.err = EntropyError.Unsupported
  r.written = 0
  r.required = req.output.len
  return r
.end

fn entropy_fill_iovec_view(req : EntropyFillIoVecRequestView) -> EntropyFillResponse
  let r : EntropyFillResponse = EntropyFillResponse
  r.err = EntropyError.Unsupported
  r.written = 0
  r.required = 0
  return r
.end

fn entropy_health_check(req : EntropyHealthCheckRequest) -> EntropyHealthCheckResponse
  let r : EntropyHealthCheckResponse = EntropyHealthCheckResponse
  r.err = EntropyError.Unsupported
  r.reports = coll.Vec[HealthTestReport]
  return r
.end

fn entropy_reseed(req : EntropyReseedRequest) -> EntropyReseedResponse
  let r : EntropyReseedResponse = EntropyReseedResponse
  r.err = EntropyError.Unsupported
  return r
.end

# ============================================================================
# Deterministic test source (pure, no platform I/O)
# ============================================================================

# Used by unit tests and deterministic benches.
# This source does NOT provide cryptographic entropy.

struct DeterministicEntropy
  state : u64
.end

fn det_entropy_new(seed : u64) -> DeterministicEntropy
  let d : DeterministicEntropy = DeterministicEntropy
  d.state = seed
  return d
.end

fn det_entropy_next_u64(d : DeterministicEntropy) -> DeterministicEntropy
  # xorshift64*
  let x : u64 = d.state
  x ^= x >> 12
  x ^= x << 25
  x ^= x >> 27
  let out : DeterministicEntropy = d
  out.state = x * 2685821657736338717
  return out
.end

fn det_entropy_fill(d_in : DeterministicEntropy, out : t.MutByteSlice) -> DeterministicEntropy
  let d : DeterministicEntropy = d_in
  let i : u64 = 0
  while i < out.len
    let d2 : DeterministicEntropy = det_entropy_next_u64(d)
    d = d2

    # write 8 bytes little-endian
    let x : u64 = d.state
    let j : u64 = 0
    while (j < 8) and ((i + j) < out.len)
      out[(i + j)] = ((x >> (8 * j)) & 0xFF) as u8
      j += 1
    .end

    i += 8
  .end

  return d
.end

# ============================================================================
# Helpers
# ============================================================================

fn entropy_quality_meets(q : EntropyQuality, min : EntropyQuality) -> bool
  # Linear ordering assumption:
  # Low < Medium < High < Hardware < Certified
  if q == min
    return true
  .end

  if min == EntropyQuality.Low
    return true
  .end

  if min == EntropyQuality.Medium
    if q == EntropyQuality.High
      return true
    .end
    if q == EntropyQuality.Hardware
      return true
    .end
    if q == EntropyQuality.Certified
      return true
    .end
  .end

  if min == EntropyQuality.High
    if q == EntropyQuality.Hardware
      return true
    .end
    if q == EntropyQuality.Certified
      return true
    .end
  .end

  if min == EntropyQuality.Hardware
    if q == EntropyQuality.Certified
      return true
    .end
  .end

  return false
.end

.end
