# plugins/crypto/host/policy.vitte
# Policy
# Blocks use `.end` only.

mod plugins.crypto.host.policy

# TODO

.end

# plugins/beryl-crypto/host/policy.vitte
# Host policy — validation/normalization across crypto families — MAX+++
# Blocks use `.end` only.

module plugins.crypto.host.policy

import std.collections as coll

import plugins.crypto.api.types as t

import plugins.crypto.host.caps as caps

# ============================================================================
# Errors
# ============================================================================

enum PolicyError
  Ok

  InvalidInput
  InvalidPolicy

  Unsupported
  IncompatibleAbi
  IncompatibleProvider
  IncompatibleAlgorithm

  MissingRequirement
  ConflictingFlags

  InvalidLength
  InvalidLimits

  InternalError
.end

struct PolicyStatus
  err     : PolicyError
  reason  : string
.end

fn policy_ok() -> PolicyStatus
  let s : PolicyStatus = PolicyStatus
  s.err = PolicyError.Ok
  s.reason = ""
  return s
.end

fn policy_err(err : PolicyError, reason : string) -> PolicyStatus
  let s : PolicyStatus = PolicyStatus
  s.err = err
  s.reason = reason
  return s
.end

# ============================================================================
# Common knobs
# ============================================================================

struct CommonPolicy
  constant_time    : bool
  sidechannel_hard : bool

  strict_lengths   : bool
  strict_nonce     : bool

  audit            : bool

  # If set, prefer local provider (non-remote).
  prefer_local     : bool

  # If set, prefer hw acceleration when available.
  prefer_hw        : bool
.end

fn common_policy_default() -> CommonPolicy
  let p : CommonPolicy = CommonPolicy
  p.constant_time = true
  p.sidechannel_hard = false
  p.strict_lengths = true
  p.strict_nonce = true
  p.audit = false
  p.prefer_local = true
  p.prefer_hw = true
  return p
.end

# ============================================================================
# Limits
# ============================================================================

struct Limits
  msg_max : u64
  aad_max : u64
  out_max : u64
.end

fn limits_unbounded() -> Limits
  let l : Limits = Limits
  l.msg_max = 0
  l.aad_max = 0
  l.out_max = 0
  return l
.end

fn limits_default_aead() -> Limits
  # Conservative defaults. Providers may expose tighter values.
  let l : Limits = Limits
  l.msg_max = 1_073_741_824
  l.aad_max = 67_108_864
  l.out_max = 1_073_741_824
  return l
.end

fn limits_default_hash() -> Limits
  let l : Limits = Limits
  l.msg_max = 4_294_967_295
  l.aad_max = 0
  l.out_max = 4096
  return l
.end

fn limits_default_cipher() -> Limits
  let l : Limits = Limits
  l.msg_max = 1_073_741_824
  l.aad_max = 0
  l.out_max = 1_073_741_824
  return l
.end

fn limits_default_sign() -> Limits
  let l : Limits = Limits
  l.msg_max = 1_073_741_824
  l.aad_max = 0
  l.out_max = 4096
  return l
.end

fn limits_default_kex() -> Limits
  let l : Limits = Limits
  l.msg_max = 0
  l.aad_max = 0
  l.out_max = 4096
  return l
.end

fn limits_default_rand() -> Limits
  let l : Limits = Limits
  l.msg_max = 16_777_216
  l.aad_max = 0
  l.out_max = 16_777_216
  return l
.end

fn limits_is_valid(l : Limits) -> bool
  # zero means unbounded
  if (l.msg_max != 0) and (l.msg_max < 1)
    return false
  .end
  if (l.aad_max != 0) and (l.aad_max < 0)
    return false
  .end
  if (l.out_max != 0) and (l.out_max < 1)
    return false
  .end
  return true
.end

# ============================================================================
# Family policy structs
# ============================================================================

# --------------------------------------------------------------------------
# AEAD
# --------------------------------------------------------------------------

struct AeadPolicy
  common     : CommonPolicy

  # sizes (0 means "provider default")
  key_len    : u32
  nonce_len  : u32
  tag_len    : u32

  # strict nonce semantics
  detect_nonce_reuse      : bool
  detect_nonce_exhaustion : bool

  limits     : Limits
.end

fn aead_policy_default() -> AeadPolicy
  let p : AeadPolicy = AeadPolicy
  p.common = common_policy_default()

  p.key_len = 0
  p.nonce_len = 0
  p.tag_len = 16

  p.detect_nonce_reuse = true
  p.detect_nonce_exhaustion = true

  p.limits = limits_default_aead()
  return p
.end

# --------------------------------------------------------------------------
# Hash
# --------------------------------------------------------------------------

struct HashPolicy
  common   : CommonPolicy

  # output length (0 means algorithm default)
  out_len  : u32

  # if true, forbid XOF variable length (must match default or explicit out_len)
  strict_out_len : bool

  limits   : Limits
.end

fn hash_policy_default() -> HashPolicy
  let p : HashPolicy = HashPolicy
  p.common = common_policy_default()
  p.out_len = 0
  p.strict_out_len = false
  p.limits = limits_default_hash()
  return p
.end

# --------------------------------------------------------------------------
# Cipher (non-AEAD)
# --------------------------------------------------------------------------

enum CipherPadding
  None
  Pkcs7
.end

enum CipherDir
  Encrypt
  Decrypt
.end

struct CipherPolicy
  common      : CommonPolicy

  # mode string id (implementation-specific): "ecb"/"cbc"/"ctr"/"xts"
  mode_id     : string
  dir         : CipherDir
  padding     : CipherPadding

  # strict lengths (e.g. CBC requires multiple of block unless padding)
  strict_block_multiple : bool

  limits      : Limits
.end

fn cipher_policy_default() -> CipherPolicy
  let p : CipherPolicy = CipherPolicy
  p.common = common_policy_default()

  p.mode_id = "ctr"
  p.dir = CipherDir.Encrypt
  p.padding = CipherPadding.None
  p.strict_block_multiple = true

  p.limits = limits_default_cipher()
  return p
.end

# --------------------------------------------------------------------------
# Sign
# --------------------------------------------------------------------------

struct SignPolicy
  common : CommonPolicy

  # if true, require deterministic signatures when algorithm supports
  require_deterministic : bool

  limits : Limits
.end

fn sign_policy_default() -> SignPolicy
  let p : SignPolicy = SignPolicy
  p.common = common_policy_default()
  p.require_deterministic = true
  p.limits = limits_default_sign()
  return p
.end

# --------------------------------------------------------------------------
# Kex
# --------------------------------------------------------------------------

struct KexPolicy
  common : CommonPolicy

  # allow fixed-base acceleration when available
  allow_fixed_base : bool

  limits : Limits
.end

fn kex_policy_default() -> KexPolicy
  let p : KexPolicy = KexPolicy
  p.common = common_policy_default()
  p.allow_fixed_base = true
  p.limits = limits_default_kex()
  return p
.end

# --------------------------------------------------------------------------
# Rand
# --------------------------------------------------------------------------

struct RandPolicy
  common : CommonPolicy

  # required minimum entropy quality tier (when backed by host entropy)
  min_entropy_quality : u32

  # reseed interval
  reseed_bytes_interval : u64

  limits : Limits
.end

fn rand_policy_default() -> RandPolicy
  let p : RandPolicy = RandPolicy
  p.common = common_policy_default()

  p.min_entropy_quality = 2
  p.reseed_bytes_interval = 1_048_576

  p.limits = limits_default_rand()
  return p
.end

# ============================================================================
# Normalization
# ============================================================================

fn normalize_common(p_in : CommonPolicy) -> CommonPolicy
  let p : CommonPolicy = p_in

  # If sidechannel_hard implies constant_time.
  if p.sidechannel_hard
    p.constant_time = true
  .end

  # strict_nonce only meaningful for AEAD, but keep value.
  # prefer_local/prefer_hw defaults are already set.

  return p
.end

fn normalize_aead(p_in : AeadPolicy) -> AeadPolicy
  let p : AeadPolicy = p_in
  p.common = normalize_common(p.common)

  # tag_len default
  if p.tag_len == 0
    p.tag_len = 16
  .end

  # strict_nonce gating
  if not p.common.strict_nonce
    p.detect_nonce_reuse = false
    p.detect_nonce_exhaustion = false
  .end

  # limits default
  if not limits_is_valid(p.limits)
    p.limits = limits_default_aead()
  .end

  return p
.end

fn normalize_hash(p_in : HashPolicy) -> HashPolicy
  let p : HashPolicy = p_in
  p.common = normalize_common(p.common)

  if not limits_is_valid(p.limits)
    p.limits = limits_default_hash()
  .end

  return p
.end

fn normalize_cipher(p_in : CipherPolicy) -> CipherPolicy
  let p : CipherPolicy = p_in
  p.common = normalize_common(p.common)

  if p.mode_id == ""
    p.mode_id = "ctr"
  .end

  if not limits_is_valid(p.limits)
    p.limits = limits_default_cipher()
  .end

  return p
.end

fn normalize_sign(p_in : SignPolicy) -> SignPolicy
  let p : SignPolicy = p_in
  p.common = normalize_common(p.common)

  if not limits_is_valid(p.limits)
    p.limits = limits_default_sign()
  .end

  return p
.end

fn normalize_kex(p_in : KexPolicy) -> KexPolicy
  let p : KexPolicy = p_in
  p.common = normalize_common(p.common)

  if not limits_is_valid(p.limits)
    p.limits = limits_default_kex()
  .end

  return p
.end

fn normalize_rand(p_in : RandPolicy) -> RandPolicy
  let p : RandPolicy = p_in
  p.common = normalize_common(p.common)

  if p.reseed_bytes_interval == 0
    p.reseed_bytes_interval = 1_048_576
  .end

  if not limits_is_valid(p.limits)
    p.limits = limits_default_rand()
  .end

  return p
.end

# ============================================================================
# Validation against ABI and capability sets
# ============================================================================

# Detailed rejection reasons are returned in PolicyStatus.reason.

fn validate_common_against_abi(p : CommonPolicy, abi : caps.RuntimeAbiCaps) -> PolicyStatus
  # Views/iovec/streaming are not requested here; validated per family.

  if p.audit
    if not abi.audit_channel
      return policy_err(PolicyError.IncompatibleAbi, "audit requested but runtime has no audit channel")
    .end
  .end

  if p.sidechannel_hard
    # sidechannel hardening may require atomics/threads for certain enforcement.
    if not abi.atomics
      return policy_err(PolicyError.IncompatibleAbi, "sidechannel_hard requested but runtime lacks atomics")
    .end
  .end

  return policy_ok()
.end

fn validate_provider_caps(p : CommonPolicy, prov : caps.ProviderCaps) -> PolicyStatus
  # Thread-safety requirement is implicit when using shared handles.
  # If strict, enforce provider threadsafe.

  if caps.caps_mask_has(prov.flags, caps.PROVIDER_FLAG_THREADSAFE)
    # ok
  .end

  if p.audit
    if not caps.caps_mask_has(prov.flags, caps.PROVIDER_FLAG_AUDIT)
      # Allow if runtime audit exists; provider may still emit via host.
      # Keep as warning-like error? Here, reject if strict.
      return policy_err(PolicyError.IncompatibleProvider, "audit requested but provider does not advertise audit")
    .end
  .end

  if p.constant_time
    if not caps.caps_mask_has(prov.flags, caps.PROVIDER_FLAG_CONSTANT_TIME)
      # Best effort: allow, but if sidechannel_hard also set, reject.
      if p.sidechannel_hard
        return policy_err(PolicyError.IncompatibleProvider, "sidechannel_hard requires provider constant-time capability")
      .end
    .end
  .end

  if p.sidechannel_hard
    if not caps.caps_mask_has(prov.flags, caps.PROVIDER_FLAG_SIDECHANNEL_HARD)
      return policy_err(PolicyError.IncompatibleProvider, "sidechannel_hard requested but provider does not support it")
    .end
  .end

  return policy_ok()
.end

fn validate_alg_caps_common(p : CommonPolicy, alg : caps.AlgCaps) -> PolicyStatus
  if p.constant_time
    if not caps.caps_mask_has(alg.flags, caps.ALG_FLAG_CONSTANT_TIME)
      if p.sidechannel_hard
        return policy_err(PolicyError.IncompatibleAlgorithm, "sidechannel_hard requires alg constant-time")
      .end
    .end
  .end

  if p.sidechannel_hard
    if not caps.caps_mask_has(alg.flags, caps.ALG_FLAG_SIDECHANNEL_HARD)
      return policy_err(PolicyError.IncompatibleAlgorithm, "sidechannel_hard requested but alg does not support it")
    .end
  .end

  return policy_ok()
.end

fn validate_limits(req : Limits, lim : caps.AlgLimits) -> PolicyStatus
  # 0 means unbounded request; but must not exceed provider limit if provider sets non-zero.
  if lim.msg_max != 0
    if req.msg_max != 0
      if req.msg_max > lim.msg_max
        return policy_err(PolicyError.InvalidLimits, "msg_max exceeds provider limit")
      .end
    .end
  .end

  if lim.aad_max != 0
    if req.aad_max != 0
      if req.aad_max > lim.aad_max
        return policy_err(PolicyError.InvalidLimits, "aad_max exceeds provider limit")
      .end
    .end
  .end

  if lim.out_max != 0
    if req.out_max != 0
      if req.out_max > lim.out_max
        return policy_err(PolicyError.InvalidLimits, "out_max exceeds provider limit")
      .end
    .end
  .end

  return policy_ok()
.end

# --------------------------------------------------------------------------
# AEAD validation
# --------------------------------------------------------------------------

fn validate_aead(p_in : AeadPolicy, abi : caps.RuntimeAbiCaps, prov : caps.ProviderCaps, alg : caps.AlgCaps) -> PolicyStatus
  let p : AeadPolicy = normalize_aead(p_in)

  let st0 : PolicyStatus = validate_common_against_abi(p.common, abi)
  if st0.err != PolicyError.Ok
    return st0
  .end

  let st1 : PolicyStatus = validate_provider_caps(p.common, prov)
  if st1.err != PolicyError.Ok
    return st1
  .end

  let st2 : PolicyStatus = validate_alg_caps_common(p.common, alg)
  if st2.err != PolicyError.Ok
    return st2
  .end

  # AEAD-specific caps
  if p.common.strict_nonce
    if p.detect_nonce_reuse
      if not caps.caps_mask_has(alg.flags, caps.ALG_FLAG_NONCE_REUSE_DETECT)
        return policy_err(PolicyError.IncompatibleAlgorithm, "strict_nonce requires nonce reuse detection")
      .end
    .end
    if p.detect_nonce_exhaustion
      if not caps.caps_mask_has(alg.flags, caps.ALG_FLAG_NONCE_EXHAUST_DETECT)
        return policy_err(PolicyError.IncompatibleAlgorithm, "strict_nonce requires nonce exhaustion detection")
      .end
    .end
  .end

  # lengths against alg limits (if provided)
  if alg.limits.key_min != 0
    if p.key_len != 0
      if (p.key_len < alg.limits.key_min) or (p.key_len > alg.limits.key_max)
        return policy_err(PolicyError.InvalidLength, "key_len outside supported range")
      .end
    .end
  .end

  if alg.limits.nonce_min != 0
    if p.nonce_len != 0
      if (p.nonce_len < alg.limits.nonce_min) or (p.nonce_len > alg.limits.nonce_max)
        return policy_err(PolicyError.InvalidLength, "nonce_len outside supported range")
      .end
    .end
  .end

  if alg.limits.tag_min != 0
    if p.tag_len != 0
      if (p.tag_len < alg.limits.tag_min) or (p.tag_len > alg.limits.tag_max)
        return policy_err(PolicyError.InvalidLength, "tag_len outside supported range")
      .end
    .end
  .end

  let stl : PolicyStatus = validate_limits(p.limits, alg.limits)
  if stl.err != PolicyError.Ok
    return stl
  .end

  return policy_ok()
.end

# --------------------------------------------------------------------------
# Hash validation
# --------------------------------------------------------------------------

fn validate_hash(p_in : HashPolicy, abi : caps.RuntimeAbiCaps, prov : caps.ProviderCaps, alg : caps.AlgCaps) -> PolicyStatus
  let p : HashPolicy = normalize_hash(p_in)

  let st0 : PolicyStatus = validate_common_against_abi(p.common, abi)
  if st0.err != PolicyError.Ok
    return st0
  .end

  let st1 : PolicyStatus = validate_provider_caps(p.common, prov)
  if st1.err != PolicyError.Ok
    return st1
  .end

  let st2 : PolicyStatus = validate_alg_caps_common(p.common, alg)
  if st2.err != PolicyError.Ok
    return st2
  .end

  # strict out len
  if p.strict_out_len
    if p.out_len == 0
      # must be default (provider-defined) -> acceptable
    .end
  .end

  let stl : PolicyStatus = validate_limits(p.limits, alg.limits)
  if stl.err != PolicyError.Ok
    return stl
  .end

  return policy_ok()
.end

# --------------------------------------------------------------------------
# Cipher validation
# --------------------------------------------------------------------------

fn validate_cipher(p_in : CipherPolicy, abi : caps.RuntimeAbiCaps, prov : caps.ProviderCaps, alg : caps.AlgCaps) -> PolicyStatus
  let p : CipherPolicy = normalize_cipher(p_in)

  let st0 : PolicyStatus = validate_common_against_abi(p.common, abi)
  if st0.err != PolicyError.Ok
    return st0
  .end

  let st1 : PolicyStatus = validate_provider_caps(p.common, prov)
  if st1.err != PolicyError.Ok
    return st1
  .end

  let st2 : PolicyStatus = validate_alg_caps_common(p.common, alg)
  if st2.err != PolicyError.Ok
    return st2
  .end

  let stl : PolicyStatus = validate_limits(p.limits, alg.limits)
  if stl.err != PolicyError.Ok
    return stl
  .end

  return policy_ok()
.end

# --------------------------------------------------------------------------
# Sign validation
# --------------------------------------------------------------------------

fn validate_sign(p_in : SignPolicy, abi : caps.RuntimeAbiCaps, prov : caps.ProviderCaps, alg : caps.AlgCaps) -> PolicyStatus
  let p : SignPolicy = normalize_sign(p_in)

  let st0 : PolicyStatus = validate_common_against_abi(p.common, abi)
  if st0.err != PolicyError.Ok
    return st0
  .end

  let st1 : PolicyStatus = validate_provider_caps(p.common, prov)
  if st1.err != PolicyError.Ok
    return st1
  .end

  let st2 : PolicyStatus = validate_alg_caps_common(p.common, alg)
  if st2.err != PolicyError.Ok
    return st2
  .end

  if p.require_deterministic
    if not caps.caps_mask_has(prov.flags, caps.PROVIDER_FLAG_DETERMINISTIC)
      # allow if alg claims deterministic
      if not caps.caps_mask_has(alg.flags, caps.ALG_FLAG_ONE_SHOT)
        return policy_err(PolicyError.IncompatibleProvider, "deterministic signatures required but provider not deterministic")
      .end
    .end
  .end

  let stl : PolicyStatus = validate_limits(p.limits, alg.limits)
  if stl.err != PolicyError.Ok
    return stl
  .end

  return policy_ok()
.end

# --------------------------------------------------------------------------
# Kex validation
# --------------------------------------------------------------------------

fn validate_kex(p_in : KexPolicy, abi : caps.RuntimeAbiCaps, prov : caps.ProviderCaps, alg : caps.AlgCaps) -> PolicyStatus
  let p : KexPolicy = normalize_kex(p_in)

  let st0 : PolicyStatus = validate_common_against_abi(p.common, abi)
  if st0.err != PolicyError.Ok
    return st0
  .end

  let st1 : PolicyStatus = validate_provider_caps(p.common, prov)
  if st1.err != PolicyError.Ok
    return st1
  .end

  let st2 : PolicyStatus = validate_alg_caps_common(p.common, alg)
  if st2.err != PolicyError.Ok
    return st2
  .end

  let stl : PolicyStatus = validate_limits(p.limits, alg.limits)
  if stl.err != PolicyError.Ok
    return stl
  .end

  return policy_ok()
.end

# --------------------------------------------------------------------------
# Rand validation
# --------------------------------------------------------------------------

fn validate_rand(p_in : RandPolicy, abi : caps.RuntimeAbiCaps, prov : caps.ProviderCaps, alg : caps.AlgCaps) -> PolicyStatus
  let p : RandPolicy = normalize_rand(p_in)

  let st0 : PolicyStatus = validate_common_against_abi(p.common, abi)
  if st0.err != PolicyError.Ok
    return st0
  .end

  let st1 : PolicyStatus = validate_provider_caps(p.common, prov)
  if st1.err != PolicyError.Ok
    return st1
  .end

  let st2 : PolicyStatus = validate_alg_caps_common(p.common, alg)
  if st2.err != PolicyError.Ok
    return st2
  .end

  let stl : PolicyStatus = validate_limits(p.limits, alg.limits)
  if stl.err != PolicyError.Ok
    return stl
  .end

  return policy_ok()
.end

# ============================================================================
# Derive registry selection policy
# ============================================================================

fn to_select_policy(common : CommonPolicy, require_views : bool, require_iovec : bool, require_streaming : bool) -> caps.SelectPolicy
  let c : CommonPolicy = normalize_common(common)

  let sp : caps.SelectPolicy = caps.select_policy_default()

  sp.require_threadsafe = false

  sp.require_views = require_views
  sp.require_iovec = require_iovec
  sp.require_streaming = require_streaming

  sp.require_constant_time = c.constant_time
  sp.require_sidechannel = c.sidechannel_hard

  sp.prefer_hw = c.prefer_hw
  sp.prefer_local = c.prefer_local

  sp.max_abi_level = 0

  return sp
.end

# ============================================================================
# Convenience: validate by family id
# ============================================================================

# This keeps host code generic: select provider/alg by family and then validate.

struct ValidateAnyResult
  ok      : bool
  status  : PolicyStatus
.end

fn validate_any_family(family : string, abi : caps.RuntimeAbiCaps, prov : caps.ProviderCaps, alg : caps.AlgCaps) -> ValidateAnyResult
  let r : ValidateAnyResult = ValidateAnyResult
  r.ok = false
  r.status = policy_err(PolicyError.InvalidInput, "unknown family")

  if family == caps.FAMILY_AEAD
    let p : AeadPolicy = aead_policy_default()
    r.status = validate_aead(p, abi, prov, alg)
    r.ok = r.status.err == PolicyError.Ok
    return r
  .end

  if family == caps.FAMILY_HASH
    let p : HashPolicy = hash_policy_default()
    r.status = validate_hash(p, abi, prov, alg)
    r.ok = r.status.err == PolicyError.Ok
    return r
  .end

  if family == caps.FAMILY_CIPHER
    let p : CipherPolicy = cipher_policy_default()
    r.status = validate_cipher(p, abi, prov, alg)
    r.ok = r.status.err == PolicyError.Ok
    return r
  .end

  if family == caps.FAMILY_SIGN
    let p : SignPolicy = sign_policy_default()
    r.status = validate_sign(p, abi, prov, alg)
    r.ok = r.status.err == PolicyError.Ok
    return r
  .end

  if family == caps.FAMILY_KEX
    let p : KexPolicy = kex_policy_default()
    r.status = validate_kex(p, abi, prov, alg)
    r.ok = r.status.err == PolicyError.Ok
    return r
  .end

  if family == caps.FAMILY_RAND
    let p : RandPolicy = rand_policy_default()
    r.status = validate_rand(p, abi, prov, alg)
    r.ok = r.status.err == PolicyError.Ok
    return r
  .end

  return r
.end

.end