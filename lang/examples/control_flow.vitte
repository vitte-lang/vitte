

module vitte.examples.control_flow

import std.collections as coll
import vitte.compiler.spans as spans
import vitte.compiler.names as names
import vitte.compiler.types as types

# ============================================================================
# Vitte examples – Modèle et exemples de structures de contrôle
#
# Objectifs de ce fichier :
#   - Illustrer, de manière déclarative, comment le compilateur peut représenter
#     les structures de contrôle de Vitte :
#       * branchements conditionnels (when / else when / else),
#       * boucles (loop / from / to / step),
#       * structures de blocs et scopes,
#       * liens avec les spans et les types.
#   - Fournir un jeu d’exemples ultra complet en "phrase syntaxe" pour :
#       * tester la grammaire et le parser,
#       * servir de base à la documentation du langage,
#       * alimenter des outils (LSP, debugger) via un modèle de données.
#
# Convention :
#   - Ce fichier reste principalement un "data model" + exemples commentés :
#       * aucune fonction exécutable "runtime" ici,
#       * pas de logique d’exécution réelle.
#   - Syntaxe officielle Vitte :
#       * blocs terminés par ".end",
#       * aucune accolade dans le code.
# ============================================================================

# ============================================================================
# Identifiants de base pour le contrôle de flux
# ============================================================================

# Identifiant logique d’un bloc (scope) dans le compilateur.
type BlockId = u32

# Identifiant logique d’une structure conditionnelle when/else.
type WhenId = u32

# Identifiant logique d’une boucle loop/from/to/step.
type LoopId = u32

# Identifiant logique d’une branche (then / else when / else).
type BranchId = u32

# Identifiant d’une instruction dans le graphe de contrôle.
type InstrId = u32

# Identifiant d’un graphe de contrôle (par exemple par fonction/scénario).
type ControlFlowGraphId = u32

# ============================================================================
# Genre de bloc et d’instruction
# ============================================================================

# Genre de bloc de contrôle :
#   - Normal     : bloc standard (séquence d’instructions),
#   - LoopBody   : corps d’une boucle,
#   - WhenBranch : bloc associé à une branche when/else when/else.
enum BlockKind
    variant Normal
    variant LoopBody
    variant WhenBranch
.end

# Genre d’instruction logique pour le graphe de contrôle :
#   - Expr       : expression simple,
#   - Assign     : affectation,
#   - Branch     : point de branchement conditionnel,
#   - Loop       : début de boucle,
#   - Break      : sortie de boucle,
#   - Continue   : saut au tour suivant de la boucle,
#   - Return     : sortie de fonction ou scénario.
enum InstrKind
    variant Expr
    variant Assign
    variant Branch
    variant Loop
    variant Break
    variant Continue
    variant Return
.end

# ============================================================================
# Modèle logique des blocs
# ============================================================================

# Représentation logique d’un bloc de code.
struct Block
    # Identifiant logique de ce bloc.
    field id: BlockId

    # Genre de bloc.
    field kind: BlockKind

    # Span global du bloc dans la source (de l’en-tête à ".end").
    field span: spans.SpanId

    # Liste d’instructions dans ce bloc (ordre séquentiel).
    field instructions: coll.List<InstrId>
.end

# Table centrale des blocs pour un graphe donné.
struct BlockTable
    field blocks: coll.List<Block>
.end

# ============================================================================
# Modèle logique des structures when / else when / else
# ============================================================================

# Genre de branche dans un when :
#   - When      : branche principale "when cond",
#   - ElseWhen  : branche intermédiaire "else when cond",
#   - Else      : branche finale "else".
enum BranchKind
    variant When
    variant ElseWhen
    variant Else
.end

# Branche logique d’une structure when.
struct Branch
    field id: BranchId

    # Genre de la branche.
    field kind: BranchKind

    # Span de la condition (pour When/ElseWhen). Pour Else, ce span peut
    # pointer vers le mot-clé "else" seulement ou être nul selon le design.
    field condition_span: spans.SpanId

    # Type logique de la condition (booléen dans la plupart des cas).
    field condition_type: types.TypeId

    # Bloc exécuté si cette branche est sélectionnée.
    field block_id: BlockId

    # Span global de la branche (depuis "when"/"else" jusqu’au ".end"
    # éventuellement partagé avec les autres branches).
    field span: spans.SpanId
.end

# Structure conditionnelle complète when/else when/else.
struct When
    # Identifiant logique de cette structure when.
    field id: WhenId

    # Liste des branches (au moins une).
    field branches: coll.List<BranchId>

    # Span global du when (couvrant toutes les branches).
    field span: spans.SpanId
.end

# ============================================================================
# Modèle logique des boucles loop / from / to / step
# ============================================================================

# Genre de boucle :
#   - Range      : boucle bornée "loop i from a to b step s",
#   - Forever    : boucle infinie "loop" (forme générale),
#   - WhileExpr  : boucle conditionnelle dérivée (desugared) d’un when.
enum LoopKind
    variant Range
    variant Forever
    variant WhileExpr
.end

# Politique d’inclusion des bornes :
#   - Inclusive  : inclut la borne supérieure,
#   - Exclusive  : exclut la borne supérieure.
enum LoopBoundsKind
    variant Inclusive
    variant Exclusive
.end

# Boucle logique.
struct Loop
    # Identifiant logique de la boucle.
    field id: LoopId

    # Genre de boucle.
    field kind: LoopKind

    # Nom symbolique du compteur (pour les boucles Range).
    field counter_name: names.SymbolId

    # Type du compteur.
    field counter_type: types.TypeId

    # Span de la clause "from".
    field from_span: spans.SpanId

    # Span de la clause "to".
    field to_span: spans.SpanId

    # Span de la clause "step".
    field step_span: spans.SpanId

    # Type des expressions de bornes et de pas.
    field from_type: types.TypeId
    field to_type: types.TypeId
    field step_type: types.TypeId

    # Politique d’inclusion/exclusion des bornes.
    field bounds_kind: LoopBoundsKind

    # Bloc représentant le corps de la boucle.
    field body_block: BlockId

    # Span global de la boucle (de "loop" à ".end").
    field span: spans.SpanId
.end

# Table centrale des boucles pour un graphe donné.
struct LoopTable
    field loops: coll.List<Loop>
.end

# ============================================================================
# Modèle des instructions et du graphe de contrôle
# ============================================================================

# Représentation logique d’une instruction.
struct Instr
    # Identifiant de l’instruction.
    field id: InstrId

    # Genre de l’instruction.
    field kind: InstrKind

    # Span de l’instruction dans la source.
    field span: spans.SpanId

    # Bloc auquel appartient cette instruction.
    field parent_block: BlockId
.end

# Graphe de contrôle associé à une fonction ou un scénario.
struct ControlFlowGraph
    # Identifiant logique du graphe.
    field id: ControlFlowGraphId

    # Table des blocs.
    field blocks: BlockTable

    # Table des structures when.
    field whens: coll.List<When>

    # Table des boucles.
    field loops: LoopTable

    # Instructions linéaires (indexées par InstrId).
    field instructions: coll.List<Instr>
.end

# Vue agrégée pour les outils (LSP, debugger, analyse statique).
struct ControlFlowModelSnapshot
    field graphs: coll.List<ControlFlowGraph>
.end

# ============================================================================
# Exemples d’utilisation en "phrase syntaxe"
# ============================================================================
#
# Les exemples suivants ne sont pas exécutés par ce module, mais servent :
#   - de documentation,
#   - de tests de parsing,
#   - de base pour les outils.
#
# Exemple 1 – when / else when / else basique
# -------------------------------------------
#
#   fn demo_when x
#       when x < 0
#           say "negatif"
#       else when x == 0
#           say "zero"
#       else
#           say "positif"
#       .end
#   .end
#
# Exemple 2 – loop from/to/step avec bornes inclusives
# ----------------------------------------------------
#
#   fn demo_loop_range
#       loop i from 0 to 5 step 1
#           say i
#       .end
#   .end
#
# Exemple 3 – loop avec break / continue (forme désucrée)
# -------------------------------------------------------
#
#   fn demo_loop_control
#       loop i from 0 to 10 step 1
#           when i == 3
#               say "skip 3"
#               # continue
#           .end
#
#           when i == 7
#               say "stop at 7"
#               # break
#           .end
#
#           say i
#       .end
#   .end
#
# Exemple 4 – while exprimé comme sucre de loop + when
# ----------------------------------------------------
#
#   fn demo_while_sugar
#       # while count < 5:
#       #     say count
#       #     count = count + 1
#       #
#       # se desucre logiquement en :
#       #
#       loop
#           when count < 5
#               say count
#               set count = count + 1
#           else
#               # break
#           .end
#       .end
#   .end
#
# Exemple 5 – combiner when et loop dans la même fonction
# -------------------------------------------------------
#
#   fn demo_mixed x
#       when x < 0
#           say "negatif, on boucle de -3 a 0"
#           loop i from -3 to 0 step 1
#               say i
#           .end
#       else when x == 0
#           say "x est zero, aucune boucle"
#       else
#           say "positif, on boucle de 1 a x"
#           loop i from 1 to x step 1
#               say i
#           .end
#       .end
#   .end
#
# Ces exemples démontrent :
#   - l’usage de when/else when/else comme primitive principale de branchement,
#   - l’usage de loop/from/to/step pour les boucles bornées,
#   - la possibilité d’exprimer while/for comme sucre syntaxique basé sur loop,
#   - la façon dont le graphe de contrôle (ControlFlowGraph) peut modéliser
#     l’ensemble de ces constructions pour les outils.

.end