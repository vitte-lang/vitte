module vitte.examples.fib

import std.collections as coll
import vitte.compiler.spans as spans
import vitte.compiler.names as names
import vitte.compiler.types as types

# ============================================================================
# Vitte examples – Modèle et exemples autour de la suite de Fibonacci
#
# Objectifs de ce fichier :
#   - Proposer un modèle déclaratif pour représenter des calculs de Fibonacci
#     dans le compilateur et les outils :
#       * identifiants d’entrées et de résultats,
#       * description du type de la fonction fib,
#       * traces d’exécution (récursive, itérative, optimisée),
#       * métadonnées utiles pour debugger et visualiser les calculs.
#   - Fournir des exemples ultra complets en "phrase syntaxe" :
#       * Fibonacci récursif simple,
#       * Fibonacci itératif,
#       * Fibonacci récursif terminal / fast doubling (schéma),
#       * scénario de comparaison et de démonstration.
#
# Convention :
#   - Ce fichier est purement "data model" + exemples commentés :
#       * aucune fonction exécutable réelle,
#       * pas de logique d’exécution dans ce module.
#   - Syntaxe officielle Vitte :
#       * blocs terminés par ".end",
#       * aucune accolade dans le code ni dans les exemples.
# ============================================================================

# ============================================================================
# Identifiants et métadonnées
# ============================================================================

# Identifiant logique d’une requête de Fibonacci.
type FibRequestId = u32

# Identifiant logique d’un résultat de Fibonacci.
type FibResultId = u32

# Identifiant logique d’une trace de Fibonacci.
type FibTraceId = u32

# Identifiant logique d’une étape individuelle dans une trace.
type FibStepId = u32

# Identifiant logique d’un scénario de démonstration.
type FibScenarioId = u32

# ============================================================================
# Genre de calcul de Fibonacci
# ============================================================================

# Genre d’algorithme utilisé pour calculer fib(n) :
#   - Recursive       : définition récursive directe,
#   - Iterative       : boucle itérative,
#   - TailRecursive   : récursivité terminale,
#   - FastDoubling    : algorithme en temps logarithmique (schéma),
#   - Builtin         : implémentation intrinsèque ou bibliothèque.
enum FibAlgoKind
    variant Recursive
    variant Iterative
    variant TailRecursive
    variant FastDoubling
    variant Builtin
.end

# Statut d’un calcul de Fibonacci :
#   - Ok        : calcul réussi,
#   - Overflow  : dépassement de capacité,
#   - Invalid   : argument invalide (par exemple n negatif),
#   - Aborted   : calcul interrompu.
enum FibStatus
    variant Ok
    variant Overflow
    variant Invalid
    variant Aborted
.end

# ============================================================================
# Modèle du type fib dans le compilateur
# ============================================================================

# Description logique du type de la fonction fib pour un type entier donné
# (par exemple Int32, Int64, BigInt).
struct FibType
    # Type d’entrée (entier non signé ou signé selon la convention).
    field input_type: types.TypeId

    # Type de sortie (généralement le même que input_type, mais pas toujours
    # si fib est calculée dans un type plus grand).
    field output_type: types.TypeId

    # Indique si l’argument est supposé non negatif.
    field non_negative_only: bool

    # Span de la déclaration ou de la définition de la fonction fib
    # dans le code source.
    field span: spans.SpanId
.end

# ============================================================================
# Représentation des requêtes et résultats
# ============================================================================

# Requête logique de calcul de fib(n).
struct FibRequest
    # Identifiant logique de la requête.
    field id: FibRequestId

    # Type de la fonction fib utilisée.
    field fib_type: FibType

    # Valeur de n demandée.
    field n_value: i64

    # Span de l’expression source correspondant à l’appel.
    field span: spans.SpanId
.end

# Résultat logique d’un calcul de Fibonacci.
struct FibResult
    # Identifiant logique du résultat.
    field id: FibResultId

    # Requête associée.
    field request_id: FibRequestId

    # Type de calcul utilisé (récursif, itératif, etc.).
    field algo_kind: FibAlgoKind

    # Statut final du calcul (Ok, Overflow, etc.).
    field status: FibStatus

    # Span de l’expression qui consomme le résultat (si pertinent).
    field span: spans.SpanId
.end

# ============================================================================
# Traces d’exécution de Fibonacci
# ============================================================================

# Nature d’une étape de calcul :
#   - Call      : appel récursif fib(k),
#   - Return    : retour d’un appel récursif,
#   - Add       : addition intermédiaire (fib(k - 1) + fib(k - 2)),
#   - Init      : initialisation des variables pour la méthode itérative,
#   - Step      : pas itératif (mise à jour de a, b),
#   - Done      : fin du calcul.
enum FibStepKind
    variant Call
    variant Return
    variant Add
    variant Init
    variant Step
    variant Done
.end

# Étape individuelle dans une trace de Fibonacci.
struct FibStep
    # Identifiant logique de l’étape.
    field id: FibStepId

    # Type d’étape.
    field kind: FibStepKind

    # Valeur courante n (argument restant ou profondeur).
    field n_value: i64

    # Valeurs courantes a et b pour les méthodes itératives ou fast doubling,
    # où en général :
    #   a = fib(k)
    #   b = fib(k + 1)
    field a_value: i64
    field b_value: i64

    # Span de l’instruction ou de l’expression associée à cette étape.
    field span: spans.SpanId
.end

# Trace complète d’un calcul de Fibonacci.
struct FibTrace
    # Identifiant logique de la trace.
    field id: FibTraceId

    # Requête associée.
    field request_id: FibRequestId

    # Liste ordonnée des étapes.
    field steps: coll.List<FibStep>

    # Span global couvrant la fonction ou le bloc responsable du calcul.
    field span: spans.SpanId
.end

# ============================================================================
# Vue agrégée pour les outils
# ============================================================================

# Vue consolidée de tout ce qui concerne Fibonacci dans un module ou un crate.
struct FibModelSnapshot
    field requests: coll.List<FibRequest>
    field results: coll.List<FibResult>
    field traces: coll.List<FibTrace>
.end

# ============================================================================
# Exemples d’utilisation en "phrase syntaxe"
# ============================================================================
#
# Les exemples ci dessous ne sont pas exécutés par ce module, mais servent :
#   - de documentation,
#   - de tests de parsing,
#   - de base pour la démonstration dans les outils.
#
# Tous les blocs se terminent par ".end".
#
# --------------------------------------------------------------------------
# Exemple 1 : Fibonacci récursif simple
# --------------------------------------------------------------------------
#
#   fn fib_recursive n
#       when n < 0
#           say "erreur: n negatif"
#           ret 0
#       else when n == 0
#           ret 0
#       else when n == 1
#           ret 1
#       else
#           # fib(n) = fib(n - 1) + fib(n - 2)
#           ret fib_recursive n - 1 + fib_recursive n - 2
#       .end
#   .end
#
# --------------------------------------------------------------------------
# Exemple 2 : Fibonacci itératif
# --------------------------------------------------------------------------
#
#   fn fib_iterative n
#       when n < 0
#           say "erreur: n negatif"
#           ret 0
#       else when n == 0
#           ret 0
#       else when n == 1
#           ret 1
#       .end
#
#       set a = 0
#       set b = 1
#
#       # Invariant attendu : a = fib(i), b = fib(i + 1)
#       loop i from 1 to n - 1 step 1
#           set tmp = a + b
#           set a = b
#           set b = tmp
#       .end
#
#       ret b
#   .end
#
# --------------------------------------------------------------------------
# Exemple 3 : Fibonacci récursif terminal (schéma)
# --------------------------------------------------------------------------
#
#   fn fib_tail_inner n a b
#       # Invariant : a = fib(k), b = fib(k + 1) pour un certain k,
#       # avec n correspondant au "reste" de la distance à parcourir.
#       when n == 0
#           ret a
#       else
#           # Passage de (a, b) à (b, a + b).
#           ret fib_tail_inner n - 1 b a + b
#       .end
#   .end
#
#   fn fib_tail n
#       when n < 0
#           say "erreur: n negatif"
#           ret 0
#       else
#           # Appel initial : fib_tail_inner n 0 1
#           ret fib_tail_inner n 0 1
#       .end
#   .end
#
# --------------------------------------------------------------------------
# Exemple 4 : scenario de comparaison
# --------------------------------------------------------------------------
#
#   scn fib_demo
#       say "Fibonacci demo"
#       set n = 10
#
#       set r1 = fib_recursive n
#       set r2 = fib_iterative n
#       set r3 = fib_tail n
#
#       say "fib_recursive:"
#       say r1
#
#       say "fib_iterative:"
#       say r2
#
#       say "fib_tail:"
#       say r3
#   .end
#
# Ces exemples montrent :
#   - plusieurs styles d’implémentation de Fibonacci,
#   - l’usage de when pour les cas de base et erreurs,
#   - l’usage de loop pour une version itérative efficace,
#   - la récursivité terminale optimisable par le compilateur,
#   - l’utilisation d’un scenario pour orchestrer une démonstration,
#   - comment le modèle de données (FibType, FibRequest, FibResult, FibTrace)
#     peut servir de base à des outils de visualisation et de debugging.
#
.end
