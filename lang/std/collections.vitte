

module std.collections

# ============================================================================
# Vitte std – Modèle déclaratif des collections
#
# Objectifs de ce module :
#   - Fournir un modèle de données canonique pour les collections standard
#     du langage Vitte, utilisable par :
#       * le compilateur (annotations de types, inférence, lints),
#       * les outils (LSP, debugger, visualisation),
#       * la documentation et les spécifications.
#   - Définir un noyau minimal mais expressif :
#       * List<T> : séquence dynamique indexée,
#       * Slice<T> : vue immuable,
#       * SliceMut<T> : vue mutable,
#       * Deque<T> : séquence doublement terminée,
#       * Queue<T> : file FIFO logique,
#       * Stack<T> : pile LIFO logique,
#       * Map<K, V> : dictionnaire clé valeur,
#       * Set<T> : ensemble.
#   - Rester purement déclaratif :
#       * aucune fonction avec corps exécutable,
#       * aucun I O,
#       * aucune dépendance vers le compilateur.
#
# Ce module décrit la "forme" logique des collections, pas leur implémentation.
# Il peut être vu comme un contrat de haut niveau que les implémentations
# concrètes doivent respecter.
#
# Syntaxe officielle Vitte :
#   - blocs terminés par ".end",
#   - aucune accolade dans le code ni dans les commentaires.
# ============================================================================

# ============================================================================
# Types scalaires partagés
# ============================================================================

# Identifiant logique d une collection quelconque dans un modèle global.
type CollectionId = u32

# Taille logique d une collection.
type CollectionLen = u32

# Capacité logique d une collection.
type CollectionCap = u32

# Index logique dans une collection séquentielle.
type Index = u32

# Niveau de charge logique d une collection de type dictionnaire.
type LoadFactor = f32

# ============================================================================
# Genres et capacités de collections
# ============================================================================

# Genre général de collection. Utile pour la télémétrie, la doc ou certains
# diagnostics de compilation.
enum CollectionKind
    variant List
    variant Slice
    variant SliceMut
    variant Deque
    variant Queue
    variant Stack
    variant Map
    variant Set
.end

# Politique de croissance d une collection dynamique.
#
#   - Doubling : capacité approximativement multipliée par deux,
#   - Linear   : croissance par pas fixes,
#   - Custom   : autre politique spécifique.
enum GrowthPolicy
    variant Doubling
    variant Linear
    variant Custom
.end

# Politique de capacité maximale.
#
#   - Unbounded : pas de limite stricte au niveau logique,
#   - Bounded   : capacité max fixée logiquement,
#   - External  : contrôlée par un environnement externe.
enum CapacityLimitKind
    variant Unbounded
    variant Bounded
    variant External
.end

# Métadonnées de capacité partagées par plusieurs collections.
struct CapacityLimit
    # Genre de limite.
    field kind: CapacityLimitKind

    # Capacité maximale logique si kind = Bounded.
    field max_cap: CollectionCap
.end

# ============================================================================
# List<T> – séquence dynamique indexée
# ============================================================================

# Métadonnées d une List<T>.
struct ListMeta
    # Identifiant logique optionnel dans un modèle global.
    field id: CollectionId

    # Longueur logique (nombre d éléments initialisés).
    field len: CollectionLen

    # Capacité logique (taille de stockage réservée).
    field cap: CollectionCap

    # Politique de croissance.
    field growth: GrowthPolicy

    # Limite de capacité éventuelle.
    field limit: CapacityLimit
.end

# Séquence dynamique d éléments de type T.
#
# Remarque :
#   - Ce modèle ne décrit pas le stockage concret des éléments, uniquement
#     la forme logique de la collection vue par le type system et les outils.
struct List<T>
    # Métadonnées de la liste.
    field meta: ListMeta
.end

# ============================================================================
# Slice<T> et SliceMut<T> – vues sur séquences
# ============================================================================

# Vue immuable sur une séquence d éléments contigus de type T.
struct Slice<T>
    # Longueur de la vue.
    field len: CollectionLen

    # Index de départ logique dans la séquence d origine.
    field start: Index
.end

# Vue mutable sur une séquence d éléments contigus de type T.
struct SliceMut<T>
    # Longueur de la vue.
    field len: CollectionLen

    # Index de départ logique dans la séquence d origine.
    field start: Index
.end

# ============================================================================
# Deque<T> – séquence doublement terminée
# ============================================================================

# Métadonnées d une Deque<T>.
struct DequeMeta
    field id: CollectionId
    field len: CollectionLen
    field cap: CollectionCap

    # Index logique de la tête et de la queue dans le tampon circulaire.
    field head: Index
    field tail: Index

    field growth: GrowthPolicy
    field limit: CapacityLimit
.end

# Deque logique : séquence dynamique avec insertion et retrait en tête et queue.
struct Deque<T>
    field meta: DequeMeta
.end

# ============================================================================
# Queue<T> et Stack<T> – abstractions FIFO et LIFO
# ============================================================================

# Queue logique, généralement implémentée au dessus d une Deque<T> ou List<T>.
struct Queue<T>
    # Métadonnées partagées avec une structure séquentielle sous jacente.
    field meta: ListMeta
.end

# Stack logique, généralement implémentée au dessus d une List<T>.
struct Stack<T>
    # Métadonnées partagées avec une structure séquentielle sous jacente.
    field meta: ListMeta
.end

# ============================================================================
# Map<K, V> – dictionnaire clé valeur
# ============================================================================

# Genre de Map pour l outillage et la doc.
#
#   - Hash      : dictionnaire basé sur un hachage,
#   - Ordered   : dictionnaire ordonné par les clés,
#   - IndexMap  : dictionnaire indexable de manière dense.
enum MapKind
    variant Hash
    variant Ordered
    variant IndexMap
.end

# Métadonnées d une Map<K, V>.
struct MapMeta
    field id: CollectionId

    # Nombre de paires clé valeur stockées.
    field len: CollectionLen

    # Nombre de cases logiques dans la table.
    field buckets: CollectionCap

    # Facteur de charge logique.
    field load_factor: LoadFactor

    # Genre de map.
    field kind: MapKind
.end

# Dictionnaire clé valeur logique.
struct Map<K, V>
    field meta: MapMeta
.end

# ============================================================================
# Set<T> – ensemble d éléments
# ============================================================================

# Genre de Set pour l outillage et la doc.
#
#   - HashSet   : ensemble basé sur une table de hachage,
#   - OrderedSet: ensemble ordonné,
#   - BitSet    : ensemble représenté comme masque de bits.
enum SetKind
    variant HashSet
    variant OrderedSet
    variant BitSet
.end

# Métadonnées d un Set<T>.
struct SetMeta
    field id: CollectionId

    # Nombre d éléments dans l ensemble.
    field len: CollectionLen

    # Nombre de cases logiques dans la structure sous jacente.
    field buckets: CollectionCap

    # Facteur de charge logique.
    field load_factor: LoadFactor

    # Genre d ensemble.
    field kind: SetKind
.end

# Ensemble logique d éléments de type T.
struct Set<T>
    field meta: SetMeta
.end

# ============================================================================
# Collections composées
# ============================================================================

# Paire clé valeur simple. Utile comme type de retour ou dans certains
# algorithmes d itération.
struct KeyValue<K, V>
    field key: K
    field value: V
.end

# Liste de paires clé valeur, souvent utilisée comme représentation
# intermédiaire ou format de sérialisation.
struct AssocList<K, V>
    field entries: List<KeyValue<K, V>>
.end

# ============================================================================
# Vues de haut niveau pour les outils
# ============================================================================

# Snapshot logique d une collection séquentielle, pour debugger et doc.
struct SeqCollectionSnapshot<T>
    # Genre concret de la collection (List, Deque, Queue, Stack).
    field kind: CollectionKind

    # Nombre d éléments.
    field len: CollectionLen

    # Métadonnées brutes (pour diagnostic, capacity, etc.).
    field meta: ListMeta

    # Remarque : les éléments eux mêmes ne sont pas stockés ici, ils sont
    # visualisés par les outils en inspectant la mémoire ou des couches
    # supplémentaires spécifiques au runtime.
.end

# Snapshot logique d une collection de type dictionnaire.
struct MapCollectionSnapshot<K, V>
    field kind: CollectionKind
    field len: CollectionLen
    field meta: MapMeta

    # Modèle de vue conceptuelle sur des paires clé valeur.
    field logical_entries: AssocList<K, V>
.end

# Snapshot logique d une collection de type ensemble.
struct SetCollectionSnapshot<T>
    field kind: CollectionKind
    field len: CollectionLen
    field meta: SetMeta
.end

# ============================================================================
# Vue agrégée pour une bibliothèque ou un module
# ============================================================================

# Agrégation de plusieurs snapshots de collections, telle qu elle peut
# être renvoyée par un debugger ou un outil de profilage.
struct CollectionsSnapshot
    field lists: List<SeqCollectionSnapshot<u8>>
    field maps: List<MapCollectionSnapshot<u8, u8>>
    field sets: List<SetCollectionSnapshot<u8>>
.end

.end