module vitte.core.macros

import std.collections as coll
import vitte.compiler.ast as ast
import vitte.compiler.diagnostics as diag
import vitte.compiler.spans as spans
import vitte.compiler.names as names

# ============================================================================
# Vitte core – Modèle logique du système de macros
#
# Objectifs :
#   - Décrire, au niveau purement déclaratif, toutes les données nécessaires
#     au système de macros de Vitte :
#       * identifiants et noms de macros,
#       * espaces de noms / genres de macros,
#       * représentation des flux de tokens et des arbres de tokens,
#       * patterns et templates pour les macros déclaratives,
#       * appels, expansions et liens avec l'AST,
#       * registre de macros disponible pour le compilateur et les outils.
#   - Servir de contrat stable entre :
#       * le front-end du compilateur (expansion de macros),
#       * les outils (LSP, REPL, runner, debugger),
#       * d’éventuels backends externes (proc-macros natifs).
#   - Ne contenir que des structures de données :
#       * aucune fonction,
#       * aucun accès I/O,
#       * aucun comportement impératif ou algorithme d’expansion.
#
# Convention générale :
#   - Ce module reste strictement "modèle de données" :
#       * les invariants sont documentés dans les commentaires,
#         mais vérifiés ailleurs (type-checker, passes d’analyse).
#   - Les types "externes" viennent d’autres modules :
#       * names.SymbolId pour les noms logiques,
#       * spans.SpanId pour les positions dans les fichiers source,
#       * ast.NodeId / ast.ItemId / ast.ExprId pour l’AST.
#   - Aucun bloc ne se termine par un simple "end" :
#       * la syntaxe Vitte officielle utilise ".end" pour marquer la fin.
# ============================================================================

# ============================================================================
# Identifiants et noms de macros
# ============================================================================

# Identifiant logique d’une définition de macro (clé dans le registre).
type MacroDefId = u32

# Identifiant d’un appel de macro dans le code source.
type MacroCallId = u32

# Identifiant logique d’une expansion (résultat d’un appel).
type MacroExpansionId = u32

# Noms et chemins de macros :
# - MacroName stocke le symbole nu (sans module),
# - MacroPath représente le chemin qualifié (module + nom).
struct MacroName
    field symbol: names.SymbolId
    # Invariant :
    #   - symbol référence toujours un identifiant de symbole textuel valide.
.end

struct MacroPath
    field module_path: names.ModulePathId
    field name: MacroName
    # Exemple conceptuel :
    #   module_path -> "core.macros.test"
    #   name        -> "my_macro"
.end

# Espace de noms d’une macro :
# - item : macros de type "macro règles" invoquées comme items,
# - expr : macros d’expression,
# - pattern : macros de pattern,
# - attribute : macros utilisées comme attributs,
# - derive : macros "derive" associées à des types.
enum MacroNamespace
    variant Item
    variant Expr
    variant Pattern
    variant Attribute
    variant Derive
.end

# Genre global de la macro (déclarative ou procédurale).
enum MacroKind
    # Macros déclaratives de type "macro règles" (style macro_rules).
    variant Declarative

    # Macros déclaratives internes au compilateur (primitives).
    variant BuiltinDeclarative

    # Macros procédurales : derive.
    variant ProceduralDerive

    # Macros procédurales : attributs.
    variant ProceduralAttribute

    # Macros procédurales : fonction classiques (function-like).
    variant ProceduralFunctionLike
.end

# Origine d’une macro (d’où provient sa définition).
enum MacroOrigin
    # Définitions dans le crate courant.
    variant Local

    # Macro importée d’un autre crate.
    variant External

    # Macro fournie par le compilateur ou la distribution standard.
    variant Builtin
.end

# Visibilité logique d’une macro.
enum MacroVisibility
    # Visible uniquement dans le module courant.
    variant Module

    # Visible dans tout le crate.
    variant Crate

    # Visible selon les règles d’export du module.
    variant Public
.end

# ============================================================================
# Représentation des flux de tokens (token stream)
# ============================================================================

# Indice d’un token dans un stockage linéaire partagé.
type MacroTokenIndex = u32

# Compteur de tokens dans un flux.
type MacroTokenCount = u32

# Identifiant logique d’un flux de tokens (Vue logique).
type MacroTokenStreamId = u32

# Type de délimiteur d’un groupe de tokens.
# Il y a typiquement :
#   - Parenthesis : groupement sous forme de parenthèses,
#   - Bracket     : groupement sous forme de crochets,
#   - Brace       : groupement sous forme d’accolades,
#   - None        : pas de délimiteur explicite.
enum MacroDelimiterKind
    variant None
    variant Parenthesis
    variant Bracket
    variant Brace
.end

# Genre de token pour les macros.
enum MacroTokenKind
    # Identificateur simple.
    variant Ident

    # Nom de vie (lifetime), généralement préfixé par un apostrophe.
    variant Lifetime

    # Littéral (numérique, chaîne, caractère, booléen, etc.).
    variant Literal

    # Punctuation / opérateurs ponctuels.
    variant Punct

    # Mot-clé (if, else, type, mod, etc.).
    variant Keyword

    # Début d’un groupe délimité (par parenthèses, crochets ou accolades).
    variant GroupOpen

    # Fin d’un groupe délimité.
    variant GroupClose
.end

# Token élémentaire vu par le système de macros.
struct MacroToken
    field kind: MacroTokenKind

    # Contenu textuel associé (ident, littéral, opérateur, etc.).
    field symbol: names.SymbolId

    # Span de ce token dans le fichier source.
    field span: spans.SpanId

    # Si vrai, ce token est joint au suivant (pour les opérateurs composés).
    field joint: bool

    # Délimiteur logique si ce token est un groupement.
    field delimiter: MacroDelimiterKind
.end

# Flux de tokens pour une macro :
# - les tokens sont stockés dans un tableau global,
# - MacroTokenStream pointe sur une tranche de ce tableau.
struct MacroTokenStream
    field id: MacroTokenStreamId
    field first: MacroTokenIndex
    field len: MacroTokenCount

    # Invariants attendus :
    #   - len peut être zéro (flux vide),
    #   - first + len ne dépasse jamais la taille du buffer global.
.end

# ============================================================================
# Arbres de tokens (token trees) pour macros
# ============================================================================

# Identifiant d’un nœud d’arbre de tokens.
type MacroTokenTreeId = u32

# Tranche de nœuds d’arbre de tokens dans un stockage linéaire.
struct MacroTokenTreeRange
    field first: MacroTokenTreeId
    field len: u32
.end

# Genre de nœud dans l’arbre de tokens :
# - Leaf     : feuille (token individuel),
# - Group    : groupement de tokens,
# - Sequence : séquence linéaire.
enum MacroTokenTreeKind
    variant Leaf
    variant Group
    variant Sequence
.end

# Nœud élémentaire de l’arbre de tokens.
struct MacroTokenTreeNode
    field id: MacroTokenTreeId
    field kind: MacroTokenTreeKind

    # Si kind = Leaf, ce champ référence un token dans le flux.
    field token_index: MacroTokenIndex

    # Si kind = Group ou Sequence, ce champ référence les enfants du nœud.
    field children: MacroTokenTreeRange

    # Span global englobant ce nœud.
    field span: spans.SpanId

    # Délimiteur éventuel (pour un groupement).
    field delimiter: MacroDelimiterKind
.end

# Arbre complet issu d’un flux de tokens.
struct MacroTokenTree
    field root: MacroTokenTreeId
    field nodes: MacroTokenTreeRange

    # Invariants :
    #   - root doit appartenir à la plage nodes,
    #   - nodes.len peut valoir zéro pour représenter un arbre vide.
.end

# ============================================================================
# Macros déclaratives – patterns et templates
# ============================================================================

# Identifiant d’un pattern de macro déclarative.
type MacroPatternId = u32

# Identifiant d’un nœud de pattern.
type MacroPatternNodeId = u32

# Tranche de nœuds de pattern.
struct MacroPatternNodeRange
    field first: MacroPatternNodeId
    field len: u32
.end

# Identifiant d’un template de macro déclarative.
type MacroTemplateId = u32

# Tranche de nœuds de template (structure similaire à l’arbre de tokens).
struct MacroTemplateNodeRange
    field first: MacroTokenTreeId
    field len: u32
.end

# Identifiant d’un bras (arm) d’une macro déclarative.
type MacroArmId = u32

# Type de répétition pour les séquences dans les patterns :
#   ZeroOrMore  : "rep*"
#   OneOrMore   : "rep+"
#   ZeroOrOne   : "rep?"
enum MacroRepetitionKind
    variant ZeroOrMore
    variant OneOrMore
    variant ZeroOrOne
.end

# Séparateur logique entre répétitions :
#   None      : pas de séparateur explicite,
#   Comma     : séparateur virgule,
#   Semicolon : séparateur point-virgule,
#   Other     : autre séparateur symbolique.
enum MacroRepetitionSeparator
    variant None
    variant Comma
    variant Semicolon
    variant Other
.end

# Métadonnées associées aux nœuds de répétition.
struct MacroRepetition
    field kind: MacroRepetitionKind
    field separator: MacroRepetitionSeparator

    # Invariants :
    #   - separator vaut None pour ZeroOrOne,
    #   - les autres combinaisons sont valides mais doivent être interprétées
    #     avec prudence par l’algorithme d’expansion.
.end

# Genre de nœud de pattern :
#   Literal      : token littéral à matcher,
#   MetaVariable : variable de pattern (capture),
#   Sequence     : séquence ordonnée de sous-nœuds,
#   Group        : groupement de pattern,
#   Repetition   : sous-pattern répété (rep*, rep+, rep?).
enum MacroPatternNodeKind
    variant Literal
    variant MetaVariable
    variant Sequence
    variant Group
    variant Repetition
.end

# Nœud d’un pattern de macro déclarative.
struct MacroPatternNode
    field id: MacroPatternNodeId
    field kind: MacroPatternNodeKind

    # Span de ce nœud dans le fichier source (pattern original).
    field span: spans.SpanId

    # Utilisé pour :
    #   - Literal      : token à matcher (genre + symbole),
    #   - MetaVariable : nom capturé,
    #   - les autres   : optionnel selon le genre.
    field token_kind: MacroTokenKind
    field token_symbol: names.SymbolId

    # Enfants pour Sequence ou Group.
    field children: MacroPatternNodeRange

    # Informations de répétition (utilisé si kind = Repetition).
    field repetition: MacroRepetition
.end

# Pattern complet d’une macro déclarative.
struct MacroPattern
    field id: MacroPatternId
    field root: MacroPatternNodeId
    field nodes: MacroPatternNodeRange

    # Flux de tokens source correspondant au pattern.
    field source_stream: MacroTokenStreamId
.end

# Template d’expansion d’une macro déclarative.
struct MacroTemplate
    field id: MacroTemplateId
    field root_tree: MacroTokenTree
    field source_stream: MacroTokenStreamId

    # Invariant :
    #   - root_tree.nodes représente la structure du template de sortie,
    #     avant substitution des captures.
.end

# Bras d’une macro déclarative :
#   - pattern : structure à matcher,
#   - template : structure de sortie.
struct MacroArm
    field id: MacroArmId
    field pattern: MacroPatternId
    field template: MacroTemplateId
    field span: spans.SpanId
.end

# Ensemble complet de bras pour une macro déclarative.
struct MacroRuleSet
    field arms: coll.List<MacroArm>

    # Invariant :
    #   - arms.len doit être strictement positif pour une macro déclarative
    #     valide, sinon la macro est "vide".
.end

# Corps logique d’une macro, dépendant de son genre.
enum MacroBodyKind
    # Macros déclaratives : une liste de bras (pattern + template).
    variant Declarative

    # Macros procédurales : point d’entrée vers une implémentation opaque.
    variant Procedural
.end

# Contenu d’une macro déclarative.
struct DeclarativeMacroBody
    field rule_set: MacroRuleSet

    # Flux de tokens d’origine (définition entière de la macro).
    field source_stream: MacroTokenStreamId
.end

# Contenu d’une macro procédurale.
#
# Remarque :
#   - L’implémentation concrète (code natif, plugin externe) n’apparaît pas
#     ici. Elle est gérée par un autre sous-système (loader de proc-macros).
struct ProceduralMacroBody
    field impl_id: u64
    field abi_name: names.SymbolId
    field span: spans.SpanId
.end

# Corps unifié d’une macro, pointeur vers la bonne structure.
struct MacroBody
    field kind: MacroBodyKind
    field declarative: DeclarativeMacroBody
    field procedural: ProceduralMacroBody
.end

# ============================================================================
# Définitions de macros et registre global
# ============================================================================

# Définition complète d’une macro, telle que vue par le compilateur.
struct MacroDef
    field id: MacroDefId
    field name: MacroName
    field path: MacroPath
    field namespace: MacroNamespace
    field kind: MacroKind
    field origin: MacroOrigin
    field visibility: MacroVisibility

    # Corps logique (déclaratif ou procédural).
    field body: MacroBody

    # Span de la déclaration principale.
    field span: spans.SpanId

    # Lien optionnel vers un nœud AST représentant cette macro dans le module.
    field ast_node: ast.NodeId
.end

# Entrée dans le registre global des macros.
struct MacroRegistryEntry
    field def_id: MacroDefId
    field module_path: names.ModulePathId
    field name: MacroName
    field namespace: MacroNamespace
    field origin: MacroOrigin
.end

# Registre global de macros :
#   - accessible à tout le compilateur,
#   - éventuellement sérialisable pour les outils.
struct MacroRegistry
    # Collection principale de définitions de macros.
    field defs: coll.List<MacroDef>

    # Index rapide par nom qualifié (module + nom).
    field entries: coll.List<MacroRegistryEntry>
.end

# ============================================================================
# Appels de macros et expansions
# ============================================================================

# Statut d’une expansion de macro.
enum MacroExpansionStatus
    # Expansion réussie, avec un flux de tokens résultant.
    variant Ok

    # Expansion ayant échoué avec une erreur récupérable.
    variant Error

    # Expansion ignorée (macro désactivée, configuration conditionnelle).
    variant Skipped
.end

# Métadonnées associées à un appel de macro dans le code source.
struct MacroCall
    field id: MacroCallId

    # Macro appelée.
    field macro_id: MacroDefId

    # Nœud AST qui porte l’appel (item, expression, attribut, etc.).
    field ast_node: ast.NodeId

    # Flux de tokens passé à la macro.
    field input_stream: MacroTokenStreamId

    # Span global englobant la syntaxe d’appel.
    field span: spans.SpanId
.end

# Résultat logique d’une expansion de macro.
struct MacroExpansion
    field id: MacroExpansionId
    field call_id: MacroCallId
    field macro_id: MacroDefId

    # Statut de l’expansion.
    field status: MacroExpansionStatus

    # Flux de tokens résultant (si status = Ok).
    field output_stream: MacroTokenStreamId

    # Nœud AST racine produit par l’expansion, si déjà analysé.
    field ast_root: ast.NodeId

    # Liste d’éventuels diagnostics produits lors de l’expansion.
    field diagnostics: coll.List<diag.DiagnosticId>
.end

# Journal global de toutes les expansions de macros effectuées
# dans une compilation.
struct MacroExpansionLog
    field expansions: coll.List<MacroExpansion>
.end

.end