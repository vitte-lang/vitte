

module vitte.core.result

import std.collections as coll
import vitte.compiler.types as types
import vitte.compiler.spans as spans
import vitte.compiler.names as names
import vitte.compiler.diagnostics as diag

# ============================================================================
# Vitte core – Modèle logique des résultats (Result)
#
# Objectifs :
#   - Décrire, au niveau purement déclaratif, la sémantique des résultats
#     typés dans Vitte :
#       * type générique de surface Result<T, E>,
#       * représentation logique des types Result dans le compilateur,
#       * représentation logique des valeurs Result,
#       * patterns et correspondance exhaustive (match sur Result),
#       * graphe d’opérations Result (map, map_err, and_then, or_else, etc.),
#       * liens possibles entre Err et le système de diagnostics.
#   - Servir de contrat entre :
#       * le cœur du type-checker (types.Result),
#       * les passes d’analyse de pattern-matching et de propagation d’erreurs,
#       * les outils (LSP, REPL, debugger, visualisation de chaînes Result),
#       * les couches d’intégration diagnostics.
#   - Rester strictement "data model" :
#       * aucune fonction,
#       * aucune I/O,
#       * aucun comportement d’exécution.
#
# Remarques :
#   - La définition de surface Result<T, E> ci-dessous représente l’API de base
#     visible dans le langage, mais ce module décrit aussi les structures
#     internes utilisées par le compilateur pour raisonner sur ces types.
#   - Les invariants logiques sont documentés dans les commentaires et doivent
#     être garantis par les autres composants (parser, type-checker, passes).
#   - Syntaxe officielle Vitte :
#       * blocs terminés par ".end",
#       * aucune accolade.
# ============================================================================

# ============================================================================
# Type générique de surface : Result<T, E>
# ============================================================================
#
# Cette enum est le modèle conceptuel utilisé dans le langage Vitte. Elle est
# volontairement simple et correspond à ce que voient les programmes Vitte :
#
#   enum Result<T, E>
#       variant Ok(value: T)
#       variant Err(error: E)
#   .end
#
# Les structures suivantes (ResultType, ResultValue, etc.) servent surtout à
# représenter ce concept dans le compilateur et les outils.

enum Result<T, E>
    # Cas où l’opération a réussi avec une valeur de type T.
    variant Ok(value: T)

    # Cas où l’opération a échoué avec une valeur d’erreur de type E.
    variant Err(error: E)
.end

# ============================================================================
# Identifiants et métadonnées Result
# ============================================================================

# Identifiant logique d’un type Result dans le compilateur.
type ResultTypeId = u32

# Identifiant logique d’une valeur Result suivie par le runtime ou le debugger.
type ResultValueId = u32

# Identifiant pour les patterns dédiés à Result dans les analyses de match.
type ResultPatternId = u32

# Identifiant pour les opérations Result dans un graphe d’opérations.
type ResultOpId = u32

# Identifiant pour le modèle de liaison entre Err et les diagnostics.
type ResultErrorModelId = u32

# Genre structurel d’un type Result dans le compilateur.
#
# Ce genre précise la "forme" du Result :
#   - Plain            : Result<T, E>
#   - Reference        : Result<&T, E>
#   - MutableReference : Result<&mut T, E>
#   - ThinError        : représentations compactes des erreurs
#                        (par exemple pour des codes d’erreur numériques).
enum ResultKind
    variant Plain
    variant Reference
    variant MutableReference
    variant ThinError
.end

# ============================================================================
# Représentation des types Result dans le compilateur
# ============================================================================

# Description logique d’un type Result<T, E> dans le graphe de types interne.
struct ResultType
    # Identifiant logique local de ce type Result.
    field id: ResultTypeId

    # Type de succès T.
    field ok_type: types.TypeId

    # Type d’erreur E.
    field err_type: types.TypeId

    # Genre structurel (plain, référence, représentation optimisée, etc.).
    field kind: ResultKind

    # Indique si ce Result est considéré "error-like" pour la propagation
    # automatique d’erreur dans certains contextes de langage.
    field is_error_like: bool

    # Indique si les erreurs de ce Result sont destinées à être reliées au
    # système de diagnostics du compilateur.
    field links_to_diagnostics: bool

    # Span de la définition (par exemple type alias, déclaration Result locale).
    field span: spans.SpanId
.end

# Table centrale de tous les types Result connus du compilateur.
struct ResultTypeTable
    # Liste de toutes les descriptions ResultType.
    field types: coll.List<ResultType>
.end

# ============================================================================
# Liaisons entre Result et diagnostics
# ============================================================================

# Modèle logique reliant un type Result particulier à des diagnostics.
#
# Le but est de permettre aux outils et à certaines passes d’identifier
# facilement quels Result erronés sont associés à quels diagnostics.
struct ResultErrorModel
    field id: ResultErrorModelId

    # Type Result concerné.
    field result_type: ResultTypeId

    # Type d’erreur associé (généralement le même que err_type mais exposé
    # explicitement pour faciliter les traitements).
    field error_type: types.TypeId

    # Diagnostic par défaut associé à ce type d’erreur lorsque une propagation
    # par défaut est déclenchée.
    field default_diagnostic: diag.DiagnosticId

    # Nom symbolique du genre d’erreur (par exemple "io_error", "parse_error").
    field error_kind_name: names.SymbolId

    # Span de la définition de liaison dans la source.
    field span: spans.SpanId
.end

# Table de tous les modèles de liaison Result vers diagnostics.
struct ResultErrorModelTable
    field models: coll.List<ResultErrorModel>
.end

# ============================================================================
# Représentation des valeurs Result (niveau logique)
# ============================================================================

# État logique d’une valeur Result.
#
# Ce modèle est volontairement simple :
#   - Ok  : la valeur de succès est présente,
#   - Err : la valeur d’erreur est présente.
enum ResultState
    variant Ok
    variant Err
.end

# Valeur Result suivie par le compilateur ou le debugger.
#
# Ce modèle ne stocke pas directement les valeurs de type T ou E, mais se
# contente de référencer le type, un identifiant conceptuel de valeur et les
# métadonnées utiles aux outils (span, état).
struct ResultValue
    # Identifiant logique de cette valeur Result.
    field id: ResultValueId

    # Type Result associé.
    field type_id: ResultTypeId

    # État actuel (Ok ou Err).
    field state: ResultState

    # Span de l’expression source qui a produit ce Result.
    field span: spans.SpanId
.end

# Ensemble de valeurs Result suivies dans une compilation ou un run de debugger.
struct ResultValueTable
    field values: coll.List<ResultValue>
.end

# ============================================================================
# Patterns dédiés à Result et match exhaustif
# ============================================================================

# Genre de pattern dédié à Result :
#   - Wildcard    : "_"
#   - OkBinding   : "Ok(x)" ou "Ok(_)"
#   - ErrBinding  : "Err(e)" ou "Err(_)"
enum ResultPatternKind
    variant Wildcard
    variant OkBinding
    variant ErrBinding
.end

# Pattern logique dédié à Result dans les analyses de match.
struct ResultPattern
    field id: ResultPatternId
    field kind: ResultPatternKind

    # Nom éventuellement capturé dans le cas OkBinding ou ErrBinding.
    # S’il n’y a pas de nom (par exemple "Ok(_)" ou "Err(_)"), ce symbole peut
    # être un symbole réservé anonyme ou un identifiant nul.
    field binding_name: names.SymbolId

    # Span du pattern dans la source.
    field span: spans.SpanId
.end

# Spécification d’un match exhaustif sur un type Result particulier.
#
# Ce modèle sert aux passes d’analyse pour raisonner sur la couverture, par
# exemple pour détecter :
#   - des branches manquantes (manque "Err" ou "Ok"),
#   - des branches inaccessibles (pattern jamais atteint),
#   - des branches redondantes.
struct ResultMatchSpec
    # Type Result concerné.
    field result_type: ResultTypeId

    # Liste des patterns utilisés dans ce bloc de match.
    field patterns: coll.List<ResultPatternId>

    # Span du match complet dans la source.
    field span: spans.SpanId
.end

# Résultat logique de l’analyse d’exhaustivité pour un match sur Result.
enum ResultMatchExhaustiveness
    # Toutes les branches nécessaires sont présentes (Ok, Err, wildcard).
    variant Exhaustive

    # Il manque au moins une case (par exemple Err manquant).
    variant NonExhaustive

    # Il existe des branches inaccessibles ou redondantes.
    variant RedundantBranches
.end

# Résultat détaillé de l’analyse d’un match.
struct ResultMatchAnalysis
    field spec: ResultMatchSpec
    field result: ResultMatchExhaustiveness

    # Patterns identifiés comme redondants ou inaccessibles.
    field redundant_patterns: coll.List<ResultPatternId>

    # Patterns manquants (par exemple manque une branche Err).
    field missing_patterns: coll.List<ResultPatternId>
.end

# ============================================================================
# Graphe logique des opérations Result
# ============================================================================

# Genre d’opération logique appliquée à une valeur Result.
#
# Ce modèle ne décrit pas l’implémentation, mais la "forme" des chaînes
# d’opérations pour l’outillage (LSP, debugger, visualisation, optimisation).
enum ResultOpKind
    # Vérifie si la valeur est Ok.
    variant IsOk

    # Vérifie si la valeur est Err.
    variant IsErr

    # Transforme la valeur de succès via une fonction (Ok(v) devient Ok(f(v))).
    variant Map

    # Transforme la valeur d’erreur via une fonction (Err(e) devient Err(g(e))).
    variant MapErr

    # Chaîne de manière monadique sur le succès (Ok(v) devient f(v) qui
    # retourne Result<U, E>).
    variant AndThen

    # Fournit un autre Result si la valeur est Err.
    variant OrElse

    # Convertit Result<T, E> vers Option<T> en jetant l’erreur.
    variant IntoOption

    # Récupère la valeur de succès en supposant qu’elle est présente.
    variant Unwrap

    # Récupère la valeur de succès avec un message explicite en cas d’erreur.
    variant Expect

    # Récupère la valeur de succès ou fournit une valeur de repli.
    variant UnwrapOr

    # Récupère la valeur de succès ou appelle une fonction de repli.
    variant UnwrapOrElse
.end

# Nœud d’opération Result dans un graphe logique.
struct ResultOp
    field id: ResultOpId
    field kind: ResultOpKind

    # Valeur Result en entrée de l’opération.
    field input: ResultValueId

    # Valeur Result en sortie de l’opération.
    # Selon l’opération, il peut s’agir :
    #   - du même Result (pour IsOk, IsErr, IntoOption utilisé comme méta),
    #   - d’un nouveau Result (pour Map, MapErr, AndThen, OrElse),
    #   - d’un Result consommé conceptuellement pour Unwrap, Expect, etc.
    field output: ResultValueId

    # Span de l’expression source correspondant à cette opération.
    field span: spans.SpanId
.end

# Graphe d’opérations Result associé à une expression ou un bloc.
struct ResultOpGraph
    # Toutes les opérations Result connues pour l’expression ou le bloc.
    field ops: coll.List<ResultOp]
.end

# ============================================================================
# Vue agrégée pour les outils (LSP, debugger, etc.)
# ============================================================================

# Vue consolidée de tout ce qui concerne Result au niveau d’un crate ou d’un
# module, afin de faciliter la sérialisation et l’inspection par les outils.
struct ResultModelSnapshot
    field type_table: ResultTypeTable
    field value_table: ResultValueTable
    field op_graph: ResultOpGraph
    field error_models: ResultErrorModelTable

    # Analyses de match associées à ce module ou crate.
    field match_analyses: coll.List<ResultMatchAnalysis>
.end

.end