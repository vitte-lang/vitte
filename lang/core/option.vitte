

module vitte.core.option

import std.collections as coll
import vitte.compiler.types as types
import vitte.compiler.spans as spans
import vitte.compiler.names as names

# ============================================================================
# Vitte core – Modèle logique des valeurs optionnelles (Option)
#
# Objectifs :
#   - Décrire, au niveau purement déclaratif, la sémantique des valeurs
#     optionnelles dans Vitte :
#       * type générique de surface Option<T>,
#       * représentation logique des types Option dans le compilateur,
#       * représentation logique des valeurs Option,
#       * patterns et correspondance exhaustive (match sur Option),
#       * opérations "classiques" sur Option (map, and_then, etc.) modélisées
#         comme des nœuds de graphe d’opérations.
#   - Servir de contrat entre :
#       * le cœur du type-checker (types.Option),
#       * les passes d’analyse de pattern-matching,
#       * les outils (LSP, REPL, debugger, visualisation des chaînes Option).
#   - Rester strictement "data model" :
#       * aucune fonction,
#       * aucune I/O,
#       * aucun comportement d’exécution.
#
# Remarques :
#   - La définition de surface Option<T> ci-dessous représente l’API de base
#     visible dans le langage, mais ce module décrit aussi les structures
#     internes utilisées par le compilateur pour raisonner sur ces types.
#   - Les invariants logiques sont documentés dans les commentaires et doivent
#     être garantis par les autres composants (parser, type-checker, passes).
#   - Syntaxe officielle Vitte :
#       * blocs terminés par ".end",
#       * aucune accolade.
# ============================================================================

# ============================================================================
# Type générique de surface : Option<T>
# ============================================================================
#
# Cette enum est le modèle conceptuel utilisé dans le langage Vitte. Elle est
# volontairement simple et correspond à ce que voient les programmes Vitte :
#
#   enum Option<T>
#       variant None
#       variant Some(value: T)
#   .end
#
# Les structures suivantes (OptionType, OptionValue, etc.) servent surtout à
# représenter ce concept dans le compilateur et les outils.

enum Option<T>
    # Cas où aucune valeur n’est présente.
    variant None

    # Cas où une valeur de type T est présente.
    variant Some(value: T)
.end

# ============================================================================
# Identifiants et métadonnées Option
# ============================================================================

# Identifiant logique d’un type Option dans le compilateur.
type OptionTypeId = u32

# Identifiant logique d’une valeur Option suivie par le runtime / debugger.
type OptionValueId = u32

# Identifiant pour les patterns dédiés à Option dans les analyses de match.
type OptionPatternId = u32

# Identifiant pour les opérations Option (map, and_then, etc.) dans un graphe.
type OptionOpId = u32

# Genre structurel d’un type Option dans le compilateur.
#
# Ce genre précise la "forme" de l’Option :
#   - Plain            : Option<T>
#   - Reference        : Option<&T>
#   - MutableReference : Option<&mut T>
#   - ThinNullable     : optimisation "nullable" possible (par ex. pointeur nul)
#                        pour certains types internes.
enum OptionKind
    variant Plain
    variant Reference
    variant MutableReference
    variant ThinNullable
.end

# ============================================================================
# Représentation des types Option dans le compilateur
# ============================================================================

# Description logique d’un type Option<T> dans le graphe de types interne.
struct OptionType
    # Identifiant logique local de ce type Option.
    field id: OptionTypeId

    # Type sous-jacent T.
    field inner_type: types.TypeId

    # Genre structurel (plain, référence, nullable optimisé, etc.).
    field kind: OptionKind

    # Si vrai, la représentation en mémoire peut être compactée en un seul mot
    # (par ex. "null pointer optimisation").
    field is_null_optimized: bool

    # Si vrai, ce type Option est considéré "nullable" au niveau des
    # annotations (interop avec FFI, bases de données, etc.).
    field is_nullable_annotated: bool

    # Span de la définition (par ex. type alias, déclaration Option locale).
    field span: spans.SpanId
.end

# Table centrale de tous les types Option connus du compilateur.
struct OptionTypeTable
    # Liste de toutes les descriptions OptionType.
    field types: coll.List<OptionType>
.end

# ============================================================================
# Représentation des valeurs Option (niveau logique)
# ============================================================================

# Présence logique d’une valeur dans une Option.
enum OptionPresence
    variant None
    variant Some
.end

# Valeur Option suivie par le compilateur / debugger.
#
# Ce modèle ne stocke pas directement la valeur de type T, mais se contente
# de référencer le type, un identifiant conceptuel de valeur et les métadonnées
# utiles aux outils (span, présence).
struct OptionValue
    # Identifiant logique de cette valeur Option.
    field id: OptionValueId

    # Type Option associé.
    field type_id: OptionTypeId

    # Présence actuelle (None ou Some).
    field presence: OptionPresence

    # Span de l’expression source qui a produit cette Option.
    field span: spans.SpanId
.end

# Ensemble de valeurs Option suivies dans une compilation ou un run de debugger.
struct OptionValueTable
    field values: coll.List<OptionValue>
.end

# ============================================================================
# Patterns dédiés à Option et match exhaustif
# ============================================================================

# Genre de pattern dédié à Option :
#   - Wildcard     : "_"
#   - None         : "None"
#   - SomeBinding  : "Some(x)" ou "Some(_)"
enum OptionPatternKind
    variant Wildcard
    variant None
    variant SomeBinding
.end

# Pattern logique dédié à Option dans les analyses de match.
struct OptionPattern
    field id: OptionPatternId
    field kind: OptionPatternKind

    # Nom éventuellement capturé dans le cas SomeBinding ("Some(x)").
    # S’il n’y a pas de nom (par ex. "Some(_)"), this binding_name peut être
    # un symbole "anonyme" réservé ou un identifiant nul.
    field binding_name: names.SymbolId

    # Span du pattern dans la source.
    field span: spans.SpanId
.end

# Spécification d’un match exhaustif sur un type Option particulier.
#
# Ce modèle sert aux passes d’analyse pour raisonner sur la couverture :
#   - quelles variantes sont couvertes,
#   - quelles combinaisons sont manquantes,
#   - quelles branches sont inaccessibles.
struct OptionMatchSpec
    # Type Option concerné.
    field option_type: OptionTypeId

    # Liste des patterns utilisés dans ce bloc de match.
    field patterns: coll.List<OptionPatternId>

    # Span du match complet dans la source.
    field span: spans.SpanId
.end

# Résultat logique de l’analyse d’exhaustivité pour un match sur Option.
enum OptionMatchExhaustiveness
    # Toutes les branches nécessaires sont présentes (None / Some / wildcard).
    variant Exhaustive

    # Il manque au moins une case (par ex. None manquant).
    variant NonExhaustive

    # Il existe des branches inaccessibles (dead code) ou redondantes.
    variant RedundantBranches
.end

struct OptionMatchAnalysis
    field spec: OptionMatchSpec
    field result: OptionMatchExhaustiveness

    # Patterns identifiés comme redondants / inaccessibles.
    field redundant_patterns: coll.List<OptionPatternId>

    # Patterns manquants (par ex. manque "None").
    field missing_patterns: coll.List<OptionPatternId>
.end

# ============================================================================
# Graphe logique des opérations Option (map, and_then, etc.)
# ============================================================================

# Genre d’opération logique appliquée à une valeur Option.
#
# Ce modèle ne décrit pas l’implémentation, mais la "forme" des chaînes
# d’opérations pour l’outillage (LSP, debugger, visualisation, optimisation).
enum OptionOpKind
    # Vérifie si la valeur est Some.
    variant IsSome

    # Vérifie si la valeur est None.
    variant IsNone

    # Récupère la valeur, en supposant la présence (peut générer une erreur
    # sémantique si utilisé dans un contexte incorrect).
    variant Unwrap

    # Récupère la valeur, avec un message explicite en cas d’absence.
    variant Expect

    # Transforme la valeur contenue via une fonction (Some(v) -> Some(f(v))).
    variant Map

    # Chaîne de manière monadique (Some(v) -> f(v) qui retourne Option<U>).
    variant AndThen

    # Fournit une valeur de repli si l’Option est None.
    variant UnwrapOr

    # Fournit une fonction de repli si l’Option est None.
    variant UnwrapOrElse

    # Filtre la valeur selon un prédicat (Some(v) -> Some(v) ou None).
    variant Filter
.end

# Nœud d’opération Option dans un graphe logique.
struct OptionOp
    field id: OptionOpId
    field kind: OptionOpKind

    # Valeur Option en entrée de l’opération.
    field input: OptionValueId

    # Valeur Option en sortie de l’opération (peut être identique à input pour
    # certaines opérations conceptuelles).
    field output: OptionValueId

    # Span de l’expression source correspondant à cette opération.
    field span: spans.SpanId
.end

# Graphe d’opérations Option associé à une expression ou un bloc.
struct OptionOpGraph
    # Toutes les opérations Option connues pour l’expression / le bloc.
    field ops: coll.List<OptionOp>
.end

# ============================================================================
# Vue agrégée pour les outils (LSP / debugger)
# ============================================================================

# Vue consolidée de tout ce qui concerne Option au niveau d’un crate ou d’un
# module, afin de faciliter la sérialisation / inspection par les outils.
struct OptionModelSnapshot
    field type_table: OptionTypeTable
    field value_table: OptionValueTable
    field op_graph: OptionOpGraph

    # Analyses de match associées à ce module / crate.
    field match_analyses: coll.List<OptionMatchAnalysis>
.end

.end